"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@firebase";
exports.ids = ["vendor-chunks/@firebase"];
exports.modules = {

/***/ "(ssr)/./node_modules/@firebase/app-compat/dist/esm/index.esm2017.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@firebase/app-compat/dist/esm/index.esm2017.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ firebase)\n/* harmony export */ });\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/app */ \"(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @firebase/logger */ \"(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n\n\n\n\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Global context object for a collection of services using\r\n * a shared authentication state.\r\n *\r\n * marked as internal because it references internal types exported from @firebase/app\r\n * @internal\r\n */ class FirebaseAppImpl {\n    constructor(_delegate, firebase){\n        this._delegate = _delegate;\n        this.firebase = firebase;\n        // add itself to container\n        (0,_firebase_app__WEBPACK_IMPORTED_MODULE_2__._addComponent)(_delegate, new _firebase_component__WEBPACK_IMPORTED_MODULE_1__.Component(\"app-compat\", ()=>this, \"PUBLIC\" /* ComponentType.PUBLIC */ ));\n        this.container = _delegate.container;\n    }\n    get automaticDataCollectionEnabled() {\n        return this._delegate.automaticDataCollectionEnabled;\n    }\n    set automaticDataCollectionEnabled(val) {\n        this._delegate.automaticDataCollectionEnabled = val;\n    }\n    get name() {\n        return this._delegate.name;\n    }\n    get options() {\n        return this._delegate.options;\n    }\n    delete() {\n        return new Promise((resolve)=>{\n            this._delegate.checkDestroyed();\n            resolve();\n        }).then(()=>{\n            this.firebase.INTERNAL.removeApp(this.name);\n            return (0,_firebase_app__WEBPACK_IMPORTED_MODULE_2__.deleteApp)(this._delegate);\n        });\n    }\n    /**\r\n     * Return a service instance associated with this app (creating it\r\n     * on demand), identified by the passed instanceIdentifier.\r\n     *\r\n     * NOTE: Currently storage and functions are the only ones that are leveraging this\r\n     * functionality. They invoke it by calling:\r\n     *\r\n     * ```javascript\r\n     * firebase.app().storage('STORAGE BUCKET ID')\r\n     * ```\r\n     *\r\n     * The service name is passed to this already\r\n     * @internal\r\n     */ _getService(name, instanceIdentifier = _firebase_app__WEBPACK_IMPORTED_MODULE_2__._DEFAULT_ENTRY_NAME) {\n        var _a;\n        this._delegate.checkDestroyed();\n        // Initialize instance if InstatiationMode is `EXPLICIT`.\n        const provider = this._delegate.container.getProvider(name);\n        if (!provider.isInitialized() && ((_a = provider.getComponent()) === null || _a === void 0 ? void 0 : _a.instantiationMode) === \"EXPLICIT\" /* InstantiationMode.EXPLICIT */ ) {\n            provider.initialize();\n        }\n        // getImmediate will always succeed because _getService is only called for registered components.\n        return provider.getImmediate({\n            identifier: instanceIdentifier\n        });\n    }\n    /**\r\n     * Remove a service instance from the cache, so we will create a new instance for this service\r\n     * when people try to get it again.\r\n     *\r\n     * NOTE: currently only firestore uses this functionality to support firestore shutdown.\r\n     *\r\n     * @param name The service name\r\n     * @param instanceIdentifier instance identifier in case multiple instances are allowed\r\n     * @internal\r\n     */ _removeServiceInstance(name, instanceIdentifier = _firebase_app__WEBPACK_IMPORTED_MODULE_2__._DEFAULT_ENTRY_NAME) {\n        this._delegate.container// eslint-disable-next-line @typescript-eslint/no-explicit-any\n        .getProvider(name).clearInstance(instanceIdentifier);\n    }\n    /**\r\n     * @param component the component being added to this app's container\r\n     * @internal\r\n     */ _addComponent(component) {\n        (0,_firebase_app__WEBPACK_IMPORTED_MODULE_2__._addComponent)(this._delegate, component);\n    }\n    _addOrOverwriteComponent(component) {\n        (0,_firebase_app__WEBPACK_IMPORTED_MODULE_2__._addOrOverwriteComponent)(this._delegate, component);\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            automaticDataCollectionEnabled: this.automaticDataCollectionEnabled,\n            options: this.options\n        };\n    }\n}\n// TODO: investigate why the following needs to be commented out\n// Prevent dead-code elimination of these methods w/o invalid property\n// copying.\n// (FirebaseAppImpl.prototype.name && FirebaseAppImpl.prototype.options) ||\n//   FirebaseAppImpl.prototype.delete ||\n//   console.log('dc');\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const ERRORS = {\n    [\"no-app\" /* AppError.NO_APP */ ]: \"No Firebase App '{$appName}' has been created - \" + \"call Firebase App.initializeApp()\",\n    [\"invalid-app-argument\" /* AppError.INVALID_APP_ARGUMENT */ ]: \"firebase.{$appName}() takes either no argument or a \" + \"Firebase App instance.\"\n};\nconst ERROR_FACTORY = new _firebase_util__WEBPACK_IMPORTED_MODULE_0__.ErrorFactory(\"app-compat\", \"Firebase\", ERRORS);\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Because auth can't share code with other components, we attach the utility functions\r\n * in an internal namespace to share code.\r\n * This function return a firebase namespace object without\r\n * any utility functions, so it can be shared between the regular firebaseNamespace and\r\n * the lite version.\r\n */ function createFirebaseNamespaceCore(firebaseAppImpl) {\n    const apps = {};\n    // // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    // const components = new Map<string, Component<any>>();\n    // A namespace is a plain JavaScript Object.\n    const namespace = {\n        // Hack to prevent Babel from modifying the object returned\n        // as the firebase namespace.\n        // @ts-ignore\n        __esModule: true,\n        initializeApp: initializeAppCompat,\n        // @ts-ignore\n        app,\n        registerVersion: _firebase_app__WEBPACK_IMPORTED_MODULE_2__.registerVersion,\n        setLogLevel: _firebase_app__WEBPACK_IMPORTED_MODULE_2__.setLogLevel,\n        onLog: _firebase_app__WEBPACK_IMPORTED_MODULE_2__.onLog,\n        // @ts-ignore\n        apps: null,\n        SDK_VERSION: _firebase_app__WEBPACK_IMPORTED_MODULE_2__.SDK_VERSION,\n        INTERNAL: {\n            registerComponent: registerComponentCompat,\n            removeApp,\n            useAsService,\n            modularAPIs: _firebase_app__WEBPACK_IMPORTED_MODULE_2__\n        }\n    };\n    // Inject a circular default export to allow Babel users who were previously\n    // using:\n    //\n    //   import firebase from 'firebase';\n    //   which becomes: var firebase = require('firebase').default;\n    //\n    // instead of\n    //\n    //   import * as firebase from 'firebase';\n    //   which becomes: var firebase = require('firebase');\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    namespace[\"default\"] = namespace;\n    // firebase.apps is a read-only getter.\n    Object.defineProperty(namespace, \"apps\", {\n        get: getApps\n    });\n    /**\r\n     * Called by App.delete() - but before any services associated with the App\r\n     * are deleted.\r\n     */ function removeApp(name) {\n        delete apps[name];\n    }\n    /**\r\n     * Get the App object for a given name (or DEFAULT).\r\n     */ function app(name) {\n        name = name || _firebase_app__WEBPACK_IMPORTED_MODULE_2__._DEFAULT_ENTRY_NAME;\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_0__.contains)(apps, name)) {\n            throw ERROR_FACTORY.create(\"no-app\" /* AppError.NO_APP */ , {\n                appName: name\n            });\n        }\n        return apps[name];\n    }\n    // @ts-ignore\n    app[\"App\"] = firebaseAppImpl;\n    /**\r\n     * Create a new App instance (name must be unique).\r\n     *\r\n     * This function is idempotent. It can be called more than once and return the same instance using the same options and config.\r\n     */ function initializeAppCompat(options, rawConfig = {}) {\n        const app = _firebase_app__WEBPACK_IMPORTED_MODULE_2__.initializeApp(options, rawConfig);\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_0__.contains)(apps, app.name)) {\n            return apps[app.name];\n        }\n        const appCompat = new firebaseAppImpl(app, namespace);\n        apps[app.name] = appCompat;\n        return appCompat;\n    }\n    /*\r\n     * Return an array of all the non-deleted FirebaseApps.\r\n     */ function getApps() {\n        // Make a copy so caller cannot mutate the apps list.\n        return Object.keys(apps).map((name)=>apps[name]);\n    }\n    function registerComponentCompat(component) {\n        const componentName = component.name;\n        const componentNameWithoutCompat = componentName.replace(\"-compat\", \"\");\n        if (_firebase_app__WEBPACK_IMPORTED_MODULE_2__._registerComponent(component) && component.type === \"PUBLIC\" /* ComponentType.PUBLIC */ ) {\n            // create service namespace for public components\n            // The Service namespace is an accessor function ...\n            const serviceNamespace = (appArg = app())=>{\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                if (typeof appArg[componentNameWithoutCompat] !== \"function\") {\n                    // Invalid argument.\n                    // This happens in the following case: firebase.storage('gs:/')\n                    throw ERROR_FACTORY.create(\"invalid-app-argument\" /* AppError.INVALID_APP_ARGUMENT */ , {\n                        appName: componentName\n                    });\n                }\n                // Forward service instance lookup to the FirebaseApp.\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                return appArg[componentNameWithoutCompat]();\n            };\n            // ... and a container for service-level properties.\n            if (component.serviceProps !== undefined) {\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_0__.deepExtend)(serviceNamespace, component.serviceProps);\n            }\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            namespace[componentNameWithoutCompat] = serviceNamespace;\n            // Patch the FirebaseAppImpl prototype\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            firebaseAppImpl.prototype[componentNameWithoutCompat] = // TODO: The eslint disable can be removed and the 'ignoreRestArgs'\n            // option added to the no-explicit-any rule when ESlint releases it.\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            function(...args) {\n                const serviceFxn = this._getService.bind(this, componentName);\n                return serviceFxn.apply(this, component.multipleInstances ? args : []);\n            };\n        }\n        return component.type === \"PUBLIC\" /* ComponentType.PUBLIC */  ? namespace[componentNameWithoutCompat] : null;\n    }\n    // Map the requested service to a registered service name\n    // (used to map auth to serverAuth service when needed).\n    function useAsService(app, name) {\n        if (name === \"serverAuth\") {\n            return null;\n        }\n        const useService = name;\n        return useService;\n    }\n    return namespace;\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Return a firebase namespace object.\r\n *\r\n * In production, this will be called exactly once and the result\r\n * assigned to the 'firebase' global.  It may be called multiple times\r\n * in unit tests.\r\n */ function createFirebaseNamespace() {\n    const namespace = createFirebaseNamespaceCore(FirebaseAppImpl);\n    namespace.INTERNAL = Object.assign(Object.assign({}, namespace.INTERNAL), {\n        createFirebaseNamespace,\n        extendNamespace,\n        createSubscribe: _firebase_util__WEBPACK_IMPORTED_MODULE_0__.createSubscribe,\n        ErrorFactory: _firebase_util__WEBPACK_IMPORTED_MODULE_0__.ErrorFactory,\n        deepExtend: _firebase_util__WEBPACK_IMPORTED_MODULE_0__.deepExtend\n    });\n    /**\r\n     * Patch the top-level firebase namespace with additional properties.\r\n     *\r\n     * firebase.INTERNAL.extendNamespace()\r\n     */ function extendNamespace(props) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_0__.deepExtend)(namespace, props);\n    }\n    return namespace;\n}\nconst firebase$1 = createFirebaseNamespace();\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const logger = new _firebase_logger__WEBPACK_IMPORTED_MODULE_3__.Logger(\"@firebase/app-compat\");\nconst name = \"@firebase/app-compat\";\nconst version = \"0.2.29\";\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function registerCoreComponents(variant) {\n    // Register `app` package.\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_2__.registerVersion)(name, version, variant);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // Firebase Lite detection\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nif ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_0__.isBrowser)() && self.firebase !== undefined) {\n    logger.warn(`\n    Warning: Firebase is already defined in the global scope. Please make sure\n    Firebase library is only loaded once.\n  `);\n    // eslint-disable-next-line\n    const sdkVersion = self.firebase.SDK_VERSION;\n    if (sdkVersion && sdkVersion.indexOf(\"LITE\") >= 0) {\n        logger.warn(`\n    Warning: You are trying to load Firebase while using Firebase Performance standalone script.\n    You should load Firebase Performance with this instance of Firebase to avoid loading duplicate code.\n    `);\n    }\n}\nconst firebase = firebase$1;\nregisterCoreComponents();\n //# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2FwcC1jb21wYXQvZGlzdC9lc20vaW5kZXguZXNtMjAxNy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFnRztBQUNoRDtBQUNIO0FBQzRFO0FBQy9FO0FBRTFDOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEOzs7Ozs7Q0FNQyxHQUNELE1BQU1hO0lBQ0ZDLFlBQVlDLFNBQVMsRUFBRUMsUUFBUSxDQUFFO1FBQzdCLElBQUksQ0FBQ0QsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUNDLFFBQVEsR0FBR0E7UUFDaEIsMEJBQTBCO1FBQzFCVCw0REFBYUEsQ0FBQ1EsV0FBVyxJQUFJViwwREFBU0EsQ0FBQyxjQUFjLElBQU0sSUFBSSxFQUFFLFNBQVMsd0JBQXdCO1FBQ2xHLElBQUksQ0FBQ1ksU0FBUyxHQUFHRixVQUFVRSxTQUFTO0lBQ3hDO0lBQ0EsSUFBSUMsaUNBQWlDO1FBQ2pDLE9BQU8sSUFBSSxDQUFDSCxTQUFTLENBQUNHLDhCQUE4QjtJQUN4RDtJQUNBLElBQUlBLCtCQUErQkMsR0FBRyxFQUFFO1FBQ3BDLElBQUksQ0FBQ0osU0FBUyxDQUFDRyw4QkFBOEIsR0FBR0M7SUFDcEQ7SUFDQSxJQUFJQyxPQUFPO1FBQ1AsT0FBTyxJQUFJLENBQUNMLFNBQVMsQ0FBQ0ssSUFBSTtJQUM5QjtJQUNBLElBQUlDLFVBQVU7UUFDVixPQUFPLElBQUksQ0FBQ04sU0FBUyxDQUFDTSxPQUFPO0lBQ2pDO0lBQ0FDLFNBQVM7UUFDTCxPQUFPLElBQUlDLFFBQVFDLENBQUFBO1lBQ2YsSUFBSSxDQUFDVCxTQUFTLENBQUNVLGNBQWM7WUFDN0JEO1FBQ0osR0FBR0UsSUFBSSxDQUFDO1lBQ0osSUFBSSxDQUFDVixRQUFRLENBQUNXLFFBQVEsQ0FBQ0MsU0FBUyxDQUFDLElBQUksQ0FBQ1IsSUFBSTtZQUMxQyxPQUFPWix3REFBU0EsQ0FBQyxJQUFJLENBQUNPLFNBQVM7UUFDbkM7SUFDSjtJQUNBOzs7Ozs7Ozs7Ozs7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WUgsNEJBQTRCakM7SUFDOUNvQyxVQUFVdEIsUUFBUSxHQUFHaUMsT0FBTzJCLE1BQU0sQ0FBQzNCLE9BQU8yQixNQUFNLENBQUMsQ0FBQyxHQUFHdEMsVUFBVXRCLFFBQVEsR0FBRztRQUFFMkQ7UUFDeEVFO1FBQ0FyRixlQUFlQSw2REFBQUE7UUFDZkgsWUFBWUEsMERBQUFBO1FBQ1pFLFVBQVVBLHdEQUFBQTtJQUFDO0lBQ2Y7Ozs7S0FJQyxHQUNELFNBQVNzRixnQkFBZ0JDLEtBQUs7UUFDMUJ2RiwwREFBVUEsQ0FBQytDLFdBQVd3QztJQUMxQjtJQUNBLE9BQU94QztBQUNYO0FBQ0EsTUFBTXlDLGFBQWFKO0FBRW5COzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNELE1BQU1LLFNBQVMsSUFBSS9FLG9EQUFNQSxDQUFDO0FBRTFCLE1BQU1RLE9BQU87QUFDYixNQUFNd0UsVUFBVTtBQUVoQjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRCxTQUFTQyx1QkFBdUJDLE9BQU87SUFDbkMsMEJBQTBCO0lBQzFCbkYsOERBQWVBLENBQUNTLE1BQU13RSxTQUFTRTtBQUNuQztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNELDBCQUEwQjtBQUMxQiw4REFBOEQ7QUFDOUQsSUFBSTFGLHlEQUFTQSxNQUFNMkYsS0FBSy9FLFFBQVEsS0FBSzhELFdBQVc7SUFDNUNhLE9BQU9LLElBQUksQ0FBQyxDQUFDOzs7RUFHZixDQUFDO0lBQ0MsMkJBQTJCO0lBQzNCLE1BQU1DLGFBQWFGLEtBQUsvRSxRQUFRLENBQUN3QyxXQUFXO0lBQzVDLElBQUl5QyxjQUFjQSxXQUFXQyxPQUFPLENBQUMsV0FBVyxHQUFHO1FBQy9DUCxPQUFPSyxJQUFJLENBQUMsQ0FBQzs7O0lBR2pCLENBQUM7SUFDRDtBQUNKO0FBQ0EsTUFBTWhGLFdBQVcwRTtBQUNqQkc7QUFFK0IsQ0FDL0IseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd29ybGR3ZWIvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2FwcC1jb21wYXQvZGlzdC9lc20vaW5kZXguZXNtMjAxNy5qcz8zMDEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVycm9yRmFjdG9yeSwgY29udGFpbnMsIGRlZXBFeHRlbmQsIGNyZWF0ZVN1YnNjcmliZSwgaXNCcm93c2VyIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGZpcmViYXNlL2NvbXBvbmVudCc7XG5pbXBvcnQgKiBhcyBtb2R1bGFyQVBJcyBmcm9tICdAZmlyZWJhc2UvYXBwJztcbmltcG9ydCB7IF9hZGRDb21wb25lbnQsIGRlbGV0ZUFwcCwgX0RFRkFVTFRfRU5UUllfTkFNRSwgX2FkZE9yT3ZlcndyaXRlQ29tcG9uZW50LCByZWdpc3RlclZlcnNpb24gfSBmcm9tICdAZmlyZWJhc2UvYXBwJztcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJ0BmaXJlYmFzZS9sb2dnZXInO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogR2xvYmFsIGNvbnRleHQgb2JqZWN0IGZvciBhIGNvbGxlY3Rpb24gb2Ygc2VydmljZXMgdXNpbmdcclxuICogYSBzaGFyZWQgYXV0aGVudGljYXRpb24gc3RhdGUuXHJcbiAqXHJcbiAqIG1hcmtlZCBhcyBpbnRlcm5hbCBiZWNhdXNlIGl0IHJlZmVyZW5jZXMgaW50ZXJuYWwgdHlwZXMgZXhwb3J0ZWQgZnJvbSBAZmlyZWJhc2UvYXBwXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY2xhc3MgRmlyZWJhc2VBcHBJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKF9kZWxlZ2F0ZSwgZmlyZWJhc2UpIHtcclxuICAgICAgICB0aGlzLl9kZWxlZ2F0ZSA9IF9kZWxlZ2F0ZTtcclxuICAgICAgICB0aGlzLmZpcmViYXNlID0gZmlyZWJhc2U7XHJcbiAgICAgICAgLy8gYWRkIGl0c2VsZiB0byBjb250YWluZXJcclxuICAgICAgICBfYWRkQ29tcG9uZW50KF9kZWxlZ2F0ZSwgbmV3IENvbXBvbmVudCgnYXBwLWNvbXBhdCcsICgpID0+IHRoaXMsIFwiUFVCTElDXCIgLyogQ29tcG9uZW50VHlwZS5QVUJMSUMgKi8pKTtcclxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IF9kZWxlZ2F0ZS5jb250YWluZXI7XHJcbiAgICB9XHJcbiAgICBnZXQgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQ7XHJcbiAgICB9XHJcbiAgICBzZXQgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkKHZhbCkge1xyXG4gICAgICAgIHRoaXMuX2RlbGVnYXRlLmF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCA9IHZhbDtcclxuICAgIH1cclxuICAgIGdldCBuYW1lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5uYW1lO1xyXG4gICAgfVxyXG4gICAgZ2V0IG9wdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLm9wdGlvbnM7XHJcbiAgICB9XHJcbiAgICBkZWxldGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9kZWxlZ2F0ZS5jaGVja0Rlc3Ryb3llZCgpO1xyXG4gICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgfSkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZmlyZWJhc2UuSU5URVJOQUwucmVtb3ZlQXBwKHRoaXMubmFtZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBkZWxldGVBcHAodGhpcy5fZGVsZWdhdGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYSBzZXJ2aWNlIGluc3RhbmNlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGFwcCAoY3JlYXRpbmcgaXRcclxuICAgICAqIG9uIGRlbWFuZCksIGlkZW50aWZpZWQgYnkgdGhlIHBhc3NlZCBpbnN0YW5jZUlkZW50aWZpZXIuXHJcbiAgICAgKlxyXG4gICAgICogTk9URTogQ3VycmVudGx5IHN0b3JhZ2UgYW5kIGZ1bmN0aW9ucyBhcmUgdGhlIG9ubHkgb25lcyB0aGF0IGFyZSBsZXZlcmFnaW5nIHRoaXNcclxuICAgICAqIGZ1bmN0aW9uYWxpdHkuIFRoZXkgaW52b2tlIGl0IGJ5IGNhbGxpbmc6XHJcbiAgICAgKlxyXG4gICAgICogYGBgamF2YXNjcmlwdFxyXG4gICAgICogZmlyZWJhc2UuYXBwKCkuc3RvcmFnZSgnU1RPUkFHRSBCVUNLRVQgSUQnKVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogVGhlIHNlcnZpY2UgbmFtZSBpcyBwYXNzZWQgdG8gdGhpcyBhbHJlYWR5XHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX2dldFNlcnZpY2UobmFtZSwgaW5zdGFuY2VJZGVudGlmaWVyID0gX0RFRkFVTFRfRU5UUllfTkFNRSkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB0aGlzLl9kZWxlZ2F0ZS5jaGVja0Rlc3Ryb3llZCgpO1xyXG4gICAgICAgIC8vIEluaXRpYWxpemUgaW5zdGFuY2UgaWYgSW5zdGF0aWF0aW9uTW9kZSBpcyBgRVhQTElDSVRgLlxyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5fZGVsZWdhdGUuY29udGFpbmVyLmdldFByb3ZpZGVyKG5hbWUpO1xyXG4gICAgICAgIGlmICghcHJvdmlkZXIuaXNJbml0aWFsaXplZCgpICYmXHJcbiAgICAgICAgICAgICgoX2EgPSBwcm92aWRlci5nZXRDb21wb25lbnQoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluc3RhbnRpYXRpb25Nb2RlKSA9PT0gXCJFWFBMSUNJVFwiIC8qIEluc3RhbnRpYXRpb25Nb2RlLkVYUExJQ0lUICovKSB7XHJcbiAgICAgICAgICAgIHByb3ZpZGVyLmluaXRpYWxpemUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZ2V0SW1tZWRpYXRlIHdpbGwgYWx3YXlzIHN1Y2NlZWQgYmVjYXVzZSBfZ2V0U2VydmljZSBpcyBvbmx5IGNhbGxlZCBmb3IgcmVnaXN0ZXJlZCBjb21wb25lbnRzLlxyXG4gICAgICAgIHJldHVybiBwcm92aWRlci5nZXRJbW1lZGlhdGUoe1xyXG4gICAgICAgICAgICBpZGVudGlmaWVyOiBpbnN0YW5jZUlkZW50aWZpZXJcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGEgc2VydmljZSBpbnN0YW5jZSBmcm9tIHRoZSBjYWNoZSwgc28gd2Ugd2lsbCBjcmVhdGUgYSBuZXcgaW5zdGFuY2UgZm9yIHRoaXMgc2VydmljZVxyXG4gICAgICogd2hlbiBwZW9wbGUgdHJ5IHRvIGdldCBpdCBhZ2Fpbi5cclxuICAgICAqXHJcbiAgICAgKiBOT1RFOiBjdXJyZW50bHkgb25seSBmaXJlc3RvcmUgdXNlcyB0aGlzIGZ1bmN0aW9uYWxpdHkgdG8gc3VwcG9ydCBmaXJlc3RvcmUgc2h1dGRvd24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIHNlcnZpY2UgbmFtZVxyXG4gICAgICogQHBhcmFtIGluc3RhbmNlSWRlbnRpZmllciBpbnN0YW5jZSBpZGVudGlmaWVyIGluIGNhc2UgbXVsdGlwbGUgaW5zdGFuY2VzIGFyZSBhbGxvd2VkXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX3JlbW92ZVNlcnZpY2VJbnN0YW5jZShuYW1lLCBpbnN0YW5jZUlkZW50aWZpZXIgPSBfREVGQVVMVF9FTlRSWV9OQU1FKSB7XHJcbiAgICAgICAgdGhpcy5fZGVsZWdhdGUuY29udGFpbmVyXHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgIC5nZXRQcm92aWRlcihuYW1lKVxyXG4gICAgICAgICAgICAuY2xlYXJJbnN0YW5jZShpbnN0YW5jZUlkZW50aWZpZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gY29tcG9uZW50IHRoZSBjb21wb25lbnQgYmVpbmcgYWRkZWQgdG8gdGhpcyBhcHAncyBjb250YWluZXJcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfYWRkQ29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gICAgICAgIF9hZGRDb21wb25lbnQodGhpcy5fZGVsZWdhdGUsIGNvbXBvbmVudCk7XHJcbiAgICB9XHJcbiAgICBfYWRkT3JPdmVyd3JpdGVDb21wb25lbnQoY29tcG9uZW50KSB7XHJcbiAgICAgICAgX2FkZE9yT3ZlcndyaXRlQ29tcG9uZW50KHRoaXMuX2RlbGVnYXRlLCBjb21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICAgICAgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkOiB0aGlzLmF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCxcclxuICAgICAgICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG4vLyBUT0RPOiBpbnZlc3RpZ2F0ZSB3aHkgdGhlIGZvbGxvd2luZyBuZWVkcyB0byBiZSBjb21tZW50ZWQgb3V0XHJcbi8vIFByZXZlbnQgZGVhZC1jb2RlIGVsaW1pbmF0aW9uIG9mIHRoZXNlIG1ldGhvZHMgdy9vIGludmFsaWQgcHJvcGVydHlcclxuLy8gY29weWluZy5cclxuLy8gKEZpcmViYXNlQXBwSW1wbC5wcm90b3R5cGUubmFtZSAmJiBGaXJlYmFzZUFwcEltcGwucHJvdG90eXBlLm9wdGlvbnMpIHx8XHJcbi8vICAgRmlyZWJhc2VBcHBJbXBsLnByb3RvdHlwZS5kZWxldGUgfHxcclxuLy8gICBjb25zb2xlLmxvZygnZGMnKTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgRVJST1JTID0ge1xyXG4gICAgW1wibm8tYXBwXCIgLyogQXBwRXJyb3IuTk9fQVBQICovXTogXCJObyBGaXJlYmFzZSBBcHAgJ3skYXBwTmFtZX0nIGhhcyBiZWVuIGNyZWF0ZWQgLSBcIiArXHJcbiAgICAgICAgJ2NhbGwgRmlyZWJhc2UgQXBwLmluaXRpYWxpemVBcHAoKScsXHJcbiAgICBbXCJpbnZhbGlkLWFwcC1hcmd1bWVudFwiIC8qIEFwcEVycm9yLklOVkFMSURfQVBQX0FSR1VNRU5UICovXTogJ2ZpcmViYXNlLnskYXBwTmFtZX0oKSB0YWtlcyBlaXRoZXIgbm8gYXJndW1lbnQgb3IgYSAnICtcclxuICAgICAgICAnRmlyZWJhc2UgQXBwIGluc3RhbmNlLidcclxufTtcclxuY29uc3QgRVJST1JfRkFDVE9SWSA9IG5ldyBFcnJvckZhY3RvcnkoJ2FwcC1jb21wYXQnLCAnRmlyZWJhc2UnLCBFUlJPUlMpO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQmVjYXVzZSBhdXRoIGNhbid0IHNoYXJlIGNvZGUgd2l0aCBvdGhlciBjb21wb25lbnRzLCB3ZSBhdHRhY2ggdGhlIHV0aWxpdHkgZnVuY3Rpb25zXHJcbiAqIGluIGFuIGludGVybmFsIG5hbWVzcGFjZSB0byBzaGFyZSBjb2RlLlxyXG4gKiBUaGlzIGZ1bmN0aW9uIHJldHVybiBhIGZpcmViYXNlIG5hbWVzcGFjZSBvYmplY3Qgd2l0aG91dFxyXG4gKiBhbnkgdXRpbGl0eSBmdW5jdGlvbnMsIHNvIGl0IGNhbiBiZSBzaGFyZWQgYmV0d2VlbiB0aGUgcmVndWxhciBmaXJlYmFzZU5hbWVzcGFjZSBhbmRcclxuICogdGhlIGxpdGUgdmVyc2lvbi5cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUZpcmViYXNlTmFtZXNwYWNlQ29yZShmaXJlYmFzZUFwcEltcGwpIHtcclxuICAgIGNvbnN0IGFwcHMgPSB7fTtcclxuICAgIC8vIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAvLyBjb25zdCBjb21wb25lbnRzID0gbmV3IE1hcDxzdHJpbmcsIENvbXBvbmVudDxhbnk+PigpO1xyXG4gICAgLy8gQSBuYW1lc3BhY2UgaXMgYSBwbGFpbiBKYXZhU2NyaXB0IE9iamVjdC5cclxuICAgIGNvbnN0IG5hbWVzcGFjZSA9IHtcclxuICAgICAgICAvLyBIYWNrIHRvIHByZXZlbnQgQmFiZWwgZnJvbSBtb2RpZnlpbmcgdGhlIG9iamVjdCByZXR1cm5lZFxyXG4gICAgICAgIC8vIGFzIHRoZSBmaXJlYmFzZSBuYW1lc3BhY2UuXHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIF9fZXNNb2R1bGU6IHRydWUsXHJcbiAgICAgICAgaW5pdGlhbGl6ZUFwcDogaW5pdGlhbGl6ZUFwcENvbXBhdCxcclxuICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgYXBwLFxyXG4gICAgICAgIHJlZ2lzdGVyVmVyc2lvbjogbW9kdWxhckFQSXMucmVnaXN0ZXJWZXJzaW9uLFxyXG4gICAgICAgIHNldExvZ0xldmVsOiBtb2R1bGFyQVBJcy5zZXRMb2dMZXZlbCxcclxuICAgICAgICBvbkxvZzogbW9kdWxhckFQSXMub25Mb2csXHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIGFwcHM6IG51bGwsXHJcbiAgICAgICAgU0RLX1ZFUlNJT046IG1vZHVsYXJBUElzLlNES19WRVJTSU9OLFxyXG4gICAgICAgIElOVEVSTkFMOiB7XHJcbiAgICAgICAgICAgIHJlZ2lzdGVyQ29tcG9uZW50OiByZWdpc3RlckNvbXBvbmVudENvbXBhdCxcclxuICAgICAgICAgICAgcmVtb3ZlQXBwLFxyXG4gICAgICAgICAgICB1c2VBc1NlcnZpY2UsXHJcbiAgICAgICAgICAgIG1vZHVsYXJBUElzXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEluamVjdCBhIGNpcmN1bGFyIGRlZmF1bHQgZXhwb3J0IHRvIGFsbG93IEJhYmVsIHVzZXJzIHdobyB3ZXJlIHByZXZpb3VzbHlcclxuICAgIC8vIHVzaW5nOlxyXG4gICAgLy9cclxuICAgIC8vICAgaW1wb3J0IGZpcmViYXNlIGZyb20gJ2ZpcmViYXNlJztcclxuICAgIC8vICAgd2hpY2ggYmVjb21lczogdmFyIGZpcmViYXNlID0gcmVxdWlyZSgnZmlyZWJhc2UnKS5kZWZhdWx0O1xyXG4gICAgLy9cclxuICAgIC8vIGluc3RlYWQgb2ZcclxuICAgIC8vXHJcbiAgICAvLyAgIGltcG9ydCAqIGFzIGZpcmViYXNlIGZyb20gJ2ZpcmViYXNlJztcclxuICAgIC8vICAgd2hpY2ggYmVjb21lczogdmFyIGZpcmViYXNlID0gcmVxdWlyZSgnZmlyZWJhc2UnKTtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICBuYW1lc3BhY2VbJ2RlZmF1bHQnXSA9IG5hbWVzcGFjZTtcclxuICAgIC8vIGZpcmViYXNlLmFwcHMgaXMgYSByZWFkLW9ubHkgZ2V0dGVyLlxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5hbWVzcGFjZSwgJ2FwcHMnLCB7XHJcbiAgICAgICAgZ2V0OiBnZXRBcHBzXHJcbiAgICB9KTtcclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIGJ5IEFwcC5kZWxldGUoKSAtIGJ1dCBiZWZvcmUgYW55IHNlcnZpY2VzIGFzc29jaWF0ZWQgd2l0aCB0aGUgQXBwXHJcbiAgICAgKiBhcmUgZGVsZXRlZC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcmVtb3ZlQXBwKG5hbWUpIHtcclxuICAgICAgICBkZWxldGUgYXBwc1tuYW1lXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBBcHAgb2JqZWN0IGZvciBhIGdpdmVuIG5hbWUgKG9yIERFRkFVTFQpLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBhcHAobmFtZSkge1xyXG4gICAgICAgIG5hbWUgPSBuYW1lIHx8IG1vZHVsYXJBUElzLl9ERUZBVUxUX0VOVFJZX05BTUU7XHJcbiAgICAgICAgaWYgKCFjb250YWlucyhhcHBzLCBuYW1lKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcIm5vLWFwcFwiIC8qIEFwcEVycm9yLk5PX0FQUCAqLywgeyBhcHBOYW1lOiBuYW1lIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXBwc1tuYW1lXTtcclxuICAgIH1cclxuICAgIC8vIEB0cy1pZ25vcmVcclxuICAgIGFwcFsnQXBwJ10gPSBmaXJlYmFzZUFwcEltcGw7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIG5ldyBBcHAgaW5zdGFuY2UgKG5hbWUgbXVzdCBiZSB1bmlxdWUpLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgaWRlbXBvdGVudC4gSXQgY2FuIGJlIGNhbGxlZCBtb3JlIHRoYW4gb25jZSBhbmQgcmV0dXJuIHRoZSBzYW1lIGluc3RhbmNlIHVzaW5nIHRoZSBzYW1lIG9wdGlvbnMgYW5kIGNvbmZpZy5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaW5pdGlhbGl6ZUFwcENvbXBhdChvcHRpb25zLCByYXdDb25maWcgPSB7fSkge1xyXG4gICAgICAgIGNvbnN0IGFwcCA9IG1vZHVsYXJBUElzLmluaXRpYWxpemVBcHAob3B0aW9ucywgcmF3Q29uZmlnKTtcclxuICAgICAgICBpZiAoY29udGFpbnMoYXBwcywgYXBwLm5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcHBzW2FwcC5uYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYXBwQ29tcGF0ID0gbmV3IGZpcmViYXNlQXBwSW1wbChhcHAsIG5hbWVzcGFjZSk7XHJcbiAgICAgICAgYXBwc1thcHAubmFtZV0gPSBhcHBDb21wYXQ7XHJcbiAgICAgICAgcmV0dXJuIGFwcENvbXBhdDtcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgYWxsIHRoZSBub24tZGVsZXRlZCBGaXJlYmFzZUFwcHMuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldEFwcHMoKSB7XHJcbiAgICAgICAgLy8gTWFrZSBhIGNvcHkgc28gY2FsbGVyIGNhbm5vdCBtdXRhdGUgdGhlIGFwcHMgbGlzdC5cclxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoYXBwcykubWFwKG5hbWUgPT4gYXBwc1tuYW1lXSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZWdpc3RlckNvbXBvbmVudENvbXBhdChjb21wb25lbnQpIHtcclxuICAgICAgICBjb25zdCBjb21wb25lbnROYW1lID0gY29tcG9uZW50Lm5hbWU7XHJcbiAgICAgICAgY29uc3QgY29tcG9uZW50TmFtZVdpdGhvdXRDb21wYXQgPSBjb21wb25lbnROYW1lLnJlcGxhY2UoJy1jb21wYXQnLCAnJyk7XHJcbiAgICAgICAgaWYgKG1vZHVsYXJBUElzLl9yZWdpc3RlckNvbXBvbmVudChjb21wb25lbnQpICYmXHJcbiAgICAgICAgICAgIGNvbXBvbmVudC50eXBlID09PSBcIlBVQkxJQ1wiIC8qIENvbXBvbmVudFR5cGUuUFVCTElDICovKSB7XHJcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBzZXJ2aWNlIG5hbWVzcGFjZSBmb3IgcHVibGljIGNvbXBvbmVudHNcclxuICAgICAgICAgICAgLy8gVGhlIFNlcnZpY2UgbmFtZXNwYWNlIGlzIGFuIGFjY2Vzc29yIGZ1bmN0aW9uIC4uLlxyXG4gICAgICAgICAgICBjb25zdCBzZXJ2aWNlTmFtZXNwYWNlID0gKGFwcEFyZyA9IGFwcCgpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcHBBcmdbY29tcG9uZW50TmFtZVdpdGhvdXRDb21wYXRdICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBhcmd1bWVudC5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGhhcHBlbnMgaW4gdGhlIGZvbGxvd2luZyBjYXNlOiBmaXJlYmFzZS5zdG9yYWdlKCdnczovJylcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImludmFsaWQtYXBwLWFyZ3VtZW50XCIgLyogQXBwRXJyb3IuSU5WQUxJRF9BUFBfQVJHVU1FTlQgKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwTmFtZTogY29tcG9uZW50TmFtZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gRm9yd2FyZCBzZXJ2aWNlIGluc3RhbmNlIGxvb2t1cCB0byB0aGUgRmlyZWJhc2VBcHAuXHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcEFyZ1tjb21wb25lbnROYW1lV2l0aG91dENvbXBhdF0oKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLy8gLi4uIGFuZCBhIGNvbnRhaW5lciBmb3Igc2VydmljZS1sZXZlbCBwcm9wZXJ0aWVzLlxyXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50LnNlcnZpY2VQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBkZWVwRXh0ZW5kKHNlcnZpY2VOYW1lc3BhY2UsIGNvbXBvbmVudC5zZXJ2aWNlUHJvcHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgIG5hbWVzcGFjZVtjb21wb25lbnROYW1lV2l0aG91dENvbXBhdF0gPSBzZXJ2aWNlTmFtZXNwYWNlO1xyXG4gICAgICAgICAgICAvLyBQYXRjaCB0aGUgRmlyZWJhc2VBcHBJbXBsIHByb3RvdHlwZVxyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICBmaXJlYmFzZUFwcEltcGwucHJvdG90eXBlW2NvbXBvbmVudE5hbWVXaXRob3V0Q29tcGF0XSA9XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBUaGUgZXNsaW50IGRpc2FibGUgY2FuIGJlIHJlbW92ZWQgYW5kIHRoZSAnaWdub3JlUmVzdEFyZ3MnXHJcbiAgICAgICAgICAgICAgICAvLyBvcHRpb24gYWRkZWQgdG8gdGhlIG5vLWV4cGxpY2l0LWFueSBydWxlIHdoZW4gRVNsaW50IHJlbGVhc2VzIGl0LlxyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VydmljZUZ4biA9IHRoaXMuX2dldFNlcnZpY2UuYmluZCh0aGlzLCBjb21wb25lbnROYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VydmljZUZ4bi5hcHBseSh0aGlzLCBjb21wb25lbnQubXVsdGlwbGVJbnN0YW5jZXMgPyBhcmdzIDogW10pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudC50eXBlID09PSBcIlBVQkxJQ1wiIC8qIENvbXBvbmVudFR5cGUuUFVCTElDICovXHJcbiAgICAgICAgICAgID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgICAgIG5hbWVzcGFjZVtjb21wb25lbnROYW1lV2l0aG91dENvbXBhdF1cclxuICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgfVxyXG4gICAgLy8gTWFwIHRoZSByZXF1ZXN0ZWQgc2VydmljZSB0byBhIHJlZ2lzdGVyZWQgc2VydmljZSBuYW1lXHJcbiAgICAvLyAodXNlZCB0byBtYXAgYXV0aCB0byBzZXJ2ZXJBdXRoIHNlcnZpY2Ugd2hlbiBuZWVkZWQpLlxyXG4gICAgZnVuY3Rpb24gdXNlQXNTZXJ2aWNlKGFwcCwgbmFtZSkge1xyXG4gICAgICAgIGlmIChuYW1lID09PSAnc2VydmVyQXV0aCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHVzZVNlcnZpY2UgPSBuYW1lO1xyXG4gICAgICAgIHJldHVybiB1c2VTZXJ2aWNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5hbWVzcGFjZTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUmV0dXJuIGEgZmlyZWJhc2UgbmFtZXNwYWNlIG9iamVjdC5cclxuICpcclxuICogSW4gcHJvZHVjdGlvbiwgdGhpcyB3aWxsIGJlIGNhbGxlZCBleGFjdGx5IG9uY2UgYW5kIHRoZSByZXN1bHRcclxuICogYXNzaWduZWQgdG8gdGhlICdmaXJlYmFzZScgZ2xvYmFsLiAgSXQgbWF5IGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lc1xyXG4gKiBpbiB1bml0IHRlc3RzLlxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlRmlyZWJhc2VOYW1lc3BhY2UoKSB7XHJcbiAgICBjb25zdCBuYW1lc3BhY2UgPSBjcmVhdGVGaXJlYmFzZU5hbWVzcGFjZUNvcmUoRmlyZWJhc2VBcHBJbXBsKTtcclxuICAgIG5hbWVzcGFjZS5JTlRFUk5BTCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbmFtZXNwYWNlLklOVEVSTkFMKSwgeyBjcmVhdGVGaXJlYmFzZU5hbWVzcGFjZSxcclxuICAgICAgICBleHRlbmROYW1lc3BhY2UsXHJcbiAgICAgICAgY3JlYXRlU3Vic2NyaWJlLFxyXG4gICAgICAgIEVycm9yRmFjdG9yeSxcclxuICAgICAgICBkZWVwRXh0ZW5kIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQYXRjaCB0aGUgdG9wLWxldmVsIGZpcmViYXNlIG5hbWVzcGFjZSB3aXRoIGFkZGl0aW9uYWwgcHJvcGVydGllcy5cclxuICAgICAqXHJcbiAgICAgKiBmaXJlYmFzZS5JTlRFUk5BTC5leHRlbmROYW1lc3BhY2UoKVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBleHRlbmROYW1lc3BhY2UocHJvcHMpIHtcclxuICAgICAgICBkZWVwRXh0ZW5kKG5hbWVzcGFjZSwgcHJvcHMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5hbWVzcGFjZTtcclxufVxyXG5jb25zdCBmaXJlYmFzZSQxID0gY3JlYXRlRmlyZWJhc2VOYW1lc3BhY2UoKTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcignQGZpcmViYXNlL2FwcC1jb21wYXQnKTtcblxuY29uc3QgbmFtZSA9IFwiQGZpcmViYXNlL2FwcC1jb21wYXRcIjtcbmNvbnN0IHZlcnNpb24gPSBcIjAuMi4yOVwiO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiByZWdpc3RlckNvcmVDb21wb25lbnRzKHZhcmlhbnQpIHtcclxuICAgIC8vIFJlZ2lzdGVyIGBhcHBgIHBhY2thZ2UuXHJcbiAgICByZWdpc3RlclZlcnNpb24obmFtZSwgdmVyc2lvbiwgdmFyaWFudCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLy8gRmlyZWJhc2UgTGl0ZSBkZXRlY3Rpb25cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuaWYgKGlzQnJvd3NlcigpICYmIHNlbGYuZmlyZWJhc2UgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgbG9nZ2VyLndhcm4oYFxuICAgIFdhcm5pbmc6IEZpcmViYXNlIGlzIGFscmVhZHkgZGVmaW5lZCBpbiB0aGUgZ2xvYmFsIHNjb3BlLiBQbGVhc2UgbWFrZSBzdXJlXG4gICAgRmlyZWJhc2UgbGlicmFyeSBpcyBvbmx5IGxvYWRlZCBvbmNlLlxuICBgKTtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG4gICAgY29uc3Qgc2RrVmVyc2lvbiA9IHNlbGYuZmlyZWJhc2UuU0RLX1ZFUlNJT047XHJcbiAgICBpZiAoc2RrVmVyc2lvbiAmJiBzZGtWZXJzaW9uLmluZGV4T2YoJ0xJVEUnKSA+PSAwKSB7XHJcbiAgICAgICAgbG9nZ2VyLndhcm4oYFxuICAgIFdhcm5pbmc6IFlvdSBhcmUgdHJ5aW5nIHRvIGxvYWQgRmlyZWJhc2Ugd2hpbGUgdXNpbmcgRmlyZWJhc2UgUGVyZm9ybWFuY2Ugc3RhbmRhbG9uZSBzY3JpcHQuXG4gICAgWW91IHNob3VsZCBsb2FkIEZpcmViYXNlIFBlcmZvcm1hbmNlIHdpdGggdGhpcyBpbnN0YW5jZSBvZiBGaXJlYmFzZSB0byBhdm9pZCBsb2FkaW5nIGR1cGxpY2F0ZSBjb2RlLlxuICAgIGApO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGZpcmViYXNlID0gZmlyZWJhc2UkMTtcclxucmVnaXN0ZXJDb3JlQ29tcG9uZW50cygpO1xuXG5leHBvcnQgeyBmaXJlYmFzZSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20yMDE3LmpzLm1hcFxuIl0sIm5hbWVzIjpbIkVycm9yRmFjdG9yeSIsImNvbnRhaW5zIiwiZGVlcEV4dGVuZCIsImNyZWF0ZVN1YnNjcmliZSIsImlzQnJvd3NlciIsIkNvbXBvbmVudCIsIm1vZHVsYXJBUElzIiwiX2FkZENvbXBvbmVudCIsImRlbGV0ZUFwcCIsIl9ERUZBVUxUX0VOVFJZX05BTUUiLCJfYWRkT3JPdmVyd3JpdGVDb21wb25lbnQiLCJyZWdpc3RlclZlcnNpb24iLCJMb2dnZXIiLCJGaXJlYmFzZUFwcEltcGwiLCJjb25zdHJ1Y3RvciIsIl9kZWxlZ2F0ZSIsImZpcmViYXNlIiwiY29udGFpbmVyIiwiYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkIiwidmFsIiwibmFtZSIsIm9wdGlvbnMiLCJkZWxldGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsImNoZWNrRGVzdHJveWVkIiwidGhlbiIsIklOVEVSTkFMIiwicmVtb3ZlQXBwIiwiX2dldFNlcnZpY2UiLCJpbnN0YW5jZUlkZW50aWZpZXIiLCJfYSIsInByb3ZpZGVyIiwiZ2V0UHJvdmlkZXIiLCJpc0luaXRpYWxpemVkIiwiZ2V0Q29tcG9uZW50IiwiaW5zdGFudGlhdGlvbk1vZGUiLCJpbml0aWFsaXplIiwiZ2V0SW1tZWRpYXRlIiwiaWRlbnRpZmllciIsIl9yZW1vdmVTZXJ2aWNlSW5zdGFuY2UiLCJjbGVhckluc3RhbmNlIiwiY29tcG9uZW50IiwidG9KU09OIiwiRVJST1JTIiwiRVJST1JfRkFDVE9SWSIsImNyZWF0ZUZpcmViYXNlTmFtZXNwYWNlQ29yZSIsImZpcmViYXNlQXBwSW1wbCIsImFwcHMiLCJuYW1lc3BhY2UiLCJfX2VzTW9kdWxlIiwiaW5pdGlhbGl6ZUFwcCIsImluaXRpYWxpemVBcHBDb21wYXQiLCJhcHAiLCJzZXRMb2dMZXZlbCIsIm9uTG9nIiwiU0RLX1ZFUlNJT04iLCJyZWdpc3RlckNvbXBvbmVudCIsInJlZ2lzdGVyQ29tcG9uZW50Q29tcGF0IiwidXNlQXNTZXJ2aWNlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJnZXRBcHBzIiwiY3JlYXRlIiwiYXBwTmFtZSIsInJhd0NvbmZpZyIsImFwcENvbXBhdCIsImtleXMiLCJtYXAiLCJjb21wb25lbnROYW1lIiwiY29tcG9uZW50TmFtZVdpdGhvdXRDb21wYXQiLCJyZXBsYWNlIiwiX3JlZ2lzdGVyQ29tcG9uZW50IiwidHlwZSIsInNlcnZpY2VOYW1lc3BhY2UiLCJhcHBBcmciLCJzZXJ2aWNlUHJvcHMiLCJ1bmRlZmluZWQiLCJwcm90b3R5cGUiLCJhcmdzIiwic2VydmljZUZ4biIsImJpbmQiLCJhcHBseSIsIm11bHRpcGxlSW5zdGFuY2VzIiwidXNlU2VydmljZSIsImNyZWF0ZUZpcmViYXNlTmFtZXNwYWNlIiwiYXNzaWduIiwiZXh0ZW5kTmFtZXNwYWNlIiwicHJvcHMiLCJmaXJlYmFzZSQxIiwibG9nZ2VyIiwidmVyc2lvbiIsInJlZ2lzdGVyQ29yZUNvbXBvbmVudHMiLCJ2YXJpYW50Iiwic2VsZiIsIndhcm4iLCJzZGtWZXJzaW9uIiwiaW5kZXhPZiIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/app-compat/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js":
/*!**************************************************************!*\
  !*** ./node_modules/@firebase/app/dist/esm/index.esm2017.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FirebaseError: () => (/* reexport safe */ _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError),\n/* harmony export */   SDK_VERSION: () => (/* binding */ SDK_VERSION),\n/* harmony export */   _DEFAULT_ENTRY_NAME: () => (/* binding */ DEFAULT_ENTRY_NAME),\n/* harmony export */   _addComponent: () => (/* binding */ _addComponent),\n/* harmony export */   _addOrOverwriteComponent: () => (/* binding */ _addOrOverwriteComponent),\n/* harmony export */   _apps: () => (/* binding */ _apps),\n/* harmony export */   _clearComponents: () => (/* binding */ _clearComponents),\n/* harmony export */   _components: () => (/* binding */ _components),\n/* harmony export */   _getProvider: () => (/* binding */ _getProvider),\n/* harmony export */   _registerComponent: () => (/* binding */ _registerComponent),\n/* harmony export */   _removeServiceInstance: () => (/* binding */ _removeServiceInstance),\n/* harmony export */   deleteApp: () => (/* binding */ deleteApp),\n/* harmony export */   getApp: () => (/* binding */ getApp),\n/* harmony export */   getApps: () => (/* binding */ getApps),\n/* harmony export */   initializeApp: () => (/* binding */ initializeApp),\n/* harmony export */   onLog: () => (/* binding */ onLog),\n/* harmony export */   registerVersion: () => (/* binding */ registerVersion),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel)\n/* harmony export */ });\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/logger */ \"(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! idb */ \"(ssr)/./node_modules/idb/build/index.js\");\n\n\n\n\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class PlatformLoggerServiceImpl {\n    constructor(container){\n        this.container = container;\n    }\n    // In initial implementation, this will be called by installations on\n    // auth token refresh, and installations will send this string.\n    getPlatformInfoString() {\n        const providers = this.container.getProviders();\n        // Loop through providers and get library/version pairs from any that are\n        // version components.\n        return providers.map((provider)=>{\n            if (isVersionServiceProvider(provider)) {\n                const service = provider.getImmediate();\n                return `${service.library}/${service.version}`;\n            } else {\n                return null;\n            }\n        }).filter((logString)=>logString).join(\" \");\n    }\n}\n/**\r\n *\r\n * @param provider check if this provider provides a VersionService\r\n *\r\n * NOTE: Using Provider<'app-version'> is a hack to indicate that the provider\r\n * provides VersionService. The provider is not necessarily a 'app-version'\r\n * provider.\r\n */ function isVersionServiceProvider(provider) {\n    const component = provider.getComponent();\n    return (component === null || component === void 0 ? void 0 : component.type) === \"VERSION\" /* ComponentType.VERSION */ ;\n}\nconst name$o = \"@firebase/app\";\nconst version$1 = \"0.9.29\";\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const logger = new _firebase_logger__WEBPACK_IMPORTED_MODULE_1__.Logger(\"@firebase/app\");\nconst name$n = \"@firebase/app-compat\";\nconst name$m = \"@firebase/analytics-compat\";\nconst name$l = \"@firebase/analytics\";\nconst name$k = \"@firebase/app-check-compat\";\nconst name$j = \"@firebase/app-check\";\nconst name$i = \"@firebase/auth\";\nconst name$h = \"@firebase/auth-compat\";\nconst name$g = \"@firebase/database\";\nconst name$f = \"@firebase/database-compat\";\nconst name$e = \"@firebase/functions\";\nconst name$d = \"@firebase/functions-compat\";\nconst name$c = \"@firebase/installations\";\nconst name$b = \"@firebase/installations-compat\";\nconst name$a = \"@firebase/messaging\";\nconst name$9 = \"@firebase/messaging-compat\";\nconst name$8 = \"@firebase/performance\";\nconst name$7 = \"@firebase/performance-compat\";\nconst name$6 = \"@firebase/remote-config\";\nconst name$5 = \"@firebase/remote-config-compat\";\nconst name$4 = \"@firebase/storage\";\nconst name$3 = \"@firebase/storage-compat\";\nconst name$2 = \"@firebase/firestore\";\nconst name$1 = \"@firebase/firestore-compat\";\nconst name = \"firebase\";\nconst version = \"10.9.0\";\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * The default app name\r\n *\r\n * @internal\r\n */ const DEFAULT_ENTRY_NAME = \"[DEFAULT]\";\nconst PLATFORM_LOG_STRING = {\n    [name$o]: \"fire-core\",\n    [name$n]: \"fire-core-compat\",\n    [name$l]: \"fire-analytics\",\n    [name$m]: \"fire-analytics-compat\",\n    [name$j]: \"fire-app-check\",\n    [name$k]: \"fire-app-check-compat\",\n    [name$i]: \"fire-auth\",\n    [name$h]: \"fire-auth-compat\",\n    [name$g]: \"fire-rtdb\",\n    [name$f]: \"fire-rtdb-compat\",\n    [name$e]: \"fire-fn\",\n    [name$d]: \"fire-fn-compat\",\n    [name$c]: \"fire-iid\",\n    [name$b]: \"fire-iid-compat\",\n    [name$a]: \"fire-fcm\",\n    [name$9]: \"fire-fcm-compat\",\n    [name$8]: \"fire-perf\",\n    [name$7]: \"fire-perf-compat\",\n    [name$6]: \"fire-rc\",\n    [name$5]: \"fire-rc-compat\",\n    [name$4]: \"fire-gcs\",\n    [name$3]: \"fire-gcs-compat\",\n    [name$2]: \"fire-fst\",\n    [name$1]: \"fire-fst-compat\",\n    \"fire-js\": \"fire-js\",\n    [name]: \"fire-js-all\"\n};\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * @internal\r\n */ const _apps = new Map();\n/**\r\n * Registered components.\r\n *\r\n * @internal\r\n */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst _components = new Map();\n/**\r\n * @param component - the component being added to this app's container\r\n *\r\n * @internal\r\n */ function _addComponent(app, component) {\n    try {\n        app.container.addComponent(component);\n    } catch (e) {\n        logger.debug(`Component ${component.name} failed to register with FirebaseApp ${app.name}`, e);\n    }\n}\n/**\r\n *\r\n * @internal\r\n */ function _addOrOverwriteComponent(app, component) {\n    app.container.addOrOverwriteComponent(component);\n}\n/**\r\n *\r\n * @param component - the component to register\r\n * @returns whether or not the component is registered successfully\r\n *\r\n * @internal\r\n */ function _registerComponent(component) {\n    const componentName = component.name;\n    if (_components.has(componentName)) {\n        logger.debug(`There were multiple attempts to register component ${componentName}.`);\n        return false;\n    }\n    _components.set(componentName, component);\n    // add the component to existing app instances\n    for (const app of _apps.values()){\n        _addComponent(app, component);\n    }\n    return true;\n}\n/**\r\n *\r\n * @param app - FirebaseApp instance\r\n * @param name - service name\r\n *\r\n * @returns the provider for the service with the matching name\r\n *\r\n * @internal\r\n */ function _getProvider(app, name) {\n    const heartbeatController = app.container.getProvider(\"heartbeat\").getImmediate({\n        optional: true\n    });\n    if (heartbeatController) {\n        void heartbeatController.triggerHeartbeat();\n    }\n    return app.container.getProvider(name);\n}\n/**\r\n *\r\n * @param app - FirebaseApp instance\r\n * @param name - service name\r\n * @param instanceIdentifier - service instance identifier in case the service supports multiple instances\r\n *\r\n * @internal\r\n */ function _removeServiceInstance(app, name, instanceIdentifier = DEFAULT_ENTRY_NAME) {\n    _getProvider(app, name).clearInstance(instanceIdentifier);\n}\n/**\r\n * Test only\r\n *\r\n * @internal\r\n */ function _clearComponents() {\n    _components.clear();\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const ERRORS = {\n    [\"no-app\" /* AppError.NO_APP */ ]: \"No Firebase App '{$appName}' has been created - \" + \"call initializeApp() first\",\n    [\"bad-app-name\" /* AppError.BAD_APP_NAME */ ]: \"Illegal App name: '{$appName}\",\n    [\"duplicate-app\" /* AppError.DUPLICATE_APP */ ]: \"Firebase App named '{$appName}' already exists with different options or config\",\n    [\"app-deleted\" /* AppError.APP_DELETED */ ]: \"Firebase App named '{$appName}' already deleted\",\n    [\"no-options\" /* AppError.NO_OPTIONS */ ]: \"Need to provide options, when not being deployed to hosting via source.\",\n    [\"invalid-app-argument\" /* AppError.INVALID_APP_ARGUMENT */ ]: \"firebase.{$appName}() takes either no argument or a \" + \"Firebase App instance.\",\n    [\"invalid-log-argument\" /* AppError.INVALID_LOG_ARGUMENT */ ]: \"First argument to `onLog` must be null or a function.\",\n    [\"idb-open\" /* AppError.IDB_OPEN */ ]: \"Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.\",\n    [\"idb-get\" /* AppError.IDB_GET */ ]: \"Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.\",\n    [\"idb-set\" /* AppError.IDB_WRITE */ ]: \"Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.\",\n    [\"idb-delete\" /* AppError.IDB_DELETE */ ]: \"Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.\"\n};\nconst ERROR_FACTORY = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.ErrorFactory(\"app\", \"Firebase\", ERRORS);\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class FirebaseAppImpl {\n    constructor(options, config, container){\n        this._isDeleted = false;\n        this._options = Object.assign({}, options);\n        this._config = Object.assign({}, config);\n        this._name = config.name;\n        this._automaticDataCollectionEnabled = config.automaticDataCollectionEnabled;\n        this._container = container;\n        this.container.addComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component(\"app\", ()=>this, \"PUBLIC\" /* ComponentType.PUBLIC */ ));\n    }\n    get automaticDataCollectionEnabled() {\n        this.checkDestroyed();\n        return this._automaticDataCollectionEnabled;\n    }\n    set automaticDataCollectionEnabled(val) {\n        this.checkDestroyed();\n        this._automaticDataCollectionEnabled = val;\n    }\n    get name() {\n        this.checkDestroyed();\n        return this._name;\n    }\n    get options() {\n        this.checkDestroyed();\n        return this._options;\n    }\n    get config() {\n        this.checkDestroyed();\n        return this._config;\n    }\n    get container() {\n        return this._container;\n    }\n    get isDeleted() {\n        return this._isDeleted;\n    }\n    set isDeleted(val) {\n        this._isDeleted = val;\n    }\n    /**\r\n     * This function will throw an Error if the App has already been deleted -\r\n     * use before performing API actions on the App.\r\n     */ checkDestroyed() {\n        if (this.isDeleted) {\n            throw ERROR_FACTORY.create(\"app-deleted\" /* AppError.APP_DELETED */ , {\n                appName: this._name\n            });\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * The current SDK version.\r\n *\r\n * @public\r\n */ const SDK_VERSION = version;\nfunction initializeApp(_options, rawConfig = {}) {\n    let options = _options;\n    if (typeof rawConfig !== \"object\") {\n        const name = rawConfig;\n        rawConfig = {\n            name\n        };\n    }\n    const config = Object.assign({\n        name: DEFAULT_ENTRY_NAME,\n        automaticDataCollectionEnabled: false\n    }, rawConfig);\n    const name = config.name;\n    if (typeof name !== \"string\" || !name) {\n        throw ERROR_FACTORY.create(\"bad-app-name\" /* AppError.BAD_APP_NAME */ , {\n            appName: String(name)\n        });\n    }\n    options || (options = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getDefaultAppConfig)());\n    if (!options) {\n        throw ERROR_FACTORY.create(\"no-options\" /* AppError.NO_OPTIONS */ );\n    }\n    const existingApp = _apps.get(name);\n    if (existingApp) {\n        // return the existing app if options and config deep equal the ones in the existing app.\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(options, existingApp.options) && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(config, existingApp.config)) {\n            return existingApp;\n        } else {\n            throw ERROR_FACTORY.create(\"duplicate-app\" /* AppError.DUPLICATE_APP */ , {\n                appName: name\n            });\n        }\n    }\n    const container = new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.ComponentContainer(name);\n    for (const component of _components.values()){\n        container.addComponent(component);\n    }\n    const newApp = new FirebaseAppImpl(options, config, container);\n    _apps.set(name, newApp);\n    return newApp;\n}\n/**\r\n * Retrieves a {@link @firebase/app#FirebaseApp} instance.\r\n *\r\n * When called with no arguments, the default app is returned. When an app name\r\n * is provided, the app corresponding to that name is returned.\r\n *\r\n * An exception is thrown if the app being retrieved has not yet been\r\n * initialized.\r\n *\r\n * @example\r\n * ```javascript\r\n * // Return the default app\r\n * const app = getApp();\r\n * ```\r\n *\r\n * @example\r\n * ```javascript\r\n * // Return a named app\r\n * const otherApp = getApp(\"otherApp\");\r\n * ```\r\n *\r\n * @param name - Optional name of the app to return. If no name is\r\n *   provided, the default is `\"[DEFAULT]\"`.\r\n *\r\n * @returns The app corresponding to the provided app name.\r\n *   If no app name is provided, the default app is returned.\r\n *\r\n * @public\r\n */ function getApp(name = DEFAULT_ENTRY_NAME) {\n    const app = _apps.get(name);\n    if (!app && name === DEFAULT_ENTRY_NAME && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getDefaultAppConfig)()) {\n        return initializeApp();\n    }\n    if (!app) {\n        throw ERROR_FACTORY.create(\"no-app\" /* AppError.NO_APP */ , {\n            appName: name\n        });\n    }\n    return app;\n}\n/**\r\n * A (read-only) array of all initialized apps.\r\n * @public\r\n */ function getApps() {\n    return Array.from(_apps.values());\n}\n/**\r\n * Renders this app unusable and frees the resources of all associated\r\n * services.\r\n *\r\n * @example\r\n * ```javascript\r\n * deleteApp(app)\r\n *   .then(function() {\r\n *     console.log(\"App deleted successfully\");\r\n *   })\r\n *   .catch(function(error) {\r\n *     console.log(\"Error deleting app:\", error);\r\n *   });\r\n * ```\r\n *\r\n * @public\r\n */ async function deleteApp(app) {\n    const name = app.name;\n    if (_apps.has(name)) {\n        _apps.delete(name);\n        await Promise.all(app.container.getProviders().map((provider)=>provider.delete()));\n        app.isDeleted = true;\n    }\n}\n/**\r\n * Registers a library's name and version for platform logging purposes.\r\n * @param library - Name of 1p or 3p library (e.g. firestore, angularfire)\r\n * @param version - Current version of that library.\r\n * @param variant - Bundle variant, e.g., node, rn, etc.\r\n *\r\n * @public\r\n */ function registerVersion(libraryKeyOrName, version, variant) {\n    var _a;\n    // TODO: We can use this check to whitelist strings when/if we set up\n    // a good whitelist system.\n    let library = (_a = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a !== void 0 ? _a : libraryKeyOrName;\n    if (variant) {\n        library += `-${variant}`;\n    }\n    const libraryMismatch = library.match(/\\s|\\//);\n    const versionMismatch = version.match(/\\s|\\//);\n    if (libraryMismatch || versionMismatch) {\n        const warning = [\n            `Unable to register library \"${library}\" with version \"${version}\":`\n        ];\n        if (libraryMismatch) {\n            warning.push(`library name \"${library}\" contains illegal characters (whitespace or \"/\")`);\n        }\n        if (libraryMismatch && versionMismatch) {\n            warning.push(\"and\");\n        }\n        if (versionMismatch) {\n            warning.push(`version name \"${version}\" contains illegal characters (whitespace or \"/\")`);\n        }\n        logger.warn(warning.join(\" \"));\n        return;\n    }\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component(`${library}-version`, ()=>({\n            library,\n            version\n        }), \"VERSION\" /* ComponentType.VERSION */ ));\n}\n/**\r\n * Sets log handler for all Firebase SDKs.\r\n * @param logCallback - An optional custom log handler that executes user code whenever\r\n * the Firebase SDK makes a logging call.\r\n *\r\n * @public\r\n */ function onLog(logCallback, options) {\n    if (logCallback !== null && typeof logCallback !== \"function\") {\n        throw ERROR_FACTORY.create(\"invalid-log-argument\" /* AppError.INVALID_LOG_ARGUMENT */ );\n    }\n    (0,_firebase_logger__WEBPACK_IMPORTED_MODULE_1__.setUserLogHandler)(logCallback, options);\n}\n/**\r\n * Sets log level for all Firebase SDKs.\r\n *\r\n * All of the log types above the current log level are captured (i.e. if\r\n * you set the log level to `info`, errors are logged, but `debug` and\r\n * `verbose` logs are not).\r\n *\r\n * @public\r\n */ function setLogLevel(logLevel) {\n    (0,_firebase_logger__WEBPACK_IMPORTED_MODULE_1__.setLogLevel)(logLevel);\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const DB_NAME = \"firebase-heartbeat-database\";\nconst DB_VERSION = 1;\nconst STORE_NAME = \"firebase-heartbeat-store\";\nlet dbPromise = null;\nfunction getDbPromise() {\n    if (!dbPromise) {\n        dbPromise = (0,idb__WEBPACK_IMPORTED_MODULE_3__.openDB)(DB_NAME, DB_VERSION, {\n            upgrade: (db, oldVersion)=>{\n                // We don't use 'break' in this switch statement, the fall-through\n                // behavior is what we want, because if there are multiple versions between\n                // the old version and the current version, we want ALL the migrations\n                // that correspond to those versions to run, not only the last one.\n                // eslint-disable-next-line default-case\n                switch(oldVersion){\n                    case 0:\n                        try {\n                            db.createObjectStore(STORE_NAME);\n                        } catch (e) {\n                            // Safari/iOS browsers throw occasional exceptions on\n                            // db.createObjectStore() that may be a bug. Avoid blocking\n                            // the rest of the app functionality.\n                            console.warn(e);\n                        }\n                }\n            }\n        }).catch((e)=>{\n            throw ERROR_FACTORY.create(\"idb-open\" /* AppError.IDB_OPEN */ , {\n                originalErrorMessage: e.message\n            });\n        });\n    }\n    return dbPromise;\n}\nasync function readHeartbeatsFromIndexedDB(app) {\n    try {\n        const db = await getDbPromise();\n        const tx = db.transaction(STORE_NAME);\n        const result = await tx.objectStore(STORE_NAME).get(computeKey(app));\n        // We already have the value but tx.done can throw,\n        // so we need to await it here to catch errors\n        await tx.done;\n        return result;\n    } catch (e) {\n        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError) {\n            logger.warn(e.message);\n        } else {\n            const idbGetError = ERROR_FACTORY.create(\"idb-get\" /* AppError.IDB_GET */ , {\n                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\n            });\n            logger.warn(idbGetError.message);\n        }\n    }\n}\nasync function writeHeartbeatsToIndexedDB(app, heartbeatObject) {\n    try {\n        const db = await getDbPromise();\n        const tx = db.transaction(STORE_NAME, \"readwrite\");\n        const objectStore = tx.objectStore(STORE_NAME);\n        await objectStore.put(heartbeatObject, computeKey(app));\n        await tx.done;\n    } catch (e) {\n        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError) {\n            logger.warn(e.message);\n        } else {\n            const idbGetError = ERROR_FACTORY.create(\"idb-set\" /* AppError.IDB_WRITE */ , {\n                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\n            });\n            logger.warn(idbGetError.message);\n        }\n    }\n}\nfunction computeKey(app) {\n    return `${app.name}!${app.options.appId}`;\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const MAX_HEADER_BYTES = 1024;\n// 30 days\nconst STORED_HEARTBEAT_RETENTION_MAX_MILLIS = 30 * 24 * 60 * 60 * 1000;\nclass HeartbeatServiceImpl {\n    constructor(container){\n        this.container = container;\n        /**\r\n         * In-memory cache for heartbeats, used by getHeartbeatsHeader() to generate\r\n         * the header string.\r\n         * Stores one record per date. This will be consolidated into the standard\r\n         * format of one record per user agent string before being sent as a header.\r\n         * Populated from indexedDB when the controller is instantiated and should\r\n         * be kept in sync with indexedDB.\r\n         * Leave public for easier testing.\r\n         */ this._heartbeatsCache = null;\n        const app = this.container.getProvider(\"app\").getImmediate();\n        this._storage = new HeartbeatStorageImpl(app);\n        this._heartbeatsCachePromise = this._storage.read().then((result)=>{\n            this._heartbeatsCache = result;\n            return result;\n        });\n    }\n    /**\r\n     * Called to report a heartbeat. The function will generate\r\n     * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it\r\n     * to IndexedDB.\r\n     * Note that we only store one heartbeat per day. So if a heartbeat for today is\r\n     * already logged, subsequent calls to this function in the same day will be ignored.\r\n     */ async triggerHeartbeat() {\n        var _a, _b;\n        const platformLogger = this.container.getProvider(\"platform-logger\").getImmediate();\n        // This is the \"Firebase user agent\" string from the platform logger\n        // service, not the browser user agent.\n        const agent = platformLogger.getPlatformInfoString();\n        const date = getUTCDateString();\n        if (((_a = this._heartbeatsCache) === null || _a === void 0 ? void 0 : _a.heartbeats) == null) {\n            this._heartbeatsCache = await this._heartbeatsCachePromise;\n            // If we failed to construct a heartbeats cache, then return immediately.\n            if (((_b = this._heartbeatsCache) === null || _b === void 0 ? void 0 : _b.heartbeats) == null) {\n                return;\n            }\n        }\n        // Do not store a heartbeat if one is already stored for this day\n        // or if a header has already been sent today.\n        if (this._heartbeatsCache.lastSentHeartbeatDate === date || this._heartbeatsCache.heartbeats.some((singleDateHeartbeat)=>singleDateHeartbeat.date === date)) {\n            return;\n        } else {\n            // There is no entry for this date. Create one.\n            this._heartbeatsCache.heartbeats.push({\n                date,\n                agent\n            });\n        }\n        // Remove entries older than 30 days.\n        this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter((singleDateHeartbeat)=>{\n            const hbTimestamp = new Date(singleDateHeartbeat.date).valueOf();\n            const now = Date.now();\n            return now - hbTimestamp <= STORED_HEARTBEAT_RETENTION_MAX_MILLIS;\n        });\n        return this._storage.overwrite(this._heartbeatsCache);\n    }\n    /**\r\n     * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.\r\n     * It also clears all heartbeats from memory as well as in IndexedDB.\r\n     *\r\n     * NOTE: Consuming product SDKs should not send the header if this method\r\n     * returns an empty string.\r\n     */ async getHeartbeatsHeader() {\n        var _a;\n        if (this._heartbeatsCache === null) {\n            await this._heartbeatsCachePromise;\n        }\n        // If it's still null or the array is empty, there is no data to send.\n        if (((_a = this._heartbeatsCache) === null || _a === void 0 ? void 0 : _a.heartbeats) == null || this._heartbeatsCache.heartbeats.length === 0) {\n            return \"\";\n        }\n        const date = getUTCDateString();\n        // Extract as many heartbeats from the cache as will fit under the size limit.\n        const { heartbeatsToSend, unsentEntries } = extractHeartbeatsForHeader(this._heartbeatsCache.heartbeats);\n        const headerString = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64urlEncodeWithoutPadding)(JSON.stringify({\n            version: 2,\n            heartbeats: heartbeatsToSend\n        }));\n        // Store last sent date to prevent another being logged/sent for the same day.\n        this._heartbeatsCache.lastSentHeartbeatDate = date;\n        if (unsentEntries.length > 0) {\n            // Store any unsent entries if they exist.\n            this._heartbeatsCache.heartbeats = unsentEntries;\n            // This seems more likely than emptying the array (below) to lead to some odd state\n            // since the cache isn't empty and this will be called again on the next request,\n            // and is probably safest if we await it.\n            await this._storage.overwrite(this._heartbeatsCache);\n        } else {\n            this._heartbeatsCache.heartbeats = [];\n            // Do not wait for this, to reduce latency.\n            void this._storage.overwrite(this._heartbeatsCache);\n        }\n        return headerString;\n    }\n}\nfunction getUTCDateString() {\n    const today = new Date();\n    // Returns date format 'YYYY-MM-DD'\n    return today.toISOString().substring(0, 10);\n}\nfunction extractHeartbeatsForHeader(heartbeatsCache, maxSize = MAX_HEADER_BYTES) {\n    // Heartbeats grouped by user agent in the standard format to be sent in\n    // the header.\n    const heartbeatsToSend = [];\n    // Single date format heartbeats that are not sent.\n    let unsentEntries = heartbeatsCache.slice();\n    for (const singleDateHeartbeat of heartbeatsCache){\n        // Look for an existing entry with the same user agent.\n        const heartbeatEntry = heartbeatsToSend.find((hb)=>hb.agent === singleDateHeartbeat.agent);\n        if (!heartbeatEntry) {\n            // If no entry for this user agent exists, create one.\n            heartbeatsToSend.push({\n                agent: singleDateHeartbeat.agent,\n                dates: [\n                    singleDateHeartbeat.date\n                ]\n            });\n            if (countBytes(heartbeatsToSend) > maxSize) {\n                // If the header would exceed max size, remove the added heartbeat\n                // entry and stop adding to the header.\n                heartbeatsToSend.pop();\n                break;\n            }\n        } else {\n            heartbeatEntry.dates.push(singleDateHeartbeat.date);\n            // If the header would exceed max size, remove the added date\n            // and stop adding to the header.\n            if (countBytes(heartbeatsToSend) > maxSize) {\n                heartbeatEntry.dates.pop();\n                break;\n            }\n        }\n        // Pop unsent entry from queue. (Skipped if adding the entry exceeded\n        // quota and the loop breaks early.)\n        unsentEntries = unsentEntries.slice(1);\n    }\n    return {\n        heartbeatsToSend,\n        unsentEntries\n    };\n}\nclass HeartbeatStorageImpl {\n    constructor(app){\n        this.app = app;\n        this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();\n    }\n    async runIndexedDBEnvironmentCheck() {\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isIndexedDBAvailable)()) {\n            return false;\n        } else {\n            return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateIndexedDBOpenable)().then(()=>true).catch(()=>false);\n        }\n    }\n    /**\r\n     * Read all heartbeats.\r\n     */ async read() {\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\n        if (!canUseIndexedDB) {\n            return {\n                heartbeats: []\n            };\n        } else {\n            const idbHeartbeatObject = await readHeartbeatsFromIndexedDB(this.app);\n            if (idbHeartbeatObject === null || idbHeartbeatObject === void 0 ? void 0 : idbHeartbeatObject.heartbeats) {\n                return idbHeartbeatObject;\n            } else {\n                return {\n                    heartbeats: []\n                };\n            }\n        }\n    }\n    // overwrite the storage with the provided heartbeats\n    async overwrite(heartbeatsObject) {\n        var _a;\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\n        if (!canUseIndexedDB) {\n            return;\n        } else {\n            const existingHeartbeatsObject = await this.read();\n            return writeHeartbeatsToIndexedDB(this.app, {\n                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,\n                heartbeats: heartbeatsObject.heartbeats\n            });\n        }\n    }\n    // add heartbeats\n    async add(heartbeatsObject) {\n        var _a;\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\n        if (!canUseIndexedDB) {\n            return;\n        } else {\n            const existingHeartbeatsObject = await this.read();\n            return writeHeartbeatsToIndexedDB(this.app, {\n                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,\n                heartbeats: [\n                    ...existingHeartbeatsObject.heartbeats,\n                    ...heartbeatsObject.heartbeats\n                ]\n            });\n        }\n    }\n}\n/**\r\n * Calculate bytes of a HeartbeatsByUserAgent array after being wrapped\r\n * in a platform logging header JSON object, stringified, and converted\r\n * to base 64.\r\n */ function countBytes(heartbeatsCache) {\n    // base64 has a restricted set of characters, all of which should be 1 byte.\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64urlEncodeWithoutPadding)(// heartbeatsCache wrapper properties\n    JSON.stringify({\n        version: 2,\n        heartbeats: heartbeatsCache\n    })).length;\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function registerCoreComponents(variant) {\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component(\"platform-logger\", (container)=>new PlatformLoggerServiceImpl(container), \"PRIVATE\" /* ComponentType.PRIVATE */ ));\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component(\"heartbeat\", (container)=>new HeartbeatServiceImpl(container), \"PRIVATE\" /* ComponentType.PRIVATE */ ));\n    // Register `app` package.\n    registerVersion(name$o, version$1, variant);\n    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\n    registerVersion(name$o, version$1, \"esm2017\");\n    // Register platform SDK identifier (no version).\n    registerVersion(\"fire-js\", \"\");\n}\n/**\r\n * Firebase App\r\n *\r\n * @remarks This package coordinates the communication between the different Firebase components\r\n * @packageDocumentation\r\n */ registerCoreComponents(\"\");\n //# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2FwcC9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0U7QUFDdUI7QUFDa0Y7QUFDOUg7QUFDbEI7QUFFN0I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0QsTUFBTWM7SUFDRkMsWUFBWUMsU0FBUyxDQUFFO1FBQ25CLElBQUksQ0FBQ0EsU0FBUyxHQUFHQTtJQUNyQjtJQUNBLHFFQUFxRTtJQUNyRSwrREFBK0Q7SUFDL0RDLHdCQUF3QjtRQUNwQixNQUFNQyxZQUFZLElBQUksQ0FBQ0YsU0FBUyxDQUFDRyxZQUFZO1FBQzdDLHlFQUF5RTtRQUN6RSxzQkFBc0I7UUFDdEIsT0FBT0QsVUFDRkUsR0FBRyxDQUFDQyxDQUFBQTtZQUNMLElBQUlDLHlCQUF5QkQsV0FBVztnQkFDcEMsTUFBTUUsVUFBVUYsU0FBU0csWUFBWTtnQkFDckMsT0FBTyxDQUFDLEVBQUVELFFBQVFFLE9BQU8sQ0FBQyxDQUFDLEVBQUVGLFFBQVFHLE9BQU8sQ0FBQyxDQUFDO1lBQ2xELE9BQ0s7Z0JBQ0QsT0FBTztZQUNYO1FBQ0osR0FDS0MsTUFBTSxDQUFDQyxDQUFBQSxZQUFhQSxXQUNwQkMsSUFBSSxDQUFDO0lBQ2Q7QUFDSjtBQUNBOzs7Ozs7O0NBT0MsR0FDRCxTQUFTUCx5QkFBeUJELFFBQVE7SUFDdEMsTUFBTVMsWUFBWVQsU0FBU1UsWUFBWTtJQUN2QyxPQUFPLENBQUNELGNBQWMsUUFBUUEsY0FBYyxLQUFLLElBQUksS0FBSyxJQUFJQSxVQUFVRSxJQUFJLE1BQU0sVUFBVSx5QkFBeUI7QUFDekg7QUFFQSxNQUFNQyxTQUFTO0FBQ2YsTUFBTUMsWUFBWTtBQUVsQjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRCxNQUFNQyxTQUFTLElBQUlqQyxvREFBTUEsQ0FBQztBQUUxQixNQUFNa0MsU0FBUztBQUVmLE1BQU1DLFNBQVM7QUFFZixNQUFNQyxTQUFTO0FB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eUJsQyxVQUFVO3VCQUNuQ2lDLGlCQUFpQmpDLFVBQVU7aUJBQ2pDO1lBQ0w7UUFDSjtJQUNKO0FBQ0o7QUFDQTs7OztDQUlDLEdBQ0QsU0FBUzJCLFdBQVdQLGVBQWU7SUFDL0IsNEVBQTRFO0lBQzVFLE9BQU92TCw2RUFBNkJBLENBQ3BDLHFDQUFxQztJQUNyQ2tMLEtBQUtDLFNBQVMsQ0FBQztRQUFFbkssU0FBUztRQUFHbUosWUFBWW9CO0lBQWdCLElBQUlWLE1BQU07QUFDdkU7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRCxTQUFTMEIsdUJBQXVCdEYsT0FBTztJQUNuQ25ELG1CQUFtQixJQUFJeEUsMERBQVNBLENBQUMsbUJBQW1CZ0IsQ0FBQUEsWUFBYSxJQUFJRiwwQkFBMEJFLFlBQVksVUFBVSx5QkFBeUI7SUFDOUl3RCxtQkFBbUIsSUFBSXhFLDBEQUFTQSxDQUFDLGFBQWFnQixDQUFBQSxZQUFhLElBQUlpSixxQkFBcUJqSixZQUFZLFVBQVUseUJBQXlCO0lBQ25JLDBCQUEwQjtJQUMxQnlHLGdCQUFnQnhGLFFBQVFDLFdBQVd5RjtJQUNuQywrRkFBK0Y7SUFDL0ZGLGdCQUFnQnhGLFFBQVFDLFdBQVc7SUFDbkMsaURBQWlEO0lBQ2pEdUYsZ0JBQWdCLFdBQVc7QUFDL0I7QUFFQTs7Ozs7Q0FLQyxHQUNEd0YsdUJBQXVCO0FBRW9RLENBQzNSLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL3dvcmxkd2ViLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hcHAvZGlzdC9lc20vaW5kZXguZXNtMjAxNy5qcz83MmMxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgQ29tcG9uZW50Q29udGFpbmVyIH0gZnJvbSAnQGZpcmViYXNlL2NvbXBvbmVudCc7XG5pbXBvcnQgeyBMb2dnZXIsIHNldFVzZXJMb2dIYW5kbGVyLCBzZXRMb2dMZXZlbCBhcyBzZXRMb2dMZXZlbCQxIH0gZnJvbSAnQGZpcmViYXNlL2xvZ2dlcic7XG5pbXBvcnQgeyBFcnJvckZhY3RvcnksIGdldERlZmF1bHRBcHBDb25maWcsIGRlZXBFcXVhbCwgRmlyZWJhc2VFcnJvciwgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcsIGlzSW5kZXhlZERCQXZhaWxhYmxlLCB2YWxpZGF0ZUluZGV4ZWREQk9wZW5hYmxlIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuZXhwb3J0IHsgRmlyZWJhc2VFcnJvciB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IG9wZW5EQiB9IGZyb20gJ2lkYic7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIFBsYXRmb3JtTG9nZ2VyU2VydmljZUltcGwge1xyXG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICB9XHJcbiAgICAvLyBJbiBpbml0aWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdpbGwgYmUgY2FsbGVkIGJ5IGluc3RhbGxhdGlvbnMgb25cclxuICAgIC8vIGF1dGggdG9rZW4gcmVmcmVzaCwgYW5kIGluc3RhbGxhdGlvbnMgd2lsbCBzZW5kIHRoaXMgc3RyaW5nLlxyXG4gICAgZ2V0UGxhdGZvcm1JbmZvU3RyaW5nKCkge1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVycyA9IHRoaXMuY29udGFpbmVyLmdldFByb3ZpZGVycygpO1xyXG4gICAgICAgIC8vIExvb3AgdGhyb3VnaCBwcm92aWRlcnMgYW5kIGdldCBsaWJyYXJ5L3ZlcnNpb24gcGFpcnMgZnJvbSBhbnkgdGhhdCBhcmVcclxuICAgICAgICAvLyB2ZXJzaW9uIGNvbXBvbmVudHMuXHJcbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyc1xyXG4gICAgICAgICAgICAubWFwKHByb3ZpZGVyID0+IHtcclxuICAgICAgICAgICAgaWYgKGlzVmVyc2lvblNlcnZpY2VQcm92aWRlcihwcm92aWRlcikpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZpY2UgPSBwcm92aWRlci5nZXRJbW1lZGlhdGUoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtzZXJ2aWNlLmxpYnJhcnl9LyR7c2VydmljZS52ZXJzaW9ufWA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5maWx0ZXIobG9nU3RyaW5nID0+IGxvZ1N0cmluZylcclxuICAgICAgICAgICAgLmpvaW4oJyAnKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICpcclxuICogQHBhcmFtIHByb3ZpZGVyIGNoZWNrIGlmIHRoaXMgcHJvdmlkZXIgcHJvdmlkZXMgYSBWZXJzaW9uU2VydmljZVxyXG4gKlxyXG4gKiBOT1RFOiBVc2luZyBQcm92aWRlcjwnYXBwLXZlcnNpb24nPiBpcyBhIGhhY2sgdG8gaW5kaWNhdGUgdGhhdCB0aGUgcHJvdmlkZXJcclxuICogcHJvdmlkZXMgVmVyc2lvblNlcnZpY2UuIFRoZSBwcm92aWRlciBpcyBub3QgbmVjZXNzYXJpbHkgYSAnYXBwLXZlcnNpb24nXHJcbiAqIHByb3ZpZGVyLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNWZXJzaW9uU2VydmljZVByb3ZpZGVyKHByb3ZpZGVyKSB7XHJcbiAgICBjb25zdCBjb21wb25lbnQgPSBwcm92aWRlci5nZXRDb21wb25lbnQoKTtcclxuICAgIHJldHVybiAoY29tcG9uZW50ID09PSBudWxsIHx8IGNvbXBvbmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29tcG9uZW50LnR5cGUpID09PSBcIlZFUlNJT05cIiAvKiBDb21wb25lbnRUeXBlLlZFUlNJT04gKi87XHJcbn1cblxuY29uc3QgbmFtZSRvID0gXCJAZmlyZWJhc2UvYXBwXCI7XG5jb25zdCB2ZXJzaW9uJDEgPSBcIjAuOS4yOVwiO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKCdAZmlyZWJhc2UvYXBwJyk7XG5cbmNvbnN0IG5hbWUkbiA9IFwiQGZpcmViYXNlL2FwcC1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRtID0gXCJAZmlyZWJhc2UvYW5hbHl0aWNzLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGwgPSBcIkBmaXJlYmFzZS9hbmFseXRpY3NcIjtcblxuY29uc3QgbmFtZSRrID0gXCJAZmlyZWJhc2UvYXBwLWNoZWNrLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGogPSBcIkBmaXJlYmFzZS9hcHAtY2hlY2tcIjtcblxuY29uc3QgbmFtZSRpID0gXCJAZmlyZWJhc2UvYXV0aFwiO1xuXG5jb25zdCBuYW1lJGggPSBcIkBmaXJlYmFzZS9hdXRoLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGcgPSBcIkBmaXJlYmFzZS9kYXRhYmFzZVwiO1xuXG5jb25zdCBuYW1lJGYgPSBcIkBmaXJlYmFzZS9kYXRhYmFzZS1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRlID0gXCJAZmlyZWJhc2UvZnVuY3Rpb25zXCI7XG5cbmNvbnN0IG5hbWUkZCA9IFwiQGZpcmViYXNlL2Z1bmN0aW9ucy1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRjID0gXCJAZmlyZWJhc2UvaW5zdGFsbGF0aW9uc1wiO1xuXG5jb25zdCBuYW1lJGIgPSBcIkBmaXJlYmFzZS9pbnN0YWxsYXRpb25zLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGEgPSBcIkBmaXJlYmFzZS9tZXNzYWdpbmdcIjtcblxuY29uc3QgbmFtZSQ5ID0gXCJAZmlyZWJhc2UvbWVzc2FnaW5nLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJDggPSBcIkBmaXJlYmFzZS9wZXJmb3JtYW5jZVwiO1xuXG5jb25zdCBuYW1lJDcgPSBcIkBmaXJlYmFzZS9wZXJmb3JtYW5jZS1jb21wYXRcIjtcblxuY29uc3QgbmFtZSQ2ID0gXCJAZmlyZWJhc2UvcmVtb3RlLWNvbmZpZ1wiO1xuXG5jb25zdCBuYW1lJDUgPSBcIkBmaXJlYmFzZS9yZW1vdGUtY29uZmlnLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJDQgPSBcIkBmaXJlYmFzZS9zdG9yYWdlXCI7XG5cbmNvbnN0IG5hbWUkMyA9IFwiQGZpcmViYXNlL3N0b3JhZ2UtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkMiA9IFwiQGZpcmViYXNlL2ZpcmVzdG9yZVwiO1xuXG5jb25zdCBuYW1lJDEgPSBcIkBmaXJlYmFzZS9maXJlc3RvcmUtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUgPSBcImZpcmViYXNlXCI7XG5jb25zdCB2ZXJzaW9uID0gXCIxMC45LjBcIjtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRoZSBkZWZhdWx0IGFwcCBuYW1lXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY29uc3QgREVGQVVMVF9FTlRSWV9OQU1FID0gJ1tERUZBVUxUXSc7XHJcbmNvbnN0IFBMQVRGT1JNX0xPR19TVFJJTkcgPSB7XHJcbiAgICBbbmFtZSRvXTogJ2ZpcmUtY29yZScsXHJcbiAgICBbbmFtZSRuXTogJ2ZpcmUtY29yZS1jb21wYXQnLFxyXG4gICAgW25hbWUkbF06ICdmaXJlLWFuYWx5dGljcycsXHJcbiAgICBbbmFtZSRtXTogJ2ZpcmUtYW5hbHl0aWNzLWNvbXBhdCcsXHJcbiAgICBbbmFtZSRqXTogJ2ZpcmUtYXBwLWNoZWNrJyxcclxuICAgIFtuYW1lJGtdOiAnZmlyZS1hcHAtY2hlY2stY29tcGF0JyxcclxuICAgIFtuYW1lJGldOiAnZmlyZS1hdXRoJyxcclxuICAgIFtuYW1lJGhdOiAnZmlyZS1hdXRoLWNvbXBhdCcsXHJcbiAgICBbbmFtZSRnXTogJ2ZpcmUtcnRkYicsXHJcbiAgICBbbmFtZSRmXTogJ2ZpcmUtcnRkYi1jb21wYXQnLFxyXG4gICAgW25hbWUkZV06ICdmaXJlLWZuJyxcclxuICAgIFtuYW1lJGRdOiAnZmlyZS1mbi1jb21wYXQnLFxyXG4gICAgW25hbWUkY106ICdmaXJlLWlpZCcsXHJcbiAgICBbbmFtZSRiXTogJ2ZpcmUtaWlkLWNvbXBhdCcsXHJcbiAgICBbbmFtZSRhXTogJ2ZpcmUtZmNtJyxcclxuICAgIFtuYW1lJDldOiAnZmlyZS1mY20tY29tcGF0JyxcclxuICAgIFtuYW1lJDhdOiAnZmlyZS1wZXJmJyxcclxuICAgIFtuYW1lJDddOiAnZmlyZS1wZXJmLWNvbXBhdCcsXHJcbiAgICBbbmFtZSQ2XTogJ2ZpcmUtcmMnLFxyXG4gICAgW25hbWUkNV06ICdmaXJlLXJjLWNvbXBhdCcsXHJcbiAgICBbbmFtZSQ0XTogJ2ZpcmUtZ2NzJyxcclxuICAgIFtuYW1lJDNdOiAnZmlyZS1nY3MtY29tcGF0JyxcclxuICAgIFtuYW1lJDJdOiAnZmlyZS1mc3QnLFxyXG4gICAgW25hbWUkMV06ICdmaXJlLWZzdC1jb21wYXQnLFxyXG4gICAgJ2ZpcmUtanMnOiAnZmlyZS1qcycsXHJcbiAgICBbbmFtZV06ICdmaXJlLWpzLWFsbCdcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY29uc3QgX2FwcHMgPSBuZXcgTWFwKCk7XHJcbi8qKlxyXG4gKiBSZWdpc3RlcmVkIGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuY29uc3QgX2NvbXBvbmVudHMgPSBuZXcgTWFwKCk7XHJcbi8qKlxyXG4gKiBAcGFyYW0gY29tcG9uZW50IC0gdGhlIGNvbXBvbmVudCBiZWluZyBhZGRlZCB0byB0aGlzIGFwcCdzIGNvbnRhaW5lclxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIF9hZGRDb21wb25lbnQoYXBwLCBjb21wb25lbnQpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgYXBwLmNvbnRhaW5lci5hZGRDb21wb25lbnQoY29tcG9uZW50KTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBDb21wb25lbnQgJHtjb21wb25lbnQubmFtZX0gZmFpbGVkIHRvIHJlZ2lzdGVyIHdpdGggRmlyZWJhc2VBcHAgJHthcHAubmFtZX1gLCBlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBfYWRkT3JPdmVyd3JpdGVDb21wb25lbnQoYXBwLCBjb21wb25lbnQpIHtcclxuICAgIGFwcC5jb250YWluZXIuYWRkT3JPdmVyd3JpdGVDb21wb25lbnQoY29tcG9uZW50KTtcclxufVxyXG4vKipcclxuICpcclxuICogQHBhcmFtIGNvbXBvbmVudCAtIHRoZSBjb21wb25lbnQgdG8gcmVnaXN0ZXJcclxuICogQHJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGNvbXBvbmVudCBpcyByZWdpc3RlcmVkIHN1Y2Nlc3NmdWxseVxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIF9yZWdpc3RlckNvbXBvbmVudChjb21wb25lbnQpIHtcclxuICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQubmFtZTtcclxuICAgIGlmIChfY29tcG9uZW50cy5oYXMoY29tcG9uZW50TmFtZSkpIHtcclxuICAgICAgICBsb2dnZXIuZGVidWcoYFRoZXJlIHdlcmUgbXVsdGlwbGUgYXR0ZW1wdHMgdG8gcmVnaXN0ZXIgY29tcG9uZW50ICR7Y29tcG9uZW50TmFtZX0uYCk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgX2NvbXBvbmVudHMuc2V0KGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudCk7XHJcbiAgICAvLyBhZGQgdGhlIGNvbXBvbmVudCB0byBleGlzdGluZyBhcHAgaW5zdGFuY2VzXHJcbiAgICBmb3IgKGNvbnN0IGFwcCBvZiBfYXBwcy52YWx1ZXMoKSkge1xyXG4gICAgICAgIF9hZGRDb21wb25lbnQoYXBwLCBjb21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSBhcHAgLSBGaXJlYmFzZUFwcCBpbnN0YW5jZVxyXG4gKiBAcGFyYW0gbmFtZSAtIHNlcnZpY2UgbmFtZVxyXG4gKlxyXG4gKiBAcmV0dXJucyB0aGUgcHJvdmlkZXIgZm9yIHRoZSBzZXJ2aWNlIHdpdGggdGhlIG1hdGNoaW5nIG5hbWVcclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBfZ2V0UHJvdmlkZXIoYXBwLCBuYW1lKSB7XHJcbiAgICBjb25zdCBoZWFydGJlYXRDb250cm9sbGVyID0gYXBwLmNvbnRhaW5lclxyXG4gICAgICAgIC5nZXRQcm92aWRlcignaGVhcnRiZWF0JylcclxuICAgICAgICAuZ2V0SW1tZWRpYXRlKHsgb3B0aW9uYWw6IHRydWUgfSk7XHJcbiAgICBpZiAoaGVhcnRiZWF0Q29udHJvbGxlcikge1xyXG4gICAgICAgIHZvaWQgaGVhcnRiZWF0Q29udHJvbGxlci50cmlnZ2VySGVhcnRiZWF0KCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXBwLmNvbnRhaW5lci5nZXRQcm92aWRlcihuYW1lKTtcclxufVxyXG4vKipcclxuICpcclxuICogQHBhcmFtIGFwcCAtIEZpcmViYXNlQXBwIGluc3RhbmNlXHJcbiAqIEBwYXJhbSBuYW1lIC0gc2VydmljZSBuYW1lXHJcbiAqIEBwYXJhbSBpbnN0YW5jZUlkZW50aWZpZXIgLSBzZXJ2aWNlIGluc3RhbmNlIGlkZW50aWZpZXIgaW4gY2FzZSB0aGUgc2VydmljZSBzdXBwb3J0cyBtdWx0aXBsZSBpbnN0YW5jZXNcclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBfcmVtb3ZlU2VydmljZUluc3RhbmNlKGFwcCwgbmFtZSwgaW5zdGFuY2VJZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XHJcbiAgICBfZ2V0UHJvdmlkZXIoYXBwLCBuYW1lKS5jbGVhckluc3RhbmNlKGluc3RhbmNlSWRlbnRpZmllcik7XHJcbn1cclxuLyoqXHJcbiAqIFRlc3Qgb25seVxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIF9jbGVhckNvbXBvbmVudHMoKSB7XHJcbiAgICBfY29tcG9uZW50cy5jbGVhcigpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IEVSUk9SUyA9IHtcclxuICAgIFtcIm5vLWFwcFwiIC8qIEFwcEVycm9yLk5PX0FQUCAqL106IFwiTm8gRmlyZWJhc2UgQXBwICd7JGFwcE5hbWV9JyBoYXMgYmVlbiBjcmVhdGVkIC0gXCIgK1xyXG4gICAgICAgICdjYWxsIGluaXRpYWxpemVBcHAoKSBmaXJzdCcsXHJcbiAgICBbXCJiYWQtYXBwLW5hbWVcIiAvKiBBcHBFcnJvci5CQURfQVBQX05BTUUgKi9dOiBcIklsbGVnYWwgQXBwIG5hbWU6ICd7JGFwcE5hbWV9XCIsXHJcbiAgICBbXCJkdXBsaWNhdGUtYXBwXCIgLyogQXBwRXJyb3IuRFVQTElDQVRFX0FQUCAqL106IFwiRmlyZWJhc2UgQXBwIG5hbWVkICd7JGFwcE5hbWV9JyBhbHJlYWR5IGV4aXN0cyB3aXRoIGRpZmZlcmVudCBvcHRpb25zIG9yIGNvbmZpZ1wiLFxyXG4gICAgW1wiYXBwLWRlbGV0ZWRcIiAvKiBBcHBFcnJvci5BUFBfREVMRVRFRCAqL106IFwiRmlyZWJhc2UgQXBwIG5hbWVkICd7JGFwcE5hbWV9JyBhbHJlYWR5IGRlbGV0ZWRcIixcclxuICAgIFtcIm5vLW9wdGlvbnNcIiAvKiBBcHBFcnJvci5OT19PUFRJT05TICovXTogJ05lZWQgdG8gcHJvdmlkZSBvcHRpb25zLCB3aGVuIG5vdCBiZWluZyBkZXBsb3llZCB0byBob3N0aW5nIHZpYSBzb3VyY2UuJyxcclxuICAgIFtcImludmFsaWQtYXBwLWFyZ3VtZW50XCIgLyogQXBwRXJyb3IuSU5WQUxJRF9BUFBfQVJHVU1FTlQgKi9dOiAnZmlyZWJhc2UueyRhcHBOYW1lfSgpIHRha2VzIGVpdGhlciBubyBhcmd1bWVudCBvciBhICcgK1xyXG4gICAgICAgICdGaXJlYmFzZSBBcHAgaW5zdGFuY2UuJyxcclxuICAgIFtcImludmFsaWQtbG9nLWFyZ3VtZW50XCIgLyogQXBwRXJyb3IuSU5WQUxJRF9MT0dfQVJHVU1FTlQgKi9dOiAnRmlyc3QgYXJndW1lbnQgdG8gYG9uTG9nYCBtdXN0IGJlIG51bGwgb3IgYSBmdW5jdGlvbi4nLFxyXG4gICAgW1wiaWRiLW9wZW5cIiAvKiBBcHBFcnJvci5JREJfT1BFTiAqL106ICdFcnJvciB0aHJvd24gd2hlbiBvcGVuaW5nIEluZGV4ZWREQi4gT3JpZ2luYWwgZXJyb3I6IHskb3JpZ2luYWxFcnJvck1lc3NhZ2V9LicsXHJcbiAgICBbXCJpZGItZ2V0XCIgLyogQXBwRXJyb3IuSURCX0dFVCAqL106ICdFcnJvciB0aHJvd24gd2hlbiByZWFkaW5nIGZyb20gSW5kZXhlZERCLiBPcmlnaW5hbCBlcnJvcjogeyRvcmlnaW5hbEVycm9yTWVzc2FnZX0uJyxcclxuICAgIFtcImlkYi1zZXRcIiAvKiBBcHBFcnJvci5JREJfV1JJVEUgKi9dOiAnRXJyb3IgdGhyb3duIHdoZW4gd3JpdGluZyB0byBJbmRleGVkREIuIE9yaWdpbmFsIGVycm9yOiB7JG9yaWdpbmFsRXJyb3JNZXNzYWdlfS4nLFxyXG4gICAgW1wiaWRiLWRlbGV0ZVwiIC8qIEFwcEVycm9yLklEQl9ERUxFVEUgKi9dOiAnRXJyb3IgdGhyb3duIHdoZW4gZGVsZXRpbmcgZnJvbSBJbmRleGVkREIuIE9yaWdpbmFsIGVycm9yOiB7JG9yaWdpbmFsRXJyb3JNZXNzYWdlfS4nXHJcbn07XHJcbmNvbnN0IEVSUk9SX0ZBQ1RPUlkgPSBuZXcgRXJyb3JGYWN0b3J5KCdhcHAnLCAnRmlyZWJhc2UnLCBFUlJPUlMpO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBGaXJlYmFzZUFwcEltcGwge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgY29uZmlnLCBjb250YWluZXIpIHtcclxuICAgICAgICB0aGlzLl9pc0RlbGV0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5fY29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKTtcclxuICAgICAgICB0aGlzLl9uYW1lID0gY29uZmlnLm5hbWU7XHJcbiAgICAgICAgdGhpcy5fYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkID1cclxuICAgICAgICAgICAgY29uZmlnLmF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZDtcclxuICAgICAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ29tcG9uZW50KG5ldyBDb21wb25lbnQoJ2FwcCcsICgpID0+IHRoaXMsIFwiUFVCTElDXCIgLyogQ29tcG9uZW50VHlwZS5QVUJMSUMgKi8pKTtcclxuICAgIH1cclxuICAgIGdldCBhdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQoKSB7XHJcbiAgICAgICAgdGhpcy5jaGVja0Rlc3Ryb3llZCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQ7XHJcbiAgICB9XHJcbiAgICBzZXQgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkKHZhbCkge1xyXG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcclxuICAgICAgICB0aGlzLl9hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQgPSB2YWw7XHJcbiAgICB9XHJcbiAgICBnZXQgbmFtZSgpIHtcclxuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XHJcbiAgICB9XHJcbiAgICBnZXQgb3B0aW9ucygpIHtcclxuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XHJcbiAgICB9XHJcbiAgICBnZXQgY29uZmlnKCkge1xyXG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29uZmlnO1xyXG4gICAgfVxyXG4gICAgZ2V0IGNvbnRhaW5lcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzRGVsZXRlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXNEZWxldGVkO1xyXG4gICAgfVxyXG4gICAgc2V0IGlzRGVsZXRlZCh2YWwpIHtcclxuICAgICAgICB0aGlzLl9pc0RlbGV0ZWQgPSB2YWw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCB0aHJvdyBhbiBFcnJvciBpZiB0aGUgQXBwIGhhcyBhbHJlYWR5IGJlZW4gZGVsZXRlZCAtXHJcbiAgICAgKiB1c2UgYmVmb3JlIHBlcmZvcm1pbmcgQVBJIGFjdGlvbnMgb24gdGhlIEFwcC5cclxuICAgICAqL1xyXG4gICAgY2hlY2tEZXN0cm95ZWQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEZWxldGVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiYXBwLWRlbGV0ZWRcIiAvKiBBcHBFcnJvci5BUFBfREVMRVRFRCAqLywgeyBhcHBOYW1lOiB0aGlzLl9uYW1lIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhlIGN1cnJlbnQgU0RLIHZlcnNpb24uXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNvbnN0IFNES19WRVJTSU9OID0gdmVyc2lvbjtcclxuZnVuY3Rpb24gaW5pdGlhbGl6ZUFwcChfb3B0aW9ucywgcmF3Q29uZmlnID0ge30pIHtcclxuICAgIGxldCBvcHRpb25zID0gX29wdGlvbnM7XHJcbiAgICBpZiAodHlwZW9mIHJhd0NvbmZpZyAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICBjb25zdCBuYW1lID0gcmF3Q29uZmlnO1xyXG4gICAgICAgIHJhd0NvbmZpZyA9IHsgbmFtZSB9O1xyXG4gICAgfVxyXG4gICAgY29uc3QgY29uZmlnID0gT2JqZWN0LmFzc2lnbih7IG5hbWU6IERFRkFVTFRfRU5UUllfTkFNRSwgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkOiBmYWxzZSB9LCByYXdDb25maWcpO1xyXG4gICAgY29uc3QgbmFtZSA9IGNvbmZpZy5uYW1lO1xyXG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCAhbmFtZSkge1xyXG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiYmFkLWFwcC1uYW1lXCIgLyogQXBwRXJyb3IuQkFEX0FQUF9OQU1FICovLCB7XHJcbiAgICAgICAgICAgIGFwcE5hbWU6IFN0cmluZyhuYW1lKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IGdldERlZmF1bHRBcHBDb25maWcoKSk7XHJcbiAgICBpZiAoIW9wdGlvbnMpIHtcclxuICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcIm5vLW9wdGlvbnNcIiAvKiBBcHBFcnJvci5OT19PUFRJT05TICovKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGV4aXN0aW5nQXBwID0gX2FwcHMuZ2V0KG5hbWUpO1xyXG4gICAgaWYgKGV4aXN0aW5nQXBwKSB7XHJcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBleGlzdGluZyBhcHAgaWYgb3B0aW9ucyBhbmQgY29uZmlnIGRlZXAgZXF1YWwgdGhlIG9uZXMgaW4gdGhlIGV4aXN0aW5nIGFwcC5cclxuICAgICAgICBpZiAoZGVlcEVxdWFsKG9wdGlvbnMsIGV4aXN0aW5nQXBwLm9wdGlvbnMpICYmXHJcbiAgICAgICAgICAgIGRlZXBFcXVhbChjb25maWcsIGV4aXN0aW5nQXBwLmNvbmZpZykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nQXBwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJkdXBsaWNhdGUtYXBwXCIgLyogQXBwRXJyb3IuRFVQTElDQVRFX0FQUCAqLywgeyBhcHBOYW1lOiBuYW1lIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IG5ldyBDb21wb25lbnRDb250YWluZXIobmFtZSk7XHJcbiAgICBmb3IgKGNvbnN0IGNvbXBvbmVudCBvZiBfY29tcG9uZW50cy52YWx1ZXMoKSkge1xyXG4gICAgICAgIGNvbnRhaW5lci5hZGRDb21wb25lbnQoY29tcG9uZW50KTtcclxuICAgIH1cclxuICAgIGNvbnN0IG5ld0FwcCA9IG5ldyBGaXJlYmFzZUFwcEltcGwob3B0aW9ucywgY29uZmlnLCBjb250YWluZXIpO1xyXG4gICAgX2FwcHMuc2V0KG5hbWUsIG5ld0FwcCk7XHJcbiAgICByZXR1cm4gbmV3QXBwO1xyXG59XHJcbi8qKlxyXG4gKiBSZXRyaWV2ZXMgYSB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZUFwcH0gaW5zdGFuY2UuXHJcbiAqXHJcbiAqIFdoZW4gY2FsbGVkIHdpdGggbm8gYXJndW1lbnRzLCB0aGUgZGVmYXVsdCBhcHAgaXMgcmV0dXJuZWQuIFdoZW4gYW4gYXBwIG5hbWVcclxuICogaXMgcHJvdmlkZWQsIHRoZSBhcHAgY29ycmVzcG9uZGluZyB0byB0aGF0IG5hbWUgaXMgcmV0dXJuZWQuXHJcbiAqXHJcbiAqIEFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gaWYgdGhlIGFwcCBiZWluZyByZXRyaWV2ZWQgaGFzIG5vdCB5ZXQgYmVlblxyXG4gKiBpbml0aWFsaXplZC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiAvLyBSZXR1cm4gdGhlIGRlZmF1bHQgYXBwXHJcbiAqIGNvbnN0IGFwcCA9IGdldEFwcCgpO1xyXG4gKiBgYGBcclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiAvLyBSZXR1cm4gYSBuYW1lZCBhcHBcclxuICogY29uc3Qgb3RoZXJBcHAgPSBnZXRBcHAoXCJvdGhlckFwcFwiKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBwYXJhbSBuYW1lIC0gT3B0aW9uYWwgbmFtZSBvZiB0aGUgYXBwIHRvIHJldHVybi4gSWYgbm8gbmFtZSBpc1xyXG4gKiAgIHByb3ZpZGVkLCB0aGUgZGVmYXVsdCBpcyBgXCJbREVGQVVMVF1cImAuXHJcbiAqXHJcbiAqIEByZXR1cm5zIFRoZSBhcHAgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvdmlkZWQgYXBwIG5hbWUuXHJcbiAqICAgSWYgbm8gYXBwIG5hbWUgaXMgcHJvdmlkZWQsIHRoZSBkZWZhdWx0IGFwcCBpcyByZXR1cm5lZC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0QXBwKG5hbWUgPSBERUZBVUxUX0VOVFJZX05BTUUpIHtcclxuICAgIGNvbnN0IGFwcCA9IF9hcHBzLmdldChuYW1lKTtcclxuICAgIGlmICghYXBwICYmIG5hbWUgPT09IERFRkFVTFRfRU5UUllfTkFNRSAmJiBnZXREZWZhdWx0QXBwQ29uZmlnKCkpIHtcclxuICAgICAgICByZXR1cm4gaW5pdGlhbGl6ZUFwcCgpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFhcHApIHtcclxuICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcIm5vLWFwcFwiIC8qIEFwcEVycm9yLk5PX0FQUCAqLywgeyBhcHBOYW1lOiBuYW1lIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFwcDtcclxufVxyXG4vKipcclxuICogQSAocmVhZC1vbmx5KSBhcnJheSBvZiBhbGwgaW5pdGlhbGl6ZWQgYXBwcy5cclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0QXBwcygpIHtcclxuICAgIHJldHVybiBBcnJheS5mcm9tKF9hcHBzLnZhbHVlcygpKTtcclxufVxyXG4vKipcclxuICogUmVuZGVycyB0aGlzIGFwcCB1bnVzYWJsZSBhbmQgZnJlZXMgdGhlIHJlc291cmNlcyBvZiBhbGwgYXNzb2NpYXRlZFxyXG4gKiBzZXJ2aWNlcy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiBkZWxldGVBcHAoYXBwKVxyXG4gKiAgIC50aGVuKGZ1bmN0aW9uKCkge1xyXG4gKiAgICAgY29uc29sZS5sb2coXCJBcHAgZGVsZXRlZCBzdWNjZXNzZnVsbHlcIik7XHJcbiAqICAgfSlcclxuICogICAuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcclxuICogICAgIGNvbnNvbGUubG9nKFwiRXJyb3IgZGVsZXRpbmcgYXBwOlwiLCBlcnJvcik7XHJcbiAqICAgfSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBkZWxldGVBcHAoYXBwKSB7XHJcbiAgICBjb25zdCBuYW1lID0gYXBwLm5hbWU7XHJcbiAgICBpZiAoX2FwcHMuaGFzKG5hbWUpKSB7XHJcbiAgICAgICAgX2FwcHMuZGVsZXRlKG5hbWUpO1xyXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGFwcC5jb250YWluZXJcclxuICAgICAgICAgICAgLmdldFByb3ZpZGVycygpXHJcbiAgICAgICAgICAgIC5tYXAocHJvdmlkZXIgPT4gcHJvdmlkZXIuZGVsZXRlKCkpKTtcclxuICAgICAgICBhcHAuaXNEZWxldGVkID0gdHJ1ZTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmVnaXN0ZXJzIGEgbGlicmFyeSdzIG5hbWUgYW5kIHZlcnNpb24gZm9yIHBsYXRmb3JtIGxvZ2dpbmcgcHVycG9zZXMuXHJcbiAqIEBwYXJhbSBsaWJyYXJ5IC0gTmFtZSBvZiAxcCBvciAzcCBsaWJyYXJ5IChlLmcuIGZpcmVzdG9yZSwgYW5ndWxhcmZpcmUpXHJcbiAqIEBwYXJhbSB2ZXJzaW9uIC0gQ3VycmVudCB2ZXJzaW9uIG9mIHRoYXQgbGlicmFyeS5cclxuICogQHBhcmFtIHZhcmlhbnQgLSBCdW5kbGUgdmFyaWFudCwgZS5nLiwgbm9kZSwgcm4sIGV0Yy5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gcmVnaXN0ZXJWZXJzaW9uKGxpYnJhcnlLZXlPck5hbWUsIHZlcnNpb24sIHZhcmlhbnQpIHtcclxuICAgIHZhciBfYTtcclxuICAgIC8vIFRPRE86IFdlIGNhbiB1c2UgdGhpcyBjaGVjayB0byB3aGl0ZWxpc3Qgc3RyaW5ncyB3aGVuL2lmIHdlIHNldCB1cFxyXG4gICAgLy8gYSBnb29kIHdoaXRlbGlzdCBzeXN0ZW0uXHJcbiAgICBsZXQgbGlicmFyeSA9IChfYSA9IFBMQVRGT1JNX0xPR19TVFJJTkdbbGlicmFyeUtleU9yTmFtZV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGxpYnJhcnlLZXlPck5hbWU7XHJcbiAgICBpZiAodmFyaWFudCkge1xyXG4gICAgICAgIGxpYnJhcnkgKz0gYC0ke3ZhcmlhbnR9YDtcclxuICAgIH1cclxuICAgIGNvbnN0IGxpYnJhcnlNaXNtYXRjaCA9IGxpYnJhcnkubWF0Y2goL1xcc3xcXC8vKTtcclxuICAgIGNvbnN0IHZlcnNpb25NaXNtYXRjaCA9IHZlcnNpb24ubWF0Y2goL1xcc3xcXC8vKTtcclxuICAgIGlmIChsaWJyYXJ5TWlzbWF0Y2ggfHwgdmVyc2lvbk1pc21hdGNoKSB7XHJcbiAgICAgICAgY29uc3Qgd2FybmluZyA9IFtcclxuICAgICAgICAgICAgYFVuYWJsZSB0byByZWdpc3RlciBsaWJyYXJ5IFwiJHtsaWJyYXJ5fVwiIHdpdGggdmVyc2lvbiBcIiR7dmVyc2lvbn1cIjpgXHJcbiAgICAgICAgXTtcclxuICAgICAgICBpZiAobGlicmFyeU1pc21hdGNoKSB7XHJcbiAgICAgICAgICAgIHdhcm5pbmcucHVzaChgbGlicmFyeSBuYW1lIFwiJHtsaWJyYXJ5fVwiIGNvbnRhaW5zIGlsbGVnYWwgY2hhcmFjdGVycyAod2hpdGVzcGFjZSBvciBcIi9cIilgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxpYnJhcnlNaXNtYXRjaCAmJiB2ZXJzaW9uTWlzbWF0Y2gpIHtcclxuICAgICAgICAgICAgd2FybmluZy5wdXNoKCdhbmQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZlcnNpb25NaXNtYXRjaCkge1xyXG4gICAgICAgICAgICB3YXJuaW5nLnB1c2goYHZlcnNpb24gbmFtZSBcIiR7dmVyc2lvbn1cIiBjb250YWlucyBpbGxlZ2FsIGNoYXJhY3RlcnMgKHdoaXRlc3BhY2Ugb3IgXCIvXCIpYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxvZ2dlci53YXJuKHdhcm5pbmcuam9pbignICcpKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBfcmVnaXN0ZXJDb21wb25lbnQobmV3IENvbXBvbmVudChgJHtsaWJyYXJ5fS12ZXJzaW9uYCwgKCkgPT4gKHsgbGlicmFyeSwgdmVyc2lvbiB9KSwgXCJWRVJTSU9OXCIgLyogQ29tcG9uZW50VHlwZS5WRVJTSU9OICovKSk7XHJcbn1cclxuLyoqXHJcbiAqIFNldHMgbG9nIGhhbmRsZXIgZm9yIGFsbCBGaXJlYmFzZSBTREtzLlxyXG4gKiBAcGFyYW0gbG9nQ2FsbGJhY2sgLSBBbiBvcHRpb25hbCBjdXN0b20gbG9nIGhhbmRsZXIgdGhhdCBleGVjdXRlcyB1c2VyIGNvZGUgd2hlbmV2ZXJcclxuICogdGhlIEZpcmViYXNlIFNESyBtYWtlcyBhIGxvZ2dpbmcgY2FsbC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gb25Mb2cobG9nQ2FsbGJhY2ssIG9wdGlvbnMpIHtcclxuICAgIGlmIChsb2dDYWxsYmFjayAhPT0gbnVsbCAmJiB0eXBlb2YgbG9nQ2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImludmFsaWQtbG9nLWFyZ3VtZW50XCIgLyogQXBwRXJyb3IuSU5WQUxJRF9MT0dfQVJHVU1FTlQgKi8pO1xyXG4gICAgfVxyXG4gICAgc2V0VXNlckxvZ0hhbmRsZXIobG9nQ2FsbGJhY2ssIG9wdGlvbnMpO1xyXG59XHJcbi8qKlxyXG4gKiBTZXRzIGxvZyBsZXZlbCBmb3IgYWxsIEZpcmViYXNlIFNES3MuXHJcbiAqXHJcbiAqIEFsbCBvZiB0aGUgbG9nIHR5cGVzIGFib3ZlIHRoZSBjdXJyZW50IGxvZyBsZXZlbCBhcmUgY2FwdHVyZWQgKGkuZS4gaWZcclxuICogeW91IHNldCB0aGUgbG9nIGxldmVsIHRvIGBpbmZvYCwgZXJyb3JzIGFyZSBsb2dnZWQsIGJ1dCBgZGVidWdgIGFuZFxyXG4gKiBgdmVyYm9zZWAgbG9ncyBhcmUgbm90KS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gc2V0TG9nTGV2ZWwobG9nTGV2ZWwpIHtcclxuICAgIHNldExvZ0xldmVsJDEobG9nTGV2ZWwpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IERCX05BTUUgPSAnZmlyZWJhc2UtaGVhcnRiZWF0LWRhdGFiYXNlJztcclxuY29uc3QgREJfVkVSU0lPTiA9IDE7XHJcbmNvbnN0IFNUT1JFX05BTUUgPSAnZmlyZWJhc2UtaGVhcnRiZWF0LXN0b3JlJztcclxubGV0IGRiUHJvbWlzZSA9IG51bGw7XHJcbmZ1bmN0aW9uIGdldERiUHJvbWlzZSgpIHtcclxuICAgIGlmICghZGJQcm9taXNlKSB7XHJcbiAgICAgICAgZGJQcm9taXNlID0gb3BlbkRCKERCX05BTUUsIERCX1ZFUlNJT04sIHtcclxuICAgICAgICAgICAgdXBncmFkZTogKGRiLCBvbGRWZXJzaW9uKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCB1c2UgJ2JyZWFrJyBpbiB0aGlzIHN3aXRjaCBzdGF0ZW1lbnQsIHRoZSBmYWxsLXRocm91Z2hcclxuICAgICAgICAgICAgICAgIC8vIGJlaGF2aW9yIGlzIHdoYXQgd2Ugd2FudCwgYmVjYXVzZSBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgdmVyc2lvbnMgYmV0d2VlblxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIG9sZCB2ZXJzaW9uIGFuZCB0aGUgY3VycmVudCB2ZXJzaW9uLCB3ZSB3YW50IEFMTCB0aGUgbWlncmF0aW9uc1xyXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBjb3JyZXNwb25kIHRvIHRob3NlIHZlcnNpb25zIHRvIHJ1biwgbm90IG9ubHkgdGhlIGxhc3Qgb25lLlxyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlZmF1bHQtY2FzZVxyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChvbGRWZXJzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoU1RPUkVfTkFNRSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaS9pT1MgYnJvd3NlcnMgdGhyb3cgb2NjYXNpb25hbCBleGNlcHRpb25zIG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkYi5jcmVhdGVPYmplY3RTdG9yZSgpIHRoYXQgbWF5IGJlIGEgYnVnLiBBdm9pZCBibG9ja2luZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHJlc3Qgb2YgdGhlIGFwcCBmdW5jdGlvbmFsaXR5LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KS5jYXRjaChlID0+IHtcclxuICAgICAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJpZGItb3BlblwiIC8qIEFwcEVycm9yLklEQl9PUEVOICovLCB7XHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEVycm9yTWVzc2FnZTogZS5tZXNzYWdlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRiUHJvbWlzZTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiByZWFkSGVhcnRiZWF0c0Zyb21JbmRleGVkREIoYXBwKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGRiID0gYXdhaXQgZ2V0RGJQcm9taXNlKCk7XHJcbiAgICAgICAgY29uc3QgdHggPSBkYi50cmFuc2FjdGlvbihTVE9SRV9OQU1FKTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0eC5vYmplY3RTdG9yZShTVE9SRV9OQU1FKS5nZXQoY29tcHV0ZUtleShhcHApKTtcclxuICAgICAgICAvLyBXZSBhbHJlYWR5IGhhdmUgdGhlIHZhbHVlIGJ1dCB0eC5kb25lIGNhbiB0aHJvdyxcclxuICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIGF3YWl0IGl0IGhlcmUgdG8gY2F0Y2ggZXJyb3JzXHJcbiAgICAgICAgYXdhaXQgdHguZG9uZTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEZpcmViYXNlRXJyb3IpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oZS5tZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkYkdldEVycm9yID0gRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJpZGItZ2V0XCIgLyogQXBwRXJyb3IuSURCX0dFVCAqLywge1xyXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFcnJvck1lc3NhZ2U6IGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5tZXNzYWdlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBsb2dnZXIud2FybihpZGJHZXRFcnJvci5tZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gd3JpdGVIZWFydGJlYXRzVG9JbmRleGVkREIoYXBwLCBoZWFydGJlYXRPYmplY3QpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgZGIgPSBhd2FpdCBnZXREYlByb21pc2UoKTtcclxuICAgICAgICBjb25zdCB0eCA9IGRiLnRyYW5zYWN0aW9uKFNUT1JFX05BTUUsICdyZWFkd3JpdGUnKTtcclxuICAgICAgICBjb25zdCBvYmplY3RTdG9yZSA9IHR4Lm9iamVjdFN0b3JlKFNUT1JFX05BTUUpO1xyXG4gICAgICAgIGF3YWl0IG9iamVjdFN0b3JlLnB1dChoZWFydGJlYXRPYmplY3QsIGNvbXB1dGVLZXkoYXBwKSk7XHJcbiAgICAgICAgYXdhaXQgdHguZG9uZTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBGaXJlYmFzZUVycm9yKSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGUubWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBpZGJHZXRFcnJvciA9IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaWRiLXNldFwiIC8qIEFwcEVycm9yLklEQl9XUklURSAqLywge1xyXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFcnJvck1lc3NhZ2U6IGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5tZXNzYWdlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBsb2dnZXIud2FybihpZGJHZXRFcnJvci5tZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY29tcHV0ZUtleShhcHApIHtcclxuICAgIHJldHVybiBgJHthcHAubmFtZX0hJHthcHAub3B0aW9ucy5hcHBJZH1gO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IE1BWF9IRUFERVJfQllURVMgPSAxMDI0O1xyXG4vLyAzMCBkYXlzXHJcbmNvbnN0IFNUT1JFRF9IRUFSVEJFQVRfUkVURU5USU9OX01BWF9NSUxMSVMgPSAzMCAqIDI0ICogNjAgKiA2MCAqIDEwMDA7XHJcbmNsYXNzIEhlYXJ0YmVhdFNlcnZpY2VJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lcikge1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluLW1lbW9yeSBjYWNoZSBmb3IgaGVhcnRiZWF0cywgdXNlZCBieSBnZXRIZWFydGJlYXRzSGVhZGVyKCkgdG8gZ2VuZXJhdGVcclxuICAgICAgICAgKiB0aGUgaGVhZGVyIHN0cmluZy5cclxuICAgICAgICAgKiBTdG9yZXMgb25lIHJlY29yZCBwZXIgZGF0ZS4gVGhpcyB3aWxsIGJlIGNvbnNvbGlkYXRlZCBpbnRvIHRoZSBzdGFuZGFyZFxyXG4gICAgICAgICAqIGZvcm1hdCBvZiBvbmUgcmVjb3JkIHBlciB1c2VyIGFnZW50IHN0cmluZyBiZWZvcmUgYmVpbmcgc2VudCBhcyBhIGhlYWRlci5cclxuICAgICAgICAgKiBQb3B1bGF0ZWQgZnJvbSBpbmRleGVkREIgd2hlbiB0aGUgY29udHJvbGxlciBpcyBpbnN0YW50aWF0ZWQgYW5kIHNob3VsZFxyXG4gICAgICAgICAqIGJlIGtlcHQgaW4gc3luYyB3aXRoIGluZGV4ZWREQi5cclxuICAgICAgICAgKiBMZWF2ZSBwdWJsaWMgZm9yIGVhc2llciB0ZXN0aW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSA9IG51bGw7XHJcbiAgICAgICAgY29uc3QgYXBwID0gdGhpcy5jb250YWluZXIuZ2V0UHJvdmlkZXIoJ2FwcCcpLmdldEltbWVkaWF0ZSgpO1xyXG4gICAgICAgIHRoaXMuX3N0b3JhZ2UgPSBuZXcgSGVhcnRiZWF0U3RvcmFnZUltcGwoYXBwKTtcclxuICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGVQcm9taXNlID0gdGhpcy5fc3RvcmFnZS5yZWFkKCkudGhlbihyZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUgPSByZXN1bHQ7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCB0byByZXBvcnQgYSBoZWFydGJlYXQuIFRoZSBmdW5jdGlvbiB3aWxsIGdlbmVyYXRlXHJcbiAgICAgKiBhIEhlYXJ0YmVhdHNCeVVzZXJBZ2VudCBvYmplY3QsIHVwZGF0ZSBoZWFydGJlYXRzQ2FjaGUsIGFuZCBwZXJzaXN0IGl0XHJcbiAgICAgKiB0byBJbmRleGVkREIuXHJcbiAgICAgKiBOb3RlIHRoYXQgd2Ugb25seSBzdG9yZSBvbmUgaGVhcnRiZWF0IHBlciBkYXkuIFNvIGlmIGEgaGVhcnRiZWF0IGZvciB0b2RheSBpc1xyXG4gICAgICogYWxyZWFkeSBsb2dnZWQsIHN1YnNlcXVlbnQgY2FsbHMgdG8gdGhpcyBmdW5jdGlvbiBpbiB0aGUgc2FtZSBkYXkgd2lsbCBiZSBpZ25vcmVkLlxyXG4gICAgICovXHJcbiAgICBhc3luYyB0cmlnZ2VySGVhcnRiZWF0KCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgY29uc3QgcGxhdGZvcm1Mb2dnZXIgPSB0aGlzLmNvbnRhaW5lclxyXG4gICAgICAgICAgICAuZ2V0UHJvdmlkZXIoJ3BsYXRmb3JtLWxvZ2dlcicpXHJcbiAgICAgICAgICAgIC5nZXRJbW1lZGlhdGUoKTtcclxuICAgICAgICAvLyBUaGlzIGlzIHRoZSBcIkZpcmViYXNlIHVzZXIgYWdlbnRcIiBzdHJpbmcgZnJvbSB0aGUgcGxhdGZvcm0gbG9nZ2VyXHJcbiAgICAgICAgLy8gc2VydmljZSwgbm90IHRoZSBicm93c2VyIHVzZXIgYWdlbnQuXHJcbiAgICAgICAgY29uc3QgYWdlbnQgPSBwbGF0Zm9ybUxvZ2dlci5nZXRQbGF0Zm9ybUluZm9TdHJpbmcoKTtcclxuICAgICAgICBjb25zdCBkYXRlID0gZ2V0VVRDRGF0ZVN0cmluZygpO1xyXG4gICAgICAgIGlmICgoKF9hID0gdGhpcy5faGVhcnRiZWF0c0NhY2hlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGVhcnRiZWF0cykgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUgPSBhd2FpdCB0aGlzLl9oZWFydGJlYXRzQ2FjaGVQcm9taXNlO1xyXG4gICAgICAgICAgICAvLyBJZiB3ZSBmYWlsZWQgdG8gY29uc3RydWN0IGEgaGVhcnRiZWF0cyBjYWNoZSwgdGhlbiByZXR1cm4gaW1tZWRpYXRlbHkuXHJcbiAgICAgICAgICAgIGlmICgoKF9iID0gdGhpcy5faGVhcnRiZWF0c0NhY2hlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaGVhcnRiZWF0cykgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIERvIG5vdCBzdG9yZSBhIGhlYXJ0YmVhdCBpZiBvbmUgaXMgYWxyZWFkeSBzdG9yZWQgZm9yIHRoaXMgZGF5XHJcbiAgICAgICAgLy8gb3IgaWYgYSBoZWFkZXIgaGFzIGFscmVhZHkgYmVlbiBzZW50IHRvZGF5LlxyXG4gICAgICAgIGlmICh0aGlzLl9oZWFydGJlYXRzQ2FjaGUubGFzdFNlbnRIZWFydGJlYXREYXRlID09PSBkYXRlIHx8XHJcbiAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzLnNvbWUoc2luZ2xlRGF0ZUhlYXJ0YmVhdCA9PiBzaW5nbGVEYXRlSGVhcnRiZWF0LmRhdGUgPT09IGRhdGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIGVudHJ5IGZvciB0aGlzIGRhdGUuIENyZWF0ZSBvbmUuXHJcbiAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzLnB1c2goeyBkYXRlLCBhZ2VudCB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmVtb3ZlIGVudHJpZXMgb2xkZXIgdGhhbiAzMCBkYXlzLlxyXG4gICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzID0gdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMuZmlsdGVyKHNpbmdsZURhdGVIZWFydGJlYXQgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBoYlRpbWVzdGFtcCA9IG5ldyBEYXRlKHNpbmdsZURhdGVIZWFydGJlYXQuZGF0ZSkudmFsdWVPZigpO1xyXG4gICAgICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICByZXR1cm4gbm93IC0gaGJUaW1lc3RhbXAgPD0gU1RPUkVEX0hFQVJUQkVBVF9SRVRFTlRJT05fTUFYX01JTExJUztcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3RvcmFnZS5vdmVyd3JpdGUodGhpcy5faGVhcnRiZWF0c0NhY2hlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZyB3aGljaCBjYW4gYmUgYXR0YWNoZWQgdG8gdGhlIGhlYXJ0YmVhdC1zcGVjaWZpYyBoZWFkZXIgZGlyZWN0bHkuXHJcbiAgICAgKiBJdCBhbHNvIGNsZWFycyBhbGwgaGVhcnRiZWF0cyBmcm9tIG1lbW9yeSBhcyB3ZWxsIGFzIGluIEluZGV4ZWREQi5cclxuICAgICAqXHJcbiAgICAgKiBOT1RFOiBDb25zdW1pbmcgcHJvZHVjdCBTREtzIHNob3VsZCBub3Qgc2VuZCB0aGUgaGVhZGVyIGlmIHRoaXMgbWV0aG9kXHJcbiAgICAgKiByZXR1cm5zIGFuIGVtcHR5IHN0cmluZy5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZ2V0SGVhcnRiZWF0c0hlYWRlcigpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9oZWFydGJlYXRzQ2FjaGVQcm9taXNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiBpdCdzIHN0aWxsIG51bGwgb3IgdGhlIGFycmF5IGlzIGVtcHR5LCB0aGVyZSBpcyBubyBkYXRhIHRvIHNlbmQuXHJcbiAgICAgICAgaWYgKCgoX2EgPSB0aGlzLl9oZWFydGJlYXRzQ2FjaGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oZWFydGJlYXRzKSA9PSBudWxsIHx8XHJcbiAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGRhdGUgPSBnZXRVVENEYXRlU3RyaW5nKCk7XHJcbiAgICAgICAgLy8gRXh0cmFjdCBhcyBtYW55IGhlYXJ0YmVhdHMgZnJvbSB0aGUgY2FjaGUgYXMgd2lsbCBmaXQgdW5kZXIgdGhlIHNpemUgbGltaXQuXHJcbiAgICAgICAgY29uc3QgeyBoZWFydGJlYXRzVG9TZW5kLCB1bnNlbnRFbnRyaWVzIH0gPSBleHRyYWN0SGVhcnRiZWF0c0ZvckhlYWRlcih0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cyk7XHJcbiAgICAgICAgY29uc3QgaGVhZGVyU3RyaW5nID0gYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcoSlNPTi5zdHJpbmdpZnkoeyB2ZXJzaW9uOiAyLCBoZWFydGJlYXRzOiBoZWFydGJlYXRzVG9TZW5kIH0pKTtcclxuICAgICAgICAvLyBTdG9yZSBsYXN0IHNlbnQgZGF0ZSB0byBwcmV2ZW50IGFub3RoZXIgYmVpbmcgbG9nZ2VkL3NlbnQgZm9yIHRoZSBzYW1lIGRheS5cclxuICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUubGFzdFNlbnRIZWFydGJlYXREYXRlID0gZGF0ZTtcclxuICAgICAgICBpZiAodW5zZW50RW50cmllcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIC8vIFN0b3JlIGFueSB1bnNlbnQgZW50cmllcyBpZiB0aGV5IGV4aXN0LlxyXG4gICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cyA9IHVuc2VudEVudHJpZXM7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgc2VlbXMgbW9yZSBsaWtlbHkgdGhhbiBlbXB0eWluZyB0aGUgYXJyYXkgKGJlbG93KSB0byBsZWFkIHRvIHNvbWUgb2RkIHN0YXRlXHJcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBjYWNoZSBpc24ndCBlbXB0eSBhbmQgdGhpcyB3aWxsIGJlIGNhbGxlZCBhZ2FpbiBvbiB0aGUgbmV4dCByZXF1ZXN0LFxyXG4gICAgICAgICAgICAvLyBhbmQgaXMgcHJvYmFibHkgc2FmZXN0IGlmIHdlIGF3YWl0IGl0LlxyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9zdG9yYWdlLm92ZXJ3cml0ZSh0aGlzLl9oZWFydGJlYXRzQ2FjaGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMgPSBbXTtcclxuICAgICAgICAgICAgLy8gRG8gbm90IHdhaXQgZm9yIHRoaXMsIHRvIHJlZHVjZSBsYXRlbmN5LlxyXG4gICAgICAgICAgICB2b2lkIHRoaXMuX3N0b3JhZ2Uub3ZlcndyaXRlKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoZWFkZXJTdHJpbmc7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0VVRDRGF0ZVN0cmluZygpIHtcclxuICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKTtcclxuICAgIC8vIFJldHVybnMgZGF0ZSBmb3JtYXQgJ1lZWVktTU0tREQnXHJcbiAgICByZXR1cm4gdG9kYXkudG9JU09TdHJpbmcoKS5zdWJzdHJpbmcoMCwgMTApO1xyXG59XHJcbmZ1bmN0aW9uIGV4dHJhY3RIZWFydGJlYXRzRm9ySGVhZGVyKGhlYXJ0YmVhdHNDYWNoZSwgbWF4U2l6ZSA9IE1BWF9IRUFERVJfQllURVMpIHtcclxuICAgIC8vIEhlYXJ0YmVhdHMgZ3JvdXBlZCBieSB1c2VyIGFnZW50IGluIHRoZSBzdGFuZGFyZCBmb3JtYXQgdG8gYmUgc2VudCBpblxyXG4gICAgLy8gdGhlIGhlYWRlci5cclxuICAgIGNvbnN0IGhlYXJ0YmVhdHNUb1NlbmQgPSBbXTtcclxuICAgIC8vIFNpbmdsZSBkYXRlIGZvcm1hdCBoZWFydGJlYXRzIHRoYXQgYXJlIG5vdCBzZW50LlxyXG4gICAgbGV0IHVuc2VudEVudHJpZXMgPSBoZWFydGJlYXRzQ2FjaGUuc2xpY2UoKTtcclxuICAgIGZvciAoY29uc3Qgc2luZ2xlRGF0ZUhlYXJ0YmVhdCBvZiBoZWFydGJlYXRzQ2FjaGUpIHtcclxuICAgICAgICAvLyBMb29rIGZvciBhbiBleGlzdGluZyBlbnRyeSB3aXRoIHRoZSBzYW1lIHVzZXIgYWdlbnQuXHJcbiAgICAgICAgY29uc3QgaGVhcnRiZWF0RW50cnkgPSBoZWFydGJlYXRzVG9TZW5kLmZpbmQoaGIgPT4gaGIuYWdlbnQgPT09IHNpbmdsZURhdGVIZWFydGJlYXQuYWdlbnQpO1xyXG4gICAgICAgIGlmICghaGVhcnRiZWF0RW50cnkpIHtcclxuICAgICAgICAgICAgLy8gSWYgbm8gZW50cnkgZm9yIHRoaXMgdXNlciBhZ2VudCBleGlzdHMsIGNyZWF0ZSBvbmUuXHJcbiAgICAgICAgICAgIGhlYXJ0YmVhdHNUb1NlbmQucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBhZ2VudDogc2luZ2xlRGF0ZUhlYXJ0YmVhdC5hZ2VudCxcclxuICAgICAgICAgICAgICAgIGRhdGVzOiBbc2luZ2xlRGF0ZUhlYXJ0YmVhdC5kYXRlXVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKGNvdW50Qnl0ZXMoaGVhcnRiZWF0c1RvU2VuZCkgPiBtYXhTaXplKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgaGVhZGVyIHdvdWxkIGV4Y2VlZCBtYXggc2l6ZSwgcmVtb3ZlIHRoZSBhZGRlZCBoZWFydGJlYXRcclxuICAgICAgICAgICAgICAgIC8vIGVudHJ5IGFuZCBzdG9wIGFkZGluZyB0byB0aGUgaGVhZGVyLlxyXG4gICAgICAgICAgICAgICAgaGVhcnRiZWF0c1RvU2VuZC5wb3AoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBoZWFydGJlYXRFbnRyeS5kYXRlcy5wdXNoKHNpbmdsZURhdGVIZWFydGJlYXQuZGF0ZSk7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBoZWFkZXIgd291bGQgZXhjZWVkIG1heCBzaXplLCByZW1vdmUgdGhlIGFkZGVkIGRhdGVcclxuICAgICAgICAgICAgLy8gYW5kIHN0b3AgYWRkaW5nIHRvIHRoZSBoZWFkZXIuXHJcbiAgICAgICAgICAgIGlmIChjb3VudEJ5dGVzKGhlYXJ0YmVhdHNUb1NlbmQpID4gbWF4U2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgaGVhcnRiZWF0RW50cnkuZGF0ZXMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBQb3AgdW5zZW50IGVudHJ5IGZyb20gcXVldWUuIChTa2lwcGVkIGlmIGFkZGluZyB0aGUgZW50cnkgZXhjZWVkZWRcclxuICAgICAgICAvLyBxdW90YSBhbmQgdGhlIGxvb3AgYnJlYWtzIGVhcmx5LilcclxuICAgICAgICB1bnNlbnRFbnRyaWVzID0gdW5zZW50RW50cmllcy5zbGljZSgxKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaGVhcnRiZWF0c1RvU2VuZCxcclxuICAgICAgICB1bnNlbnRFbnRyaWVzXHJcbiAgICB9O1xyXG59XHJcbmNsYXNzIEhlYXJ0YmVhdFN0b3JhZ2VJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKGFwcCkge1xyXG4gICAgICAgIHRoaXMuYXBwID0gYXBwO1xyXG4gICAgICAgIHRoaXMuX2NhblVzZUluZGV4ZWREQlByb21pc2UgPSB0aGlzLnJ1bkluZGV4ZWREQkVudmlyb25tZW50Q2hlY2soKTtcclxuICAgIH1cclxuICAgIGFzeW5jIHJ1bkluZGV4ZWREQkVudmlyb25tZW50Q2hlY2soKSB7XHJcbiAgICAgICAgaWYgKCFpc0luZGV4ZWREQkF2YWlsYWJsZSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZUluZGV4ZWREQk9wZW5hYmxlKClcclxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHRydWUpXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goKCkgPT4gZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVhZCBhbGwgaGVhcnRiZWF0cy5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgcmVhZCgpIHtcclxuICAgICAgICBjb25zdCBjYW5Vc2VJbmRleGVkREIgPSBhd2FpdCB0aGlzLl9jYW5Vc2VJbmRleGVkREJQcm9taXNlO1xyXG4gICAgICAgIGlmICghY2FuVXNlSW5kZXhlZERCKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IGhlYXJ0YmVhdHM6IFtdIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBpZGJIZWFydGJlYXRPYmplY3QgPSBhd2FpdCByZWFkSGVhcnRiZWF0c0Zyb21JbmRleGVkREIodGhpcy5hcHApO1xyXG4gICAgICAgICAgICBpZiAoaWRiSGVhcnRiZWF0T2JqZWN0ID09PSBudWxsIHx8IGlkYkhlYXJ0YmVhdE9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaWRiSGVhcnRiZWF0T2JqZWN0LmhlYXJ0YmVhdHMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpZGJIZWFydGJlYXRPYmplY3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBoZWFydGJlYXRzOiBbXSB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gb3ZlcndyaXRlIHRoZSBzdG9yYWdlIHdpdGggdGhlIHByb3ZpZGVkIGhlYXJ0YmVhdHNcclxuICAgIGFzeW5jIG92ZXJ3cml0ZShoZWFydGJlYXRzT2JqZWN0KSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IGNhblVzZUluZGV4ZWREQiA9IGF3YWl0IHRoaXMuX2NhblVzZUluZGV4ZWREQlByb21pc2U7XHJcbiAgICAgICAgaWYgKCFjYW5Vc2VJbmRleGVkREIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdIZWFydGJlYXRzT2JqZWN0ID0gYXdhaXQgdGhpcy5yZWFkKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB3cml0ZUhlYXJ0YmVhdHNUb0luZGV4ZWREQih0aGlzLmFwcCwge1xyXG4gICAgICAgICAgICAgICAgbGFzdFNlbnRIZWFydGJlYXREYXRlOiAoX2EgPSBoZWFydGJlYXRzT2JqZWN0Lmxhc3RTZW50SGVhcnRiZWF0RGF0ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZXhpc3RpbmdIZWFydGJlYXRzT2JqZWN0Lmxhc3RTZW50SGVhcnRiZWF0RGF0ZSxcclxuICAgICAgICAgICAgICAgIGhlYXJ0YmVhdHM6IGhlYXJ0YmVhdHNPYmplY3QuaGVhcnRiZWF0c1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBhZGQgaGVhcnRiZWF0c1xyXG4gICAgYXN5bmMgYWRkKGhlYXJ0YmVhdHNPYmplY3QpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgY2FuVXNlSW5kZXhlZERCID0gYXdhaXQgdGhpcy5fY2FuVXNlSW5kZXhlZERCUHJvbWlzZTtcclxuICAgICAgICBpZiAoIWNhblVzZUluZGV4ZWREQikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ0hlYXJ0YmVhdHNPYmplY3QgPSBhd2FpdCB0aGlzLnJlYWQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHdyaXRlSGVhcnRiZWF0c1RvSW5kZXhlZERCKHRoaXMuYXBwLCB7XHJcbiAgICAgICAgICAgICAgICBsYXN0U2VudEhlYXJ0YmVhdERhdGU6IChfYSA9IGhlYXJ0YmVhdHNPYmplY3QubGFzdFNlbnRIZWFydGJlYXREYXRlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBleGlzdGluZ0hlYXJ0YmVhdHNPYmplY3QubGFzdFNlbnRIZWFydGJlYXREYXRlLFxyXG4gICAgICAgICAgICAgICAgaGVhcnRiZWF0czogW1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLmV4aXN0aW5nSGVhcnRiZWF0c09iamVjdC5oZWFydGJlYXRzLFxyXG4gICAgICAgICAgICAgICAgICAgIC4uLmhlYXJ0YmVhdHNPYmplY3QuaGVhcnRiZWF0c1xyXG4gICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENhbGN1bGF0ZSBieXRlcyBvZiBhIEhlYXJ0YmVhdHNCeVVzZXJBZ2VudCBhcnJheSBhZnRlciBiZWluZyB3cmFwcGVkXHJcbiAqIGluIGEgcGxhdGZvcm0gbG9nZ2luZyBoZWFkZXIgSlNPTiBvYmplY3QsIHN0cmluZ2lmaWVkLCBhbmQgY29udmVydGVkXHJcbiAqIHRvIGJhc2UgNjQuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb3VudEJ5dGVzKGhlYXJ0YmVhdHNDYWNoZSkge1xyXG4gICAgLy8gYmFzZTY0IGhhcyBhIHJlc3RyaWN0ZWQgc2V0IG9mIGNoYXJhY3RlcnMsIGFsbCBvZiB3aGljaCBzaG91bGQgYmUgMSBieXRlLlxyXG4gICAgcmV0dXJuIGJhc2U2NHVybEVuY29kZVdpdGhvdXRQYWRkaW5nKFxyXG4gICAgLy8gaGVhcnRiZWF0c0NhY2hlIHdyYXBwZXIgcHJvcGVydGllc1xyXG4gICAgSlNPTi5zdHJpbmdpZnkoeyB2ZXJzaW9uOiAyLCBoZWFydGJlYXRzOiBoZWFydGJlYXRzQ2FjaGUgfSkpLmxlbmd0aDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiByZWdpc3RlckNvcmVDb21wb25lbnRzKHZhcmlhbnQpIHtcclxuICAgIF9yZWdpc3RlckNvbXBvbmVudChuZXcgQ29tcG9uZW50KCdwbGF0Zm9ybS1sb2dnZXInLCBjb250YWluZXIgPT4gbmV3IFBsYXRmb3JtTG9nZ2VyU2VydmljZUltcGwoY29udGFpbmVyKSwgXCJQUklWQVRFXCIgLyogQ29tcG9uZW50VHlwZS5QUklWQVRFICovKSk7XHJcbiAgICBfcmVnaXN0ZXJDb21wb25lbnQobmV3IENvbXBvbmVudCgnaGVhcnRiZWF0JywgY29udGFpbmVyID0+IG5ldyBIZWFydGJlYXRTZXJ2aWNlSW1wbChjb250YWluZXIpLCBcIlBSSVZBVEVcIiAvKiBDb21wb25lbnRUeXBlLlBSSVZBVEUgKi8pKTtcclxuICAgIC8vIFJlZ2lzdGVyIGBhcHBgIHBhY2thZ2UuXHJcbiAgICByZWdpc3RlclZlcnNpb24obmFtZSRvLCB2ZXJzaW9uJDEsIHZhcmlhbnQpO1xyXG4gICAgLy8gQlVJTERfVEFSR0VUIHdpbGwgYmUgcmVwbGFjZWQgYnkgdmFsdWVzIGxpa2UgZXNtNSwgZXNtMjAxNywgY2pzNSwgZXRjIGR1cmluZyB0aGUgY29tcGlsYXRpb25cclxuICAgIHJlZ2lzdGVyVmVyc2lvbihuYW1lJG8sIHZlcnNpb24kMSwgJ2VzbTIwMTcnKTtcclxuICAgIC8vIFJlZ2lzdGVyIHBsYXRmb3JtIFNESyBpZGVudGlmaWVyIChubyB2ZXJzaW9uKS5cclxuICAgIHJlZ2lzdGVyVmVyc2lvbignZmlyZS1qcycsICcnKTtcclxufVxuXG4vKipcclxuICogRmlyZWJhc2UgQXBwXHJcbiAqXHJcbiAqIEByZW1hcmtzIFRoaXMgcGFja2FnZSBjb29yZGluYXRlcyB0aGUgY29tbXVuaWNhdGlvbiBiZXR3ZWVuIHRoZSBkaWZmZXJlbnQgRmlyZWJhc2UgY29tcG9uZW50c1xyXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cclxuICovXHJcbnJlZ2lzdGVyQ29yZUNvbXBvbmVudHMoJycpO1xuXG5leHBvcnQgeyBTREtfVkVSU0lPTiwgREVGQVVMVF9FTlRSWV9OQU1FIGFzIF9ERUZBVUxUX0VOVFJZX05BTUUsIF9hZGRDb21wb25lbnQsIF9hZGRPck92ZXJ3cml0ZUNvbXBvbmVudCwgX2FwcHMsIF9jbGVhckNvbXBvbmVudHMsIF9jb21wb25lbnRzLCBfZ2V0UHJvdmlkZXIsIF9yZWdpc3RlckNvbXBvbmVudCwgX3JlbW92ZVNlcnZpY2VJbnN0YW5jZSwgZGVsZXRlQXBwLCBnZXRBcHAsIGdldEFwcHMsIGluaXRpYWxpemVBcHAsIG9uTG9nLCByZWdpc3RlclZlcnNpb24sIHNldExvZ0xldmVsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20yMDE3LmpzLm1hcFxuIl0sIm5hbWVzIjpbIkNvbXBvbmVudCIsIkNvbXBvbmVudENvbnRhaW5lciIsIkxvZ2dlciIsInNldFVzZXJMb2dIYW5kbGVyIiwic2V0TG9nTGV2ZWwiLCJzZXRMb2dMZXZlbCQxIiwiRXJyb3JGYWN0b3J5IiwiZ2V0RGVmYXVsdEFwcENvbmZpZyIsImRlZXBFcXVhbCIsIkZpcmViYXNlRXJyb3IiLCJiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyIsImlzSW5kZXhlZERCQXZhaWxhYmxlIiwidmFsaWRhdGVJbmRleGVkREJPcGVuYWJsZSIsIm9wZW5EQiIsIlBsYXRmb3JtTG9nZ2VyU2VydmljZUltcGwiLCJjb25zdHJ1Y3RvciIsImNvbnRhaW5lciIsImdldFBsYXRmb3JtSW5mb1N0cmluZyIsInByb3ZpZGVycyIsImdldFByb3ZpZGVycyIsIm1hcCIsInByb3ZpZGVyIiwiaXNWZXJzaW9uU2VydmljZVByb3ZpZGVyIiwic2VydmljZSIsImdldEltbWVkaWF0ZSIsImxpYnJhcnkiLCJ2ZXJzaW9uIiwiZmlsdGVyIiwibG9nU3RyaW5nIiwiam9pbiIsImNvbXBvbmVudCIsImdldENvbXBvbmVudCIsInR5cGUiLCJuYW1lJG8iLCJ2ZXJzaW9uJDEiLCJsb2dnZXIiLCJuYW1lJG4iLCJuYW1lJG0iLCJuYW1lJGwiLCJuYW1lJGsiLCJuYW1lJGoiLCJuYW1lJGkiLCJuYW1lJGgiLCJuYW1lJGciLCJuYW1lJGYiLCJuYW1lJGUiLCJuYW1lJGQiLCJuYW1lJGMiLCJuYW1lJGIiLCJuYW1lJGEiLCJuYW1lJDkiLCJuYW1lJDgiLCJuYW1lJDciLCJuYW1lJDYiLCJuYW1lJDUiLCJuYW1lJDQiLCJuYW1lJDMiLCJuYW1lJDIiLCJuYW1lJDEiLCJuYW1lIiwiREVGQVVMVF9FTlRSWV9OQU1FIiwiUExBVEZPUk1fTE9HX1NUUklORyIsIl9hcHBzIiwiTWFwIiwiX2NvbXBvbmVudHMiLCJfYWRkQ29tcG9uZW50IiwiYXBwIiwiYWRkQ29tcG9uZW50IiwiZSIsImRlYnVnIiwiX2FkZE9yT3ZlcndyaXRlQ29tcG9uZW50IiwiYWRkT3JPdmVyd3JpdGVDb21wb25lbnQiLCJfcmVnaXN0ZXJDb21wb25lbnQiLCJjb21wb25lbnROYW1lIiwiaGFzIiwic2V0IiwidmFsdWVzIiwiX2dldFByb3ZpZGVyIiwiaGVhcnRiZWF0Q29udHJvbGxlciIsImdldFByb3ZpZGVyIiwib3B0aW9uYWwiLCJ0cmlnZ2VySGVhcnRiZWF0IiwiX3JlbW92ZVNlcnZpY2VJbnN0YW5jZSIsImluc3RhbmNlSWRlbnRpZmllciIsImNsZWFySW5zdGFuY2UiLCJfY2xlYXJDb21wb25lbnRzIiwiY2xlYXIiLCJFUlJPUlMiLCJFUlJPUl9GQUNUT1JZIiwiRmlyZWJhc2VBcHBJbXBsIiwib3B0aW9ucyIsImNvbmZpZyIsIl9pc0RlbGV0ZWQiLCJfb3B0aW9ucyIsIk9iamVjdCIsImFzc2lnbiIsIl9jb25maWciLCJfbmFtZSIsIl9hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQiLCJhdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQiLCJfY29udGFpbmVyIiwiY2hlY2tEZXN0cm95ZWQiLCJ2YWwiLCJpc0RlbGV0ZWQiLCJjcmVhdGUiLCJhcHBOYW1lIiwiU0RLX1ZFUlNJT04iLCJpbml0aWFsaXplQXBwIiwicmF3Q29uZmlnIiwiU3RyaW5nIiwiZXhpc3RpbmdBcHAiLCJnZXQiLCJuZXdBcHAiLCJnZXRBcHAiLCJnZXRBcHBzIiwiQXJyYXkiLCJmcm9tIiwiZGVsZXRlQXBwIiwiZGVsZXRlIiwiUHJvbWlzZSIsImFsbCIsInJlZ2lzdGVyVmVyc2lvbiIsImxpYnJhcnlLZXlPck5hbWUiLCJ2YXJpYW50IiwiX2EiLCJsaWJyYXJ5TWlzbWF0Y2giLCJtYXRjaCIsInZlcnNpb25NaXNtYXRjaCIsIndhcm5pbmciLCJwdXNoIiwid2FybiIsIm9uTG9nIiwibG9nQ2FsbGJhY2siLCJsb2dMZXZlbCIsIkRCX05BTUUiLCJEQl9WRVJTSU9OIiwiU1RPUkVfTkFNRSIsImRiUHJvbWlzZSIsImdldERiUHJvbWlzZSIsInVwZ3JhZGUiLCJkYiIsIm9sZFZlcnNpb24iLCJjcmVhdGVPYmplY3RTdG9yZSIsImNvbnNvbGUiLCJjYXRjaCIsIm9yaWdpbmFsRXJyb3JNZXNzYWdlIiwibWVzc2FnZSIsInJlYWRIZWFydGJlYXRzRnJvbUluZGV4ZWREQiIsInR4IiwidHJhbnNhY3Rpb24iLCJyZXN1bHQiLCJvYmplY3RTdG9yZSIsImNvbXB1dGVLZXkiLCJkb25lIiwiaWRiR2V0RXJyb3IiLCJ3cml0ZUhlYXJ0YmVhdHNUb0luZGV4ZWREQiIsImhlYXJ0YmVhdE9iamVjdCIsInB1dCIsImFwcElkIiwiTUFYX0hFQURFUl9CWVRFUyIsIlNUT1JFRF9IRUFSVEJFQVRfUkVURU5USU9OX01BWF9NSUxMSVMiLCJIZWFydGJlYXRTZXJ2aWNlSW1wbCIsIl9oZWFydGJlYXRzQ2FjaGUiLCJfc3RvcmFnZSIsIkhlYXJ0YmVhdFN0b3JhZ2VJbXBsIiwiX2hlYXJ0YmVhdHNDYWNoZVByb21pc2UiLCJyZWFkIiwidGhlbiIsIl9iIiwicGxhdGZvcm1Mb2dnZXIiLCJhZ2VudCIsImRhdGUiLCJnZXRVVENEYXRlU3RyaW5nIiwiaGVhcnRiZWF0cyIsImxhc3RTZW50SGVhcnRiZWF0RGF0ZSIsInNvbWUiLCJzaW5nbGVEYXRlSGVhcnRiZWF0IiwiaGJUaW1lc3RhbXAiLCJEYXRlIiwidmFsdWVPZiIsIm5vdyIsIm92ZXJ3cml0ZSIsImdldEhlYXJ0YmVhdHNIZWFkZXIiLCJsZW5ndGgiLCJoZWFydGJlYXRzVG9TZW5kIiwidW5zZW50RW50cmllcyIsImV4dHJhY3RIZWFydGJlYXRzRm9ySGVhZGVyIiwiaGVhZGVyU3RyaW5nIiwiSlNPTiIsInN0cmluZ2lmeSIsInRvZGF5IiwidG9JU09TdHJpbmciLCJzdWJzdHJpbmciLCJoZWFydGJlYXRzQ2FjaGUiLCJtYXhTaXplIiwic2xpY2UiLCJoZWFydGJlYXRFbnRyeSIsImZpbmQiLCJoYiIsImRhdGVzIiwiY291bnRCeXRlcyIsInBvcCIsIl9jYW5Vc2VJbmRleGVkREJQcm9taXNlIiwicnVuSW5kZXhlZERCRW52aXJvbm1lbnRDaGVjayIsImNhblVzZUluZGV4ZWREQiIsImlkYkhlYXJ0YmVhdE9iamVjdCIsImhlYXJ0YmVhdHNPYmplY3QiLCJleGlzdGluZ0hlYXJ0YmVhdHNPYmplY3QiLCJhZGQiLCJyZWdpc3RlckNvcmVDb21wb25lbnRzIiwiX0RFRkFVTFRfRU5UUllfTkFNRSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js":
/*!********************************************************************!*\
  !*** ./node_modules/@firebase/component/dist/esm/index.esm2017.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Component: () => (/* binding */ Component),\n/* harmony export */   ComponentContainer: () => (/* binding */ ComponentContainer),\n/* harmony export */   Provider: () => (/* binding */ Provider)\n/* harmony export */ });\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n\n/**\r\n * Component for service name T, e.g. `auth`, `auth-internal`\r\n */ class Component {\n    /**\r\n     *\r\n     * @param name The public service name, e.g. app, auth, firestore, database\r\n     * @param instanceFactory Service factory responsible for creating the public interface\r\n     * @param type whether the service provided by the component is public or private\r\n     */ constructor(name, instanceFactory, type){\n        this.name = name;\n        this.instanceFactory = instanceFactory;\n        this.type = type;\n        this.multipleInstances = false;\n        /**\r\n         * Properties to be added to the service namespace\r\n         */ this.serviceProps = {};\n        this.instantiationMode = \"LAZY\" /* InstantiationMode.LAZY */ ;\n        this.onInstanceCreated = null;\n    }\n    setInstantiationMode(mode) {\n        this.instantiationMode = mode;\n        return this;\n    }\n    setMultipleInstances(multipleInstances) {\n        this.multipleInstances = multipleInstances;\n        return this;\n    }\n    setServiceProps(props) {\n        this.serviceProps = props;\n        return this;\n    }\n    setInstanceCreatedCallback(callback) {\n        this.onInstanceCreated = callback;\n        return this;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const DEFAULT_ENTRY_NAME = \"[DEFAULT]\";\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Provider for instance for service name T, e.g. 'auth', 'auth-internal'\r\n * NameServiceMapping[T] is an alias for the type of the instance\r\n */ class Provider {\n    constructor(name, container){\n        this.name = name;\n        this.container = container;\n        this.component = null;\n        this.instances = new Map();\n        this.instancesDeferred = new Map();\n        this.instancesOptions = new Map();\n        this.onInitCallbacks = new Map();\n    }\n    /**\r\n     * @param identifier A provider can provide mulitple instances of a service\r\n     * if this.component.multipleInstances is true.\r\n     */ get(identifier) {\n        // if multipleInstances is not supported, use the default name\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n        if (!this.instancesDeferred.has(normalizedIdentifier)) {\n            const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_0__.Deferred();\n            this.instancesDeferred.set(normalizedIdentifier, deferred);\n            if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {\n                // initialize the service if it can be auto-initialized\n                try {\n                    const instance = this.getOrInitializeService({\n                        instanceIdentifier: normalizedIdentifier\n                    });\n                    if (instance) {\n                        deferred.resolve(instance);\n                    }\n                } catch (e) {\n                // when the instance factory throws an exception during get(), it should not cause\n                // a fatal error. We just return the unresolved promise in this case.\n                }\n            }\n        }\n        return this.instancesDeferred.get(normalizedIdentifier).promise;\n    }\n    getImmediate(options) {\n        var _a;\n        // if multipleInstances is not supported, use the default name\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);\n        const optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;\n        if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {\n            try {\n                return this.getOrInitializeService({\n                    instanceIdentifier: normalizedIdentifier\n                });\n            } catch (e) {\n                if (optional) {\n                    return null;\n                } else {\n                    throw e;\n                }\n            }\n        } else {\n            // In case a component is not initialized and should/can not be auto-initialized at the moment, return null if the optional flag is set, or throw\n            if (optional) {\n                return null;\n            } else {\n                throw Error(`Service ${this.name} is not available`);\n            }\n        }\n    }\n    getComponent() {\n        return this.component;\n    }\n    setComponent(component) {\n        if (component.name !== this.name) {\n            throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);\n        }\n        if (this.component) {\n            throw Error(`Component for ${this.name} has already been provided`);\n        }\n        this.component = component;\n        // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)\n        if (!this.shouldAutoInitialize()) {\n            return;\n        }\n        // if the service is eager, initialize the default instance\n        if (isComponentEager(component)) {\n            try {\n                this.getOrInitializeService({\n                    instanceIdentifier: DEFAULT_ENTRY_NAME\n                });\n            } catch (e) {\n            // when the instance factory for an eager Component throws an exception during the eager\n            // initialization, it should not cause a fatal error.\n            // TODO: Investigate if we need to make it configurable, because some component may want to cause\n            // a fatal error in this case?\n            }\n        }\n        // Create service instances for the pending promises and resolve them\n        // NOTE: if this.multipleInstances is false, only the default instance will be created\n        // and all promises with resolve with it regardless of the identifier.\n        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()){\n            const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n            try {\n                // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.\n                const instance = this.getOrInitializeService({\n                    instanceIdentifier: normalizedIdentifier\n                });\n                instanceDeferred.resolve(instance);\n            } catch (e) {\n            // when the instance factory throws an exception, it should not cause\n            // a fatal error. We just leave the promise unresolved.\n            }\n        }\n    }\n    clearInstance(identifier = DEFAULT_ENTRY_NAME) {\n        this.instancesDeferred.delete(identifier);\n        this.instancesOptions.delete(identifier);\n        this.instances.delete(identifier);\n    }\n    // app.delete() will call this method on every provider to delete the services\n    // TODO: should we mark the provider as deleted?\n    async delete() {\n        const services = Array.from(this.instances.values());\n        await Promise.all([\n            ...services.filter((service)=>\"INTERNAL\" in service) // legacy services\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            .map((service)=>service.INTERNAL.delete()),\n            ...services.filter((service)=>\"_delete\" in service) // modularized services\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            .map((service)=>service._delete())\n        ]);\n    }\n    isComponentSet() {\n        return this.component != null;\n    }\n    isInitialized(identifier = DEFAULT_ENTRY_NAME) {\n        return this.instances.has(identifier);\n    }\n    getOptions(identifier = DEFAULT_ENTRY_NAME) {\n        return this.instancesOptions.get(identifier) || {};\n    }\n    initialize(opts = {}) {\n        const { options = {} } = opts;\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);\n        if (this.isInitialized(normalizedIdentifier)) {\n            throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);\n        }\n        if (!this.isComponentSet()) {\n            throw Error(`Component ${this.name} has not been registered yet`);\n        }\n        const instance = this.getOrInitializeService({\n            instanceIdentifier: normalizedIdentifier,\n            options\n        });\n        // resolve any pending promise waiting for the service instance\n        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()){\n            const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n            if (normalizedIdentifier === normalizedDeferredIdentifier) {\n                instanceDeferred.resolve(instance);\n            }\n        }\n        return instance;\n    }\n    /**\r\n     *\r\n     * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().\r\n     * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.\r\n     *\r\n     * @param identifier An optional instance identifier\r\n     * @returns a function to unregister the callback\r\n     */ onInit(callback, identifier) {\n        var _a;\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n        const existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();\n        existingCallbacks.add(callback);\n        this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);\n        const existingInstance = this.instances.get(normalizedIdentifier);\n        if (existingInstance) {\n            callback(existingInstance, normalizedIdentifier);\n        }\n        return ()=>{\n            existingCallbacks.delete(callback);\n        };\n    }\n    /**\r\n     * Invoke onInit callbacks synchronously\r\n     * @param instance the service instance`\r\n     */ invokeOnInitCallbacks(instance, identifier) {\n        const callbacks = this.onInitCallbacks.get(identifier);\n        if (!callbacks) {\n            return;\n        }\n        for (const callback of callbacks){\n            try {\n                callback(instance, identifier);\n            } catch (_a) {\n            // ignore errors in the onInit callback\n            }\n        }\n    }\n    getOrInitializeService({ instanceIdentifier, options = {} }) {\n        let instance = this.instances.get(instanceIdentifier);\n        if (!instance && this.component) {\n            instance = this.component.instanceFactory(this.container, {\n                instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),\n                options\n            });\n            this.instances.set(instanceIdentifier, instance);\n            this.instancesOptions.set(instanceIdentifier, options);\n            /**\r\n             * Invoke onInit listeners.\r\n             * Note this.component.onInstanceCreated is different, which is used by the component creator,\r\n             * while onInit listeners are registered by consumers of the provider.\r\n             */ this.invokeOnInitCallbacks(instance, instanceIdentifier);\n            /**\r\n             * Order is important\r\n             * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which\r\n             * makes `isInitialized()` return true.\r\n             */ if (this.component.onInstanceCreated) {\n                try {\n                    this.component.onInstanceCreated(this.container, instanceIdentifier, instance);\n                } catch (_a) {\n                // ignore errors in the onInstanceCreatedCallback\n                }\n            }\n        }\n        return instance || null;\n    }\n    normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME) {\n        if (this.component) {\n            return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;\n        } else {\n            return identifier; // assume multiple instances are supported before the component is provided.\n        }\n    }\n    shouldAutoInitialize() {\n        return !!this.component && this.component.instantiationMode !== \"EXPLICIT\" /* InstantiationMode.EXPLICIT */ ;\n    }\n}\n// undefined should be passed to the service factory for the default instance\nfunction normalizeIdentifierForFactory(identifier) {\n    return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;\n}\nfunction isComponentEager(component) {\n    return component.instantiationMode === \"EAGER\" /* InstantiationMode.EAGER */ ;\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`\r\n */ class ComponentContainer {\n    constructor(name){\n        this.name = name;\n        this.providers = new Map();\n    }\n    /**\r\n     *\r\n     * @param component Component being added\r\n     * @param overwrite When a component with the same name has already been registered,\r\n     * if overwrite is true: overwrite the existing component with the new component and create a new\r\n     * provider with the new component. It can be useful in tests where you want to use different mocks\r\n     * for different tests.\r\n     * if overwrite is false: throw an exception\r\n     */ addComponent(component) {\n        const provider = this.getProvider(component.name);\n        if (provider.isComponentSet()) {\n            throw new Error(`Component ${component.name} has already been registered with ${this.name}`);\n        }\n        provider.setComponent(component);\n    }\n    addOrOverwriteComponent(component) {\n        const provider = this.getProvider(component.name);\n        if (provider.isComponentSet()) {\n            // delete the existing provider from the container, so we can register the new component\n            this.providers.delete(component.name);\n        }\n        this.addComponent(component);\n    }\n    /**\r\n     * getProvider provides a type safe interface where it can only be called with a field name\r\n     * present in NameServiceMapping interface.\r\n     *\r\n     * Firebase SDKs providing services should extend NameServiceMapping interface to register\r\n     * themselves.\r\n     */ getProvider(name) {\n        if (this.providers.has(name)) {\n            return this.providers.get(name);\n        }\n        // create a Provider for a service that hasn't registered with Firebase\n        const provider = new Provider(name, this);\n        this.providers.set(name, provider);\n        return provider;\n    }\n    getProviders() {\n        return Array.from(this.providers.values());\n    }\n}\n //# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2NvbXBvbmVudC9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBMEM7QUFFMUM7O0NBRUMsR0FDRCxNQUFNQztJQUNGOzs7OztLQUtDLEdBQ0RDLFlBQVlDLElBQUksRUFBRUMsZUFBZSxFQUFFQyxJQUFJLENBQUU7UUFDckMsSUFBSSxDQUFDRixJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDQyxlQUFlLEdBQUdBO1FBQ3ZCLElBQUksQ0FBQ0MsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUc7UUFDekI7O1NBRUMsR0FDRCxJQUFJLENBQUNDLFlBQVksR0FBRyxDQUFDO1FBQ3JCLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUcsT0FBTywwQkFBMEI7UUFDMUQsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRztJQUM3QjtJQUNBQyxxQkFBcUJDLElBQUksRUFBRTtRQUN2QixJQUFJLENBQUNILGlCQUFpQixHQUFHRztRQUN6QixPQUFPLElBQUk7SUFDZjtJQUNBQyxxQkFBcUJOLGlCQUFpQixFQUFFO1FBQ3BDLElBQUksQ0FBQ0EsaUJBQWlCLEdBQUdBO1FBQ3pCLE9BQU8sSUFBSTtJQUNmO0lBQ0FPLGdCQUFnQkMsS0FBSyxFQUFFO1FBQ25CLElBQUksQ0FBQ1AsWUFBWSxHQUFHTztRQUNwQixPQUFPLElBQUk7SUFDZjtJQUNBQywyQkFBMkJDLFFBQVEsRUFBRTtRQUNqQyxJQUFJLENBQUNQLGlCQUFpQixHQUFHTztRQUN6QixPQUFPLElBQUk7SUFDZjtBQUNKO0FBRUE7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0QsTUFBTUMscUJBQXFCO0FBRTNCOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEOzs7Q0FHQyxHQUNELE1BQU1DO0lBQ0ZoQixZQUFZQyxJQUFJLEVBQUVnQixTQUFTLENBQUU7UUFDekIsSUFBSSxDQUFDaEIsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ2dC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T0FBT0E7SUFDWDtJQUNBRyxlQUFlO1FBQ1gsT0FBTzlCLE1BQU1DLElBQUksQ0FBQyxJQUFJLENBQUN3QixTQUFTLENBQUN2QixNQUFNO0lBQzNDO0FBQ0o7QUFFbUQsQ0FDbkQseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd29ybGR3ZWIvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2NvbXBvbmVudC9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzPzI0M2MiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGVmZXJyZWQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5cbi8qKlxyXG4gKiBDb21wb25lbnQgZm9yIHNlcnZpY2UgbmFtZSBULCBlLmcuIGBhdXRoYCwgYGF1dGgtaW50ZXJuYWxgXHJcbiAqL1xyXG5jbGFzcyBDb21wb25lbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIHB1YmxpYyBzZXJ2aWNlIG5hbWUsIGUuZy4gYXBwLCBhdXRoLCBmaXJlc3RvcmUsIGRhdGFiYXNlXHJcbiAgICAgKiBAcGFyYW0gaW5zdGFuY2VGYWN0b3J5IFNlcnZpY2UgZmFjdG9yeSByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhlIHB1YmxpYyBpbnRlcmZhY2VcclxuICAgICAqIEBwYXJhbSB0eXBlIHdoZXRoZXIgdGhlIHNlcnZpY2UgcHJvdmlkZWQgYnkgdGhlIGNvbXBvbmVudCBpcyBwdWJsaWMgb3IgcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBpbnN0YW5jZUZhY3RvcnksIHR5cGUpIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2VGYWN0b3J5ID0gaW5zdGFuY2VGYWN0b3J5O1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICAgICAgdGhpcy5tdWx0aXBsZUluc3RhbmNlcyA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb3BlcnRpZXMgdG8gYmUgYWRkZWQgdG8gdGhlIHNlcnZpY2UgbmFtZXNwYWNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zZXJ2aWNlUHJvcHMgPSB7fTtcclxuICAgICAgICB0aGlzLmluc3RhbnRpYXRpb25Nb2RlID0gXCJMQVpZXCIgLyogSW5zdGFudGlhdGlvbk1vZGUuTEFaWSAqLztcclxuICAgICAgICB0aGlzLm9uSW5zdGFuY2VDcmVhdGVkID0gbnVsbDtcclxuICAgIH1cclxuICAgIHNldEluc3RhbnRpYXRpb25Nb2RlKG1vZGUpIHtcclxuICAgICAgICB0aGlzLmluc3RhbnRpYXRpb25Nb2RlID0gbW9kZTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHNldE11bHRpcGxlSW5zdGFuY2VzKG11bHRpcGxlSW5zdGFuY2VzKSB7XHJcbiAgICAgICAgdGhpcy5tdWx0aXBsZUluc3RhbmNlcyA9IG11bHRpcGxlSW5zdGFuY2VzO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgc2V0U2VydmljZVByb3BzKHByb3BzKSB7XHJcbiAgICAgICAgdGhpcy5zZXJ2aWNlUHJvcHMgPSBwcm9wcztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHNldEluc3RhbmNlQ3JlYXRlZENhbGxiYWNrKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5vbkluc3RhbmNlQ3JlYXRlZCA9IGNhbGxiYWNrO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IERFRkFVTFRfRU5UUllfTkFNRSA9ICdbREVGQVVMVF0nO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUHJvdmlkZXIgZm9yIGluc3RhbmNlIGZvciBzZXJ2aWNlIG5hbWUgVCwgZS5nLiAnYXV0aCcsICdhdXRoLWludGVybmFsJ1xyXG4gKiBOYW1lU2VydmljZU1hcHBpbmdbVF0gaXMgYW4gYWxpYXMgZm9yIHRoZSB0eXBlIG9mIHRoZSBpbnN0YW5jZVxyXG4gKi9cclxuY2xhc3MgUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IobmFtZSwgY29udGFpbmVyKSB7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZXMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZXNEZWZlcnJlZCA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLmluc3RhbmNlc09wdGlvbnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5vbkluaXRDYWxsYmFja3MgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBpZGVudGlmaWVyIEEgcHJvdmlkZXIgY2FuIHByb3ZpZGUgbXVsaXRwbGUgaW5zdGFuY2VzIG9mIGEgc2VydmljZVxyXG4gICAgICogaWYgdGhpcy5jb21wb25lbnQubXVsdGlwbGVJbnN0YW5jZXMgaXMgdHJ1ZS5cclxuICAgICAqL1xyXG4gICAgZ2V0KGlkZW50aWZpZXIpIHtcclxuICAgICAgICAvLyBpZiBtdWx0aXBsZUluc3RhbmNlcyBpcyBub3Qgc3VwcG9ydGVkLCB1c2UgdGhlIGRlZmF1bHQgbmFtZVxyXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRJZGVudGlmaWVyID0gdGhpcy5ub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIoaWRlbnRpZmllcik7XHJcbiAgICAgICAgaWYgKCF0aGlzLmluc3RhbmNlc0RlZmVycmVkLmhhcyhub3JtYWxpemVkSWRlbnRpZmllcikpIHtcclxuICAgICAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5zZXQobm9ybWFsaXplZElkZW50aWZpZXIsIGRlZmVycmVkKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZChub3JtYWxpemVkSWRlbnRpZmllcikgfHxcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hvdWxkQXV0b0luaXRpYWxpemUoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgc2VydmljZSBpZiBpdCBjYW4gYmUgYXV0by1pbml0aWFsaXplZFxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuZ2V0T3JJbml0aWFsaXplU2VydmljZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplZElkZW50aWZpZXJcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSBpbnN0YW5jZSBmYWN0b3J5IHRocm93cyBhbiBleGNlcHRpb24gZHVyaW5nIGdldCgpLCBpdCBzaG91bGQgbm90IGNhdXNlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYSBmYXRhbCBlcnJvci4gV2UganVzdCByZXR1cm4gdGhlIHVucmVzb2x2ZWQgcHJvbWlzZSBpbiB0aGlzIGNhc2UuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuZ2V0KG5vcm1hbGl6ZWRJZGVudGlmaWVyKS5wcm9taXNlO1xyXG4gICAgfVxyXG4gICAgZ2V0SW1tZWRpYXRlKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgLy8gaWYgbXVsdGlwbGVJbnN0YW5jZXMgaXMgbm90IHN1cHBvcnRlZCwgdXNlIHRoZSBkZWZhdWx0IG5hbWVcclxuICAgICAgICBjb25zdCBub3JtYWxpemVkSWRlbnRpZmllciA9IHRoaXMubm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pZGVudGlmaWVyKTtcclxuICAgICAgICBjb25zdCBvcHRpb25hbCA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vcHRpb25hbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZChub3JtYWxpemVkSWRlbnRpZmllcikgfHxcclxuICAgICAgICAgICAgdGhpcy5zaG91bGRBdXRvSW5pdGlhbGl6ZSgpKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPckluaXRpYWxpemVTZXJ2aWNlKHtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUlkZW50aWZpZXI6IG5vcm1hbGl6ZWRJZGVudGlmaWVyXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBJbiBjYXNlIGEgY29tcG9uZW50IGlzIG5vdCBpbml0aWFsaXplZCBhbmQgc2hvdWxkL2NhbiBub3QgYmUgYXV0by1pbml0aWFsaXplZCBhdCB0aGUgbW9tZW50LCByZXR1cm4gbnVsbCBpZiB0aGUgb3B0aW9uYWwgZmxhZyBpcyBzZXQsIG9yIHRocm93XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25hbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihgU2VydmljZSAke3RoaXMubmFtZX0gaXMgbm90IGF2YWlsYWJsZWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0Q29tcG9uZW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudDtcclxuICAgIH1cclxuICAgIHNldENvbXBvbmVudChjb21wb25lbnQpIHtcclxuICAgICAgICBpZiAoY29tcG9uZW50Lm5hbWUgIT09IHRoaXMubmFtZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgTWlzbWF0Y2hpbmcgQ29tcG9uZW50ICR7Y29tcG9uZW50Lm5hbWV9IGZvciBQcm92aWRlciAke3RoaXMubmFtZX0uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgQ29tcG9uZW50IGZvciAke3RoaXMubmFtZX0gaGFzIGFscmVhZHkgYmVlbiBwcm92aWRlZGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcclxuICAgICAgICAvLyByZXR1cm4gZWFybHkgd2l0aG91dCBhdHRlbXB0aW5nIHRvIGluaXRpYWxpemUgdGhlIGNvbXBvbmVudCBpZiB0aGUgY29tcG9uZW50IHJlcXVpcmVzIGV4cGxpY2l0IGluaXRpYWxpemF0aW9uIChjYWxsaW5nIGBQcm92aWRlci5pbml0aWFsaXplKClgKVxyXG4gICAgICAgIGlmICghdGhpcy5zaG91bGRBdXRvSW5pdGlhbGl6ZSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgdGhlIHNlcnZpY2UgaXMgZWFnZXIsIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgaW5zdGFuY2VcclxuICAgICAgICBpZiAoaXNDb21wb25lbnRFYWdlcihjb21wb25lbnQpKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdldE9ySW5pdGlhbGl6ZVNlcnZpY2UoeyBpbnN0YW5jZUlkZW50aWZpZXI6IERFRkFVTFRfRU5UUllfTkFNRSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gd2hlbiB0aGUgaW5zdGFuY2UgZmFjdG9yeSBmb3IgYW4gZWFnZXIgQ29tcG9uZW50IHRocm93cyBhbiBleGNlcHRpb24gZHVyaW5nIHRoZSBlYWdlclxyXG4gICAgICAgICAgICAgICAgLy8gaW5pdGlhbGl6YXRpb24sIGl0IHNob3VsZCBub3QgY2F1c2UgYSBmYXRhbCBlcnJvci5cclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IEludmVzdGlnYXRlIGlmIHdlIG5lZWQgdG8gbWFrZSBpdCBjb25maWd1cmFibGUsIGJlY2F1c2Ugc29tZSBjb21wb25lbnQgbWF5IHdhbnQgdG8gY2F1c2VcclxuICAgICAgICAgICAgICAgIC8vIGEgZmF0YWwgZXJyb3IgaW4gdGhpcyBjYXNlP1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENyZWF0ZSBzZXJ2aWNlIGluc3RhbmNlcyBmb3IgdGhlIHBlbmRpbmcgcHJvbWlzZXMgYW5kIHJlc29sdmUgdGhlbVxyXG4gICAgICAgIC8vIE5PVEU6IGlmIHRoaXMubXVsdGlwbGVJbnN0YW5jZXMgaXMgZmFsc2UsIG9ubHkgdGhlIGRlZmF1bHQgaW5zdGFuY2Ugd2lsbCBiZSBjcmVhdGVkXHJcbiAgICAgICAgLy8gYW5kIGFsbCBwcm9taXNlcyB3aXRoIHJlc29sdmUgd2l0aCBpdCByZWdhcmRsZXNzIG9mIHRoZSBpZGVudGlmaWVyLlxyXG4gICAgICAgIGZvciAoY29uc3QgW2luc3RhbmNlSWRlbnRpZmllciwgaW5zdGFuY2VEZWZlcnJlZF0gb2YgdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5lbnRyaWVzKCkpIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpbnN0YW5jZUlkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgLy8gYGdldE9ySW5pdGlhbGl6ZVNlcnZpY2UoKWAgc2hvdWxkIGFsd2F5cyByZXR1cm4gYSB2YWxpZCBpbnN0YW5jZSBzaW5jZSBhIGNvbXBvbmVudCBpcyBndWFyYW50ZWVkLiB1c2UgISB0byBtYWtlIHR5cGVzY3JpcHQgaGFwcHkuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuZ2V0T3JJbml0aWFsaXplU2VydmljZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VJZGVudGlmaWVyOiBub3JtYWxpemVkSWRlbnRpZmllclxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZURlZmVycmVkLnJlc29sdmUoaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSBpbnN0YW5jZSBmYWN0b3J5IHRocm93cyBhbiBleGNlcHRpb24sIGl0IHNob3VsZCBub3QgY2F1c2VcclxuICAgICAgICAgICAgICAgIC8vIGEgZmF0YWwgZXJyb3IuIFdlIGp1c3QgbGVhdmUgdGhlIHByb21pc2UgdW5yZXNvbHZlZC5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNsZWFySW5zdGFuY2UoaWRlbnRpZmllciA9IERFRkFVTFRfRU5UUllfTkFNRSkge1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuZGVsZXRlKGlkZW50aWZpZXIpO1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2VzT3B0aW9ucy5kZWxldGUoaWRlbnRpZmllcik7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZXMuZGVsZXRlKGlkZW50aWZpZXIpO1xyXG4gICAgfVxyXG4gICAgLy8gYXBwLmRlbGV0ZSgpIHdpbGwgY2FsbCB0aGlzIG1ldGhvZCBvbiBldmVyeSBwcm92aWRlciB0byBkZWxldGUgdGhlIHNlcnZpY2VzXHJcbiAgICAvLyBUT0RPOiBzaG91bGQgd2UgbWFyayB0aGUgcHJvdmlkZXIgYXMgZGVsZXRlZD9cclxuICAgIGFzeW5jIGRlbGV0ZSgpIHtcclxuICAgICAgICBjb25zdCBzZXJ2aWNlcyA9IEFycmF5LmZyb20odGhpcy5pbnN0YW5jZXMudmFsdWVzKCkpO1xyXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgICAgICAgICAgLi4uc2VydmljZXNcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoc2VydmljZSA9PiAnSU5URVJOQUwnIGluIHNlcnZpY2UpIC8vIGxlZ2FjeSBzZXJ2aWNlc1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgICAgIC5tYXAoc2VydmljZSA9PiBzZXJ2aWNlLklOVEVSTkFMLmRlbGV0ZSgpKSxcclxuICAgICAgICAgICAgLi4uc2VydmljZXNcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoc2VydmljZSA9PiAnX2RlbGV0ZScgaW4gc2VydmljZSkgLy8gbW9kdWxhcml6ZWQgc2VydmljZXNcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgICAgICAubWFwKHNlcnZpY2UgPT4gc2VydmljZS5fZGVsZXRlKCkpXHJcbiAgICAgICAgXSk7XHJcbiAgICB9XHJcbiAgICBpc0NvbXBvbmVudFNldCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnQgIT0gbnVsbDtcclxuICAgIH1cclxuICAgIGlzSW5pdGlhbGl6ZWQoaWRlbnRpZmllciA9IERFRkFVTFRfRU5UUllfTkFNRSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlcy5oYXMoaWRlbnRpZmllcik7XHJcbiAgICB9XHJcbiAgICBnZXRPcHRpb25zKGlkZW50aWZpZXIgPSBERUZBVUxUX0VOVFJZX05BTUUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZXNPcHRpb25zLmdldChpZGVudGlmaWVyKSB8fCB7fTtcclxuICAgIH1cclxuICAgIGluaXRpYWxpemUob3B0cyA9IHt9KSB7XHJcbiAgICAgICAgY29uc3QgeyBvcHRpb25zID0ge30gfSA9IG9wdHM7XHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihvcHRzLmluc3RhbmNlSWRlbnRpZmllcik7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZChub3JtYWxpemVkSWRlbnRpZmllcikpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYCR7dGhpcy5uYW1lfSgke25vcm1hbGl6ZWRJZGVudGlmaWVyfSkgaGFzIGFscmVhZHkgYmVlbiBpbml0aWFsaXplZGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuaXNDb21wb25lbnRTZXQoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgQ29tcG9uZW50ICR7dGhpcy5uYW1lfSBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZCB5ZXRgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmdldE9ySW5pdGlhbGl6ZVNlcnZpY2Uoe1xyXG4gICAgICAgICAgICBpbnN0YW5jZUlkZW50aWZpZXI6IG5vcm1hbGl6ZWRJZGVudGlmaWVyLFxyXG4gICAgICAgICAgICBvcHRpb25zXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gcmVzb2x2ZSBhbnkgcGVuZGluZyBwcm9taXNlIHdhaXRpbmcgZm9yIHRoZSBzZXJ2aWNlIGluc3RhbmNlXHJcbiAgICAgICAgZm9yIChjb25zdCBbaW5zdGFuY2VJZGVudGlmaWVyLCBpbnN0YW5jZURlZmVycmVkXSBvZiB0aGlzLmluc3RhbmNlc0RlZmVycmVkLmVudHJpZXMoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkRGVmZXJyZWRJZGVudGlmaWVyID0gdGhpcy5ub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIoaW5zdGFuY2VJZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRJZGVudGlmaWVyID09PSBub3JtYWxpemVkRGVmZXJyZWRJZGVudGlmaWVyKSB7XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZURlZmVycmVkLnJlc29sdmUoaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGludm9rZWQgIGFmdGVyIHRoZSBwcm92aWRlciBoYXMgYmVlbiBpbml0aWFsaXplZCBieSBjYWxsaW5nIHByb3ZpZGVyLmluaXRpYWxpemUoKS5cclxuICAgICAqIFRoZSBmdW5jdGlvbiBpcyBpbnZva2VkIFNZTkNIUk9OT1VTTFksIHNvIGl0IHNob3VsZCBub3QgZXhlY3V0ZSBhbnkgbG9uZ3J1bm5pbmcgdGFza3MgaW4gb3JkZXIgdG8gbm90IGJsb2NrIHRoZSBwcm9ncmFtLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpZGVudGlmaWVyIEFuIG9wdGlvbmFsIGluc3RhbmNlIGlkZW50aWZpZXJcclxuICAgICAqIEByZXR1cm5zIGEgZnVuY3Rpb24gdG8gdW5yZWdpc3RlciB0aGUgY2FsbGJhY2tcclxuICAgICAqL1xyXG4gICAgb25Jbml0KGNhbGxiYWNrLCBpZGVudGlmaWVyKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRJZGVudGlmaWVyID0gdGhpcy5ub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIoaWRlbnRpZmllcik7XHJcbiAgICAgICAgY29uc3QgZXhpc3RpbmdDYWxsYmFja3MgPSAoX2EgPSB0aGlzLm9uSW5pdENhbGxiYWNrcy5nZXQobm9ybWFsaXplZElkZW50aWZpZXIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgU2V0KCk7XHJcbiAgICAgICAgZXhpc3RpbmdDYWxsYmFja3MuYWRkKGNhbGxiYWNrKTtcclxuICAgICAgICB0aGlzLm9uSW5pdENhbGxiYWNrcy5zZXQobm9ybWFsaXplZElkZW50aWZpZXIsIGV4aXN0aW5nQ2FsbGJhY2tzKTtcclxuICAgICAgICBjb25zdCBleGlzdGluZ0luc3RhbmNlID0gdGhpcy5pbnN0YW5jZXMuZ2V0KG5vcm1hbGl6ZWRJZGVudGlmaWVyKTtcclxuICAgICAgICBpZiAoZXhpc3RpbmdJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhleGlzdGluZ0luc3RhbmNlLCBub3JtYWxpemVkSWRlbnRpZmllcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGV4aXN0aW5nQ2FsbGJhY2tzLmRlbGV0ZShjYWxsYmFjayk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW52b2tlIG9uSW5pdCBjYWxsYmFja3Mgc3luY2hyb25vdXNseVxyXG4gICAgICogQHBhcmFtIGluc3RhbmNlIHRoZSBzZXJ2aWNlIGluc3RhbmNlYFxyXG4gICAgICovXHJcbiAgICBpbnZva2VPbkluaXRDYWxsYmFja3MoaW5zdGFuY2UsIGlkZW50aWZpZXIpIHtcclxuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLm9uSW5pdENhbGxiYWNrcy5nZXQoaWRlbnRpZmllcik7XHJcbiAgICAgICAgaWYgKCFjYWxsYmFja3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIGNhbGxiYWNrcykge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soaW5zdGFuY2UsIGlkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xyXG4gICAgICAgICAgICAgICAgLy8gaWdub3JlIGVycm9ycyBpbiB0aGUgb25Jbml0IGNhbGxiYWNrXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRPckluaXRpYWxpemVTZXJ2aWNlKHsgaW5zdGFuY2VJZGVudGlmaWVyLCBvcHRpb25zID0ge30gfSkge1xyXG4gICAgICAgIGxldCBpbnN0YW5jZSA9IHRoaXMuaW5zdGFuY2VzLmdldChpbnN0YW5jZUlkZW50aWZpZXIpO1xyXG4gICAgICAgIGlmICghaW5zdGFuY2UgJiYgdGhpcy5jb21wb25lbnQpIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UgPSB0aGlzLmNvbXBvbmVudC5pbnN0YW5jZUZhY3RvcnkodGhpcy5jb250YWluZXIsIHtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplSWRlbnRpZmllckZvckZhY3RvcnkoaW5zdGFuY2VJZGVudGlmaWVyKSxcclxuICAgICAgICAgICAgICAgIG9wdGlvbnNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2VzLnNldChpbnN0YW5jZUlkZW50aWZpZXIsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZXNPcHRpb25zLnNldChpbnN0YW5jZUlkZW50aWZpZXIsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW52b2tlIG9uSW5pdCBsaXN0ZW5lcnMuXHJcbiAgICAgICAgICAgICAqIE5vdGUgdGhpcy5jb21wb25lbnQub25JbnN0YW5jZUNyZWF0ZWQgaXMgZGlmZmVyZW50LCB3aGljaCBpcyB1c2VkIGJ5IHRoZSBjb21wb25lbnQgY3JlYXRvcixcclxuICAgICAgICAgICAgICogd2hpbGUgb25Jbml0IGxpc3RlbmVycyBhcmUgcmVnaXN0ZXJlZCBieSBjb25zdW1lcnMgb2YgdGhlIHByb3ZpZGVyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5pbnZva2VPbkluaXRDYWxsYmFja3MoaW5zdGFuY2UsIGluc3RhbmNlSWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBPcmRlciBpcyBpbXBvcnRhbnRcclxuICAgICAgICAgICAgICogb25JbnN0YW5jZUNyZWF0ZWQoKSBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIHRoaXMuaW5zdGFuY2VzLnNldChpbnN0YW5jZUlkZW50aWZpZXIsIGluc3RhbmNlKTsgd2hpY2hcclxuICAgICAgICAgICAgICogbWFrZXMgYGlzSW5pdGlhbGl6ZWQoKWAgcmV0dXJuIHRydWUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb21wb25lbnQub25JbnN0YW5jZUNyZWF0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnQub25JbnN0YW5jZUNyZWF0ZWQodGhpcy5jb250YWluZXIsIGluc3RhbmNlSWRlbnRpZmllciwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIGVycm9ycyBpbiB0aGUgb25JbnN0YW5jZUNyZWF0ZWRDYWxsYmFja1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbnN0YW5jZSB8fCBudWxsO1xyXG4gICAgfVxyXG4gICAgbm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKGlkZW50aWZpZXIgPSBERUZBVUxUX0VOVFJZX05BTUUpIHtcclxuICAgICAgICBpZiAodGhpcy5jb21wb25lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50Lm11bHRpcGxlSW5zdGFuY2VzID8gaWRlbnRpZmllciA6IERFRkFVTFRfRU5UUllfTkFNRTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpZGVudGlmaWVyOyAvLyBhc3N1bWUgbXVsdGlwbGUgaW5zdGFuY2VzIGFyZSBzdXBwb3J0ZWQgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgcHJvdmlkZWQuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2hvdWxkQXV0b0luaXRpYWxpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuICghIXRoaXMuY29tcG9uZW50ICYmXHJcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50Lmluc3RhbnRpYXRpb25Nb2RlICE9PSBcIkVYUExJQ0lUXCIgLyogSW5zdGFudGlhdGlvbk1vZGUuRVhQTElDSVQgKi8pO1xyXG4gICAgfVxyXG59XHJcbi8vIHVuZGVmaW5lZCBzaG91bGQgYmUgcGFzc2VkIHRvIHRoZSBzZXJ2aWNlIGZhY3RvcnkgZm9yIHRoZSBkZWZhdWx0IGluc3RhbmNlXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUlkZW50aWZpZXJGb3JGYWN0b3J5KGlkZW50aWZpZXIpIHtcclxuICAgIHJldHVybiBpZGVudGlmaWVyID09PSBERUZBVUxUX0VOVFJZX05BTUUgPyB1bmRlZmluZWQgOiBpZGVudGlmaWVyO1xyXG59XHJcbmZ1bmN0aW9uIGlzQ29tcG9uZW50RWFnZXIoY29tcG9uZW50KSB7XHJcbiAgICByZXR1cm4gY29tcG9uZW50Lmluc3RhbnRpYXRpb25Nb2RlID09PSBcIkVBR0VSXCIgLyogSW5zdGFudGlhdGlvbk1vZGUuRUFHRVIgKi87XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIENvbXBvbmVudENvbnRhaW5lciB0aGF0IHByb3ZpZGVzIFByb3ZpZGVycyBmb3Igc2VydmljZSBuYW1lIFQsIGUuZy4gYGF1dGhgLCBgYXV0aC1pbnRlcm5hbGBcclxuICovXHJcbmNsYXNzIENvbXBvbmVudENvbnRhaW5lciB7XHJcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycyA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb21wb25lbnQgQ29tcG9uZW50IGJlaW5nIGFkZGVkXHJcbiAgICAgKiBAcGFyYW0gb3ZlcndyaXRlIFdoZW4gYSBjb21wb25lbnQgd2l0aCB0aGUgc2FtZSBuYW1lIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCxcclxuICAgICAqIGlmIG92ZXJ3cml0ZSBpcyB0cnVlOiBvdmVyd3JpdGUgdGhlIGV4aXN0aW5nIGNvbXBvbmVudCB3aXRoIHRoZSBuZXcgY29tcG9uZW50IGFuZCBjcmVhdGUgYSBuZXdcclxuICAgICAqIHByb3ZpZGVyIHdpdGggdGhlIG5ldyBjb21wb25lbnQuIEl0IGNhbiBiZSB1c2VmdWwgaW4gdGVzdHMgd2hlcmUgeW91IHdhbnQgdG8gdXNlIGRpZmZlcmVudCBtb2Nrc1xyXG4gICAgICogZm9yIGRpZmZlcmVudCB0ZXN0cy5cclxuICAgICAqIGlmIG92ZXJ3cml0ZSBpcyBmYWxzZTogdGhyb3cgYW4gZXhjZXB0aW9uXHJcbiAgICAgKi9cclxuICAgIGFkZENvbXBvbmVudChjb21wb25lbnQpIHtcclxuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIoY29tcG9uZW50Lm5hbWUpO1xyXG4gICAgICAgIGlmIChwcm92aWRlci5pc0NvbXBvbmVudFNldCgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29tcG9uZW50ICR7Y29tcG9uZW50Lm5hbWV9IGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCB3aXRoICR7dGhpcy5uYW1lfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcm92aWRlci5zZXRDb21wb25lbnQoY29tcG9uZW50KTtcclxuICAgIH1cclxuICAgIGFkZE9yT3ZlcndyaXRlQ29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihjb21wb25lbnQubmFtZSk7XHJcbiAgICAgICAgaWYgKHByb3ZpZGVyLmlzQ29tcG9uZW50U2V0KCkpIHtcclxuICAgICAgICAgICAgLy8gZGVsZXRlIHRoZSBleGlzdGluZyBwcm92aWRlciBmcm9tIHRoZSBjb250YWluZXIsIHNvIHdlIGNhbiByZWdpc3RlciB0aGUgbmV3IGNvbXBvbmVudFxyXG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVycy5kZWxldGUoY29tcG9uZW50Lm5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFkZENvbXBvbmVudChjb21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBnZXRQcm92aWRlciBwcm92aWRlcyBhIHR5cGUgc2FmZSBpbnRlcmZhY2Ugd2hlcmUgaXQgY2FuIG9ubHkgYmUgY2FsbGVkIHdpdGggYSBmaWVsZCBuYW1lXHJcbiAgICAgKiBwcmVzZW50IGluIE5hbWVTZXJ2aWNlTWFwcGluZyBpbnRlcmZhY2UuXHJcbiAgICAgKlxyXG4gICAgICogRmlyZWJhc2UgU0RLcyBwcm92aWRpbmcgc2VydmljZXMgc2hvdWxkIGV4dGVuZCBOYW1lU2VydmljZU1hcHBpbmcgaW50ZXJmYWNlIHRvIHJlZ2lzdGVyXHJcbiAgICAgKiB0aGVtc2VsdmVzLlxyXG4gICAgICovXHJcbiAgICBnZXRQcm92aWRlcihuYW1lKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucHJvdmlkZXJzLmhhcyhuYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlcnMuZ2V0KG5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjcmVhdGUgYSBQcm92aWRlciBmb3IgYSBzZXJ2aWNlIHRoYXQgaGFzbid0IHJlZ2lzdGVyZWQgd2l0aCBGaXJlYmFzZVxyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IFByb3ZpZGVyKG5hbWUsIHRoaXMpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuYW1lLCBwcm92aWRlcik7XHJcbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyO1xyXG4gICAgfVxyXG4gICAgZ2V0UHJvdmlkZXJzKCkge1xyXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMucHJvdmlkZXJzLnZhbHVlcygpKTtcclxuICAgIH1cclxufVxuXG5leHBvcnQgeyBDb21wb25lbnQsIENvbXBvbmVudENvbnRhaW5lciwgUHJvdmlkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbTIwMTcuanMubWFwXG4iXSwibmFtZXMiOlsiRGVmZXJyZWQiLCJDb21wb25lbnQiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJpbnN0YW5jZUZhY3RvcnkiLCJ0eXBlIiwibXVsdGlwbGVJbnN0YW5jZXMiLCJzZXJ2aWNlUHJvcHMiLCJpbnN0YW50aWF0aW9uTW9kZSIsIm9uSW5zdGFuY2VDcmVhdGVkIiwic2V0SW5zdGFudGlhdGlvbk1vZGUiLCJtb2RlIiwic2V0TXVsdGlwbGVJbnN0YW5jZXMiLCJzZXRTZXJ2aWNlUHJvcHMiLCJwcm9wcyIsInNldEluc3RhbmNlQ3JlYXRlZENhbGxiYWNrIiwiY2FsbGJhY2siLCJERUZBVUxUX0VOVFJZX05BTUUiLCJQcm92aWRlciIsImNvbnRhaW5lciIsImNvbXBvbmVudCIsImluc3RhbmNlcyIsIk1hcCIsImluc3RhbmNlc0RlZmVycmVkIiwiaW5zdGFuY2VzT3B0aW9ucyIsIm9uSW5pdENhbGxiYWNrcyIsImdldCIsImlkZW50aWZpZXIiLCJub3JtYWxpemVkSWRlbnRpZmllciIsIm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllciIsImhhcyIsImRlZmVycmVkIiwic2V0IiwiaXNJbml0aWFsaXplZCIsInNob3VsZEF1dG9Jbml0aWFsaXplIiwiaW5zdGFuY2UiLCJnZXRPckluaXRpYWxpemVTZXJ2aWNlIiwiaW5zdGFuY2VJZGVudGlmaWVyIiwicmVzb2x2ZSIsImUiLCJwcm9taXNlIiwiZ2V0SW1tZWRpYXRlIiwib3B0aW9ucyIsIl9hIiwib3B0aW9uYWwiLCJFcnJvciIsImdldENvbXBvbmVudCIsInNldENvbXBvbmVudCIsImlzQ29tcG9uZW50RWFnZXIiLCJpbnN0YW5jZURlZmVycmVkIiwiZW50cmllcyIsImNsZWFySW5zdGFuY2UiLCJkZWxldGUiLCJzZXJ2aWNlcyIsIkFycmF5IiwiZnJvbSIsInZhbHVlcyIsIlByb21pc2UiLCJhbGwiLCJmaWx0ZXIiLCJzZXJ2aWNlIiwibWFwIiwiSU5URVJOQUwiLCJfZGVsZXRlIiwiaXNDb21wb25lbnRTZXQiLCJnZXRPcHRpb25zIiwiaW5pdGlhbGl6ZSIsIm9wdHMiLCJub3JtYWxpemVkRGVmZXJyZWRJZGVudGlmaWVyIiwib25Jbml0IiwiZXhpc3RpbmdDYWxsYmFja3MiLCJTZXQiLCJhZGQiLCJleGlzdGluZ0luc3RhbmNlIiwiaW52b2tlT25Jbml0Q2FsbGJhY2tzIiwiY2FsbGJhY2tzIiwibm9ybWFsaXplSWRlbnRpZmllckZvckZhY3RvcnkiLCJ1bmRlZmluZWQiLCJDb21wb25lbnRDb250YWluZXIiLCJwcm92aWRlcnMiLCJhZGRDb21wb25lbnQiLCJwcm92aWRlciIsImdldFByb3ZpZGVyIiwiYWRkT3JPdmVyd3JpdGVDb21wb25lbnQiLCJnZXRQcm92aWRlcnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/database-compat/dist/node-esm/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@firebase/database-compat/dist/node-esm/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _firebase_app_compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app-compat */ \"(ssr)/./node_modules/@firebase/app-compat/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_database__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/database */ \"(ssr)/./node_modules/@firebase/database/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @firebase/logger */ \"(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n\n\n\n\n\nconst name = \"@firebase/database-compat\";\nconst version = \"1.0.3\";\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const logClient = new _firebase_logger__WEBPACK_IMPORTED_MODULE_4__.Logger(\"@firebase/database-compat\");\nconst warn = function(msg) {\n    const message = \"FIREBASE WARNING: \" + msg;\n    logClient.warn(message);\n};\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const validateBoolean = function(fnName, argumentName, bool, optional) {\n    if (optional && bool === undefined) {\n        return;\n    }\n    if (typeof bool !== \"boolean\") {\n        throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.errorPrefix)(fnName, argumentName) + \"must be a boolean.\");\n    }\n};\nconst validateEventType = function(fnName, eventType, optional) {\n    if (optional && eventType === undefined) {\n        return;\n    }\n    switch(eventType){\n        case \"value\":\n        case \"child_added\":\n        case \"child_removed\":\n        case \"child_changed\":\n        case \"child_moved\":\n            break;\n        default:\n            throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.errorPrefix)(fnName, \"eventType\") + 'must be a valid event type = \"value\", \"child_added\", \"child_removed\", ' + '\"child_changed\", or \"child_moved\".');\n    }\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class OnDisconnect {\n    constructor(_delegate){\n        this._delegate = _delegate;\n    }\n    cancel(onComplete) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"OnDisconnect.cancel\", 0, 1, arguments.length);\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateCallback)(\"OnDisconnect.cancel\", \"onComplete\", onComplete, true);\n        const result = this._delegate.cancel();\n        if (onComplete) {\n            result.then(()=>onComplete(null), (error)=>onComplete(error));\n        }\n        return result;\n    }\n    remove(onComplete) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"OnDisconnect.remove\", 0, 1, arguments.length);\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateCallback)(\"OnDisconnect.remove\", \"onComplete\", onComplete, true);\n        const result = this._delegate.remove();\n        if (onComplete) {\n            result.then(()=>onComplete(null), (error)=>onComplete(error));\n        }\n        return result;\n    }\n    set(value, onComplete) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"OnDisconnect.set\", 1, 2, arguments.length);\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateCallback)(\"OnDisconnect.set\", \"onComplete\", onComplete, true);\n        const result = this._delegate.set(value);\n        if (onComplete) {\n            result.then(()=>onComplete(null), (error)=>onComplete(error));\n        }\n        return result;\n    }\n    setWithPriority(value, priority, onComplete) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"OnDisconnect.setWithPriority\", 2, 3, arguments.length);\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateCallback)(\"OnDisconnect.setWithPriority\", \"onComplete\", onComplete, true);\n        const result = this._delegate.setWithPriority(value, priority);\n        if (onComplete) {\n            result.then(()=>onComplete(null), (error)=>onComplete(error));\n        }\n        return result;\n    }\n    update(objectToMerge, onComplete) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"OnDisconnect.update\", 1, 2, arguments.length);\n        if (Array.isArray(objectToMerge)) {\n            const newObjectToMerge = {};\n            for(let i = 0; i < objectToMerge.length; ++i){\n                newObjectToMerge[\"\" + i] = objectToMerge[i];\n            }\n            objectToMerge = newObjectToMerge;\n            warn(\"Passing an Array to firebase.database.onDisconnect().update() is deprecated. Use set() if you want to overwrite the \" + \"existing data, or an Object with integer keys if you really do want to only update some of the children.\");\n        }\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateCallback)(\"OnDisconnect.update\", \"onComplete\", onComplete, true);\n        const result = this._delegate.update(objectToMerge);\n        if (onComplete) {\n            result.then(()=>onComplete(null), (error)=>onComplete(error));\n        }\n        return result;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class TransactionResult {\n    /**\r\n     * A type for the resolve value of Firebase.transaction.\r\n     */ constructor(committed, snapshot){\n        this.committed = committed;\n        this.snapshot = snapshot;\n    }\n    // Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary\n    // for end-users\n    toJSON() {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"TransactionResult.toJSON\", 0, 1, arguments.length);\n        return {\n            committed: this.committed,\n            snapshot: this.snapshot.toJSON()\n        };\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Class representing a firebase data snapshot.  It wraps a SnapshotNode and\r\n * surfaces the public methods (val, forEach, etc.) we want to expose.\r\n */ class DataSnapshot {\n    constructor(_database, _delegate){\n        this._database = _database;\n        this._delegate = _delegate;\n    }\n    /**\r\n     * Retrieves the snapshot contents as JSON.  Returns null if the snapshot is\r\n     * empty.\r\n     *\r\n     * @returns JSON representation of the DataSnapshot contents, or null if empty.\r\n     */ val() {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"DataSnapshot.val\", 0, 0, arguments.length);\n        return this._delegate.val();\n    }\n    /**\r\n     * Returns the snapshot contents as JSON, including priorities of node.  Suitable for exporting\r\n     * the entire node contents.\r\n     * @returns JSON representation of the DataSnapshot contents, or null if empty.\r\n     */ exportVal() {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"DataSnapshot.exportVal\", 0, 0, arguments.length);\n        return this._delegate.exportVal();\n    }\n    // Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary\n    // for end-users\n    toJSON() {\n        // Optional spacer argument is unnecessary because we're depending on recursion rather than stringifying the content\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"DataSnapshot.toJSON\", 0, 1, arguments.length);\n        return this._delegate.toJSON();\n    }\n    /**\r\n     * Returns whether the snapshot contains a non-null value.\r\n     *\r\n     * @returns Whether the snapshot contains a non-null value, or is empty.\r\n     */ exists() {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"DataSnapshot.exists\", 0, 0, arguments.length);\n        return this._delegate.exists();\n    }\n    /**\r\n     * Returns a DataSnapshot of the specified child node's contents.\r\n     *\r\n     * @param path - Path to a child.\r\n     * @returns DataSnapshot for child node.\r\n     */ child(path) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"DataSnapshot.child\", 0, 1, arguments.length);\n        // Ensure the childPath is a string (can be a number)\n        path = String(path);\n        (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__._validatePathString)(\"DataSnapshot.child\", \"path\", path, false);\n        return new DataSnapshot(this._database, this._delegate.child(path));\n    }\n    /**\r\n     * Returns whether the snapshot contains a child at the specified path.\r\n     *\r\n     * @param path - Path to a child.\r\n     * @returns Whether the child exists.\r\n     */ hasChild(path) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"DataSnapshot.hasChild\", 1, 1, arguments.length);\n        (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__._validatePathString)(\"DataSnapshot.hasChild\", \"path\", path, false);\n        return this._delegate.hasChild(path);\n    }\n    /**\r\n     * Returns the priority of the object, or null if no priority was set.\r\n     *\r\n     * @returns The priority.\r\n     */ getPriority() {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"DataSnapshot.getPriority\", 0, 0, arguments.length);\n        return this._delegate.priority;\n    }\n    /**\r\n     * Iterates through child nodes and calls the specified action for each one.\r\n     *\r\n     * @param action - Callback function to be called\r\n     * for each child.\r\n     * @returns True if forEach was canceled by action returning true for\r\n     * one of the child nodes.\r\n     */ forEach(action) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"DataSnapshot.forEach\", 1, 1, arguments.length);\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateCallback)(\"DataSnapshot.forEach\", \"action\", action, false);\n        return this._delegate.forEach((expDataSnapshot)=>action(new DataSnapshot(this._database, expDataSnapshot)));\n    }\n    /**\r\n     * Returns whether this DataSnapshot has children.\r\n     * @returns True if the DataSnapshot contains 1 or more child nodes.\r\n     */ hasChildren() {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"DataSnapshot.hasChildren\", 0, 0, arguments.length);\n        return this._delegate.hasChildren();\n    }\n    get key() {\n        return this._delegate.key;\n    }\n    /**\r\n     * Returns the number of children for this DataSnapshot.\r\n     * @returns The number of children that this DataSnapshot contains.\r\n     */ numChildren() {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"DataSnapshot.numChildren\", 0, 0, arguments.length);\n        return this._delegate.size;\n    }\n    /**\r\n     * @returns The Firebase reference for the location this snapshot's data came\r\n     * from.\r\n     */ getRef() {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"DataSnapshot.ref\", 0, 0, arguments.length);\n        return new Reference(this._database, this._delegate.ref);\n    }\n    get ref() {\n        return this.getRef();\n    }\n}\n/**\r\n * A Query represents a filter to be applied to a firebase location.  This object purely represents the\r\n * query expression (and exposes our public API to build the query).  The actual query logic is in ViewBase.js.\r\n *\r\n * Since every Firebase reference is a query, Firebase inherits from this object.\r\n */ class Query {\n    constructor(database, _delegate){\n        this.database = database;\n        this._delegate = _delegate;\n    }\n    on(eventType, callback, cancelCallbackOrContext, context) {\n        var _a;\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"Query.on\", 2, 4, arguments.length);\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateCallback)(\"Query.on\", \"callback\", callback, false);\n        const ret = Query.getCancelAndContextArgs_(\"Query.on\", cancelCallbackOrContext, context);\n        const valueCallback = (expSnapshot, previousChildName)=>{\n            callback.call(ret.context, new DataSnapshot(this.database, expSnapshot), previousChildName);\n        };\n        valueCallback.userCallback = callback;\n        valueCallback.context = ret.context;\n        const cancelCallback = (_a = ret.cancel) === null || _a === void 0 ? void 0 : _a.bind(ret.context);\n        switch(eventType){\n            case \"value\":\n                (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.onValue)(this._delegate, valueCallback, cancelCallback);\n                return callback;\n            case \"child_added\":\n                (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.onChildAdded)(this._delegate, valueCallback, cancelCallback);\n                return callback;\n            case \"child_removed\":\n                (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.onChildRemoved)(this._delegate, valueCallback, cancelCallback);\n                return callback;\n            case \"child_changed\":\n                (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.onChildChanged)(this._delegate, valueCallback, cancelCallback);\n                return callback;\n            case \"child_moved\":\n                (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.onChildMoved)(this._delegate, valueCallback, cancelCallback);\n                return callback;\n            default:\n                throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.errorPrefix)(\"Query.on\", \"eventType\") + 'must be a valid event type = \"value\", \"child_added\", \"child_removed\", ' + '\"child_changed\", or \"child_moved\".');\n        }\n    }\n    off(eventType, callback, context) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"Query.off\", 0, 3, arguments.length);\n        validateEventType(\"Query.off\", eventType, true);\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateCallback)(\"Query.off\", \"callback\", callback, true);\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateContextObject)(\"Query.off\", \"context\", context, true);\n        if (callback) {\n            const valueCallback = ()=>{};\n            valueCallback.userCallback = callback;\n            valueCallback.context = context;\n            (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.off)(this._delegate, eventType, valueCallback);\n        } else {\n            (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.off)(this._delegate, eventType);\n        }\n    }\n    /**\r\n     * Get the server-value for this query, or return a cached value if not connected.\r\n     */ get() {\n        return (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.get)(this._delegate).then((expSnapshot)=>{\n            return new DataSnapshot(this.database, expSnapshot);\n        });\n    }\n    /**\r\n     * Attaches a listener, waits for the first event, and then removes the listener\r\n     */ once(eventType, callback, failureCallbackOrContext, context) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"Query.once\", 1, 4, arguments.length);\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateCallback)(\"Query.once\", \"callback\", callback, true);\n        const ret = Query.getCancelAndContextArgs_(\"Query.once\", failureCallbackOrContext, context);\n        const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_3__.Deferred();\n        const valueCallback = (expSnapshot, previousChildName)=>{\n            const result = new DataSnapshot(this.database, expSnapshot);\n            if (callback) {\n                callback.call(ret.context, result, previousChildName);\n            }\n            deferred.resolve(result);\n        };\n        valueCallback.userCallback = callback;\n        valueCallback.context = ret.context;\n        const cancelCallback = (error)=>{\n            if (ret.cancel) {\n                ret.cancel.call(ret.context, error);\n            }\n            deferred.reject(error);\n        };\n        switch(eventType){\n            case \"value\":\n                (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.onValue)(this._delegate, valueCallback, cancelCallback, {\n                    onlyOnce: true\n                });\n                break;\n            case \"child_added\":\n                (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.onChildAdded)(this._delegate, valueCallback, cancelCallback, {\n                    onlyOnce: true\n                });\n                break;\n            case \"child_removed\":\n                (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.onChildRemoved)(this._delegate, valueCallback, cancelCallback, {\n                    onlyOnce: true\n                });\n                break;\n            case \"child_changed\":\n                (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.onChildChanged)(this._delegate, valueCallback, cancelCallback, {\n                    onlyOnce: true\n                });\n                break;\n            case \"child_moved\":\n                (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.onChildMoved)(this._delegate, valueCallback, cancelCallback, {\n                    onlyOnce: true\n                });\n                break;\n            default:\n                throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.errorPrefix)(\"Query.once\", \"eventType\") + 'must be a valid event type = \"value\", \"child_added\", \"child_removed\", ' + '\"child_changed\", or \"child_moved\".');\n        }\n        return deferred.promise;\n    }\n    /**\r\n     * Set a limit and anchor it to the start of the window.\r\n     */ limitToFirst(limit) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"Query.limitToFirst\", 1, 1, arguments.length);\n        return new Query(this.database, (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.query)(this._delegate, (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.limitToFirst)(limit)));\n    }\n    /**\r\n     * Set a limit and anchor it to the end of the window.\r\n     */ limitToLast(limit) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"Query.limitToLast\", 1, 1, arguments.length);\n        return new Query(this.database, (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.query)(this._delegate, (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.limitToLast)(limit)));\n    }\n    /**\r\n     * Given a child path, return a new query ordered by the specified grandchild path.\r\n     */ orderByChild(path) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"Query.orderByChild\", 1, 1, arguments.length);\n        return new Query(this.database, (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.query)(this._delegate, (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.orderByChild)(path)));\n    }\n    /**\r\n     * Return a new query ordered by the KeyIndex\r\n     */ orderByKey() {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"Query.orderByKey\", 0, 0, arguments.length);\n        return new Query(this.database, (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.query)(this._delegate, (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.orderByKey)()));\n    }\n    /**\r\n     * Return a new query ordered by the PriorityIndex\r\n     */ orderByPriority() {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"Query.orderByPriority\", 0, 0, arguments.length);\n        return new Query(this.database, (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.query)(this._delegate, (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.orderByPriority)()));\n    }\n    /**\r\n     * Return a new query ordered by the ValueIndex\r\n     */ orderByValue() {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"Query.orderByValue\", 0, 0, arguments.length);\n        return new Query(this.database, (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.query)(this._delegate, (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.orderByValue)()));\n    }\n    startAt(value = null, name) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"Query.startAt\", 0, 2, arguments.length);\n        return new Query(this.database, (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.query)(this._delegate, (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.startAt)(value, name)));\n    }\n    startAfter(value = null, name) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"Query.startAfter\", 0, 2, arguments.length);\n        return new Query(this.database, (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.query)(this._delegate, (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.startAfter)(value, name)));\n    }\n    endAt(value = null, name) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"Query.endAt\", 0, 2, arguments.length);\n        return new Query(this.database, (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.query)(this._delegate, (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.endAt)(value, name)));\n    }\n    endBefore(value = null, name) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"Query.endBefore\", 0, 2, arguments.length);\n        return new Query(this.database, (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.query)(this._delegate, (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.endBefore)(value, name)));\n    }\n    /**\r\n     * Load the selection of children with exactly the specified value, and, optionally,\r\n     * the specified name.\r\n     */ equalTo(value, name) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"Query.equalTo\", 1, 2, arguments.length);\n        return new Query(this.database, (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.query)(this._delegate, (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.equalTo)(value, name)));\n    }\n    /**\r\n     * @returns URL for this location.\r\n     */ toString() {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"Query.toString\", 0, 0, arguments.length);\n        return this._delegate.toString();\n    }\n    // Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary\n    // for end-users.\n    toJSON() {\n        // An optional spacer argument is unnecessary for a string.\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"Query.toJSON\", 0, 1, arguments.length);\n        return this._delegate.toJSON();\n    }\n    /**\r\n     * Return true if this query and the provided query are equivalent; otherwise, return false.\r\n     */ isEqual(other) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"Query.isEqual\", 1, 1, arguments.length);\n        if (!(other instanceof Query)) {\n            const error = \"Query.isEqual failed: First argument must be an instance of firebase.database.Query.\";\n            throw new Error(error);\n        }\n        return this._delegate.isEqual(other._delegate);\n    }\n    /**\r\n     * Helper used by .on and .once to extract the context and or cancel arguments.\r\n     * @param fnName - The function name (on or once)\r\n     *\r\n     */ static getCancelAndContextArgs_(fnName, cancelOrContext, context) {\n        const ret = {\n            cancel: undefined,\n            context: undefined\n        };\n        if (cancelOrContext && context) {\n            ret.cancel = cancelOrContext;\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateCallback)(fnName, \"cancel\", ret.cancel, true);\n            ret.context = context;\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateContextObject)(fnName, \"context\", ret.context, true);\n        } else if (cancelOrContext) {\n            // we have either a cancel callback or a context.\n            if (typeof cancelOrContext === \"object\" && cancelOrContext !== null) {\n                // it's a context!\n                ret.context = cancelOrContext;\n            } else if (typeof cancelOrContext === \"function\") {\n                ret.cancel = cancelOrContext;\n            } else {\n                throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.errorPrefix)(fnName, \"cancelOrContext\") + \" must either be a cancel callback or a context object.\");\n            }\n        }\n        return ret;\n    }\n    get ref() {\n        return new Reference(this.database, new _firebase_database__WEBPACK_IMPORTED_MODULE_2__._ReferenceImpl(this._delegate._repo, this._delegate._path));\n    }\n}\nclass Reference extends Query {\n    /**\r\n     * Call options:\r\n     *   new Reference(Repo, Path) or\r\n     *   new Reference(url: string, string|RepoManager)\r\n     *\r\n     * Externally - this is the firebase.database.Reference type.\r\n     */ constructor(database, _delegate){\n        super(database, new _firebase_database__WEBPACK_IMPORTED_MODULE_2__._QueryImpl(_delegate._repo, _delegate._path, new _firebase_database__WEBPACK_IMPORTED_MODULE_2__._QueryParams(), false));\n        this.database = database;\n        this._delegate = _delegate;\n    }\n    /** @returns {?string} */ getKey() {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"Reference.key\", 0, 0, arguments.length);\n        return this._delegate.key;\n    }\n    child(pathString) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"Reference.child\", 1, 1, arguments.length);\n        if (typeof pathString === \"number\") {\n            pathString = String(pathString);\n        }\n        return new Reference(this.database, (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.child)(this._delegate, pathString));\n    }\n    /** @returns {?Reference} */ getParent() {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"Reference.parent\", 0, 0, arguments.length);\n        const parent = this._delegate.parent;\n        return parent ? new Reference(this.database, parent) : null;\n    }\n    /** @returns {!Reference} */ getRoot() {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"Reference.root\", 0, 0, arguments.length);\n        return new Reference(this.database, this._delegate.root);\n    }\n    set(newVal, onComplete) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"Reference.set\", 1, 2, arguments.length);\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateCallback)(\"Reference.set\", \"onComplete\", onComplete, true);\n        const result = (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.set)(this._delegate, newVal);\n        if (onComplete) {\n            result.then(()=>onComplete(null), (error)=>onComplete(error));\n        }\n        return result;\n    }\n    update(values, onComplete) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"Reference.update\", 1, 2, arguments.length);\n        if (Array.isArray(values)) {\n            const newObjectToMerge = {};\n            for(let i = 0; i < values.length; ++i){\n                newObjectToMerge[\"\" + i] = values[i];\n            }\n            values = newObjectToMerge;\n            warn(\"Passing an Array to Firebase.update() is deprecated. \" + \"Use set() if you want to overwrite the existing data, or \" + \"an Object with integer keys if you really do want to \" + \"only update some of the children.\");\n        }\n        (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__._validateWritablePath)(\"Reference.update\", this._delegate._path);\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateCallback)(\"Reference.update\", \"onComplete\", onComplete, true);\n        const result = (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.update)(this._delegate, values);\n        if (onComplete) {\n            result.then(()=>onComplete(null), (error)=>onComplete(error));\n        }\n        return result;\n    }\n    setWithPriority(newVal, newPriority, onComplete) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"Reference.setWithPriority\", 2, 3, arguments.length);\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateCallback)(\"Reference.setWithPriority\", \"onComplete\", onComplete, true);\n        const result = (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.setWithPriority)(this._delegate, newVal, newPriority);\n        if (onComplete) {\n            result.then(()=>onComplete(null), (error)=>onComplete(error));\n        }\n        return result;\n    }\n    remove(onComplete) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"Reference.remove\", 0, 1, arguments.length);\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateCallback)(\"Reference.remove\", \"onComplete\", onComplete, true);\n        const result = (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.remove)(this._delegate);\n        if (onComplete) {\n            result.then(()=>onComplete(null), (error)=>onComplete(error));\n        }\n        return result;\n    }\n    transaction(transactionUpdate, onComplete, applyLocally) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"Reference.transaction\", 1, 3, arguments.length);\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateCallback)(\"Reference.transaction\", \"transactionUpdate\", transactionUpdate, false);\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateCallback)(\"Reference.transaction\", \"onComplete\", onComplete, true);\n        validateBoolean(\"Reference.transaction\", \"applyLocally\", applyLocally, true);\n        const result = (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.runTransaction)(this._delegate, transactionUpdate, {\n            applyLocally\n        }).then((transactionResult)=>new TransactionResult(transactionResult.committed, new DataSnapshot(this.database, transactionResult.snapshot)));\n        if (onComplete) {\n            result.then((transactionResult)=>onComplete(null, transactionResult.committed, transactionResult.snapshot), (error)=>onComplete(error, false, null));\n        }\n        return result;\n    }\n    setPriority(priority, onComplete) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"Reference.setPriority\", 1, 2, arguments.length);\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateCallback)(\"Reference.setPriority\", \"onComplete\", onComplete, true);\n        const result = (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.setPriority)(this._delegate, priority);\n        if (onComplete) {\n            result.then(()=>onComplete(null), (error)=>onComplete(error));\n        }\n        return result;\n    }\n    push(value, onComplete) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"Reference.push\", 0, 2, arguments.length);\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateCallback)(\"Reference.push\", \"onComplete\", onComplete, true);\n        const expPromise = (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.push)(this._delegate, value);\n        const promise = expPromise.then((expRef)=>new Reference(this.database, expRef));\n        if (onComplete) {\n            promise.then(()=>onComplete(null), (error)=>onComplete(error));\n        }\n        const result = new Reference(this.database, expPromise);\n        result.then = promise.then.bind(promise);\n        result.catch = promise.catch.bind(promise, undefined);\n        return result;\n    }\n    onDisconnect() {\n        (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__._validateWritablePath)(\"Reference.onDisconnect\", this._delegate._path);\n        return new OnDisconnect(new _firebase_database__WEBPACK_IMPORTED_MODULE_2__.OnDisconnect(this._delegate._repo, this._delegate._path));\n    }\n    get key() {\n        return this.getKey();\n    }\n    get parent() {\n        return this.getParent();\n    }\n    get root() {\n        return this.getRoot();\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Class representing a firebase database.\r\n */ class Database {\n    /**\r\n     * The constructor should not be called by users of our public API.\r\n     */ constructor(_delegate, app){\n        this._delegate = _delegate;\n        this.app = app;\n        this.INTERNAL = {\n            delete: ()=>this._delegate._delete(),\n            forceWebSockets: _firebase_database__WEBPACK_IMPORTED_MODULE_2__.forceWebSockets,\n            forceLongPolling: _firebase_database__WEBPACK_IMPORTED_MODULE_2__.forceLongPolling\n        };\n    }\n    /**\r\n     * Modify this instance to communicate with the Realtime Database emulator.\r\n     *\r\n     * <p>Note: This method must be called before performing any other operation.\r\n     *\r\n     * @param host - the emulator host (ex: localhost)\r\n     * @param port - the emulator port (ex: 8080)\r\n     * @param options.mockUserToken - the mock auth token to use for unit testing Security Rules\r\n     */ useEmulator(host, port, options = {}) {\n        (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.connectDatabaseEmulator)(this._delegate, host, port, options);\n    }\n    ref(path) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"database.ref\", 0, 1, arguments.length);\n        if (path instanceof Reference) {\n            const childRef = (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.refFromURL)(this._delegate, path.toString());\n            return new Reference(this, childRef);\n        } else {\n            const childRef = (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.ref)(this._delegate, path);\n            return new Reference(this, childRef);\n        }\n    }\n    /**\r\n     * Returns a reference to the root or the path specified in url.\r\n     * We throw a exception if the url is not in the same domain as the\r\n     * current repo.\r\n     * @returns Firebase reference.\r\n     */ refFromURL(url) {\n        const apiName = \"database.refFromURL\";\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(apiName, 1, 1, arguments.length);\n        const childRef = (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.refFromURL)(this._delegate, url);\n        return new Reference(this, childRef);\n    }\n    // Make individual repo go offline.\n    goOffline() {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"database.goOffline\", 0, 0, arguments.length);\n        return (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.goOffline)(this._delegate);\n    }\n    goOnline() {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_3__.validateArgCount)(\"database.goOnline\", 0, 0, arguments.length);\n        return (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.goOnline)(this._delegate);\n    }\n}\nDatabase.ServerValue = {\n    TIMESTAMP: (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.serverTimestamp)(),\n    increment: (delta)=>(0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__.increment)(delta)\n};\n/**\r\n * Used by console to create a database based on the app,\r\n * passed database URL and a custom auth implementation.\r\n *\r\n * @param app - A valid FirebaseApp-like object\r\n * @param url - A valid Firebase databaseURL\r\n * @param version - custom version e.g. firebase-admin version\r\n * @param customAuthImpl - custom auth implementation\r\n */ function initStandalone({ app, url, version, customAuthImpl, customAppCheckImpl, namespace, nodeAdmin = false }) {\n    (0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__._setSDKVersion)(version);\n    const container = new _firebase_component__WEBPACK_IMPORTED_MODULE_1__.ComponentContainer(\"database-standalone\");\n    /**\r\n     * ComponentContainer('database-standalone') is just a placeholder that doesn't perform\r\n     * any actual function.\r\n     */ const authProvider = new _firebase_component__WEBPACK_IMPORTED_MODULE_1__.Provider(\"auth-internal\", container);\n    authProvider.setComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_1__.Component(\"auth-internal\", ()=>customAuthImpl, \"PRIVATE\" /* ComponentType.PRIVATE */ ));\n    let appCheckProvider = undefined;\n    if (customAppCheckImpl) {\n        appCheckProvider = new _firebase_component__WEBPACK_IMPORTED_MODULE_1__.Provider(\"app-check-internal\", container);\n        appCheckProvider.setComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_1__.Component(\"app-check-internal\", ()=>customAppCheckImpl, \"PRIVATE\" /* ComponentType.PRIVATE */ ));\n    }\n    return {\n        instance: new Database((0,_firebase_database__WEBPACK_IMPORTED_MODULE_2__._repoManagerDatabaseFromApp)(app, authProvider, appCheckProvider, url, nodeAdmin), app),\n        namespace\n    };\n}\nvar INTERNAL = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    initStandalone: initStandalone\n});\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const ServerValue = Database.ServerValue;\nfunction registerDatabase(instance) {\n    // Register the Database Service with the 'firebase' namespace.\n    instance.INTERNAL.registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_1__.Component(\"database-compat\", (container, { instanceIdentifier: url })=>{\n        /* Dependencies */ // getImmediate for FirebaseApp will always succeed\n        const app = container.getProvider(\"app-compat\").getImmediate();\n        const databaseExp = container.getProvider(\"database\").getImmediate({\n            identifier: url\n        });\n        return new Database(databaseExp, app);\n    }, \"PUBLIC\" /* ComponentType.PUBLIC */ ).setServiceProps(// firebase.database namespace properties\n    {\n        Reference,\n        Query,\n        Database,\n        DataSnapshot,\n        enableLogging: _firebase_database__WEBPACK_IMPORTED_MODULE_2__.enableLogging,\n        INTERNAL,\n        ServerValue\n    }).setMultipleInstances(true));\n    instance.registerVersion(name, version, \"node\");\n}\nregisterDatabase(_firebase_app_compat__WEBPACK_IMPORTED_MODULE_0__[\"default\"]); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlLWNvbXBhdC9kaXN0L25vZGUtZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE0QztBQUNrQztBQUNnakI7QUFDNWdCO0FBQ3hFO0FBRTFDLE1BQU13RCxPQUFPO0FBQ2IsTUFBTUMsVUFBVTtBQUVoQjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRCxNQUFNQyxZQUFZLElBQUlILG9EQUFNQSxDQUFDO0FBQzdCLE1BQU1JLE9BQU8sU0FBVUMsR0FBRztJQUN0QixNQUFNQyxVQUFVLHVCQUF1QkQ7SUFDdkNGLFVBQVVDLElBQUksQ0FBQ0U7QUFDbkI7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRCxNQUFNQyxrQkFBa0IsU0FBVUMsTUFBTSxFQUFFQyxZQUFZLEVBQUVDLElBQUksRUFBRUMsUUFBUTtJQUNsRSxJQUFJQSxZQUFZRCxTQUFTRSxXQUFXO1FBQ2hDO0lBQ0o7SUFDQSxJQUFJLE9BQU9GLFNBQVMsV0FBVztRQUMzQixNQUFNLElBQUlHLE1BQU1sQiwyREFBV0EsQ0FBQ2EsUUFBUUMsZ0JBQWdCO0lBQ3hEO0FBQ0o7QUFDQSxNQUFNSyxvQkFBb0IsU0FBVU4sTUFBTSxFQUFFTyxTQUFTLEVBQUVKLFFBQVE7SUFDM0QsSUFBSUEsWUFBWUksY0FBY0gsV0FBVztRQUNyQztJQUNKO0lBQ0EsT0FBUUc7UUFDSixLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNEO1FBQ0o7WUFDSSxNQUFNLElBQUlGLE1BQU1sQiwyREFBV0EsQ0FBQ2EsUUFBUSxlQUNoQywyRUFDQTtJQUNaO0FBQ0o7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRCxNQUFNM0I7SUFDRm1DLFlBQVlDLFNBQVMsQ0FBRTtRQUNuQixJQUFJLENBQUNBLFNBQVMsR0FBR0E7SUFDckI7SUFDQUMsT0FBT0MsVUFBVSxFQUFFO1FBQ2Z2QixnRUFBZ0JBLENBQUMsdUJBQXVCLEdB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QUF5QztJQUN6QztRQUNJbkY7UUFDQUM7UUFDQStDO1FBQ0FqRTtRQUNBMUMsYUFBYUEsK0RBQUFBO1FBQ2I2RztRQUNBVTtJQUNKLEdBQ0t3QixvQkFBb0IsQ0FBQztJQUMxQlosU0FBU2EsZUFBZSxDQUFDekksTUFBTUMsU0FBUztBQUM1QztBQUNBK0gsaUJBQWlCeEwsNERBQVFBLEdBQ3pCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dvcmxkd2ViLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS1jb21wYXQvZGlzdC9ub2RlLWVzbS9pbmRleC5qcz82MTgwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmaXJlYmFzZSBmcm9tICdAZmlyZWJhc2UvYXBwLWNvbXBhdCc7XG5pbXBvcnQgeyBDb21wb25lbnRDb250YWluZXIsIFByb3ZpZGVyLCBDb21wb25lbnQgfSBmcm9tICdAZmlyZWJhc2UvY29tcG9uZW50JztcbmltcG9ydCB7IF92YWxpZGF0ZVBhdGhTdHJpbmcsIG9uQ2hpbGRNb3ZlZCwgb25DaGlsZENoYW5nZWQsIG9uQ2hpbGRSZW1vdmVkLCBvbkNoaWxkQWRkZWQsIG9uVmFsdWUsIG9mZiwgZ2V0LCBxdWVyeSwgbGltaXRUb0ZpcnN0LCBsaW1pdFRvTGFzdCwgb3JkZXJCeUNoaWxkLCBvcmRlckJ5S2V5LCBvcmRlckJ5UHJpb3JpdHksIG9yZGVyQnlWYWx1ZSwgc3RhcnRBdCwgc3RhcnRBZnRlciwgZW5kQXQsIGVuZEJlZm9yZSwgZXF1YWxUbywgX1JlZmVyZW5jZUltcGwsIF9RdWVyeUltcGwsIF9RdWVyeVBhcmFtcywgY2hpbGQsIHNldCwgX3ZhbGlkYXRlV3JpdGFibGVQYXRoLCB1cGRhdGUsIHNldFdpdGhQcmlvcml0eSwgcmVtb3ZlLCBydW5UcmFuc2FjdGlvbiwgc2V0UHJpb3JpdHksIHB1c2gsIE9uRGlzY29ubmVjdCBhcyBPbkRpc2Nvbm5lY3QkMSwgZm9yY2VXZWJTb2NrZXRzLCBmb3JjZUxvbmdQb2xsaW5nLCBjb25uZWN0RGF0YWJhc2VFbXVsYXRvciwgcmVmRnJvbVVSTCwgcmVmLCBnb09mZmxpbmUsIGdvT25saW5lLCBzZXJ2ZXJUaW1lc3RhbXAsIGluY3JlbWVudCwgX3NldFNES1ZlcnNpb24sIF9yZXBvTWFuYWdlckRhdGFiYXNlRnJvbUFwcCwgZW5hYmxlTG9nZ2luZyB9IGZyb20gJ0BmaXJlYmFzZS9kYXRhYmFzZSc7XG5pbXBvcnQgeyBlcnJvclByZWZpeCwgdmFsaWRhdGVBcmdDb3VudCwgdmFsaWRhdGVDYWxsYmFjaywgdmFsaWRhdGVDb250ZXh0T2JqZWN0LCBEZWZlcnJlZCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJ0BmaXJlYmFzZS9sb2dnZXInO1xuXG5jb25zdCBuYW1lID0gXCJAZmlyZWJhc2UvZGF0YWJhc2UtY29tcGF0XCI7XG5jb25zdCB2ZXJzaW9uID0gXCIxLjAuM1wiO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBsb2dDbGllbnQgPSBuZXcgTG9nZ2VyKCdAZmlyZWJhc2UvZGF0YWJhc2UtY29tcGF0Jyk7XHJcbmNvbnN0IHdhcm4gPSBmdW5jdGlvbiAobXNnKSB7XHJcbiAgICBjb25zdCBtZXNzYWdlID0gJ0ZJUkVCQVNFIFdBUk5JTkc6ICcgKyBtc2c7XHJcbiAgICBsb2dDbGllbnQud2FybihtZXNzYWdlKTtcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgdmFsaWRhdGVCb29sZWFuID0gZnVuY3Rpb24gKGZuTmFtZSwgYXJndW1lbnROYW1lLCBib29sLCBvcHRpb25hbCkge1xyXG4gICAgaWYgKG9wdGlvbmFsICYmIGJvb2wgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgYm9vbCAhPT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4KGZuTmFtZSwgYXJndW1lbnROYW1lKSArICdtdXN0IGJlIGEgYm9vbGVhbi4nKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgdmFsaWRhdGVFdmVudFR5cGUgPSBmdW5jdGlvbiAoZm5OYW1lLCBldmVudFR5cGUsIG9wdGlvbmFsKSB7XHJcbiAgICBpZiAob3B0aW9uYWwgJiYgZXZlbnRUeXBlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBzd2l0Y2ggKGV2ZW50VHlwZSkge1xyXG4gICAgICAgIGNhc2UgJ3ZhbHVlJzpcclxuICAgICAgICBjYXNlICdjaGlsZF9hZGRlZCc6XHJcbiAgICAgICAgY2FzZSAnY2hpbGRfcmVtb3ZlZCc6XHJcbiAgICAgICAgY2FzZSAnY2hpbGRfY2hhbmdlZCc6XHJcbiAgICAgICAgY2FzZSAnY2hpbGRfbW92ZWQnOlxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoZm5OYW1lLCAnZXZlbnRUeXBlJykgK1xyXG4gICAgICAgICAgICAgICAgJ211c3QgYmUgYSB2YWxpZCBldmVudCB0eXBlID0gXCJ2YWx1ZVwiLCBcImNoaWxkX2FkZGVkXCIsIFwiY2hpbGRfcmVtb3ZlZFwiLCAnICtcclxuICAgICAgICAgICAgICAgICdcImNoaWxkX2NoYW5nZWRcIiwgb3IgXCJjaGlsZF9tb3ZlZFwiLicpO1xyXG4gICAgfVxyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBPbkRpc2Nvbm5lY3Qge1xyXG4gICAgY29uc3RydWN0b3IoX2RlbGVnYXRlKSB7XHJcbiAgICAgICAgdGhpcy5fZGVsZWdhdGUgPSBfZGVsZWdhdGU7XHJcbiAgICB9XHJcbiAgICBjYW5jZWwob25Db21wbGV0ZSkge1xyXG4gICAgICAgIHZhbGlkYXRlQXJnQ291bnQoJ09uRGlzY29ubmVjdC5jYW5jZWwnLCAwLCAxLCBhcmd1bWVudHMubGVuZ3RoKTtcclxuICAgICAgICB2YWxpZGF0ZUNhbGxiYWNrKCdPbkRpc2Nvbm5lY3QuY2FuY2VsJywgJ29uQ29tcGxldGUnLCBvbkNvbXBsZXRlLCB0cnVlKTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9kZWxlZ2F0ZS5jYW5jZWwoKTtcclxuICAgICAgICBpZiAob25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICByZXN1bHQudGhlbigoKSA9PiBvbkNvbXBsZXRlKG51bGwpLCBlcnJvciA9PiBvbkNvbXBsZXRlKGVycm9yKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICByZW1vdmUob25Db21wbGV0ZSkge1xyXG4gICAgICAgIHZhbGlkYXRlQXJnQ291bnQoJ09uRGlzY29ubmVjdC5yZW1vdmUnLCAwLCAxLCBhcmd1bWVudHMubGVuZ3RoKTtcclxuICAgICAgICB2YWxpZGF0ZUNhbGxiYWNrKCdPbkRpc2Nvbm5lY3QucmVtb3ZlJywgJ29uQ29tcGxldGUnLCBvbkNvbXBsZXRlLCB0cnVlKTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9kZWxlZ2F0ZS5yZW1vdmUoKTtcclxuICAgICAgICBpZiAob25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICByZXN1bHQudGhlbigoKSA9PiBvbkNvbXBsZXRlKG51bGwpLCBlcnJvciA9PiBvbkNvbXBsZXRlKGVycm9yKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBzZXQodmFsdWUsIG9uQ29tcGxldGUpIHtcclxuICAgICAgICB2YWxpZGF0ZUFyZ0NvdW50KCdPbkRpc2Nvbm5lY3Quc2V0JywgMSwgMiwgYXJndW1lbnRzLmxlbmd0aCk7XHJcbiAgICAgICAgdmFsaWRhdGVDYWxsYmFjaygnT25EaXNjb25uZWN0LnNldCcsICdvbkNvbXBsZXRlJywgb25Db21wbGV0ZSwgdHJ1ZSk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fZGVsZWdhdGUuc2V0KHZhbHVlKTtcclxuICAgICAgICBpZiAob25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICByZXN1bHQudGhlbigoKSA9PiBvbkNvbXBsZXRlKG51bGwpLCBlcnJvciA9PiBvbkNvbXBsZXRlKGVycm9yKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBzZXRXaXRoUHJpb3JpdHkodmFsdWUsIHByaW9yaXR5LCBvbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnT25EaXNjb25uZWN0LnNldFdpdGhQcmlvcml0eScsIDIsIDMsIGFyZ3VtZW50cy5sZW5ndGgpO1xyXG4gICAgICAgIHZhbGlkYXRlQ2FsbGJhY2soJ09uRGlzY29ubmVjdC5zZXRXaXRoUHJpb3JpdHknLCAnb25Db21wbGV0ZScsIG9uQ29tcGxldGUsIHRydWUpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2RlbGVnYXRlLnNldFdpdGhQcmlvcml0eSh2YWx1ZSwgcHJpb3JpdHkpO1xyXG4gICAgICAgIGlmIChvbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC50aGVuKCgpID0+IG9uQ29tcGxldGUobnVsbCksIGVycm9yID0+IG9uQ29tcGxldGUoZXJyb3IpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHVwZGF0ZShvYmplY3RUb01lcmdlLCBvbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnT25EaXNjb25uZWN0LnVwZGF0ZScsIDEsIDIsIGFyZ3VtZW50cy5sZW5ndGgpO1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdFRvTWVyZ2UpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld09iamVjdFRvTWVyZ2UgPSB7fTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmplY3RUb01lcmdlLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdPYmplY3RUb01lcmdlWycnICsgaV0gPSBvYmplY3RUb01lcmdlW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9iamVjdFRvTWVyZ2UgPSBuZXdPYmplY3RUb01lcmdlO1xyXG4gICAgICAgICAgICB3YXJuKCdQYXNzaW5nIGFuIEFycmF5IHRvIGZpcmViYXNlLmRhdGFiYXNlLm9uRGlzY29ubmVjdCgpLnVwZGF0ZSgpIGlzIGRlcHJlY2F0ZWQuIFVzZSBzZXQoKSBpZiB5b3Ugd2FudCB0byBvdmVyd3JpdGUgdGhlICcgK1xyXG4gICAgICAgICAgICAgICAgJ2V4aXN0aW5nIGRhdGEsIG9yIGFuIE9iamVjdCB3aXRoIGludGVnZXIga2V5cyBpZiB5b3UgcmVhbGx5IGRvIHdhbnQgdG8gb25seSB1cGRhdGUgc29tZSBvZiB0aGUgY2hpbGRyZW4uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhbGlkYXRlQ2FsbGJhY2soJ09uRGlzY29ubmVjdC51cGRhdGUnLCAnb25Db21wbGV0ZScsIG9uQ29tcGxldGUsIHRydWUpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2RlbGVnYXRlLnVwZGF0ZShvYmplY3RUb01lcmdlKTtcclxuICAgICAgICBpZiAob25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICByZXN1bHQudGhlbigoKSA9PiBvbkNvbXBsZXRlKG51bGwpLCBlcnJvciA9PiBvbkNvbXBsZXRlKGVycm9yKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgVHJhbnNhY3Rpb25SZXN1bHQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIHR5cGUgZm9yIHRoZSByZXNvbHZlIHZhbHVlIG9mIEZpcmViYXNlLnRyYW5zYWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb21taXR0ZWQsIHNuYXBzaG90KSB7XHJcbiAgICAgICAgdGhpcy5jb21taXR0ZWQgPSBjb21taXR0ZWQ7XHJcbiAgICAgICAgdGhpcy5zbmFwc2hvdCA9IHNuYXBzaG90O1xyXG4gICAgfVxyXG4gICAgLy8gRG8gbm90IGNyZWF0ZSBwdWJsaWMgZG9jdW1lbnRhdGlvbi4gVGhpcyBpcyBpbnRlbmRlZCB0byBtYWtlIEpTT04gc2VyaWFsaXphdGlvbiB3b3JrIGJ1dCBpcyBvdGhlcndpc2UgdW5uZWNlc3NhcnlcclxuICAgIC8vIGZvciBlbmQtdXNlcnNcclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICB2YWxpZGF0ZUFyZ0NvdW50KCdUcmFuc2FjdGlvblJlc3VsdC50b0pTT04nLCAwLCAxLCBhcmd1bWVudHMubGVuZ3RoKTtcclxuICAgICAgICByZXR1cm4geyBjb21taXR0ZWQ6IHRoaXMuY29tbWl0dGVkLCBzbmFwc2hvdDogdGhpcy5zbmFwc2hvdC50b0pTT04oKSB9O1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBmaXJlYmFzZSBkYXRhIHNuYXBzaG90LiAgSXQgd3JhcHMgYSBTbmFwc2hvdE5vZGUgYW5kXHJcbiAqIHN1cmZhY2VzIHRoZSBwdWJsaWMgbWV0aG9kcyAodmFsLCBmb3JFYWNoLCBldGMuKSB3ZSB3YW50IHRvIGV4cG9zZS5cclxuICovXHJcbmNsYXNzIERhdGFTbmFwc2hvdCB7XHJcbiAgICBjb25zdHJ1Y3RvcihfZGF0YWJhc2UsIF9kZWxlZ2F0ZSkge1xyXG4gICAgICAgIHRoaXMuX2RhdGFiYXNlID0gX2RhdGFiYXNlO1xyXG4gICAgICAgIHRoaXMuX2RlbGVnYXRlID0gX2RlbGVnYXRlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHNuYXBzaG90IGNvbnRlbnRzIGFzIEpTT04uICBSZXR1cm5zIG51bGwgaWYgdGhlIHNuYXBzaG90IGlzXHJcbiAgICAgKiBlbXB0eS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBEYXRhU25hcHNob3QgY29udGVudHMsIG9yIG51bGwgaWYgZW1wdHkuXHJcbiAgICAgKi9cclxuICAgIHZhbCgpIHtcclxuICAgICAgICB2YWxpZGF0ZUFyZ0NvdW50KCdEYXRhU25hcHNob3QudmFsJywgMCwgMCwgYXJndW1lbnRzLmxlbmd0aCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLnZhbCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzbmFwc2hvdCBjb250ZW50cyBhcyBKU09OLCBpbmNsdWRpbmcgcHJpb3JpdGllcyBvZiBub2RlLiAgU3VpdGFibGUgZm9yIGV4cG9ydGluZ1xyXG4gICAgICogdGhlIGVudGlyZSBub2RlIGNvbnRlbnRzLlxyXG4gICAgICogQHJldHVybnMgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgRGF0YVNuYXBzaG90IGNvbnRlbnRzLCBvciBudWxsIGlmIGVtcHR5LlxyXG4gICAgICovXHJcbiAgICBleHBvcnRWYWwoKSB7XHJcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnRGF0YVNuYXBzaG90LmV4cG9ydFZhbCcsIDAsIDAsIGFyZ3VtZW50cy5sZW5ndGgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5leHBvcnRWYWwoKTtcclxuICAgIH1cclxuICAgIC8vIERvIG5vdCBjcmVhdGUgcHVibGljIGRvY3VtZW50YXRpb24uIFRoaXMgaXMgaW50ZW5kZWQgdG8gbWFrZSBKU09OIHNlcmlhbGl6YXRpb24gd29yayBidXQgaXMgb3RoZXJ3aXNlIHVubmVjZXNzYXJ5XHJcbiAgICAvLyBmb3IgZW5kLXVzZXJzXHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgLy8gT3B0aW9uYWwgc3BhY2VyIGFyZ3VtZW50IGlzIHVubmVjZXNzYXJ5IGJlY2F1c2Ugd2UncmUgZGVwZW5kaW5nIG9uIHJlY3Vyc2lvbiByYXRoZXIgdGhhbiBzdHJpbmdpZnlpbmcgdGhlIGNvbnRlbnRcclxuICAgICAgICB2YWxpZGF0ZUFyZ0NvdW50KCdEYXRhU25hcHNob3QudG9KU09OJywgMCwgMSwgYXJndW1lbnRzLmxlbmd0aCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLnRvSlNPTigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHNuYXBzaG90IGNvbnRhaW5zIGEgbm9uLW51bGwgdmFsdWUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgc25hcHNob3QgY29udGFpbnMgYSBub24tbnVsbCB2YWx1ZSwgb3IgaXMgZW1wdHkuXHJcbiAgICAgKi9cclxuICAgIGV4aXN0cygpIHtcclxuICAgICAgICB2YWxpZGF0ZUFyZ0NvdW50KCdEYXRhU25hcHNob3QuZXhpc3RzJywgMCwgMCwgYXJndW1lbnRzLmxlbmd0aCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmV4aXN0cygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgRGF0YVNuYXBzaG90IG9mIHRoZSBzcGVjaWZpZWQgY2hpbGQgbm9kZSdzIGNvbnRlbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXRoIC0gUGF0aCB0byBhIGNoaWxkLlxyXG4gICAgICogQHJldHVybnMgRGF0YVNuYXBzaG90IGZvciBjaGlsZCBub2RlLlxyXG4gICAgICovXHJcbiAgICBjaGlsZChwYXRoKSB7XHJcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnRGF0YVNuYXBzaG90LmNoaWxkJywgMCwgMSwgYXJndW1lbnRzLmxlbmd0aCk7XHJcbiAgICAgICAgLy8gRW5zdXJlIHRoZSBjaGlsZFBhdGggaXMgYSBzdHJpbmcgKGNhbiBiZSBhIG51bWJlcilcclxuICAgICAgICBwYXRoID0gU3RyaW5nKHBhdGgpO1xyXG4gICAgICAgIF92YWxpZGF0ZVBhdGhTdHJpbmcoJ0RhdGFTbmFwc2hvdC5jaGlsZCcsICdwYXRoJywgcGF0aCwgZmFsc2UpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRGF0YVNuYXBzaG90KHRoaXMuX2RhdGFiYXNlLCB0aGlzLl9kZWxlZ2F0ZS5jaGlsZChwYXRoKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgc25hcHNob3QgY29udGFpbnMgYSBjaGlsZCBhdCB0aGUgc3BlY2lmaWVkIHBhdGguXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhdGggLSBQYXRoIHRvIGEgY2hpbGQuXHJcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBjaGlsZCBleGlzdHMuXHJcbiAgICAgKi9cclxuICAgIGhhc0NoaWxkKHBhdGgpIHtcclxuICAgICAgICB2YWxpZGF0ZUFyZ0NvdW50KCdEYXRhU25hcHNob3QuaGFzQ2hpbGQnLCAxLCAxLCBhcmd1bWVudHMubGVuZ3RoKTtcclxuICAgICAgICBfdmFsaWRhdGVQYXRoU3RyaW5nKCdEYXRhU25hcHNob3QuaGFzQ2hpbGQnLCAncGF0aCcsIHBhdGgsIGZhbHNlKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUuaGFzQ2hpbGQocGF0aCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHByaW9yaXR5IG9mIHRoZSBvYmplY3QsIG9yIG51bGwgaWYgbm8gcHJpb3JpdHkgd2FzIHNldC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgcHJpb3JpdHkuXHJcbiAgICAgKi9cclxuICAgIGdldFByaW9yaXR5KCkge1xyXG4gICAgICAgIHZhbGlkYXRlQXJnQ291bnQoJ0RhdGFTbmFwc2hvdC5nZXRQcmlvcml0eScsIDAsIDAsIGFyZ3VtZW50cy5sZW5ndGgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5wcmlvcml0eTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSXRlcmF0ZXMgdGhyb3VnaCBjaGlsZCBub2RlcyBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb24gZm9yIGVhY2ggb25lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhY3Rpb24gLSBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWRcclxuICAgICAqIGZvciBlYWNoIGNoaWxkLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiBmb3JFYWNoIHdhcyBjYW5jZWxlZCBieSBhY3Rpb24gcmV0dXJuaW5nIHRydWUgZm9yXHJcbiAgICAgKiBvbmUgb2YgdGhlIGNoaWxkIG5vZGVzLlxyXG4gICAgICovXHJcbiAgICBmb3JFYWNoKGFjdGlvbikge1xyXG4gICAgICAgIHZhbGlkYXRlQXJnQ291bnQoJ0RhdGFTbmFwc2hvdC5mb3JFYWNoJywgMSwgMSwgYXJndW1lbnRzLmxlbmd0aCk7XHJcbiAgICAgICAgdmFsaWRhdGVDYWxsYmFjaygnRGF0YVNuYXBzaG90LmZvckVhY2gnLCAnYWN0aW9uJywgYWN0aW9uLCBmYWxzZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmZvckVhY2goZXhwRGF0YVNuYXBzaG90ID0+IGFjdGlvbihuZXcgRGF0YVNuYXBzaG90KHRoaXMuX2RhdGFiYXNlLCBleHBEYXRhU25hcHNob3QpKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGlzIERhdGFTbmFwc2hvdCBoYXMgY2hpbGRyZW4uXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBEYXRhU25hcHNob3QgY29udGFpbnMgMSBvciBtb3JlIGNoaWxkIG5vZGVzLlxyXG4gICAgICovXHJcbiAgICBoYXNDaGlsZHJlbigpIHtcclxuICAgICAgICB2YWxpZGF0ZUFyZ0NvdW50KCdEYXRhU25hcHNob3QuaGFzQ2hpbGRyZW4nLCAwLCAwLCBhcmd1bWVudHMubGVuZ3RoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUuaGFzQ2hpbGRyZW4oKTtcclxuICAgIH1cclxuICAgIGdldCBrZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmtleTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGZvciB0aGlzIERhdGFTbmFwc2hvdC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCB0aGlzIERhdGFTbmFwc2hvdCBjb250YWlucy5cclxuICAgICAqL1xyXG4gICAgbnVtQ2hpbGRyZW4oKSB7XHJcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnRGF0YVNuYXBzaG90Lm51bUNoaWxkcmVuJywgMCwgMCwgYXJndW1lbnRzLmxlbmd0aCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLnNpemU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRoZSBGaXJlYmFzZSByZWZlcmVuY2UgZm9yIHRoZSBsb2NhdGlvbiB0aGlzIHNuYXBzaG90J3MgZGF0YSBjYW1lXHJcbiAgICAgKiBmcm9tLlxyXG4gICAgICovXHJcbiAgICBnZXRSZWYoKSB7XHJcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnRGF0YVNuYXBzaG90LnJlZicsIDAsIDAsIGFyZ3VtZW50cy5sZW5ndGgpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVmZXJlbmNlKHRoaXMuX2RhdGFiYXNlLCB0aGlzLl9kZWxlZ2F0ZS5yZWYpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHJlZigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZWYoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQSBRdWVyeSByZXByZXNlbnRzIGEgZmlsdGVyIHRvIGJlIGFwcGxpZWQgdG8gYSBmaXJlYmFzZSBsb2NhdGlvbi4gIFRoaXMgb2JqZWN0IHB1cmVseSByZXByZXNlbnRzIHRoZVxyXG4gKiBxdWVyeSBleHByZXNzaW9uIChhbmQgZXhwb3NlcyBvdXIgcHVibGljIEFQSSB0byBidWlsZCB0aGUgcXVlcnkpLiAgVGhlIGFjdHVhbCBxdWVyeSBsb2dpYyBpcyBpbiBWaWV3QmFzZS5qcy5cclxuICpcclxuICogU2luY2UgZXZlcnkgRmlyZWJhc2UgcmVmZXJlbmNlIGlzIGEgcXVlcnksIEZpcmViYXNlIGluaGVyaXRzIGZyb20gdGhpcyBvYmplY3QuXHJcbiAqL1xyXG5jbGFzcyBRdWVyeSB7XHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhYmFzZSwgX2RlbGVnYXRlKSB7XHJcbiAgICAgICAgdGhpcy5kYXRhYmFzZSA9IGRhdGFiYXNlO1xyXG4gICAgICAgIHRoaXMuX2RlbGVnYXRlID0gX2RlbGVnYXRlO1xyXG4gICAgfVxyXG4gICAgb24oZXZlbnRUeXBlLCBjYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2tPckNvbnRleHQsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnUXVlcnkub24nLCAyLCA0LCBhcmd1bWVudHMubGVuZ3RoKTtcclxuICAgICAgICB2YWxpZGF0ZUNhbGxiYWNrKCdRdWVyeS5vbicsICdjYWxsYmFjaycsIGNhbGxiYWNrLCBmYWxzZSk7XHJcbiAgICAgICAgY29uc3QgcmV0ID0gUXVlcnkuZ2V0Q2FuY2VsQW5kQ29udGV4dEFyZ3NfKCdRdWVyeS5vbicsIGNhbmNlbENhbGxiYWNrT3JDb250ZXh0LCBjb250ZXh0KTtcclxuICAgICAgICBjb25zdCB2YWx1ZUNhbGxiYWNrID0gKGV4cFNuYXBzaG90LCBwcmV2aW91c0NoaWxkTmFtZSkgPT4ge1xyXG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKHJldC5jb250ZXh0LCBuZXcgRGF0YVNuYXBzaG90KHRoaXMuZGF0YWJhc2UsIGV4cFNuYXBzaG90KSwgcHJldmlvdXNDaGlsZE5hbWUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFsdWVDYWxsYmFjay51c2VyQ2FsbGJhY2sgPSBjYWxsYmFjaztcclxuICAgICAgICB2YWx1ZUNhbGxiYWNrLmNvbnRleHQgPSByZXQuY29udGV4dDtcclxuICAgICAgICBjb25zdCBjYW5jZWxDYWxsYmFjayA9IChfYSA9IHJldC5jYW5jZWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5iaW5kKHJldC5jb250ZXh0KTtcclxuICAgICAgICBzd2l0Y2ggKGV2ZW50VHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlICd2YWx1ZSc6XHJcbiAgICAgICAgICAgICAgICBvblZhbHVlKHRoaXMuX2RlbGVnYXRlLCB2YWx1ZUNhbGxiYWNrLCBjYW5jZWxDYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2s7XHJcbiAgICAgICAgICAgIGNhc2UgJ2NoaWxkX2FkZGVkJzpcclxuICAgICAgICAgICAgICAgIG9uQ2hpbGRBZGRlZCh0aGlzLl9kZWxlZ2F0ZSwgdmFsdWVDYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrO1xyXG4gICAgICAgICAgICBjYXNlICdjaGlsZF9yZW1vdmVkJzpcclxuICAgICAgICAgICAgICAgIG9uQ2hpbGRSZW1vdmVkKHRoaXMuX2RlbGVnYXRlLCB2YWx1ZUNhbGxiYWNrLCBjYW5jZWxDYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2s7XHJcbiAgICAgICAgICAgIGNhc2UgJ2NoaWxkX2NoYW5nZWQnOlxyXG4gICAgICAgICAgICAgICAgb25DaGlsZENoYW5nZWQodGhpcy5fZGVsZWdhdGUsIHZhbHVlQ2FsbGJhY2ssIGNhbmNlbENhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaztcclxuICAgICAgICAgICAgY2FzZSAnY2hpbGRfbW92ZWQnOlxyXG4gICAgICAgICAgICAgICAgb25DaGlsZE1vdmVkKHRoaXMuX2RlbGVnYXRlLCB2YWx1ZUNhbGxiYWNrLCBjYW5jZWxDYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2s7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoJ1F1ZXJ5Lm9uJywgJ2V2ZW50VHlwZScpICtcclxuICAgICAgICAgICAgICAgICAgICAnbXVzdCBiZSBhIHZhbGlkIGV2ZW50IHR5cGUgPSBcInZhbHVlXCIsIFwiY2hpbGRfYWRkZWRcIiwgXCJjaGlsZF9yZW1vdmVkXCIsICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdcImNoaWxkX2NoYW5nZWRcIiwgb3IgXCJjaGlsZF9tb3ZlZFwiLicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9mZihldmVudFR5cGUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnUXVlcnkub2ZmJywgMCwgMywgYXJndW1lbnRzLmxlbmd0aCk7XHJcbiAgICAgICAgdmFsaWRhdGVFdmVudFR5cGUoJ1F1ZXJ5Lm9mZicsIGV2ZW50VHlwZSwgdHJ1ZSk7XHJcbiAgICAgICAgdmFsaWRhdGVDYWxsYmFjaygnUXVlcnkub2ZmJywgJ2NhbGxiYWNrJywgY2FsbGJhY2ssIHRydWUpO1xyXG4gICAgICAgIHZhbGlkYXRlQ29udGV4dE9iamVjdCgnUXVlcnkub2ZmJywgJ2NvbnRleHQnLCBjb250ZXh0LCB0cnVlKTtcclxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgY29uc3QgdmFsdWVDYWxsYmFjayA9ICgpID0+IHsgfTtcclxuICAgICAgICAgICAgdmFsdWVDYWxsYmFjay51c2VyQ2FsbGJhY2sgPSBjYWxsYmFjaztcclxuICAgICAgICAgICAgdmFsdWVDYWxsYmFjay5jb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICAgICAgb2ZmKHRoaXMuX2RlbGVnYXRlLCBldmVudFR5cGUsIHZhbHVlQ2FsbGJhY2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb2ZmKHRoaXMuX2RlbGVnYXRlLCBldmVudFR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBzZXJ2ZXItdmFsdWUgZm9yIHRoaXMgcXVlcnksIG9yIHJldHVybiBhIGNhY2hlZCB2YWx1ZSBpZiBub3QgY29ubmVjdGVkLlxyXG4gICAgICovXHJcbiAgICBnZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldCh0aGlzLl9kZWxlZ2F0ZSkudGhlbihleHBTbmFwc2hvdCA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0YVNuYXBzaG90KHRoaXMuZGF0YWJhc2UsIGV4cFNuYXBzaG90KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXR0YWNoZXMgYSBsaXN0ZW5lciwgd2FpdHMgZm9yIHRoZSBmaXJzdCBldmVudCwgYW5kIHRoZW4gcmVtb3ZlcyB0aGUgbGlzdGVuZXJcclxuICAgICAqL1xyXG4gICAgb25jZShldmVudFR5cGUsIGNhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2tPckNvbnRleHQsIGNvbnRleHQpIHtcclxuICAgICAgICB2YWxpZGF0ZUFyZ0NvdW50KCdRdWVyeS5vbmNlJywgMSwgNCwgYXJndW1lbnRzLmxlbmd0aCk7XHJcbiAgICAgICAgdmFsaWRhdGVDYWxsYmFjaygnUXVlcnkub25jZScsICdjYWxsYmFjaycsIGNhbGxiYWNrLCB0cnVlKTtcclxuICAgICAgICBjb25zdCByZXQgPSBRdWVyeS5nZXRDYW5jZWxBbmRDb250ZXh0QXJnc18oJ1F1ZXJ5Lm9uY2UnLCBmYWlsdXJlQ2FsbGJhY2tPckNvbnRleHQsIGNvbnRleHQpO1xyXG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICAgICAgY29uc3QgdmFsdWVDYWxsYmFjayA9IChleHBTbmFwc2hvdCwgcHJldmlvdXNDaGlsZE5hbWUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IERhdGFTbmFwc2hvdCh0aGlzLmRhdGFiYXNlLCBleHBTbmFwc2hvdCk7XHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChyZXQuY29udGV4dCwgcmVzdWx0LCBwcmV2aW91c0NoaWxkTmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFsdWVDYWxsYmFjay51c2VyQ2FsbGJhY2sgPSBjYWxsYmFjaztcclxuICAgICAgICB2YWx1ZUNhbGxiYWNrLmNvbnRleHQgPSByZXQuY29udGV4dDtcclxuICAgICAgICBjb25zdCBjYW5jZWxDYWxsYmFjayA9IChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICBpZiAocmV0LmNhbmNlbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0LmNhbmNlbC5jYWxsKHJldC5jb250ZXh0LCBlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycm9yKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHN3aXRjaCAoZXZlbnRUeXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ3ZhbHVlJzpcclxuICAgICAgICAgICAgICAgIG9uVmFsdWUodGhpcy5fZGVsZWdhdGUsIHZhbHVlQ2FsbGJhY2ssIGNhbmNlbENhbGxiYWNrLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgb25seU9uY2U6IHRydWVcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2NoaWxkX2FkZGVkJzpcclxuICAgICAgICAgICAgICAgIG9uQ2hpbGRBZGRlZCh0aGlzLl9kZWxlZ2F0ZSwgdmFsdWVDYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2ssIHtcclxuICAgICAgICAgICAgICAgICAgICBvbmx5T25jZTogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnY2hpbGRfcmVtb3ZlZCc6XHJcbiAgICAgICAgICAgICAgICBvbkNoaWxkUmVtb3ZlZCh0aGlzLl9kZWxlZ2F0ZSwgdmFsdWVDYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2ssIHtcclxuICAgICAgICAgICAgICAgICAgICBvbmx5T25jZTogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnY2hpbGRfY2hhbmdlZCc6XHJcbiAgICAgICAgICAgICAgICBvbkNoaWxkQ2hhbmdlZCh0aGlzLl9kZWxlZ2F0ZSwgdmFsdWVDYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2ssIHtcclxuICAgICAgICAgICAgICAgICAgICBvbmx5T25jZTogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnY2hpbGRfbW92ZWQnOlxyXG4gICAgICAgICAgICAgICAgb25DaGlsZE1vdmVkKHRoaXMuX2RlbGVnYXRlLCB2YWx1ZUNhbGxiYWNrLCBjYW5jZWxDYWxsYmFjaywge1xyXG4gICAgICAgICAgICAgICAgICAgIG9ubHlPbmNlOiB0cnVlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4KCdRdWVyeS5vbmNlJywgJ2V2ZW50VHlwZScpICtcclxuICAgICAgICAgICAgICAgICAgICAnbXVzdCBiZSBhIHZhbGlkIGV2ZW50IHR5cGUgPSBcInZhbHVlXCIsIFwiY2hpbGRfYWRkZWRcIiwgXCJjaGlsZF9yZW1vdmVkXCIsICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdcImNoaWxkX2NoYW5nZWRcIiwgb3IgXCJjaGlsZF9tb3ZlZFwiLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGEgbGltaXQgYW5kIGFuY2hvciBpdCB0byB0aGUgc3RhcnQgb2YgdGhlIHdpbmRvdy5cclxuICAgICAqL1xyXG4gICAgbGltaXRUb0ZpcnN0KGxpbWl0KSB7XHJcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnUXVlcnkubGltaXRUb0ZpcnN0JywgMSwgMSwgYXJndW1lbnRzLmxlbmd0aCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeSh0aGlzLmRhdGFiYXNlLCBxdWVyeSh0aGlzLl9kZWxlZ2F0ZSwgbGltaXRUb0ZpcnN0KGxpbWl0KSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgYSBsaW1pdCBhbmQgYW5jaG9yIGl0IHRvIHRoZSBlbmQgb2YgdGhlIHdpbmRvdy5cclxuICAgICAqL1xyXG4gICAgbGltaXRUb0xhc3QobGltaXQpIHtcclxuICAgICAgICB2YWxpZGF0ZUFyZ0NvdW50KCdRdWVyeS5saW1pdFRvTGFzdCcsIDEsIDEsIGFyZ3VtZW50cy5sZW5ndGgpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUXVlcnkodGhpcy5kYXRhYmFzZSwgcXVlcnkodGhpcy5fZGVsZWdhdGUsIGxpbWl0VG9MYXN0KGxpbWl0KSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhIGNoaWxkIHBhdGgsIHJldHVybiBhIG5ldyBxdWVyeSBvcmRlcmVkIGJ5IHRoZSBzcGVjaWZpZWQgZ3JhbmRjaGlsZCBwYXRoLlxyXG4gICAgICovXHJcbiAgICBvcmRlckJ5Q2hpbGQocGF0aCkge1xyXG4gICAgICAgIHZhbGlkYXRlQXJnQ291bnQoJ1F1ZXJ5Lm9yZGVyQnlDaGlsZCcsIDEsIDEsIGFyZ3VtZW50cy5sZW5ndGgpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUXVlcnkodGhpcy5kYXRhYmFzZSwgcXVlcnkodGhpcy5fZGVsZWdhdGUsIG9yZGVyQnlDaGlsZChwYXRoKSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgcXVlcnkgb3JkZXJlZCBieSB0aGUgS2V5SW5kZXhcclxuICAgICAqL1xyXG4gICAgb3JkZXJCeUtleSgpIHtcclxuICAgICAgICB2YWxpZGF0ZUFyZ0NvdW50KCdRdWVyeS5vcmRlckJ5S2V5JywgMCwgMCwgYXJndW1lbnRzLmxlbmd0aCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeSh0aGlzLmRhdGFiYXNlLCBxdWVyeSh0aGlzLl9kZWxlZ2F0ZSwgb3JkZXJCeUtleSgpKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIG5ldyBxdWVyeSBvcmRlcmVkIGJ5IHRoZSBQcmlvcml0eUluZGV4XHJcbiAgICAgKi9cclxuICAgIG9yZGVyQnlQcmlvcml0eSgpIHtcclxuICAgICAgICB2YWxpZGF0ZUFyZ0NvdW50KCdRdWVyeS5vcmRlckJ5UHJpb3JpdHknLCAwLCAwLCBhcmd1bWVudHMubGVuZ3RoKTtcclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KHRoaXMuZGF0YWJhc2UsIHF1ZXJ5KHRoaXMuX2RlbGVnYXRlLCBvcmRlckJ5UHJpb3JpdHkoKSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgcXVlcnkgb3JkZXJlZCBieSB0aGUgVmFsdWVJbmRleFxyXG4gICAgICovXHJcbiAgICBvcmRlckJ5VmFsdWUoKSB7XHJcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnUXVlcnkub3JkZXJCeVZhbHVlJywgMCwgMCwgYXJndW1lbnRzLmxlbmd0aCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeSh0aGlzLmRhdGFiYXNlLCBxdWVyeSh0aGlzLl9kZWxlZ2F0ZSwgb3JkZXJCeVZhbHVlKCkpKTtcclxuICAgIH1cclxuICAgIHN0YXJ0QXQodmFsdWUgPSBudWxsLCBuYW1lKSB7XHJcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnUXVlcnkuc3RhcnRBdCcsIDAsIDIsIGFyZ3VtZW50cy5sZW5ndGgpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUXVlcnkodGhpcy5kYXRhYmFzZSwgcXVlcnkodGhpcy5fZGVsZWdhdGUsIHN0YXJ0QXQodmFsdWUsIG5hbWUpKSk7XHJcbiAgICB9XHJcbiAgICBzdGFydEFmdGVyKHZhbHVlID0gbnVsbCwgbmFtZSkge1xyXG4gICAgICAgIHZhbGlkYXRlQXJnQ291bnQoJ1F1ZXJ5LnN0YXJ0QWZ0ZXInLCAwLCAyLCBhcmd1bWVudHMubGVuZ3RoKTtcclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KHRoaXMuZGF0YWJhc2UsIHF1ZXJ5KHRoaXMuX2RlbGVnYXRlLCBzdGFydEFmdGVyKHZhbHVlLCBuYW1lKSkpO1xyXG4gICAgfVxyXG4gICAgZW5kQXQodmFsdWUgPSBudWxsLCBuYW1lKSB7XHJcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnUXVlcnkuZW5kQXQnLCAwLCAyLCBhcmd1bWVudHMubGVuZ3RoKTtcclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KHRoaXMuZGF0YWJhc2UsIHF1ZXJ5KHRoaXMuX2RlbGVnYXRlLCBlbmRBdCh2YWx1ZSwgbmFtZSkpKTtcclxuICAgIH1cclxuICAgIGVuZEJlZm9yZSh2YWx1ZSA9IG51bGwsIG5hbWUpIHtcclxuICAgICAgICB2YWxpZGF0ZUFyZ0NvdW50KCdRdWVyeS5lbmRCZWZvcmUnLCAwLCAyLCBhcmd1bWVudHMubGVuZ3RoKTtcclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KHRoaXMuZGF0YWJhc2UsIHF1ZXJ5KHRoaXMuX2RlbGVnYXRlLCBlbmRCZWZvcmUodmFsdWUsIG5hbWUpKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIExvYWQgdGhlIHNlbGVjdGlvbiBvZiBjaGlsZHJlbiB3aXRoIGV4YWN0bHkgdGhlIHNwZWNpZmllZCB2YWx1ZSwgYW5kLCBvcHRpb25hbGx5LFxyXG4gICAgICogdGhlIHNwZWNpZmllZCBuYW1lLlxyXG4gICAgICovXHJcbiAgICBlcXVhbFRvKHZhbHVlLCBuYW1lKSB7XHJcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnUXVlcnkuZXF1YWxUbycsIDEsIDIsIGFyZ3VtZW50cy5sZW5ndGgpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUXVlcnkodGhpcy5kYXRhYmFzZSwgcXVlcnkodGhpcy5fZGVsZWdhdGUsIGVxdWFsVG8odmFsdWUsIG5hbWUpKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFVSTCBmb3IgdGhpcyBsb2NhdGlvbi5cclxuICAgICAqL1xyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnUXVlcnkudG9TdHJpbmcnLCAwLCAwLCBhcmd1bWVudHMubGVuZ3RoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUudG9TdHJpbmcoKTtcclxuICAgIH1cclxuICAgIC8vIERvIG5vdCBjcmVhdGUgcHVibGljIGRvY3VtZW50YXRpb24uIFRoaXMgaXMgaW50ZW5kZWQgdG8gbWFrZSBKU09OIHNlcmlhbGl6YXRpb24gd29yayBidXQgaXMgb3RoZXJ3aXNlIHVubmVjZXNzYXJ5XHJcbiAgICAvLyBmb3IgZW5kLXVzZXJzLlxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIC8vIEFuIG9wdGlvbmFsIHNwYWNlciBhcmd1bWVudCBpcyB1bm5lY2Vzc2FyeSBmb3IgYSBzdHJpbmcuXHJcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnUXVlcnkudG9KU09OJywgMCwgMSwgYXJndW1lbnRzLmxlbmd0aCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLnRvSlNPTigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGlzIHF1ZXJ5IGFuZCB0aGUgcHJvdmlkZWQgcXVlcnkgYXJlIGVxdWl2YWxlbnQ7IG90aGVyd2lzZSwgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBpc0VxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnUXVlcnkuaXNFcXVhbCcsIDEsIDEsIGFyZ3VtZW50cy5sZW5ndGgpO1xyXG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgUXVlcnkpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gJ1F1ZXJ5LmlzRXF1YWwgZmFpbGVkOiBGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIGZpcmViYXNlLmRhdGFiYXNlLlF1ZXJ5Lic7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5pc0VxdWFsKG90aGVyLl9kZWxlZ2F0ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEhlbHBlciB1c2VkIGJ5IC5vbiBhbmQgLm9uY2UgdG8gZXh0cmFjdCB0aGUgY29udGV4dCBhbmQgb3IgY2FuY2VsIGFyZ3VtZW50cy5cclxuICAgICAqIEBwYXJhbSBmbk5hbWUgLSBUaGUgZnVuY3Rpb24gbmFtZSAob24gb3Igb25jZSlcclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRDYW5jZWxBbmRDb250ZXh0QXJnc18oZm5OYW1lLCBjYW5jZWxPckNvbnRleHQsIGNvbnRleHQpIHtcclxuICAgICAgICBjb25zdCByZXQgPSB7IGNhbmNlbDogdW5kZWZpbmVkLCBjb250ZXh0OiB1bmRlZmluZWQgfTtcclxuICAgICAgICBpZiAoY2FuY2VsT3JDb250ZXh0ICYmIGNvbnRleHQpIHtcclxuICAgICAgICAgICAgcmV0LmNhbmNlbCA9IGNhbmNlbE9yQ29udGV4dDtcclxuICAgICAgICAgICAgdmFsaWRhdGVDYWxsYmFjayhmbk5hbWUsICdjYW5jZWwnLCByZXQuY2FuY2VsLCB0cnVlKTtcclxuICAgICAgICAgICAgcmV0LmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgICAgICB2YWxpZGF0ZUNvbnRleHRPYmplY3QoZm5OYW1lLCAnY29udGV4dCcsIHJldC5jb250ZXh0LCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2FuY2VsT3JDb250ZXh0KSB7XHJcbiAgICAgICAgICAgIC8vIHdlIGhhdmUgZWl0aGVyIGEgY2FuY2VsIGNhbGxiYWNrIG9yIGEgY29udGV4dC5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYW5jZWxPckNvbnRleHQgPT09ICdvYmplY3QnICYmIGNhbmNlbE9yQ29udGV4dCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgLy8gaXQncyBhIGNvbnRleHQhXHJcbiAgICAgICAgICAgICAgICByZXQuY29udGV4dCA9IGNhbmNlbE9yQ29udGV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2FuY2VsT3JDb250ZXh0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICByZXQuY2FuY2VsID0gY2FuY2VsT3JDb250ZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4KGZuTmFtZSwgJ2NhbmNlbE9yQ29udGV4dCcpICtcclxuICAgICAgICAgICAgICAgICAgICAnIG11c3QgZWl0aGVyIGJlIGEgY2FuY2VsIGNhbGxiYWNrIG9yIGEgY29udGV4dCBvYmplY3QuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH1cclxuICAgIGdldCByZWYoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZWZlcmVuY2UodGhpcy5kYXRhYmFzZSwgbmV3IF9SZWZlcmVuY2VJbXBsKHRoaXMuX2RlbGVnYXRlLl9yZXBvLCB0aGlzLl9kZWxlZ2F0ZS5fcGF0aCkpO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIFJlZmVyZW5jZSBleHRlbmRzIFF1ZXJ5IHtcclxuICAgIC8qKlxyXG4gICAgICogQ2FsbCBvcHRpb25zOlxyXG4gICAgICogICBuZXcgUmVmZXJlbmNlKFJlcG8sIFBhdGgpIG9yXHJcbiAgICAgKiAgIG5ldyBSZWZlcmVuY2UodXJsOiBzdHJpbmcsIHN0cmluZ3xSZXBvTWFuYWdlcilcclxuICAgICAqXHJcbiAgICAgKiBFeHRlcm5hbGx5IC0gdGhpcyBpcyB0aGUgZmlyZWJhc2UuZGF0YWJhc2UuUmVmZXJlbmNlIHR5cGUuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGRhdGFiYXNlLCBfZGVsZWdhdGUpIHtcclxuICAgICAgICBzdXBlcihkYXRhYmFzZSwgbmV3IF9RdWVyeUltcGwoX2RlbGVnYXRlLl9yZXBvLCBfZGVsZWdhdGUuX3BhdGgsIG5ldyBfUXVlcnlQYXJhbXMoKSwgZmFsc2UpKTtcclxuICAgICAgICB0aGlzLmRhdGFiYXNlID0gZGF0YWJhc2U7XHJcbiAgICAgICAgdGhpcy5fZGVsZWdhdGUgPSBfZGVsZWdhdGU7XHJcbiAgICB9XHJcbiAgICAvKiogQHJldHVybnMgez9zdHJpbmd9ICovXHJcbiAgICBnZXRLZXkoKSB7XHJcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnUmVmZXJlbmNlLmtleScsIDAsIDAsIGFyZ3VtZW50cy5sZW5ndGgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5rZXk7XHJcbiAgICB9XHJcbiAgICBjaGlsZChwYXRoU3RyaW5nKSB7XHJcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnUmVmZXJlbmNlLmNoaWxkJywgMSwgMSwgYXJndW1lbnRzLmxlbmd0aCk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBwYXRoU3RyaW5nID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICBwYXRoU3RyaW5nID0gU3RyaW5nKHBhdGhTdHJpbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFJlZmVyZW5jZSh0aGlzLmRhdGFiYXNlLCBjaGlsZCh0aGlzLl9kZWxlZ2F0ZSwgcGF0aFN0cmluZykpO1xyXG4gICAgfVxyXG4gICAgLyoqIEByZXR1cm5zIHs/UmVmZXJlbmNlfSAqL1xyXG4gICAgZ2V0UGFyZW50KCkge1xyXG4gICAgICAgIHZhbGlkYXRlQXJnQ291bnQoJ1JlZmVyZW5jZS5wYXJlbnQnLCAwLCAwLCBhcmd1bWVudHMubGVuZ3RoKTtcclxuICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl9kZWxlZ2F0ZS5wYXJlbnQ7XHJcbiAgICAgICAgcmV0dXJuIHBhcmVudCA/IG5ldyBSZWZlcmVuY2UodGhpcy5kYXRhYmFzZSwgcGFyZW50KSA6IG51bGw7XHJcbiAgICB9XHJcbiAgICAvKiogQHJldHVybnMgeyFSZWZlcmVuY2V9ICovXHJcbiAgICBnZXRSb290KCkge1xyXG4gICAgICAgIHZhbGlkYXRlQXJnQ291bnQoJ1JlZmVyZW5jZS5yb290JywgMCwgMCwgYXJndW1lbnRzLmxlbmd0aCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZWZlcmVuY2UodGhpcy5kYXRhYmFzZSwgdGhpcy5fZGVsZWdhdGUucm9vdCk7XHJcbiAgICB9XHJcbiAgICBzZXQobmV3VmFsLCBvbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnUmVmZXJlbmNlLnNldCcsIDEsIDIsIGFyZ3VtZW50cy5sZW5ndGgpO1xyXG4gICAgICAgIHZhbGlkYXRlQ2FsbGJhY2soJ1JlZmVyZW5jZS5zZXQnLCAnb25Db21wbGV0ZScsIG9uQ29tcGxldGUsIHRydWUpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHNldCh0aGlzLl9kZWxlZ2F0ZSwgbmV3VmFsKTtcclxuICAgICAgICBpZiAob25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICByZXN1bHQudGhlbigoKSA9PiBvbkNvbXBsZXRlKG51bGwpLCBlcnJvciA9PiBvbkNvbXBsZXRlKGVycm9yKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUodmFsdWVzLCBvbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnUmVmZXJlbmNlLnVwZGF0ZScsIDEsIDIsIGFyZ3VtZW50cy5sZW5ndGgpO1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcclxuICAgICAgICAgICAgY29uc3QgbmV3T2JqZWN0VG9NZXJnZSA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgbmV3T2JqZWN0VG9NZXJnZVsnJyArIGldID0gdmFsdWVzW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhbHVlcyA9IG5ld09iamVjdFRvTWVyZ2U7XHJcbiAgICAgICAgICAgIHdhcm4oJ1Bhc3NpbmcgYW4gQXJyYXkgdG8gRmlyZWJhc2UudXBkYXRlKCkgaXMgZGVwcmVjYXRlZC4gJyArXHJcbiAgICAgICAgICAgICAgICAnVXNlIHNldCgpIGlmIHlvdSB3YW50IHRvIG92ZXJ3cml0ZSB0aGUgZXhpc3RpbmcgZGF0YSwgb3IgJyArXHJcbiAgICAgICAgICAgICAgICAnYW4gT2JqZWN0IHdpdGggaW50ZWdlciBrZXlzIGlmIHlvdSByZWFsbHkgZG8gd2FudCB0byAnICtcclxuICAgICAgICAgICAgICAgICdvbmx5IHVwZGF0ZSBzb21lIG9mIHRoZSBjaGlsZHJlbi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3ZhbGlkYXRlV3JpdGFibGVQYXRoKCdSZWZlcmVuY2UudXBkYXRlJywgdGhpcy5fZGVsZWdhdGUuX3BhdGgpO1xyXG4gICAgICAgIHZhbGlkYXRlQ2FsbGJhY2soJ1JlZmVyZW5jZS51cGRhdGUnLCAnb25Db21wbGV0ZScsIG9uQ29tcGxldGUsIHRydWUpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHVwZGF0ZSh0aGlzLl9kZWxlZ2F0ZSwgdmFsdWVzKTtcclxuICAgICAgICBpZiAob25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICByZXN1bHQudGhlbigoKSA9PiBvbkNvbXBsZXRlKG51bGwpLCBlcnJvciA9PiBvbkNvbXBsZXRlKGVycm9yKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBzZXRXaXRoUHJpb3JpdHkobmV3VmFsLCBuZXdQcmlvcml0eSwgb25Db21wbGV0ZSkge1xyXG4gICAgICAgIHZhbGlkYXRlQXJnQ291bnQoJ1JlZmVyZW5jZS5zZXRXaXRoUHJpb3JpdHknLCAyLCAzLCBhcmd1bWVudHMubGVuZ3RoKTtcclxuICAgICAgICB2YWxpZGF0ZUNhbGxiYWNrKCdSZWZlcmVuY2Uuc2V0V2l0aFByaW9yaXR5JywgJ29uQ29tcGxldGUnLCBvbkNvbXBsZXRlLCB0cnVlKTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBzZXRXaXRoUHJpb3JpdHkodGhpcy5fZGVsZWdhdGUsIG5ld1ZhbCwgbmV3UHJpb3JpdHkpO1xyXG4gICAgICAgIGlmIChvbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC50aGVuKCgpID0+IG9uQ29tcGxldGUobnVsbCksIGVycm9yID0+IG9uQ29tcGxldGUoZXJyb3IpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHJlbW92ZShvbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnUmVmZXJlbmNlLnJlbW92ZScsIDAsIDEsIGFyZ3VtZW50cy5sZW5ndGgpO1xyXG4gICAgICAgIHZhbGlkYXRlQ2FsbGJhY2soJ1JlZmVyZW5jZS5yZW1vdmUnLCAnb25Db21wbGV0ZScsIG9uQ29tcGxldGUsIHRydWUpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlbW92ZSh0aGlzLl9kZWxlZ2F0ZSk7XHJcbiAgICAgICAgaWYgKG9uQ29tcGxldGUpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnRoZW4oKCkgPT4gb25Db21wbGV0ZShudWxsKSwgZXJyb3IgPT4gb25Db21wbGV0ZShlcnJvcikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgdHJhbnNhY3Rpb24odHJhbnNhY3Rpb25VcGRhdGUsIG9uQ29tcGxldGUsIGFwcGx5TG9jYWxseSkge1xyXG4gICAgICAgIHZhbGlkYXRlQXJnQ291bnQoJ1JlZmVyZW5jZS50cmFuc2FjdGlvbicsIDEsIDMsIGFyZ3VtZW50cy5sZW5ndGgpO1xyXG4gICAgICAgIHZhbGlkYXRlQ2FsbGJhY2soJ1JlZmVyZW5jZS50cmFuc2FjdGlvbicsICd0cmFuc2FjdGlvblVwZGF0ZScsIHRyYW5zYWN0aW9uVXBkYXRlLCBmYWxzZSk7XHJcbiAgICAgICAgdmFsaWRhdGVDYWxsYmFjaygnUmVmZXJlbmNlLnRyYW5zYWN0aW9uJywgJ29uQ29tcGxldGUnLCBvbkNvbXBsZXRlLCB0cnVlKTtcclxuICAgICAgICB2YWxpZGF0ZUJvb2xlYW4oJ1JlZmVyZW5jZS50cmFuc2FjdGlvbicsICdhcHBseUxvY2FsbHknLCBhcHBseUxvY2FsbHksIHRydWUpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHJ1blRyYW5zYWN0aW9uKHRoaXMuX2RlbGVnYXRlLCB0cmFuc2FjdGlvblVwZGF0ZSwge1xyXG4gICAgICAgICAgICBhcHBseUxvY2FsbHlcclxuICAgICAgICB9KS50aGVuKHRyYW5zYWN0aW9uUmVzdWx0ID0+IG5ldyBUcmFuc2FjdGlvblJlc3VsdCh0cmFuc2FjdGlvblJlc3VsdC5jb21taXR0ZWQsIG5ldyBEYXRhU25hcHNob3QodGhpcy5kYXRhYmFzZSwgdHJhbnNhY3Rpb25SZXN1bHQuc25hcHNob3QpKSk7XHJcbiAgICAgICAgaWYgKG9uQ29tcGxldGUpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnRoZW4odHJhbnNhY3Rpb25SZXN1bHQgPT4gb25Db21wbGV0ZShudWxsLCB0cmFuc2FjdGlvblJlc3VsdC5jb21taXR0ZWQsIHRyYW5zYWN0aW9uUmVzdWx0LnNuYXBzaG90KSwgZXJyb3IgPT4gb25Db21wbGV0ZShlcnJvciwgZmFsc2UsIG51bGwpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHNldFByaW9yaXR5KHByaW9yaXR5LCBvbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnUmVmZXJlbmNlLnNldFByaW9yaXR5JywgMSwgMiwgYXJndW1lbnRzLmxlbmd0aCk7XHJcbiAgICAgICAgdmFsaWRhdGVDYWxsYmFjaygnUmVmZXJlbmNlLnNldFByaW9yaXR5JywgJ29uQ29tcGxldGUnLCBvbkNvbXBsZXRlLCB0cnVlKTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBzZXRQcmlvcml0eSh0aGlzLl9kZWxlZ2F0ZSwgcHJpb3JpdHkpO1xyXG4gICAgICAgIGlmIChvbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC50aGVuKCgpID0+IG9uQ29tcGxldGUobnVsbCksIGVycm9yID0+IG9uQ29tcGxldGUoZXJyb3IpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHB1c2godmFsdWUsIG9uQ29tcGxldGUpIHtcclxuICAgICAgICB2YWxpZGF0ZUFyZ0NvdW50KCdSZWZlcmVuY2UucHVzaCcsIDAsIDIsIGFyZ3VtZW50cy5sZW5ndGgpO1xyXG4gICAgICAgIHZhbGlkYXRlQ2FsbGJhY2soJ1JlZmVyZW5jZS5wdXNoJywgJ29uQ29tcGxldGUnLCBvbkNvbXBsZXRlLCB0cnVlKTtcclxuICAgICAgICBjb25zdCBleHBQcm9taXNlID0gcHVzaCh0aGlzLl9kZWxlZ2F0ZSwgdmFsdWUpO1xyXG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBleHBQcm9taXNlLnRoZW4oZXhwUmVmID0+IG5ldyBSZWZlcmVuY2UodGhpcy5kYXRhYmFzZSwgZXhwUmVmKSk7XHJcbiAgICAgICAgaWYgKG9uQ29tcGxldGUpIHtcclxuICAgICAgICAgICAgcHJvbWlzZS50aGVuKCgpID0+IG9uQ29tcGxldGUobnVsbCksIGVycm9yID0+IG9uQ29tcGxldGUoZXJyb3IpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFJlZmVyZW5jZSh0aGlzLmRhdGFiYXNlLCBleHBQcm9taXNlKTtcclxuICAgICAgICByZXN1bHQudGhlbiA9IHByb21pc2UudGhlbi5iaW5kKHByb21pc2UpO1xyXG4gICAgICAgIHJlc3VsdC5jYXRjaCA9IHByb21pc2UuY2F0Y2guYmluZChwcm9taXNlLCB1bmRlZmluZWQpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBvbkRpc2Nvbm5lY3QoKSB7XHJcbiAgICAgICAgX3ZhbGlkYXRlV3JpdGFibGVQYXRoKCdSZWZlcmVuY2Uub25EaXNjb25uZWN0JywgdGhpcy5fZGVsZWdhdGUuX3BhdGgpO1xyXG4gICAgICAgIHJldHVybiBuZXcgT25EaXNjb25uZWN0KG5ldyBPbkRpc2Nvbm5lY3QkMSh0aGlzLl9kZWxlZ2F0ZS5fcmVwbywgdGhpcy5fZGVsZWdhdGUuX3BhdGgpKTtcclxuICAgIH1cclxuICAgIGdldCBrZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0S2V5KCk7XHJcbiAgICB9XHJcbiAgICBnZXQgcGFyZW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFBhcmVudCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHJvb3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Um9vdCgpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBmaXJlYmFzZSBkYXRhYmFzZS5cclxuICovXHJcbmNsYXNzIERhdGFiYXNlIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNvbnN0cnVjdG9yIHNob3VsZCBub3QgYmUgY2FsbGVkIGJ5IHVzZXJzIG9mIG91ciBwdWJsaWMgQVBJLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihfZGVsZWdhdGUsIGFwcCkge1xyXG4gICAgICAgIHRoaXMuX2RlbGVnYXRlID0gX2RlbGVnYXRlO1xyXG4gICAgICAgIHRoaXMuYXBwID0gYXBwO1xyXG4gICAgICAgIHRoaXMuSU5URVJOQUwgPSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZTogKCkgPT4gdGhpcy5fZGVsZWdhdGUuX2RlbGV0ZSgpLFxyXG4gICAgICAgICAgICBmb3JjZVdlYlNvY2tldHMsXHJcbiAgICAgICAgICAgIGZvcmNlTG9uZ1BvbGxpbmdcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNb2RpZnkgdGhpcyBpbnN0YW5jZSB0byBjb21tdW5pY2F0ZSB3aXRoIHRoZSBSZWFsdGltZSBEYXRhYmFzZSBlbXVsYXRvci5cclxuICAgICAqXHJcbiAgICAgKiA8cD5Ob3RlOiBUaGlzIG1ldGhvZCBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgcGVyZm9ybWluZyBhbnkgb3RoZXIgb3BlcmF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBob3N0IC0gdGhlIGVtdWxhdG9yIGhvc3QgKGV4OiBsb2NhbGhvc3QpXHJcbiAgICAgKiBAcGFyYW0gcG9ydCAtIHRoZSBlbXVsYXRvciBwb3J0IChleDogODA4MClcclxuICAgICAqIEBwYXJhbSBvcHRpb25zLm1vY2tVc2VyVG9rZW4gLSB0aGUgbW9jayBhdXRoIHRva2VuIHRvIHVzZSBmb3IgdW5pdCB0ZXN0aW5nIFNlY3VyaXR5IFJ1bGVzXHJcbiAgICAgKi9cclxuICAgIHVzZUVtdWxhdG9yKGhvc3QsIHBvcnQsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgICAgIGNvbm5lY3REYXRhYmFzZUVtdWxhdG9yKHRoaXMuX2RlbGVnYXRlLCBob3N0LCBwb3J0LCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIHJlZihwYXRoKSB7XHJcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnZGF0YWJhc2UucmVmJywgMCwgMSwgYXJndW1lbnRzLmxlbmd0aCk7XHJcbiAgICAgICAgaWYgKHBhdGggaW5zdGFuY2VvZiBSZWZlcmVuY2UpIHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGRSZWYgPSByZWZGcm9tVVJMKHRoaXMuX2RlbGVnYXRlLCBwYXRoLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZmVyZW5jZSh0aGlzLCBjaGlsZFJlZik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZFJlZiA9IHJlZih0aGlzLl9kZWxlZ2F0ZSwgcGF0aCk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVmZXJlbmNlKHRoaXMsIGNoaWxkUmVmKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIHJvb3Qgb3IgdGhlIHBhdGggc3BlY2lmaWVkIGluIHVybC5cclxuICAgICAqIFdlIHRocm93IGEgZXhjZXB0aW9uIGlmIHRoZSB1cmwgaXMgbm90IGluIHRoZSBzYW1lIGRvbWFpbiBhcyB0aGVcclxuICAgICAqIGN1cnJlbnQgcmVwby5cclxuICAgICAqIEByZXR1cm5zIEZpcmViYXNlIHJlZmVyZW5jZS5cclxuICAgICAqL1xyXG4gICAgcmVmRnJvbVVSTCh1cmwpIHtcclxuICAgICAgICBjb25zdCBhcGlOYW1lID0gJ2RhdGFiYXNlLnJlZkZyb21VUkwnO1xyXG4gICAgICAgIHZhbGlkYXRlQXJnQ291bnQoYXBpTmFtZSwgMSwgMSwgYXJndW1lbnRzLmxlbmd0aCk7XHJcbiAgICAgICAgY29uc3QgY2hpbGRSZWYgPSByZWZGcm9tVVJMKHRoaXMuX2RlbGVnYXRlLCB1cmwpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVmZXJlbmNlKHRoaXMsIGNoaWxkUmVmKTtcclxuICAgIH1cclxuICAgIC8vIE1ha2UgaW5kaXZpZHVhbCByZXBvIGdvIG9mZmxpbmUuXHJcbiAgICBnb09mZmxpbmUoKSB7XHJcbiAgICAgICAgdmFsaWRhdGVBcmdDb3VudCgnZGF0YWJhc2UuZ29PZmZsaW5lJywgMCwgMCwgYXJndW1lbnRzLmxlbmd0aCk7XHJcbiAgICAgICAgcmV0dXJuIGdvT2ZmbGluZSh0aGlzLl9kZWxlZ2F0ZSk7XHJcbiAgICB9XHJcbiAgICBnb09ubGluZSgpIHtcclxuICAgICAgICB2YWxpZGF0ZUFyZ0NvdW50KCdkYXRhYmFzZS5nb09ubGluZScsIDAsIDAsIGFyZ3VtZW50cy5sZW5ndGgpO1xyXG4gICAgICAgIHJldHVybiBnb09ubGluZSh0aGlzLl9kZWxlZ2F0ZSk7XHJcbiAgICB9XHJcbn1cclxuRGF0YWJhc2UuU2VydmVyVmFsdWUgPSB7XHJcbiAgICBUSU1FU1RBTVA6IHNlcnZlclRpbWVzdGFtcCgpLFxyXG4gICAgaW5jcmVtZW50OiAoZGVsdGEpID0+IGluY3JlbWVudChkZWx0YSlcclxufTtcblxuLyoqXHJcbiAqIFVzZWQgYnkgY29uc29sZSB0byBjcmVhdGUgYSBkYXRhYmFzZSBiYXNlZCBvbiB0aGUgYXBwLFxyXG4gKiBwYXNzZWQgZGF0YWJhc2UgVVJMIGFuZCBhIGN1c3RvbSBhdXRoIGltcGxlbWVudGF0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0gYXBwIC0gQSB2YWxpZCBGaXJlYmFzZUFwcC1saWtlIG9iamVjdFxyXG4gKiBAcGFyYW0gdXJsIC0gQSB2YWxpZCBGaXJlYmFzZSBkYXRhYmFzZVVSTFxyXG4gKiBAcGFyYW0gdmVyc2lvbiAtIGN1c3RvbSB2ZXJzaW9uIGUuZy4gZmlyZWJhc2UtYWRtaW4gdmVyc2lvblxyXG4gKiBAcGFyYW0gY3VzdG9tQXV0aEltcGwgLSBjdXN0b20gYXV0aCBpbXBsZW1lbnRhdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gaW5pdFN0YW5kYWxvbmUoeyBhcHAsIHVybCwgdmVyc2lvbiwgY3VzdG9tQXV0aEltcGwsIGN1c3RvbUFwcENoZWNrSW1wbCwgbmFtZXNwYWNlLCBub2RlQWRtaW4gPSBmYWxzZSB9KSB7XHJcbiAgICBfc2V0U0RLVmVyc2lvbih2ZXJzaW9uKTtcclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IG5ldyBDb21wb25lbnRDb250YWluZXIoJ2RhdGFiYXNlLXN0YW5kYWxvbmUnKTtcclxuICAgIC8qKlxyXG4gICAgICogQ29tcG9uZW50Q29udGFpbmVyKCdkYXRhYmFzZS1zdGFuZGFsb25lJykgaXMganVzdCBhIHBsYWNlaG9sZGVyIHRoYXQgZG9lc24ndCBwZXJmb3JtXHJcbiAgICAgKiBhbnkgYWN0dWFsIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBjb25zdCBhdXRoUHJvdmlkZXIgPSBuZXcgUHJvdmlkZXIoJ2F1dGgtaW50ZXJuYWwnLCBjb250YWluZXIpO1xyXG4gICAgYXV0aFByb3ZpZGVyLnNldENvbXBvbmVudChuZXcgQ29tcG9uZW50KCdhdXRoLWludGVybmFsJywgKCkgPT4gY3VzdG9tQXV0aEltcGwsIFwiUFJJVkFURVwiIC8qIENvbXBvbmVudFR5cGUuUFJJVkFURSAqLykpO1xyXG4gICAgbGV0IGFwcENoZWNrUHJvdmlkZXIgPSB1bmRlZmluZWQ7XHJcbiAgICBpZiAoY3VzdG9tQXBwQ2hlY2tJbXBsKSB7XHJcbiAgICAgICAgYXBwQ2hlY2tQcm92aWRlciA9IG5ldyBQcm92aWRlcignYXBwLWNoZWNrLWludGVybmFsJywgY29udGFpbmVyKTtcclxuICAgICAgICBhcHBDaGVja1Byb3ZpZGVyLnNldENvbXBvbmVudChuZXcgQ29tcG9uZW50KCdhcHAtY2hlY2staW50ZXJuYWwnLCAoKSA9PiBjdXN0b21BcHBDaGVja0ltcGwsIFwiUFJJVkFURVwiIC8qIENvbXBvbmVudFR5cGUuUFJJVkFURSAqLykpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpbnN0YW5jZTogbmV3IERhdGFiYXNlKF9yZXBvTWFuYWdlckRhdGFiYXNlRnJvbUFwcChhcHAsIGF1dGhQcm92aWRlciwgYXBwQ2hlY2tQcm92aWRlciwgdXJsLCBub2RlQWRtaW4pLCBhcHApLFxyXG4gICAgICAgIG5hbWVzcGFjZVxyXG4gICAgfTtcclxufVxuXG52YXIgSU5URVJOQUwgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgaW5pdFN0YW5kYWxvbmU6IGluaXRTdGFuZGFsb25lXG59KTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgU2VydmVyVmFsdWUgPSBEYXRhYmFzZS5TZXJ2ZXJWYWx1ZTtcclxuZnVuY3Rpb24gcmVnaXN0ZXJEYXRhYmFzZShpbnN0YW5jZSkge1xyXG4gICAgLy8gUmVnaXN0ZXIgdGhlIERhdGFiYXNlIFNlcnZpY2Ugd2l0aCB0aGUgJ2ZpcmViYXNlJyBuYW1lc3BhY2UuXHJcbiAgICBpbnN0YW5jZS5JTlRFUk5BTC5yZWdpc3RlckNvbXBvbmVudChuZXcgQ29tcG9uZW50KCdkYXRhYmFzZS1jb21wYXQnLCAoY29udGFpbmVyLCB7IGluc3RhbmNlSWRlbnRpZmllcjogdXJsIH0pID0+IHtcclxuICAgICAgICAvKiBEZXBlbmRlbmNpZXMgKi9cclxuICAgICAgICAvLyBnZXRJbW1lZGlhdGUgZm9yIEZpcmViYXNlQXBwIHdpbGwgYWx3YXlzIHN1Y2NlZWRcclxuICAgICAgICBjb25zdCBhcHAgPSBjb250YWluZXIuZ2V0UHJvdmlkZXIoJ2FwcC1jb21wYXQnKS5nZXRJbW1lZGlhdGUoKTtcclxuICAgICAgICBjb25zdCBkYXRhYmFzZUV4cCA9IGNvbnRhaW5lclxyXG4gICAgICAgICAgICAuZ2V0UHJvdmlkZXIoJ2RhdGFiYXNlJylcclxuICAgICAgICAgICAgLmdldEltbWVkaWF0ZSh7IGlkZW50aWZpZXI6IHVybCB9KTtcclxuICAgICAgICByZXR1cm4gbmV3IERhdGFiYXNlKGRhdGFiYXNlRXhwLCBhcHApO1xyXG4gICAgfSwgXCJQVUJMSUNcIiAvKiBDb21wb25lbnRUeXBlLlBVQkxJQyAqLylcclxuICAgICAgICAuc2V0U2VydmljZVByb3BzKFxyXG4gICAgLy8gZmlyZWJhc2UuZGF0YWJhc2UgbmFtZXNwYWNlIHByb3BlcnRpZXNcclxuICAgIHtcclxuICAgICAgICBSZWZlcmVuY2UsXHJcbiAgICAgICAgUXVlcnksXHJcbiAgICAgICAgRGF0YWJhc2UsXHJcbiAgICAgICAgRGF0YVNuYXBzaG90LFxyXG4gICAgICAgIGVuYWJsZUxvZ2dpbmcsXHJcbiAgICAgICAgSU5URVJOQUwsXHJcbiAgICAgICAgU2VydmVyVmFsdWVcclxuICAgIH0pXHJcbiAgICAgICAgLnNldE11bHRpcGxlSW5zdGFuY2VzKHRydWUpKTtcclxuICAgIGluc3RhbmNlLnJlZ2lzdGVyVmVyc2lvbihuYW1lLCB2ZXJzaW9uLCAnbm9kZScpO1xyXG59XHJcbnJlZ2lzdGVyRGF0YWJhc2UoZmlyZWJhc2UpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiZmlyZWJhc2UiLCJDb21wb25lbnRDb250YWluZXIiLCJQcm92aWRlciIsIkNvbXBvbmVudCIsIl92YWxpZGF0ZVBhdGhTdHJpbmciLCJvbkNoaWxkTW92ZWQiLCJvbkNoaWxkQ2hhbmdlZCIsIm9uQ2hpbGRSZW1vdmVkIiwib25DaGlsZEFkZGVkIiwib25WYWx1ZSIsIm9mZiIsImdldCIsInF1ZXJ5IiwibGltaXRUb0ZpcnN0IiwibGltaXRUb0xhc3QiLCJvcmRlckJ5Q2hpbGQiLCJvcmRlckJ5S2V5Iiwib3JkZXJCeVByaW9yaXR5Iiwib3JkZXJCeVZhbHVlIiwic3RhcnRBdCIsInN0YXJ0QWZ0ZXIiLCJlbmRBdCIsImVuZEJlZm9yZSIsImVxdWFsVG8iLCJfUmVmZXJlbmNlSW1wbCIsIl9RdWVyeUltcGwiLCJfUXVlcnlQYXJhbXMiLCJjaGlsZCIsInNldCIsIl92YWxpZGF0ZVdyaXRhYmxlUGF0aCIsInVwZGF0ZSIsInNldFdpdGhQcmlvcml0eSIsInJlbW92ZSIsInJ1blRyYW5zYWN0aW9uIiwic2V0UHJpb3JpdHkiLCJwdXNoIiwiT25EaXNjb25uZWN0IiwiT25EaXNjb25uZWN0JDEiLCJmb3JjZVdlYlNvY2tldHMiLCJmb3JjZUxvbmdQb2xsaW5nIiwiY29ubmVjdERhdGFiYXNlRW11bGF0b3IiLCJyZWZGcm9tVVJMIiwicmVmIiwiZ29PZmZsaW5lIiwiZ29PbmxpbmUiLCJzZXJ2ZXJUaW1lc3RhbXAiLCJpbmNyZW1lbnQiLCJfc2V0U0RLVmVyc2lvbiIsIl9yZXBvTWFuYWdlckRhdGFiYXNlRnJvbUFwcCIsImVuYWJsZUxvZ2dpbmciLCJlcnJvclByZWZpeCIsInZhbGlkYXRlQXJnQ291bnQiLCJ2YWxpZGF0ZUNhbGxiYWNrIiwidmFsaWRhdGVDb250ZXh0T2JqZWN0IiwiRGVmZXJyZWQiLCJMb2dnZXIiLCJuYW1lIiwidmVyc2lvbiIsImxvZ0NsaWVudCIsIndhcm4iLCJtc2ciLCJtZXNzYWdlIiwidmFsaWRhdGVCb29sZWFuIiwiZm5OYW1lIiwiYXJndW1lbnROYW1lIiwiYm9vbCIsIm9wdGlvbmFsIiwidW5kZWZpbmVkIiwiRXJyb3IiLCJ2YWxpZGF0ZUV2ZW50VHlwZSIsImV2ZW50VHlwZSIsImNvbnN0cnVjdG9yIiwiX2RlbGVnYXRlIiwiY2FuY2VsIiwib25Db21wbGV0ZSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInJlc3VsdCIsInRoZW4iLCJlcnJvciIsInZhbHVlIiwicHJpb3JpdHkiLCJvYmplY3RUb01lcmdlIiwiQXJyYXkiLCJpc0FycmF5IiwibmV3T2JqZWN0VG9NZXJnZSIsImkiLCJUcmFuc2FjdGlvblJlc3VsdCIsImNvbW1pdHRlZCIsInNuYXBzaG90IiwidG9KU09OIiwiRGF0YVNuYXBzaG90IiwiX2RhdGFiYXNlIiwidmFsIiwiZXhwb3J0VmFsIiwiZXhpc3RzIiwicGF0aCIsIlN0cmluZyIsImhhc0NoaWxkIiwiZ2V0UHJpb3JpdHkiLCJmb3JFYWNoIiwiYWN0aW9uIiwiZXhwRGF0YVNuYXBzaG90IiwiaGFzQ2hpbGRyZW4iLCJrZXkiLCJudW1DaGlsZHJlbiIsInNpemUiLCJnZXRSZWYiLCJSZWZlcmVuY2UiLCJRdWVyeSIsImRhdGFiYXNlIiwib24iLCJjYWxsYmFjayIsImNhbmNlbENhbGxiYWNrT3JDb250ZXh0IiwiY29udGV4dCIsIl9hIiwicmV0IiwiZ2V0Q2FuY2VsQW5kQ29udGV4dEFyZ3NfIiwidmFsdWVDYWxsYmFjayIsImV4cFNuYXBzaG90IiwicHJldmlvdXNDaGlsZE5hbWUiLCJjYWxsIiwidXNlckNhbGxiYWNrIiwiY2FuY2VsQ2FsbGJhY2siLCJiaW5kIiwib25jZSIsImZhaWx1cmVDYWxsYmFja09yQ29udGV4dCIsImRlZmVycmVkIiwicmVzb2x2ZSIsInJlamVjdCIsIm9ubHlPbmNlIiwicHJvbWlzZSIsImxpbWl0IiwidG9TdHJpbmciLCJpc0VxdWFsIiwib3RoZXIiLCJjYW5jZWxPckNvbnRleHQiLCJfcmVwbyIsIl9wYXRoIiwiZ2V0S2V5IiwicGF0aFN0cmluZyIsImdldFBhcmVudCIsInBhcmVudCIsImdldFJvb3QiLCJyb290IiwibmV3VmFsIiwidmFsdWVzIiwibmV3UHJpb3JpdHkiLCJ0cmFuc2FjdGlvbiIsInRyYW5zYWN0aW9uVXBkYXRlIiwiYXBwbHlMb2NhbGx5IiwidHJhbnNhY3Rpb25SZXN1bHQiLCJleHBQcm9taXNlIiwiZXhwUmVmIiwiY2F0Y2giLCJvbkRpc2Nvbm5lY3QiLCJEYXRhYmFzZSIsImFwcCIsIklOVEVSTkFMIiwiZGVsZXRlIiwiX2RlbGV0ZSIsInVzZUVtdWxhdG9yIiwiaG9zdCIsInBvcnQiLCJvcHRpb25zIiwiY2hpbGRSZWYiLCJ1cmwiLCJhcGlOYW1lIiwiU2VydmVyVmFsdWUiLCJUSU1FU1RBTVAiLCJkZWx0YSIsImluaXRTdGFuZGFsb25lIiwiY3VzdG9tQXV0aEltcGwiLCJjdXN0b21BcHBDaGVja0ltcGwiLCJuYW1lc3BhY2UiLCJub2RlQWRtaW4iLCJjb250YWluZXIiLCJhdXRoUHJvdmlkZXIiLCJzZXRDb21wb25lbnQiLCJhcHBDaGVja1Byb3ZpZGVyIiwiaW5zdGFuY2UiLCJPYmplY3QiLCJmcmVlemUiLCJfX3Byb3RvX18iLCJyZWdpc3RlckRhdGFiYXNlIiwicmVnaXN0ZXJDb21wb25lbnQiLCJpbnN0YW5jZUlkZW50aWZpZXIiLCJnZXRQcm92aWRlciIsImdldEltbWVkaWF0ZSIsImRhdGFiYXNlRXhwIiwiaWRlbnRpZmllciIsInNldFNlcnZpY2VQcm9wcyIsInNldE11bHRpcGxlSW5zdGFuY2VzIiwicmVnaXN0ZXJWZXJzaW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/database-compat/dist/node-esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/database/dist/node-esm/index.node.esm.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@firebase/database/dist/node-esm/index.node.esm.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataSnapshot: () => (/* binding */ DataSnapshot),\n/* harmony export */   Database: () => (/* binding */ Database),\n/* harmony export */   OnDisconnect: () => (/* binding */ OnDisconnect),\n/* harmony export */   QueryConstraint: () => (/* binding */ QueryConstraint),\n/* harmony export */   TransactionResult: () => (/* binding */ TransactionResult),\n/* harmony export */   _QueryImpl: () => (/* binding */ QueryImpl),\n/* harmony export */   _QueryParams: () => (/* binding */ QueryParams),\n/* harmony export */   _ReferenceImpl: () => (/* binding */ ReferenceImpl),\n/* harmony export */   _TEST_ACCESS_forceRestClient: () => (/* binding */ forceRestClient),\n/* harmony export */   _TEST_ACCESS_hijackHash: () => (/* binding */ hijackHash),\n/* harmony export */   _initStandalone: () => (/* binding */ _initStandalone),\n/* harmony export */   _repoManagerDatabaseFromApp: () => (/* binding */ repoManagerDatabaseFromApp),\n/* harmony export */   _setSDKVersion: () => (/* binding */ setSDKVersion),\n/* harmony export */   _validatePathString: () => (/* binding */ validatePathString),\n/* harmony export */   _validateWritablePath: () => (/* binding */ validateWritablePath),\n/* harmony export */   child: () => (/* binding */ child),\n/* harmony export */   connectDatabaseEmulator: () => (/* binding */ connectDatabaseEmulator),\n/* harmony export */   enableLogging: () => (/* binding */ enableLogging),\n/* harmony export */   endAt: () => (/* binding */ endAt),\n/* harmony export */   endBefore: () => (/* binding */ endBefore),\n/* harmony export */   equalTo: () => (/* binding */ equalTo),\n/* harmony export */   forceLongPolling: () => (/* binding */ forceLongPolling),\n/* harmony export */   forceWebSockets: () => (/* binding */ forceWebSockets),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   getDatabase: () => (/* binding */ getDatabase),\n/* harmony export */   goOffline: () => (/* binding */ goOffline),\n/* harmony export */   goOnline: () => (/* binding */ goOnline),\n/* harmony export */   increment: () => (/* binding */ increment),\n/* harmony export */   limitToFirst: () => (/* binding */ limitToFirst),\n/* harmony export */   limitToLast: () => (/* binding */ limitToLast),\n/* harmony export */   off: () => (/* binding */ off),\n/* harmony export */   onChildAdded: () => (/* binding */ onChildAdded),\n/* harmony export */   onChildChanged: () => (/* binding */ onChildChanged),\n/* harmony export */   onChildMoved: () => (/* binding */ onChildMoved),\n/* harmony export */   onChildRemoved: () => (/* binding */ onChildRemoved),\n/* harmony export */   onDisconnect: () => (/* binding */ onDisconnect),\n/* harmony export */   onValue: () => (/* binding */ onValue),\n/* harmony export */   orderByChild: () => (/* binding */ orderByChild),\n/* harmony export */   orderByKey: () => (/* binding */ orderByKey),\n/* harmony export */   orderByPriority: () => (/* binding */ orderByPriority),\n/* harmony export */   orderByValue: () => (/* binding */ orderByValue),\n/* harmony export */   push: () => (/* binding */ push),\n/* harmony export */   query: () => (/* binding */ query),\n/* harmony export */   ref: () => (/* binding */ ref),\n/* harmony export */   refFromURL: () => (/* binding */ refFromURL),\n/* harmony export */   remove: () => (/* binding */ remove),\n/* harmony export */   runTransaction: () => (/* binding */ runTransaction),\n/* harmony export */   serverTimestamp: () => (/* binding */ serverTimestamp),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   setPriority: () => (/* binding */ setPriority),\n/* harmony export */   setWithPriority: () => (/* binding */ setWithPriority),\n/* harmony export */   startAfter: () => (/* binding */ startAfter),\n/* harmony export */   startAt: () => (/* binding */ startAt),\n/* harmony export */   update: () => (/* binding */ update)\n/* harmony export */ });\n/* harmony import */ var faye_websocket__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! faye-websocket */ \"(ssr)/./node_modules/faye-websocket/lib/faye/websocket.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/logger */ \"(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @firebase/app */ \"(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n\n\n\n\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const PROTOCOL_VERSION = \"5\";\nconst VERSION_PARAM = \"v\";\nconst TRANSPORT_SESSION_PARAM = \"s\";\nconst REFERER_PARAM = \"r\";\nconst FORGE_REF = \"f\";\n// Matches console.firebase.google.com, firebase-console-*.corp.google.com and\n// firebase.corp.google.com\nconst FORGE_DOMAIN_RE = /(console\\.firebase|firebase-console-\\w+\\.corp|firebase\\.corp)\\.google\\.com/;\nconst LAST_SESSION_PARAM = \"ls\";\nconst APPLICATION_ID_PARAM = \"p\";\nconst APP_CHECK_TOKEN_PARAM = \"ac\";\nconst WEBSOCKET = \"websocket\";\nconst LONG_POLLING = \"long_polling\";\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Wraps a DOM Storage object and:\r\n * - automatically encode objects as JSON strings before storing them to allow us to store arbitrary types.\r\n * - prefixes names with \"firebase:\" to avoid collisions with app data.\r\n *\r\n * We automatically (see storage.js) create two such wrappers, one for sessionStorage,\r\n * and one for localStorage.\r\n *\r\n */ class DOMStorageWrapper {\n    /**\r\n     * @param domStorage_ - The underlying storage object (e.g. localStorage or sessionStorage)\r\n     */ constructor(domStorage_){\n        this.domStorage_ = domStorage_;\n        // Use a prefix to avoid collisions with other stuff saved by the app.\n        this.prefix_ = \"firebase:\";\n    }\n    /**\r\n     * @param key - The key to save the value under\r\n     * @param value - The value being stored, or null to remove the key.\r\n     */ set(key, value) {\n        if (value == null) {\n            this.domStorage_.removeItem(this.prefixedName_(key));\n        } else {\n            this.domStorage_.setItem(this.prefixedName_(key), (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(value));\n        }\n    }\n    /**\r\n     * @returns The value that was stored under this key, or null\r\n     */ get(key) {\n        const storedVal = this.domStorage_.getItem(this.prefixedName_(key));\n        if (storedVal == null) {\n            return null;\n        } else {\n            return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.jsonEval)(storedVal);\n        }\n    }\n    remove(key) {\n        this.domStorage_.removeItem(this.prefixedName_(key));\n    }\n    prefixedName_(name) {\n        return this.prefix_ + name;\n    }\n    toString() {\n        return this.domStorage_.toString();\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * An in-memory storage implementation that matches the API of DOMStorageWrapper\r\n * (TODO: create interface for both to implement).\r\n */ class MemoryStorage {\n    constructor(){\n        this.cache_ = {};\n        this.isInMemoryStorage = true;\n    }\n    set(key, value) {\n        if (value == null) {\n            delete this.cache_[key];\n        } else {\n            this.cache_[key] = value;\n        }\n    }\n    get(key) {\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.contains)(this.cache_, key)) {\n            return this.cache_[key];\n        }\n        return null;\n    }\n    remove(key) {\n        delete this.cache_[key];\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Helper to create a DOMStorageWrapper or else fall back to MemoryStorage.\r\n * TODO: Once MemoryStorage and DOMStorageWrapper have a shared interface this method annotation should change\r\n * to reflect this type\r\n *\r\n * @param domStorageName - Name of the underlying storage object\r\n *   (e.g. 'localStorage' or 'sessionStorage').\r\n * @returns Turning off type information until a common interface is defined.\r\n */ const createStoragefor = function(domStorageName) {\n    try {\n        // NOTE: just accessing \"localStorage\" or \"window['localStorage']\" may throw a security exception,\n        // so it must be inside the try/catch.\n        if (false) {}\n    } catch (e) {}\n    // Failed to create wrapper.  Just return in-memory storage.\n    // TODO: log?\n    return new MemoryStorage();\n};\n/** A storage object that lasts across sessions */ const PersistentStorage = createStoragefor(\"localStorage\");\n/** A storage object that only lasts one session */ const SessionStorage = createStoragefor(\"sessionStorage\");\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const logClient = new _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.Logger(\"@firebase/database\");\n/**\r\n * Returns a locally-unique ID (generated by just incrementing up from 0 each time its called).\r\n */ const LUIDGenerator = function() {\n    let id = 1;\n    return function() {\n        return id++;\n    };\n}();\n/**\r\n * Sha1 hash of the input string\r\n * @param str - The string to hash\r\n * @returns {!string} The resulting hash\r\n */ const sha1 = function(str) {\n    const utf8Bytes = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringToByteArray)(str);\n    const sha1 = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Sha1();\n    sha1.update(utf8Bytes);\n    const sha1Bytes = sha1.digest();\n    return _firebase_util__WEBPACK_IMPORTED_MODULE_1__.base64.encodeByteArray(sha1Bytes);\n};\nconst buildLogMessage_ = function(...varArgs) {\n    let message = \"\";\n    for(let i = 0; i < varArgs.length; i++){\n        const arg = varArgs[i];\n        if (Array.isArray(arg) || arg && typeof arg === \"object\" && // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        typeof arg.length === \"number\") {\n            message += buildLogMessage_.apply(null, arg);\n        } else if (typeof arg === \"object\") {\n            message += (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(arg);\n        } else {\n            message += arg;\n        }\n        message += \" \";\n    }\n    return message;\n};\n/**\r\n * Use this for all debug messages in Firebase.\r\n */ let logger = null;\n/**\r\n * Flag to check for log availability on first log message\r\n */ let firstLog_ = true;\n/**\r\n * The implementation of Firebase.enableLogging (defined here to break dependencies)\r\n * @param logger_ - A flag to turn on logging, or a custom logger\r\n * @param persistent - Whether or not to persist logging settings across refreshes\r\n */ const enableLogging$1 = function(logger_, persistent) {\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(!persistent || logger_ === true || logger_ === false, \"Can't turn on custom loggers persistently.\");\n    if (logger_ === true) {\n        logClient.logLevel = _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.VERBOSE;\n        logger = logClient.log.bind(logClient);\n        if (persistent) {\n            SessionStorage.set(\"logging_enabled\", true);\n        }\n    } else if (typeof logger_ === \"function\") {\n        logger = logger_;\n    } else {\n        logger = null;\n        SessionStorage.remove(\"logging_enabled\");\n    }\n};\nconst log = function(...varArgs) {\n    if (firstLog_ === true) {\n        firstLog_ = false;\n        if (logger === null && SessionStorage.get(\"logging_enabled\") === true) {\n            enableLogging$1(true);\n        }\n    }\n    if (logger) {\n        const message = buildLogMessage_.apply(null, varArgs);\n        logger(message);\n    }\n};\nconst logWrapper = function(prefix) {\n    return function(...varArgs) {\n        log(prefix, ...varArgs);\n    };\n};\nconst error = function(...varArgs) {\n    const message = \"FIREBASE INTERNAL ERROR: \" + buildLogMessage_(...varArgs);\n    logClient.error(message);\n};\nconst fatal = function(...varArgs) {\n    const message = `FIREBASE FATAL ERROR: ${buildLogMessage_(...varArgs)}`;\n    logClient.error(message);\n    throw new Error(message);\n};\nconst warn = function(...varArgs) {\n    const message = \"FIREBASE WARNING: \" + buildLogMessage_(...varArgs);\n    logClient.warn(message);\n};\n/**\r\n * Logs a warning if the containing page uses https. Called when a call to new Firebase\r\n * does not use https.\r\n */ const warnIfPageIsSecure = function() {\n    // Be very careful accessing browser globals. Who knows what may or may not exist.\n    if (false) {}\n};\n/**\r\n * Returns true if data is NaN, or +/- Infinity.\r\n */ const isInvalidJSONNumber = function(data) {\n    return typeof data === \"number\" && (data !== data || // NaN\n    data === Number.POSITIVE_INFINITY || data === Number.NEGATIVE_INFINITY);\n};\nconst executeWhenDOMReady = function(fn) {\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isNodeSdk)() || document.readyState === \"complete\") {\n        fn();\n    } else {\n        // Modeled after jQuery. Try DOMContentLoaded and onreadystatechange (which\n        // fire before onload), but fall back to onload.\n        let called = false;\n        const wrappedFn = function() {\n            if (!document.body) {\n                setTimeout(wrappedFn, Math.floor(10));\n                return;\n            }\n            if (!called) {\n                called = true;\n                fn();\n            }\n        };\n        if (document.addEventListener) {\n            document.addEventListener(\"DOMContentLoaded\", wrappedFn, false);\n            // fallback to onload.\n            window.addEventListener(\"load\", wrappedFn, false);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } else if (document.attachEvent) {\n            // IE.\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            document.attachEvent(\"onreadystatechange\", ()=>{\n                if (document.readyState === \"complete\") {\n                    wrappedFn();\n                }\n            });\n            // fallback to onload.\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            window.attachEvent(\"onload\", wrappedFn);\n        // jQuery has an extra hack for IE that we could employ (based on\n        // http://javascript.nwbox.com/IEContentLoaded/) But it looks really old.\n        // I'm hoping we don't need it.\n        }\n    }\n};\n/**\r\n * Minimum key name. Invalid for actual data, used as a marker to sort before any valid names\r\n */ const MIN_NAME = \"[MIN_NAME]\";\n/**\r\n * Maximum key name. Invalid for actual data, used as a marker to sort above any valid names\r\n */ const MAX_NAME = \"[MAX_NAME]\";\n/**\r\n * Compares valid Firebase key names, plus min and max name\r\n */ const nameCompare = function(a, b) {\n    if (a === b) {\n        return 0;\n    } else if (a === MIN_NAME || b === MAX_NAME) {\n        return -1;\n    } else if (b === MIN_NAME || a === MAX_NAME) {\n        return 1;\n    } else {\n        const aAsInt = tryParseInt(a), bAsInt = tryParseInt(b);\n        if (aAsInt !== null) {\n            if (bAsInt !== null) {\n                return aAsInt - bAsInt === 0 ? a.length - b.length : aAsInt - bAsInt;\n            } else {\n                return -1;\n            }\n        } else if (bAsInt !== null) {\n            return 1;\n        } else {\n            return a < b ? -1 : 1;\n        }\n    }\n};\n/**\r\n * @returns {!number} comparison result.\r\n */ const stringCompare = function(a, b) {\n    if (a === b) {\n        return 0;\n    } else if (a < b) {\n        return -1;\n    } else {\n        return 1;\n    }\n};\nconst requireKey = function(key, obj) {\n    if (obj && key in obj) {\n        return obj[key];\n    } else {\n        throw new Error(\"Missing required key (\" + key + \") in object: \" + (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(obj));\n    }\n};\nconst ObjectToUniqueKey = function(obj) {\n    if (typeof obj !== \"object\" || obj === null) {\n        return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(obj);\n    }\n    const keys = [];\n    // eslint-disable-next-line guard-for-in\n    for(const k in obj){\n        keys.push(k);\n    }\n    // Export as json, but with the keys sorted.\n    keys.sort();\n    let key = \"{\";\n    for(let i = 0; i < keys.length; i++){\n        if (i !== 0) {\n            key += \",\";\n        }\n        key += (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(keys[i]);\n        key += \":\";\n        key += ObjectToUniqueKey(obj[keys[i]]);\n    }\n    key += \"}\";\n    return key;\n};\n/**\r\n * Splits a string into a number of smaller segments of maximum size\r\n * @param str - The string\r\n * @param segsize - The maximum number of chars in the string.\r\n * @returns The string, split into appropriately-sized chunks\r\n */ const splitStringBySize = function(str, segsize) {\n    const len = str.length;\n    if (len <= segsize) {\n        return [\n            str\n        ];\n    }\n    const dataSegs = [];\n    for(let c = 0; c < len; c += segsize){\n        if (c + segsize > len) {\n            dataSegs.push(str.substring(c, len));\n        } else {\n            dataSegs.push(str.substring(c, c + segsize));\n        }\n    }\n    return dataSegs;\n};\n/**\r\n * Apply a function to each (key, value) pair in an object or\r\n * apply a function to each (index, value) pair in an array\r\n * @param obj - The object or array to iterate over\r\n * @param fn - The function to apply\r\n */ function each(obj, fn) {\n    for(const key in obj){\n        if (obj.hasOwnProperty(key)) {\n            fn(key, obj[key]);\n        }\n    }\n}\n/**\r\n * Borrowed from http://hg.secondlife.com/llsd/src/tip/js/typedarray.js (MIT License)\r\n * I made one modification at the end and removed the NaN / Infinity\r\n * handling (since it seemed broken [caused an overflow] and we don't need it).  See MJL comments.\r\n * @param v - A double\r\n *\r\n */ const doubleToIEEE754String = function(v) {\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(!isInvalidJSONNumber(v), \"Invalid JSON number\"); // MJL\n    const ebits = 11, fbits = 52;\n    const bias = (1 << ebits - 1) - 1;\n    let s, e, f, ln, i;\n    // Compute sign, exponent, fraction\n    // Skip NaN / Infinity handling --MJL.\n    if (v === 0) {\n        e = 0;\n        f = 0;\n        s = 1 / v === -Infinity ? 1 : 0;\n    } else {\n        s = v < 0;\n        v = Math.abs(v);\n        if (v >= Math.pow(2, 1 - bias)) {\n            // Normalized\n            ln = Math.min(Math.floor(Math.log(v) / Math.LN2), bias);\n            e = ln + bias;\n            f = Math.round(v * Math.pow(2, fbits - ln) - Math.pow(2, fbits));\n        } else {\n            // Denormalized\n            e = 0;\n            f = Math.round(v / Math.pow(2, 1 - bias - fbits));\n        }\n    }\n    // Pack sign, exponent, fraction\n    const bits = [];\n    for(i = fbits; i; i -= 1){\n        bits.push(f % 2 ? 1 : 0);\n        f = Math.floor(f / 2);\n    }\n    for(i = ebits; i; i -= 1){\n        bits.push(e % 2 ? 1 : 0);\n        e = Math.floor(e / 2);\n    }\n    bits.push(s ? 1 : 0);\n    bits.reverse();\n    const str = bits.join(\"\");\n    // Return the data as a hex string. --MJL\n    let hexByteString = \"\";\n    for(i = 0; i < 64; i += 8){\n        let hexByte = parseInt(str.substr(i, 8), 2).toString(16);\n        if (hexByte.length === 1) {\n            hexByte = \"0\" + hexByte;\n        }\n        hexByteString = hexByteString + hexByte;\n    }\n    return hexByteString.toLowerCase();\n};\n/**\r\n * Used to detect if we're in a Chrome content script (which executes in an\r\n * isolated environment where long-polling doesn't work).\r\n */ const isChromeExtensionContentScript = function() {\n    return !!( false && 0);\n};\n/**\r\n * Used to detect if we're in a Windows 8 Store app.\r\n */ const isWindowsStoreApp = function() {\n    // Check for the presence of a couple WinRT globals\n    return typeof Windows === \"object\" && typeof Windows.UI === \"object\";\n};\n/**\r\n * Converts a server error code to a Javascript Error\r\n */ function errorForServerCode(code, query) {\n    let reason = \"Unknown Error\";\n    if (code === \"too_big\") {\n        reason = \"The data requested exceeds the maximum size \" + \"that can be accessed with a single request.\";\n    } else if (code === \"permission_denied\") {\n        reason = \"Client doesn't have permission to access the desired data.\";\n    } else if (code === \"unavailable\") {\n        reason = \"The service is unavailable\";\n    }\n    const error = new Error(code + \" at \" + query._path.toString() + \": \" + reason);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    error.code = code.toUpperCase();\n    return error;\n}\n/**\r\n * Used to test for integer-looking strings\r\n */ const INTEGER_REGEXP_ = new RegExp(\"^-?(0*)\\\\d{1,10}$\");\n/**\r\n * For use in keys, the minimum possible 32-bit integer.\r\n */ const INTEGER_32_MIN = -2147483648;\n/**\r\n * For use in kyes, the maximum possible 32-bit integer.\r\n */ const INTEGER_32_MAX = 2147483647;\n/**\r\n * If the string contains a 32-bit integer, return it.  Else return null.\r\n */ const tryParseInt = function(str) {\n    if (INTEGER_REGEXP_.test(str)) {\n        const intVal = Number(str);\n        if (intVal >= INTEGER_32_MIN && intVal <= INTEGER_32_MAX) {\n            return intVal;\n        }\n    }\n    return null;\n};\n/**\r\n * Helper to run some code but catch any exceptions and re-throw them later.\r\n * Useful for preventing user callbacks from breaking internal code.\r\n *\r\n * Re-throwing the exception from a setTimeout is a little evil, but it's very\r\n * convenient (we don't have to try to figure out when is a safe point to\r\n * re-throw it), and the behavior seems reasonable:\r\n *\r\n * * If you aren't pausing on exceptions, you get an error in the console with\r\n *   the correct stack trace.\r\n * * If you're pausing on all exceptions, the debugger will pause on your\r\n *   exception and then again when we rethrow it.\r\n * * If you're only pausing on uncaught exceptions, the debugger will only pause\r\n *   on us re-throwing it.\r\n *\r\n * @param fn - The code to guard.\r\n */ const exceptionGuard = function(fn) {\n    try {\n        fn();\n    } catch (e) {\n        // Re-throw exception when it's safe.\n        setTimeout(()=>{\n            // It used to be that \"throw e\" would result in a good console error with\n            // relevant context, but as of Chrome 39, you just get the firebase.js\n            // file/line number where we re-throw it, which is useless. So we log\n            // e.stack explicitly.\n            const stack = e.stack || \"\";\n            warn(\"Exception was thrown by user callback.\", stack);\n            throw e;\n        }, Math.floor(0));\n    }\n};\n/**\r\n * @returns {boolean} true if we think we're currently being crawled.\r\n */ const beingCrawled = function() {\n    const userAgent =  false || \"\";\n    // For now we whitelist the most popular crawlers.  We should refine this to be the set of crawlers we\n    // believe to support JavaScript/AJAX rendering.\n    // NOTE: Google Webmaster Tools doesn't really belong, but their \"This is how a visitor to your website\n    // would have seen the page\" is flaky if we don't treat it as a crawler.\n    return userAgent.search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i) >= 0;\n};\n/**\r\n * Same as setTimeout() except on Node.JS it will /not/ prevent the process from exiting.\r\n *\r\n * It is removed with clearTimeout() as normal.\r\n *\r\n * @param fn - Function to run.\r\n * @param time - Milliseconds to wait before running.\r\n * @returns The setTimeout() return value.\r\n */ const setTimeoutNonBlocking = function(fn, time) {\n    const timeout = setTimeout(fn, time);\n    // Note: at the time of this comment, unrefTimer is under the unstable set of APIs. Run with --unstable to enable the API.\n    if (typeof timeout === \"number\" && // @ts-ignore Is only defined in Deno environments.\n    typeof Deno !== \"undefined\" && // @ts-ignore Deno and unrefTimer are only defined in Deno environments.\n    Deno[\"unrefTimer\"]) {\n        // @ts-ignore Deno and unrefTimer are only defined in Deno environments.\n        Deno.unrefTimer(timeout);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } else if (typeof timeout === \"object\" && timeout[\"unref\"]) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        timeout[\"unref\"]();\n    }\n    return timeout;\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * A class that holds metadata about a Repo object\r\n */ class RepoInfo {\n    /**\r\n     * @param host - Hostname portion of the url for the repo\r\n     * @param secure - Whether or not this repo is accessed over ssl\r\n     * @param namespace - The namespace represented by the repo\r\n     * @param webSocketOnly - Whether to prefer websockets over all other transports (used by Nest).\r\n     * @param nodeAdmin - Whether this instance uses Admin SDK credentials\r\n     * @param persistenceKey - Override the default session persistence storage key\r\n     */ constructor(host, secure, namespace, webSocketOnly, nodeAdmin = false, persistenceKey = \"\", includeNamespaceInQueryParams = false, isUsingEmulator = false){\n        this.secure = secure;\n        this.namespace = namespace;\n        this.webSocketOnly = webSocketOnly;\n        this.nodeAdmin = nodeAdmin;\n        this.persistenceKey = persistenceKey;\n        this.includeNamespaceInQueryParams = includeNamespaceInQueryParams;\n        this.isUsingEmulator = isUsingEmulator;\n        this._host = host.toLowerCase();\n        this._domain = this._host.substr(this._host.indexOf(\".\") + 1);\n        this.internalHost = PersistentStorage.get(\"host:\" + host) || this._host;\n    }\n    isCacheableHost() {\n        return this.internalHost.substr(0, 2) === \"s-\";\n    }\n    isCustomHost() {\n        return this._domain !== \"firebaseio.com\" && this._domain !== \"firebaseio-demo.com\";\n    }\n    get host() {\n        return this._host;\n    }\n    set host(newHost) {\n        if (newHost !== this.internalHost) {\n            this.internalHost = newHost;\n            if (this.isCacheableHost()) {\n                PersistentStorage.set(\"host:\" + this._host, this.internalHost);\n            }\n        }\n    }\n    toString() {\n        let str = this.toURLString();\n        if (this.persistenceKey) {\n            str += \"<\" + this.persistenceKey + \">\";\n        }\n        return str;\n    }\n    toURLString() {\n        const protocol = this.secure ? \"https://\" : \"http://\";\n        const query = this.includeNamespaceInQueryParams ? `?ns=${this.namespace}` : \"\";\n        return `${protocol}${this.host}/${query}`;\n    }\n}\nfunction repoInfoNeedsQueryParam(repoInfo) {\n    return repoInfo.host !== repoInfo.internalHost || repoInfo.isCustomHost() || repoInfo.includeNamespaceInQueryParams;\n}\n/**\r\n * Returns the websocket URL for this repo\r\n * @param repoInfo - RepoInfo object\r\n * @param type - of connection\r\n * @param params - list\r\n * @returns The URL for this repo\r\n */ function repoInfoConnectionURL(repoInfo, type, params) {\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(typeof type === \"string\", \"typeof type must == string\");\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(typeof params === \"object\", \"typeof params must == object\");\n    let connURL;\n    if (type === WEBSOCKET) {\n        connURL = (repoInfo.secure ? \"wss://\" : \"ws://\") + repoInfo.internalHost + \"/.ws?\";\n    } else if (type === LONG_POLLING) {\n        connURL = (repoInfo.secure ? \"https://\" : \"http://\") + repoInfo.internalHost + \"/.lp?\";\n    } else {\n        throw new Error(\"Unknown connection type: \" + type);\n    }\n    if (repoInfoNeedsQueryParam(repoInfo)) {\n        params[\"ns\"] = repoInfo.namespace;\n    }\n    const pairs = [];\n    each(params, (key, value)=>{\n        pairs.push(key + \"=\" + value);\n    });\n    return connURL + pairs.join(\"&\");\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Tracks a collection of stats.\r\n */ class StatsCollection {\n    constructor(){\n        this.counters_ = {};\n    }\n    incrementCounter(name, amount = 1) {\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.contains)(this.counters_, name)) {\n            this.counters_[name] = 0;\n        }\n        this.counters_[name] += amount;\n    }\n    get() {\n        return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.deepCopy)(this.counters_);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const collections = {};\nconst reporters = {};\nfunction statsManagerGetCollection(repoInfo) {\n    const hashString = repoInfo.toString();\n    if (!collections[hashString]) {\n        collections[hashString] = new StatsCollection();\n    }\n    return collections[hashString];\n}\nfunction statsManagerGetOrCreateReporter(repoInfo, creatorFunction) {\n    const hashString = repoInfo.toString();\n    if (!reporters[hashString]) {\n        reporters[hashString] = creatorFunction();\n    }\n    return reporters[hashString];\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /** The semver (www.semver.org) version of the SDK. */ let SDK_VERSION = \"\";\n/**\r\n * SDK_VERSION should be set before any database instance is created\r\n * @internal\r\n */ function setSDKVersion(version) {\n    SDK_VERSION = version;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const WEBSOCKET_MAX_FRAME_SIZE = 16384;\nconst WEBSOCKET_KEEPALIVE_INTERVAL = 45000;\nlet WebSocketImpl = null;\nif (typeof MozWebSocket !== \"undefined\") {\n    WebSocketImpl = MozWebSocket;\n} else if (typeof WebSocket !== \"undefined\") {\n    WebSocketImpl = WebSocket;\n}\nfunction setWebSocketImpl(impl) {\n    WebSocketImpl = impl;\n}\n/**\r\n * Create a new websocket connection with the given callbacks.\r\n */ class WebSocketConnection {\n    /**\r\n     * @param connId identifier for this transport\r\n     * @param repoInfo The info for the websocket endpoint.\r\n     * @param applicationId The Firebase App ID for this project.\r\n     * @param appCheckToken The App Check Token for this client.\r\n     * @param authToken The Auth Token for this client.\r\n     * @param transportSessionId Optional transportSessionId if this is connecting\r\n     * to an existing transport session\r\n     * @param lastSessionId Optional lastSessionId if there was a previous\r\n     * connection\r\n     */ constructor(connId, repoInfo, applicationId, appCheckToken, authToken, transportSessionId, lastSessionId){\n        this.connId = connId;\n        this.applicationId = applicationId;\n        this.appCheckToken = appCheckToken;\n        this.authToken = authToken;\n        this.keepaliveTimer = null;\n        this.frames = null;\n        this.totalFrames = 0;\n        this.bytesSent = 0;\n        this.bytesReceived = 0;\n        this.log_ = logWrapper(this.connId);\n        this.stats_ = statsManagerGetCollection(repoInfo);\n        this.connURL = WebSocketConnection.connectionURL_(repoInfo, transportSessionId, lastSessionId, appCheckToken, applicationId);\n        this.nodeAdmin = repoInfo.nodeAdmin;\n    }\n    /**\r\n     * @param repoInfo - The info for the websocket endpoint.\r\n     * @param transportSessionId - Optional transportSessionId if this is connecting to an existing transport\r\n     *                                         session\r\n     * @param lastSessionId - Optional lastSessionId if there was a previous connection\r\n     * @returns connection url\r\n     */ static connectionURL_(repoInfo, transportSessionId, lastSessionId, appCheckToken, applicationId) {\n        const urlParams = {};\n        urlParams[VERSION_PARAM] = PROTOCOL_VERSION;\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isNodeSdk)() && typeof location !== \"undefined\" && location.hostname && FORGE_DOMAIN_RE.test(location.hostname)) {\n            urlParams[REFERER_PARAM] = FORGE_REF;\n        }\n        if (transportSessionId) {\n            urlParams[TRANSPORT_SESSION_PARAM] = transportSessionId;\n        }\n        if (lastSessionId) {\n            urlParams[LAST_SESSION_PARAM] = lastSessionId;\n        }\n        if (appCheckToken) {\n            urlParams[APP_CHECK_TOKEN_PARAM] = appCheckToken;\n        }\n        if (applicationId) {\n            urlParams[APPLICATION_ID_PARAM] = applicationId;\n        }\n        return repoInfoConnectionURL(repoInfo, WEBSOCKET, urlParams);\n    }\n    /**\r\n     * @param onMessage - Callback when messages arrive\r\n     * @param onDisconnect - Callback with connection lost.\r\n     */ open(onMessage, onDisconnect) {\n        this.onDisconnect = onDisconnect;\n        this.onMessage = onMessage;\n        this.log_(\"Websocket connecting to \" + this.connURL);\n        this.everConnected_ = false;\n        // Assume failure until proven otherwise.\n        PersistentStorage.set(\"previous_websocket_failure\", true);\n        try {\n            let options;\n            if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isNodeSdk)()) {\n                const device = this.nodeAdmin ? \"AdminNode\" : \"Node\";\n                // UA Format: Firebase/<wire_protocol>/<sdk_version>/<platform>/<device>\n                options = {\n                    headers: {\n                        \"User-Agent\": `Firebase/${PROTOCOL_VERSION}/${SDK_VERSION}/${process.platform}/${device}`,\n                        \"X-Firebase-GMPID\": this.applicationId || \"\"\n                    }\n                };\n                // If using Node with admin creds, AppCheck-related checks are unnecessary.\n                // Note that we send the credentials here even if they aren't admin credentials, which is\n                // not a problem.\n                // Note that this header is just used to bypass appcheck, and the token should still be sent\n                // through the websocket connection once it is established.\n                if (this.authToken) {\n                    options.headers[\"Authorization\"] = `Bearer ${this.authToken}`;\n                }\n                if (this.appCheckToken) {\n                    options.headers[\"X-Firebase-AppCheck\"] = this.appCheckToken;\n                }\n                // Plumb appropriate http_proxy environment variable into faye-websocket if it exists.\n                const env = process[\"env\"];\n                const proxy = this.connURL.indexOf(\"wss://\") === 0 ? env[\"HTTPS_PROXY\"] || env[\"https_proxy\"] : env[\"HTTP_PROXY\"] || env[\"http_proxy\"];\n                if (proxy) {\n                    options[\"proxy\"] = {\n                        origin: proxy\n                    };\n                }\n            }\n            this.mySock = new WebSocketImpl(this.connURL, [], options);\n        } catch (e) {\n            this.log_(\"Error instantiating WebSocket.\");\n            const error = e.message || e.data;\n            if (error) {\n                this.log_(error);\n            }\n            this.onClosed_();\n            return;\n        }\n        this.mySock.onopen = ()=>{\n            this.log_(\"Websocket connected.\");\n            this.everConnected_ = true;\n        };\n        this.mySock.onclose = ()=>{\n            this.log_(\"Websocket connection was disconnected.\");\n            this.mySock = null;\n            this.onClosed_();\n        };\n        this.mySock.onmessage = (m)=>{\n            this.handleIncomingFrame(m);\n        };\n        this.mySock.onerror = (e)=>{\n            this.log_(\"WebSocket error.  Closing connection.\");\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const error = e.message || e.data;\n            if (error) {\n                this.log_(error);\n            }\n            this.onClosed_();\n        };\n    }\n    /**\r\n     * No-op for websockets, we don't need to do anything once the connection is confirmed as open\r\n     */ start() {}\n    static forceDisallow() {\n        WebSocketConnection.forceDisallow_ = true;\n    }\n    static isAvailable() {\n        let isOldAndroid = false;\n        if (typeof navigator !== \"undefined\" && navigator.userAgent) {\n            const oldAndroidRegex = /Android ([0-9]{0,}\\.[0-9]{0,})/;\n            const oldAndroidMatch = navigator.userAgent.match(oldAndroidRegex);\n            if (oldAndroidMatch && oldAndroidMatch.length > 1) {\n                if (parseFloat(oldAndroidMatch[1]) < 4.4) {\n                    isOldAndroid = true;\n                }\n            }\n        }\n        return !isOldAndroid && WebSocketImpl !== null && !WebSocketConnection.forceDisallow_;\n    }\n    /**\r\n     * Returns true if we previously failed to connect with this transport.\r\n     */ static previouslyFailed() {\n        // If our persistent storage is actually only in-memory storage,\n        // we default to assuming that it previously failed to be safe.\n        return PersistentStorage.isInMemoryStorage || PersistentStorage.get(\"previous_websocket_failure\") === true;\n    }\n    markConnectionHealthy() {\n        PersistentStorage.remove(\"previous_websocket_failure\");\n    }\n    appendFrame_(data) {\n        this.frames.push(data);\n        if (this.frames.length === this.totalFrames) {\n            const fullMess = this.frames.join(\"\");\n            this.frames = null;\n            const jsonMess = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.jsonEval)(fullMess);\n            //handle the message\n            this.onMessage(jsonMess);\n        }\n    }\n    /**\r\n     * @param frameCount - The number of frames we are expecting from the server\r\n     */ handleNewFrameCount_(frameCount) {\n        this.totalFrames = frameCount;\n        this.frames = [];\n    }\n    /**\r\n     * Attempts to parse a frame count out of some text. If it can't, assumes a value of 1\r\n     * @returns Any remaining data to be process, or null if there is none\r\n     */ extractFrameCount_(data) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(this.frames === null, \"We already have a frame buffer\");\n        // TODO: The server is only supposed to send up to 9999 frames (i.e. length <= 4), but that isn't being enforced\n        // currently.  So allowing larger frame counts (length <= 6).  See https://app.asana.com/0/search/8688598998380/8237608042508\n        if (data.length <= 6) {\n            const frameCount = Number(data);\n            if (!isNaN(frameCount)) {\n                this.handleNewFrameCount_(frameCount);\n                return null;\n            }\n        }\n        this.handleNewFrameCount_(1);\n        return data;\n    }\n    /**\r\n     * Process a websocket frame that has arrived from the server.\r\n     * @param mess - The frame data\r\n     */ handleIncomingFrame(mess) {\n        if (this.mySock === null) {\n            return; // Chrome apparently delivers incoming packets even after we .close() the connection sometimes.\n        }\n        const data = mess[\"data\"];\n        this.bytesReceived += data.length;\n        this.stats_.incrementCounter(\"bytes_received\", data.length);\n        this.resetKeepAlive();\n        if (this.frames !== null) {\n            // we're buffering\n            this.appendFrame_(data);\n        } else {\n            // try to parse out a frame count, otherwise, assume 1 and process it\n            const remainingData = this.extractFrameCount_(data);\n            if (remainingData !== null) {\n                this.appendFrame_(remainingData);\n            }\n        }\n    }\n    /**\r\n     * Send a message to the server\r\n     * @param data - The JSON object to transmit\r\n     */ send(data) {\n        this.resetKeepAlive();\n        const dataStr = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(data);\n        this.bytesSent += dataStr.length;\n        this.stats_.incrementCounter(\"bytes_sent\", dataStr.length);\n        //We can only fit a certain amount in each websocket frame, so we need to split this request\n        //up into multiple pieces if it doesn't fit in one request.\n        const dataSegs = splitStringBySize(dataStr, WEBSOCKET_MAX_FRAME_SIZE);\n        //Send the length header\n        if (dataSegs.length > 1) {\n            this.sendString_(String(dataSegs.length));\n        }\n        //Send the actual data in segments.\n        for(let i = 0; i < dataSegs.length; i++){\n            this.sendString_(dataSegs[i]);\n        }\n    }\n    shutdown_() {\n        this.isClosed_ = true;\n        if (this.keepaliveTimer) {\n            clearInterval(this.keepaliveTimer);\n            this.keepaliveTimer = null;\n        }\n        if (this.mySock) {\n            this.mySock.close();\n            this.mySock = null;\n        }\n    }\n    onClosed_() {\n        if (!this.isClosed_) {\n            this.log_(\"WebSocket is closing itself\");\n            this.shutdown_();\n            // since this is an internal close, trigger the close listener\n            if (this.onDisconnect) {\n                this.onDisconnect(this.everConnected_);\n                this.onDisconnect = null;\n            }\n        }\n    }\n    /**\r\n     * External-facing close handler.\r\n     * Close the websocket and kill the connection.\r\n     */ close() {\n        if (!this.isClosed_) {\n            this.log_(\"WebSocket is being closed\");\n            this.shutdown_();\n        }\n    }\n    /**\r\n     * Kill the current keepalive timer and start a new one, to ensure that it always fires N seconds after\r\n     * the last activity.\r\n     */ resetKeepAlive() {\n        clearInterval(this.keepaliveTimer);\n        this.keepaliveTimer = setInterval(()=>{\n            //If there has been no websocket activity for a while, send a no-op\n            if (this.mySock) {\n                this.sendString_(\"0\");\n            }\n            this.resetKeepAlive();\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }, Math.floor(WEBSOCKET_KEEPALIVE_INTERVAL));\n    }\n    /**\r\n     * Send a string over the websocket.\r\n     *\r\n     * @param str - String to send.\r\n     */ sendString_(str) {\n        // Firefox seems to sometimes throw exceptions (NS_ERROR_UNEXPECTED) from websocket .send()\n        // calls for some unknown reason.  We treat these as an error and disconnect.\n        // See https://app.asana.com/0/58926111402292/68021340250410\n        try {\n            this.mySock.send(str);\n        } catch (e) {\n            this.log_(\"Exception thrown from WebSocket.send():\", e.message || e.data, \"Closing connection.\");\n            setTimeout(this.onClosed_.bind(this), 0);\n        }\n    }\n}\n/**\r\n * Number of response before we consider the connection \"healthy.\"\r\n */ WebSocketConnection.responsesRequiredToBeHealthy = 2;\n/**\r\n * Time to wait for the connection te become healthy before giving up.\r\n */ WebSocketConnection.healthyTimeout = 30000;\nconst name = \"@firebase/database\";\nconst version = \"1.0.3\";\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Abstraction around AppCheck's token fetching capabilities.\r\n */ class AppCheckTokenProvider {\n    constructor(appName_, appCheckProvider){\n        this.appName_ = appName_;\n        this.appCheckProvider = appCheckProvider;\n        this.appCheck = appCheckProvider === null || appCheckProvider === void 0 ? void 0 : appCheckProvider.getImmediate({\n            optional: true\n        });\n        if (!this.appCheck) {\n            appCheckProvider === null || appCheckProvider === void 0 ? void 0 : appCheckProvider.get().then((appCheck)=>this.appCheck = appCheck);\n        }\n    }\n    getToken(forceRefresh) {\n        if (!this.appCheck) {\n            return new Promise((resolve, reject)=>{\n                // Support delayed initialization of FirebaseAppCheck. This allows our\n                // customers to initialize the RTDB SDK before initializing Firebase\n                // AppCheck and ensures that all requests are authenticated if a token\n                // becomes available before the timoeout below expires.\n                setTimeout(()=>{\n                    if (this.appCheck) {\n                        this.getToken(forceRefresh).then(resolve, reject);\n                    } else {\n                        resolve(null);\n                    }\n                }, 0);\n            });\n        }\n        return this.appCheck.getToken(forceRefresh);\n    }\n    addTokenChangeListener(listener) {\n        var _a;\n        (_a = this.appCheckProvider) === null || _a === void 0 ? void 0 : _a.get().then((appCheck)=>appCheck.addTokenListener(listener));\n    }\n    notifyForInvalidToken() {\n        warn(`Provided AppCheck credentials for the app named \"${this.appName_}\" ` + \"are invalid. This usually indicates your app was not initialized correctly.\");\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Abstraction around FirebaseApp's token fetching capabilities.\r\n */ class FirebaseAuthTokenProvider {\n    constructor(appName_, firebaseOptions_, authProvider_){\n        this.appName_ = appName_;\n        this.firebaseOptions_ = firebaseOptions_;\n        this.authProvider_ = authProvider_;\n        this.auth_ = null;\n        this.auth_ = authProvider_.getImmediate({\n            optional: true\n        });\n        if (!this.auth_) {\n            authProvider_.onInit((auth)=>this.auth_ = auth);\n        }\n    }\n    getToken(forceRefresh) {\n        if (!this.auth_) {\n            return new Promise((resolve, reject)=>{\n                // Support delayed initialization of FirebaseAuth. This allows our\n                // customers to initialize the RTDB SDK before initializing Firebase\n                // Auth and ensures that all requests are authenticated if a token\n                // becomes available before the timoeout below expires.\n                setTimeout(()=>{\n                    if (this.auth_) {\n                        this.getToken(forceRefresh).then(resolve, reject);\n                    } else {\n                        resolve(null);\n                    }\n                }, 0);\n            });\n        }\n        return this.auth_.getToken(forceRefresh).catch((error)=>{\n            // TODO: Need to figure out all the cases this is raised and whether\n            // this makes sense.\n            if (error && error.code === \"auth/token-not-initialized\") {\n                log(\"Got auth/token-not-initialized error.  Treating as null token.\");\n                return null;\n            } else {\n                return Promise.reject(error);\n            }\n        });\n    }\n    addTokenChangeListener(listener) {\n        // TODO: We might want to wrap the listener and call it with no args to\n        // avoid a leaky abstraction, but that makes removing the listener harder.\n        if (this.auth_) {\n            this.auth_.addAuthTokenListener(listener);\n        } else {\n            this.authProvider_.get().then((auth)=>auth.addAuthTokenListener(listener));\n        }\n    }\n    removeTokenChangeListener(listener) {\n        this.authProvider_.get().then((auth)=>auth.removeAuthTokenListener(listener));\n    }\n    notifyForInvalidToken() {\n        let errorMessage = 'Provided authentication credentials for the app named \"' + this.appName_ + '\" are invalid. This usually indicates your app was not ' + \"initialized correctly. \";\n        if (\"credential\" in this.firebaseOptions_) {\n            errorMessage += 'Make sure the \"credential\" property provided to initializeApp() ' + 'is authorized to access the specified \"databaseURL\" and is from the correct ' + \"project.\";\n        } else if (\"serviceAccount\" in this.firebaseOptions_) {\n            errorMessage += 'Make sure the \"serviceAccount\" property provided to initializeApp() ' + 'is authorized to access the specified \"databaseURL\" and is from the correct ' + \"project.\";\n        } else {\n            errorMessage += 'Make sure the \"apiKey\" and \"databaseURL\" properties provided to ' + \"initializeApp() match the values provided for your app at \" + \"https://console.firebase.google.com/.\";\n        }\n        warn(errorMessage);\n    }\n}\n/* AuthTokenProvider that supplies a constant token. Used by Admin SDK or mockUserToken with emulators. */ class EmulatorTokenProvider {\n    constructor(accessToken){\n        this.accessToken = accessToken;\n    }\n    getToken(forceRefresh) {\n        return Promise.resolve({\n            accessToken: this.accessToken\n        });\n    }\n    addTokenChangeListener(listener) {\n        // Invoke the listener immediately to match the behavior in Firebase Auth\n        // (see packages/auth/src/auth.js#L1807)\n        listener(this.accessToken);\n    }\n    removeTokenChangeListener(listener) {}\n    notifyForInvalidToken() {}\n}\n/** A string that is treated as an admin access token by the RTDB emulator. Used by Admin SDK. */ EmulatorTokenProvider.OWNER = \"owner\";\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * This class ensures the packets from the server arrive in order\r\n * This class takes data from the server and ensures it gets passed into the callbacks in order.\r\n */ class PacketReceiver {\n    /**\r\n     * @param onMessage_\r\n     */ constructor(onMessage_){\n        this.onMessage_ = onMessage_;\n        this.pendingResponses = [];\n        this.currentResponseNum = 0;\n        this.closeAfterResponse = -1;\n        this.onClose = null;\n    }\n    closeAfter(responseNum, callback) {\n        this.closeAfterResponse = responseNum;\n        this.onClose = callback;\n        if (this.closeAfterResponse < this.currentResponseNum) {\n            this.onClose();\n            this.onClose = null;\n        }\n    }\n    /**\r\n     * Each message from the server comes with a response number, and an array of data. The responseNumber\r\n     * allows us to ensure that we process them in the right order, since we can't be guaranteed that all\r\n     * browsers will respond in the same order as the requests we sent\r\n     */ handleResponse(requestNum, data) {\n        this.pendingResponses[requestNum] = data;\n        while(this.pendingResponses[this.currentResponseNum]){\n            const toProcess = this.pendingResponses[this.currentResponseNum];\n            delete this.pendingResponses[this.currentResponseNum];\n            for(let i = 0; i < toProcess.length; ++i){\n                if (toProcess[i]) {\n                    exceptionGuard(()=>{\n                        this.onMessage_(toProcess[i]);\n                    });\n                }\n            }\n            if (this.currentResponseNum === this.closeAfterResponse) {\n                if (this.onClose) {\n                    this.onClose();\n                    this.onClose = null;\n                }\n                break;\n            }\n            this.currentResponseNum++;\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // URL query parameters associated with longpolling\nconst FIREBASE_LONGPOLL_START_PARAM = \"start\";\nconst FIREBASE_LONGPOLL_CLOSE_COMMAND = \"close\";\nconst FIREBASE_LONGPOLL_COMMAND_CB_NAME = \"pLPCommand\";\nconst FIREBASE_LONGPOLL_DATA_CB_NAME = \"pRTLPCB\";\nconst FIREBASE_LONGPOLL_ID_PARAM = \"id\";\nconst FIREBASE_LONGPOLL_PW_PARAM = \"pw\";\nconst FIREBASE_LONGPOLL_SERIAL_PARAM = \"ser\";\nconst FIREBASE_LONGPOLL_CALLBACK_ID_PARAM = \"cb\";\nconst FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM = \"seg\";\nconst FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET = \"ts\";\nconst FIREBASE_LONGPOLL_DATA_PARAM = \"d\";\nconst FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM = \"dframe\";\n//Data size constants.\n//TODO: Perf: the maximum length actually differs from browser to browser.\n// We should check what browser we're on and set accordingly.\nconst MAX_URL_DATA_SIZE = 1870;\nconst SEG_HEADER_SIZE = 30; //ie: &seg=8299234&ts=982389123&d=\nconst MAX_PAYLOAD_SIZE = MAX_URL_DATA_SIZE - SEG_HEADER_SIZE;\n/**\r\n * Keepalive period\r\n * send a fresh request at minimum every 25 seconds. Opera has a maximum request\r\n * length of 30 seconds that we can't exceed.\r\n */ const KEEPALIVE_REQUEST_INTERVAL = 25000;\n/**\r\n * How long to wait before aborting a long-polling connection attempt.\r\n */ const LP_CONNECT_TIMEOUT = 30000;\n/**\r\n * This class manages a single long-polling connection.\r\n */ class BrowserPollConnection {\n    /**\r\n     * @param connId An identifier for this connection, used for logging\r\n     * @param repoInfo The info for the endpoint to send data to.\r\n     * @param applicationId The Firebase App ID for this project.\r\n     * @param appCheckToken The AppCheck token for this client.\r\n     * @param authToken The AuthToken to use for this connection.\r\n     * @param transportSessionId Optional transportSessionid if we are\r\n     * reconnecting for an existing transport session\r\n     * @param lastSessionId Optional lastSessionId if the PersistentConnection has\r\n     * already created a connection previously\r\n     */ constructor(connId, repoInfo, applicationId, appCheckToken, authToken, transportSessionId, lastSessionId){\n        this.connId = connId;\n        this.repoInfo = repoInfo;\n        this.applicationId = applicationId;\n        this.appCheckToken = appCheckToken;\n        this.authToken = authToken;\n        this.transportSessionId = transportSessionId;\n        this.lastSessionId = lastSessionId;\n        this.bytesSent = 0;\n        this.bytesReceived = 0;\n        this.everConnected_ = false;\n        this.log_ = logWrapper(connId);\n        this.stats_ = statsManagerGetCollection(repoInfo);\n        this.urlFn = (params)=>{\n            // Always add the token if we have one.\n            if (this.appCheckToken) {\n                params[APP_CHECK_TOKEN_PARAM] = this.appCheckToken;\n            }\n            return repoInfoConnectionURL(repoInfo, LONG_POLLING, params);\n        };\n    }\n    /**\r\n     * @param onMessage - Callback when messages arrive\r\n     * @param onDisconnect - Callback with connection lost.\r\n     */ open(onMessage, onDisconnect) {\n        this.curSegmentNum = 0;\n        this.onDisconnect_ = onDisconnect;\n        this.myPacketOrderer = new PacketReceiver(onMessage);\n        this.isClosed_ = false;\n        this.connectTimeoutTimer_ = setTimeout(()=>{\n            this.log_(\"Timed out trying to connect.\");\n            // Make sure we clear the host cache\n            this.onClosed_();\n            this.connectTimeoutTimer_ = null;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }, Math.floor(LP_CONNECT_TIMEOUT));\n        // Ensure we delay the creation of the iframe until the DOM is loaded.\n        executeWhenDOMReady(()=>{\n            if (this.isClosed_) {\n                return;\n            }\n            //Set up a callback that gets triggered once a connection is set up.\n            this.scriptTagHolder = new FirebaseIFrameScriptHolder((...args)=>{\n                const [command, arg1, arg2, arg3, arg4] = args;\n                this.incrementIncomingBytes_(args);\n                if (!this.scriptTagHolder) {\n                    return; // we closed the connection.\n                }\n                if (this.connectTimeoutTimer_) {\n                    clearTimeout(this.connectTimeoutTimer_);\n                    this.connectTimeoutTimer_ = null;\n                }\n                this.everConnected_ = true;\n                if (command === FIREBASE_LONGPOLL_START_PARAM) {\n                    this.id = arg1;\n                    this.password = arg2;\n                } else if (command === FIREBASE_LONGPOLL_CLOSE_COMMAND) {\n                    // Don't clear the host cache. We got a response from the server, so we know it's reachable\n                    if (arg1) {\n                        // We aren't expecting any more data (other than what the server's already in the process of sending us\n                        // through our already open polls), so don't send any more.\n                        this.scriptTagHolder.sendNewPolls = false;\n                        // arg1 in this case is the last response number sent by the server. We should try to receive\n                        // all of the responses up to this one before closing\n                        this.myPacketOrderer.closeAfter(arg1, ()=>{\n                            this.onClosed_();\n                        });\n                    } else {\n                        this.onClosed_();\n                    }\n                } else {\n                    throw new Error(\"Unrecognized command received: \" + command);\n                }\n            }, (...args)=>{\n                const [pN, data] = args;\n                this.incrementIncomingBytes_(args);\n                this.myPacketOrderer.handleResponse(pN, data);\n            }, ()=>{\n                this.onClosed_();\n            }, this.urlFn);\n            //Send the initial request to connect. The serial number is simply to keep the browser from pulling previous results\n            //from cache.\n            const urlParams = {};\n            urlParams[FIREBASE_LONGPOLL_START_PARAM] = \"t\";\n            urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = Math.floor(Math.random() * 100000000);\n            if (this.scriptTagHolder.uniqueCallbackIdentifier) {\n                urlParams[FIREBASE_LONGPOLL_CALLBACK_ID_PARAM] = this.scriptTagHolder.uniqueCallbackIdentifier;\n            }\n            urlParams[VERSION_PARAM] = PROTOCOL_VERSION;\n            if (this.transportSessionId) {\n                urlParams[TRANSPORT_SESSION_PARAM] = this.transportSessionId;\n            }\n            if (this.lastSessionId) {\n                urlParams[LAST_SESSION_PARAM] = this.lastSessionId;\n            }\n            if (this.applicationId) {\n                urlParams[APPLICATION_ID_PARAM] = this.applicationId;\n            }\n            if (this.appCheckToken) {\n                urlParams[APP_CHECK_TOKEN_PARAM] = this.appCheckToken;\n            }\n            if (typeof location !== \"undefined\" && location.hostname && FORGE_DOMAIN_RE.test(location.hostname)) {\n                urlParams[REFERER_PARAM] = FORGE_REF;\n            }\n            const connectURL = this.urlFn(urlParams);\n            this.log_(\"Connecting via long-poll to \" + connectURL);\n            this.scriptTagHolder.addTag(connectURL, ()=>{\n            /* do nothing */ });\n        });\n    }\n    /**\r\n     * Call this when a handshake has completed successfully and we want to consider the connection established\r\n     */ start() {\n        this.scriptTagHolder.startLongPoll(this.id, this.password);\n        this.addDisconnectPingFrame(this.id, this.password);\n    }\n    /**\r\n     * Forces long polling to be considered as a potential transport\r\n     */ static forceAllow() {\n        BrowserPollConnection.forceAllow_ = true;\n    }\n    /**\r\n     * Forces longpolling to not be considered as a potential transport\r\n     */ static forceDisallow() {\n        BrowserPollConnection.forceDisallow_ = true;\n    }\n    // Static method, use string literal so it can be accessed in a generic way\n    static isAvailable() {\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isNodeSdk)()) {\n            return false;\n        } else if (BrowserPollConnection.forceAllow_) {\n            return true;\n        } else {\n            // NOTE: In React-Native there's normally no 'document', but if you debug a React-Native app in\n            // the Chrome debugger, 'document' is defined, but document.createElement is null (2015/06/08).\n            return !BrowserPollConnection.forceDisallow_ && typeof document !== \"undefined\" && document.createElement != null && !isChromeExtensionContentScript() && !isWindowsStoreApp();\n        }\n    }\n    /**\r\n     * No-op for polling\r\n     */ markConnectionHealthy() {}\n    /**\r\n     * Stops polling and cleans up the iframe\r\n     */ shutdown_() {\n        this.isClosed_ = true;\n        if (this.scriptTagHolder) {\n            this.scriptTagHolder.close();\n            this.scriptTagHolder = null;\n        }\n        //remove the disconnect frame, which will trigger an XHR call to the server to tell it we're leaving.\n        if (this.myDisconnFrame) {\n            document.body.removeChild(this.myDisconnFrame);\n            this.myDisconnFrame = null;\n        }\n        if (this.connectTimeoutTimer_) {\n            clearTimeout(this.connectTimeoutTimer_);\n            this.connectTimeoutTimer_ = null;\n        }\n    }\n    /**\r\n     * Triggered when this transport is closed\r\n     */ onClosed_() {\n        if (!this.isClosed_) {\n            this.log_(\"Longpoll is closing itself\");\n            this.shutdown_();\n            if (this.onDisconnect_) {\n                this.onDisconnect_(this.everConnected_);\n                this.onDisconnect_ = null;\n            }\n        }\n    }\n    /**\r\n     * External-facing close handler. RealTime has requested we shut down. Kill our connection and tell the server\r\n     * that we've left.\r\n     */ close() {\n        if (!this.isClosed_) {\n            this.log_(\"Longpoll is being closed.\");\n            this.shutdown_();\n        }\n    }\n    /**\r\n     * Send the JSON object down to the server. It will need to be stringified, base64 encoded, and then\r\n     * broken into chunks (since URLs have a small maximum length).\r\n     * @param data - The JSON data to transmit.\r\n     */ send(data) {\n        const dataStr = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(data);\n        this.bytesSent += dataStr.length;\n        this.stats_.incrementCounter(\"bytes_sent\", dataStr.length);\n        //first, lets get the base64-encoded data\n        const base64data = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.base64Encode)(dataStr);\n        //We can only fit a certain amount in each URL, so we need to split this request\n        //up into multiple pieces if it doesn't fit in one request.\n        const dataSegs = splitStringBySize(base64data, MAX_PAYLOAD_SIZE);\n        //Enqueue each segment for transmission. We assign each chunk a sequential ID and a total number\n        //of segments so that we can reassemble the packet on the server.\n        for(let i = 0; i < dataSegs.length; i++){\n            this.scriptTagHolder.enqueueSegment(this.curSegmentNum, dataSegs.length, dataSegs[i]);\n            this.curSegmentNum++;\n        }\n    }\n    /**\r\n     * This is how we notify the server that we're leaving.\r\n     * We aren't able to send requests with DHTML on a window close event, but we can\r\n     * trigger XHR requests in some browsers (everything but Opera basically).\r\n     */ addDisconnectPingFrame(id, pw) {\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isNodeSdk)()) {\n            return;\n        }\n        this.myDisconnFrame = document.createElement(\"iframe\");\n        const urlParams = {};\n        urlParams[FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM] = \"t\";\n        urlParams[FIREBASE_LONGPOLL_ID_PARAM] = id;\n        urlParams[FIREBASE_LONGPOLL_PW_PARAM] = pw;\n        this.myDisconnFrame.src = this.urlFn(urlParams);\n        this.myDisconnFrame.style.display = \"none\";\n        document.body.appendChild(this.myDisconnFrame);\n    }\n    /**\r\n     * Used to track the bytes received by this client\r\n     */ incrementIncomingBytes_(args) {\n        // TODO: This is an annoying perf hit just to track the number of incoming bytes.  Maybe it should be opt-in.\n        const bytesReceived = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(args).length;\n        this.bytesReceived += bytesReceived;\n        this.stats_.incrementCounter(\"bytes_received\", bytesReceived);\n    }\n}\n/*********************************************************************************************\r\n * A wrapper around an iframe that is used as a long-polling script holder.\r\n *********************************************************************************************/ class FirebaseIFrameScriptHolder {\n    /**\r\n     * @param commandCB - The callback to be called when control commands are recevied from the server.\r\n     * @param onMessageCB - The callback to be triggered when responses arrive from the server.\r\n     * @param onDisconnect - The callback to be triggered when this tag holder is closed\r\n     * @param urlFn - A function that provides the URL of the endpoint to send data to.\r\n     */ constructor(commandCB, onMessageCB, onDisconnect, urlFn){\n        this.onDisconnect = onDisconnect;\n        this.urlFn = urlFn;\n        //We maintain a count of all of the outstanding requests, because if we have too many active at once it can cause\n        //problems in some browsers.\n        this.outstandingRequests = new Set();\n        //A queue of the pending segments waiting for transmission to the server.\n        this.pendingSegs = [];\n        //A serial number. We use this for two things:\n        // 1) A way to ensure the browser doesn't cache responses to polls\n        // 2) A way to make the server aware when long-polls arrive in a different order than we started them. The\n        //    server needs to release both polls in this case or it will cause problems in Opera since Opera can only execute\n        //    JSONP code in the order it was added to the iframe.\n        this.currentSerial = Math.floor(Math.random() * 100000000);\n        // This gets set to false when we're \"closing down\" the connection (e.g. we're switching transports but there's still\n        // incoming data from the server that we're waiting for).\n        this.sendNewPolls = true;\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isNodeSdk)()) {\n            //Each script holder registers a couple of uniquely named callbacks with the window. These are called from the\n            //iframes where we put the long-polling script tags. We have two callbacks:\n            //   1) Command Callback - Triggered for control issues, like starting a connection.\n            //   2) Message Callback - Triggered when new data arrives.\n            this.uniqueCallbackIdentifier = LUIDGenerator();\n            window[FIREBASE_LONGPOLL_COMMAND_CB_NAME + this.uniqueCallbackIdentifier] = commandCB;\n            window[FIREBASE_LONGPOLL_DATA_CB_NAME + this.uniqueCallbackIdentifier] = onMessageCB;\n            //Create an iframe for us to add script tags to.\n            this.myIFrame = FirebaseIFrameScriptHolder.createIFrame_();\n            // Set the iframe's contents.\n            let script = \"\";\n            // if we set a javascript url, it's IE and we need to set the document domain. The javascript url is sufficient\n            // for ie9, but ie8 needs to do it again in the document itself.\n            if (this.myIFrame.src && this.myIFrame.src.substr(0, \"javascript:\".length) === \"javascript:\") {\n                const currentDomain = document.domain;\n                script = '<script>document.domain=\"' + currentDomain + '\";</script>';\n            }\n            const iframeContents = \"<html><body>\" + script + \"</body></html>\";\n            try {\n                this.myIFrame.doc.open();\n                this.myIFrame.doc.write(iframeContents);\n                this.myIFrame.doc.close();\n            } catch (e) {\n                log(\"frame writing exception\");\n                if (e.stack) {\n                    log(e.stack);\n                }\n                log(e);\n            }\n        } else {\n            this.commandCB = commandCB;\n            this.onMessageCB = onMessageCB;\n        }\n    }\n    /**\r\n     * Each browser has its own funny way to handle iframes. Here we mush them all together into one object that I can\r\n     * actually use.\r\n     */ static createIFrame_() {\n        const iframe = document.createElement(\"iframe\");\n        iframe.style.display = \"none\";\n        // This is necessary in order to initialize the document inside the iframe\n        if (document.body) {\n            document.body.appendChild(iframe);\n            try {\n                // If document.domain has been modified in IE, this will throw an error, and we need to set the\n                // domain of the iframe's document manually. We can do this via a javascript: url as the src attribute\n                // Also note that we must do this *after* the iframe has been appended to the page. Otherwise it doesn't work.\n                const a = iframe.contentWindow.document;\n                if (!a) {\n                    // Apologies for the log-spam, I need to do something to keep closure from optimizing out the assignment above.\n                    log(\"No IE domain setting required\");\n                }\n            } catch (e) {\n                const domain = document.domain;\n                iframe.src = \"javascript:void((function(){document.open();document.domain='\" + domain + \"';document.close();})())\";\n            }\n        } else {\n            // LongPollConnection attempts to delay initialization until the document is ready, so hopefully this\n            // never gets hit.\n            throw \"Document body has not initialized. Wait to initialize Firebase until after the document is ready.\";\n        }\n        // Get the document of the iframe in a browser-specific way.\n        if (iframe.contentDocument) {\n            iframe.doc = iframe.contentDocument; // Firefox, Opera, Safari\n        } else if (iframe.contentWindow) {\n            iframe.doc = iframe.contentWindow.document; // Internet Explorer\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } else if (iframe.document) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            iframe.doc = iframe.document; //others?\n        }\n        return iframe;\n    }\n    /**\r\n     * Cancel all outstanding queries and remove the frame.\r\n     */ close() {\n        //Mark this iframe as dead, so no new requests are sent.\n        this.alive = false;\n        if (this.myIFrame) {\n            //We have to actually remove all of the html inside this iframe before removing it from the\n            //window, or IE will continue loading and executing the script tags we've already added, which\n            //can lead to some errors being thrown. Setting textContent seems to be the safest way to do this.\n            this.myIFrame.doc.body.textContent = \"\";\n            setTimeout(()=>{\n                if (this.myIFrame !== null) {\n                    document.body.removeChild(this.myIFrame);\n                    this.myIFrame = null;\n                }\n            }, Math.floor(0));\n        }\n        // Protect from being called recursively.\n        const onDisconnect = this.onDisconnect;\n        if (onDisconnect) {\n            this.onDisconnect = null;\n            onDisconnect();\n        }\n    }\n    /**\r\n     * Actually start the long-polling session by adding the first script tag(s) to the iframe.\r\n     * @param id - The ID of this connection\r\n     * @param pw - The password for this connection\r\n     */ startLongPoll(id, pw) {\n        this.myID = id;\n        this.myPW = pw;\n        this.alive = true;\n        //send the initial request. If there are requests queued, make sure that we transmit as many as we are currently able to.\n        while(this.newRequest_()){}\n    }\n    /**\r\n     * This is called any time someone might want a script tag to be added. It adds a script tag when there aren't\r\n     * too many outstanding requests and we are still alive.\r\n     *\r\n     * If there are outstanding packet segments to send, it sends one. If there aren't, it sends a long-poll anyways if\r\n     * needed.\r\n     */ newRequest_() {\n        // We keep one outstanding request open all the time to receive data, but if we need to send data\n        // (pendingSegs.length > 0) then we create a new request to send the data.  The server will automatically\n        // close the old request.\n        if (this.alive && this.sendNewPolls && this.outstandingRequests.size < (this.pendingSegs.length > 0 ? 2 : 1)) {\n            //construct our url\n            this.currentSerial++;\n            const urlParams = {};\n            urlParams[FIREBASE_LONGPOLL_ID_PARAM] = this.myID;\n            urlParams[FIREBASE_LONGPOLL_PW_PARAM] = this.myPW;\n            urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = this.currentSerial;\n            let theURL = this.urlFn(urlParams);\n            //Now add as much data as we can.\n            let curDataString = \"\";\n            let i = 0;\n            while(this.pendingSegs.length > 0){\n                //first, lets see if the next segment will fit.\n                const nextSeg = this.pendingSegs[0];\n                if (nextSeg.d.length + SEG_HEADER_SIZE + curDataString.length <= MAX_URL_DATA_SIZE) {\n                    //great, the segment will fit. Lets append it.\n                    const theSeg = this.pendingSegs.shift();\n                    curDataString = curDataString + \"&\" + FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM + i + \"=\" + theSeg.seg + \"&\" + FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET + i + \"=\" + theSeg.ts + \"&\" + FIREBASE_LONGPOLL_DATA_PARAM + i + \"=\" + theSeg.d;\n                    i++;\n                } else {\n                    break;\n                }\n            }\n            theURL = theURL + curDataString;\n            this.addLongPollTag_(theURL, this.currentSerial);\n            return true;\n        } else {\n            return false;\n        }\n    }\n    /**\r\n     * Queue a packet for transmission to the server.\r\n     * @param segnum - A sequential id for this packet segment used for reassembly\r\n     * @param totalsegs - The total number of segments in this packet\r\n     * @param data - The data for this segment.\r\n     */ enqueueSegment(segnum, totalsegs, data) {\n        //add this to the queue of segments to send.\n        this.pendingSegs.push({\n            seg: segnum,\n            ts: totalsegs,\n            d: data\n        });\n        //send the data immediately if there isn't already data being transmitted, unless\n        //startLongPoll hasn't been called yet.\n        if (this.alive) {\n            this.newRequest_();\n        }\n    }\n    /**\r\n     * Add a script tag for a regular long-poll request.\r\n     * @param url - The URL of the script tag.\r\n     * @param serial - The serial number of the request.\r\n     */ addLongPollTag_(url, serial) {\n        //remember that we sent this request.\n        this.outstandingRequests.add(serial);\n        const doNewRequest = ()=>{\n            this.outstandingRequests.delete(serial);\n            this.newRequest_();\n        };\n        // If this request doesn't return on its own accord (by the server sending us some data), we'll\n        // create a new one after the KEEPALIVE interval to make sure we always keep a fresh request open.\n        const keepaliveTimeout = setTimeout(doNewRequest, Math.floor(KEEPALIVE_REQUEST_INTERVAL));\n        const readyStateCB = ()=>{\n            // Request completed.  Cancel the keepalive.\n            clearTimeout(keepaliveTimeout);\n            // Trigger a new request so we can continue receiving data.\n            doNewRequest();\n        };\n        this.addTag(url, readyStateCB);\n    }\n    /**\r\n     * Add an arbitrary script tag to the iframe.\r\n     * @param url - The URL for the script tag source.\r\n     * @param loadCB - A callback to be triggered once the script has loaded.\r\n     */ addTag(url, loadCB) {\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isNodeSdk)()) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.doNodeLongPoll(url, loadCB);\n        } else {\n            setTimeout(()=>{\n                try {\n                    // if we're already closed, don't add this poll\n                    if (!this.sendNewPolls) {\n                        return;\n                    }\n                    const newScript = this.myIFrame.doc.createElement(\"script\");\n                    newScript.type = \"text/javascript\";\n                    newScript.async = true;\n                    newScript.src = url;\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    newScript.onload = newScript.onreadystatechange = function() {\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        const rstate = newScript.readyState;\n                        if (!rstate || rstate === \"loaded\" || rstate === \"complete\") {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            newScript.onload = newScript.onreadystatechange = null;\n                            if (newScript.parentNode) {\n                                newScript.parentNode.removeChild(newScript);\n                            }\n                            loadCB();\n                        }\n                    };\n                    newScript.onerror = ()=>{\n                        log(\"Long-poll script failed to load: \" + url);\n                        this.sendNewPolls = false;\n                        this.close();\n                    };\n                    this.myIFrame.doc.body.appendChild(newScript);\n                } catch (e) {\n                // TODO: we should make this error visible somehow\n                }\n            }, Math.floor(1));\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Currently simplistic, this class manages what transport a Connection should use at various stages of its\r\n * lifecycle.\r\n *\r\n * It starts with longpolling in a browser, and httppolling on node. It then upgrades to websockets if\r\n * they are available.\r\n */ class TransportManager {\n    /**\r\n     * @param repoInfo - Metadata around the namespace we're connecting to\r\n     */ constructor(repoInfo){\n        this.initTransports_(repoInfo);\n    }\n    static get ALL_TRANSPORTS() {\n        return [\n            BrowserPollConnection,\n            WebSocketConnection\n        ];\n    }\n    /**\r\n     * Returns whether transport has been selected to ensure WebSocketConnection or BrowserPollConnection are not called after\r\n     * TransportManager has already set up transports_\r\n     */ static get IS_TRANSPORT_INITIALIZED() {\n        return this.globalTransportInitialized_;\n    }\n    initTransports_(repoInfo) {\n        const isWebSocketsAvailable = WebSocketConnection && WebSocketConnection[\"isAvailable\"]();\n        let isSkipPollConnection = isWebSocketsAvailable && !WebSocketConnection.previouslyFailed();\n        if (repoInfo.webSocketOnly) {\n            if (!isWebSocketsAvailable) {\n                warn(\"wss:// URL used, but browser isn't known to support websockets.  Trying anyway.\");\n            }\n            isSkipPollConnection = true;\n        }\n        if (isSkipPollConnection) {\n            this.transports_ = [\n                WebSocketConnection\n            ];\n        } else {\n            const transports = this.transports_ = [];\n            for (const transport of TransportManager.ALL_TRANSPORTS){\n                if (transport && transport[\"isAvailable\"]()) {\n                    transports.push(transport);\n                }\n            }\n            TransportManager.globalTransportInitialized_ = true;\n        }\n    }\n    /**\r\n     * @returns The constructor for the initial transport to use\r\n     */ initialTransport() {\n        if (this.transports_.length > 0) {\n            return this.transports_[0];\n        } else {\n            throw new Error(\"No transports available\");\n        }\n    }\n    /**\r\n     * @returns The constructor for the next transport, or null\r\n     */ upgradeTransport() {\n        if (this.transports_.length > 1) {\n            return this.transports_[1];\n        } else {\n            return null;\n        }\n    }\n}\n// Keeps track of whether the TransportManager has already chosen a transport to use\nTransportManager.globalTransportInitialized_ = false;\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // Abort upgrade attempt if it takes longer than 60s.\nconst UPGRADE_TIMEOUT = 60000;\n// For some transports (WebSockets), we need to \"validate\" the transport by exchanging a few requests and responses.\n// If we haven't sent enough requests within 5s, we'll start sending noop ping requests.\nconst DELAY_BEFORE_SENDING_EXTRA_REQUESTS = 5000;\n// If the initial data sent triggers a lot of bandwidth (i.e. it's a large put or a listen for a large amount of data)\n// then we may not be able to exchange our ping/pong requests within the healthy timeout.  So if we reach the timeout\n// but we've sent/received enough bytes, we don't cancel the connection.\nconst BYTES_SENT_HEALTHY_OVERRIDE = 10 * 1024;\nconst BYTES_RECEIVED_HEALTHY_OVERRIDE = 100 * 1024;\nconst MESSAGE_TYPE = \"t\";\nconst MESSAGE_DATA = \"d\";\nconst CONTROL_SHUTDOWN = \"s\";\nconst CONTROL_RESET = \"r\";\nconst CONTROL_ERROR = \"e\";\nconst CONTROL_PONG = \"o\";\nconst SWITCH_ACK = \"a\";\nconst END_TRANSMISSION = \"n\";\nconst PING = \"p\";\nconst SERVER_HELLO = \"h\";\n/**\r\n * Creates a new real-time connection to the server using whichever method works\r\n * best in the current browser.\r\n */ class Connection {\n    /**\r\n     * @param id - an id for this connection\r\n     * @param repoInfo_ - the info for the endpoint to connect to\r\n     * @param applicationId_ - the Firebase App ID for this project\r\n     * @param appCheckToken_ - The App Check Token for this device.\r\n     * @param authToken_ - The auth token for this session.\r\n     * @param onMessage_ - the callback to be triggered when a server-push message arrives\r\n     * @param onReady_ - the callback to be triggered when this connection is ready to send messages.\r\n     * @param onDisconnect_ - the callback to be triggered when a connection was lost\r\n     * @param onKill_ - the callback to be triggered when this connection has permanently shut down.\r\n     * @param lastSessionId - last session id in persistent connection. is used to clean up old session in real-time server\r\n     */ constructor(id, repoInfo_, applicationId_, appCheckToken_, authToken_, onMessage_, onReady_, onDisconnect_, onKill_, lastSessionId){\n        this.id = id;\n        this.repoInfo_ = repoInfo_;\n        this.applicationId_ = applicationId_;\n        this.appCheckToken_ = appCheckToken_;\n        this.authToken_ = authToken_;\n        this.onMessage_ = onMessage_;\n        this.onReady_ = onReady_;\n        this.onDisconnect_ = onDisconnect_;\n        this.onKill_ = onKill_;\n        this.lastSessionId = lastSessionId;\n        this.connectionCount = 0;\n        this.pendingDataMessages = [];\n        this.state_ = 0 /* RealtimeState.CONNECTING */ ;\n        this.log_ = logWrapper(\"c:\" + this.id + \":\");\n        this.transportManager_ = new TransportManager(repoInfo_);\n        this.log_(\"Connection created\");\n        this.start_();\n    }\n    /**\r\n     * Starts a connection attempt\r\n     */ start_() {\n        const conn = this.transportManager_.initialTransport();\n        this.conn_ = new conn(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, null, this.lastSessionId);\n        // For certain transports (WebSockets), we need to send and receive several messages back and forth before we\n        // can consider the transport healthy.\n        this.primaryResponsesRequired_ = conn[\"responsesRequiredToBeHealthy\"] || 0;\n        const onMessageReceived = this.connReceiver_(this.conn_);\n        const onConnectionLost = this.disconnReceiver_(this.conn_);\n        this.tx_ = this.conn_;\n        this.rx_ = this.conn_;\n        this.secondaryConn_ = null;\n        this.isHealthy_ = false;\n        /*\r\n         * Firefox doesn't like when code from one iframe tries to create another iframe by way of the parent frame.\r\n         * This can occur in the case of a redirect, i.e. we guessed wrong on what server to connect to and received a reset.\r\n         * Somehow, setTimeout seems to make this ok. That doesn't make sense from a security perspective, since you should\r\n         * still have the context of your originating frame.\r\n         */ setTimeout(()=>{\n            // this.conn_ gets set to null in some of the tests. Check to make sure it still exists before using it\n            this.conn_ && this.conn_.open(onMessageReceived, onConnectionLost);\n        }, Math.floor(0));\n        const healthyTimeoutMS = conn[\"healthyTimeout\"] || 0;\n        if (healthyTimeoutMS > 0) {\n            this.healthyTimeout_ = setTimeoutNonBlocking(()=>{\n                this.healthyTimeout_ = null;\n                if (!this.isHealthy_) {\n                    if (this.conn_ && this.conn_.bytesReceived > BYTES_RECEIVED_HEALTHY_OVERRIDE) {\n                        this.log_(\"Connection exceeded healthy timeout but has received \" + this.conn_.bytesReceived + \" bytes.  Marking connection healthy.\");\n                        this.isHealthy_ = true;\n                        this.conn_.markConnectionHealthy();\n                    } else if (this.conn_ && this.conn_.bytesSent > BYTES_SENT_HEALTHY_OVERRIDE) {\n                        this.log_(\"Connection exceeded healthy timeout but has sent \" + this.conn_.bytesSent + \" bytes.  Leaving connection alive.\");\n                    // NOTE: We don't want to mark it healthy, since we have no guarantee that the bytes have made it to\n                    // the server.\n                    } else {\n                        this.log_(\"Closing unhealthy connection after timeout.\");\n                        this.close();\n                    }\n                }\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            }, Math.floor(healthyTimeoutMS));\n        }\n    }\n    nextTransportId_() {\n        return \"c:\" + this.id + \":\" + this.connectionCount++;\n    }\n    disconnReceiver_(conn) {\n        return (everConnected)=>{\n            if (conn === this.conn_) {\n                this.onConnectionLost_(everConnected);\n            } else if (conn === this.secondaryConn_) {\n                this.log_(\"Secondary connection lost.\");\n                this.onSecondaryConnectionLost_();\n            } else {\n                this.log_(\"closing an old connection\");\n            }\n        };\n    }\n    connReceiver_(conn) {\n        return (message)=>{\n            if (this.state_ !== 2 /* RealtimeState.DISCONNECTED */ ) {\n                if (conn === this.rx_) {\n                    this.onPrimaryMessageReceived_(message);\n                } else if (conn === this.secondaryConn_) {\n                    this.onSecondaryMessageReceived_(message);\n                } else {\n                    this.log_(\"message on old connection\");\n                }\n            }\n        };\n    }\n    /**\r\n     * @param dataMsg - An arbitrary data message to be sent to the server\r\n     */ sendRequest(dataMsg) {\n        // wrap in a data message envelope and send it on\n        const msg = {\n            t: \"d\",\n            d: dataMsg\n        };\n        this.sendData_(msg);\n    }\n    tryCleanupConnection() {\n        if (this.tx_ === this.secondaryConn_ && this.rx_ === this.secondaryConn_) {\n            this.log_(\"cleaning up and promoting a connection: \" + this.secondaryConn_.connId);\n            this.conn_ = this.secondaryConn_;\n            this.secondaryConn_ = null;\n        // the server will shutdown the old connection\n        }\n    }\n    onSecondaryControl_(controlData) {\n        if (MESSAGE_TYPE in controlData) {\n            const cmd = controlData[MESSAGE_TYPE];\n            if (cmd === SWITCH_ACK) {\n                this.upgradeIfSecondaryHealthy_();\n            } else if (cmd === CONTROL_RESET) {\n                // Most likely the session wasn't valid. Abandon the switch attempt\n                this.log_(\"Got a reset on secondary, closing it\");\n                this.secondaryConn_.close();\n                // If we were already using this connection for something, than we need to fully close\n                if (this.tx_ === this.secondaryConn_ || this.rx_ === this.secondaryConn_) {\n                    this.close();\n                }\n            } else if (cmd === CONTROL_PONG) {\n                this.log_(\"got pong on secondary.\");\n                this.secondaryResponsesRequired_--;\n                this.upgradeIfSecondaryHealthy_();\n            }\n        }\n    }\n    onSecondaryMessageReceived_(parsedData) {\n        const layer = requireKey(\"t\", parsedData);\n        const data = requireKey(\"d\", parsedData);\n        if (layer === \"c\") {\n            this.onSecondaryControl_(data);\n        } else if (layer === \"d\") {\n            // got a data message, but we're still second connection. Need to buffer it up\n            this.pendingDataMessages.push(data);\n        } else {\n            throw new Error(\"Unknown protocol layer: \" + layer);\n        }\n    }\n    upgradeIfSecondaryHealthy_() {\n        if (this.secondaryResponsesRequired_ <= 0) {\n            this.log_(\"Secondary connection is healthy.\");\n            this.isHealthy_ = true;\n            this.secondaryConn_.markConnectionHealthy();\n            this.proceedWithUpgrade_();\n        } else {\n            // Send a ping to make sure the connection is healthy.\n            this.log_(\"sending ping on secondary.\");\n            this.secondaryConn_.send({\n                t: \"c\",\n                d: {\n                    t: PING,\n                    d: {}\n                }\n            });\n        }\n    }\n    proceedWithUpgrade_() {\n        // tell this connection to consider itself open\n        this.secondaryConn_.start();\n        // send ack\n        this.log_(\"sending client ack on secondary\");\n        this.secondaryConn_.send({\n            t: \"c\",\n            d: {\n                t: SWITCH_ACK,\n                d: {}\n            }\n        });\n        // send end packet on primary transport, switch to sending on this one\n        // can receive on this one, buffer responses until end received on primary transport\n        this.log_(\"Ending transmission on primary\");\n        this.conn_.send({\n            t: \"c\",\n            d: {\n                t: END_TRANSMISSION,\n                d: {}\n            }\n        });\n        this.tx_ = this.secondaryConn_;\n        this.tryCleanupConnection();\n    }\n    onPrimaryMessageReceived_(parsedData) {\n        // Must refer to parsedData properties in quotes, so closure doesn't touch them.\n        const layer = requireKey(\"t\", parsedData);\n        const data = requireKey(\"d\", parsedData);\n        if (layer === \"c\") {\n            this.onControl_(data);\n        } else if (layer === \"d\") {\n            this.onDataMessage_(data);\n        }\n    }\n    onDataMessage_(message) {\n        this.onPrimaryResponse_();\n        // We don't do anything with data messages, just kick them up a level\n        this.onMessage_(message);\n    }\n    onPrimaryResponse_() {\n        if (!this.isHealthy_) {\n            this.primaryResponsesRequired_--;\n            if (this.primaryResponsesRequired_ <= 0) {\n                this.log_(\"Primary connection is healthy.\");\n                this.isHealthy_ = true;\n                this.conn_.markConnectionHealthy();\n            }\n        }\n    }\n    onControl_(controlData) {\n        const cmd = requireKey(MESSAGE_TYPE, controlData);\n        if (MESSAGE_DATA in controlData) {\n            const payload = controlData[MESSAGE_DATA];\n            if (cmd === SERVER_HELLO) {\n                const handshakePayload = Object.assign({}, payload);\n                if (this.repoInfo_.isUsingEmulator) {\n                    // Upon connecting, the emulator will pass the hostname that it's aware of, but we prefer the user's set hostname via `connectDatabaseEmulator` over what the emulator passes.\n                    handshakePayload.h = this.repoInfo_.host;\n                }\n                this.onHandshake_(handshakePayload);\n            } else if (cmd === END_TRANSMISSION) {\n                this.log_(\"recvd end transmission on primary\");\n                this.rx_ = this.secondaryConn_;\n                for(let i = 0; i < this.pendingDataMessages.length; ++i){\n                    this.onDataMessage_(this.pendingDataMessages[i]);\n                }\n                this.pendingDataMessages = [];\n                this.tryCleanupConnection();\n            } else if (cmd === CONTROL_SHUTDOWN) {\n                // This was previously the 'onKill' callback passed to the lower-level connection\n                // payload in this case is the reason for the shutdown. Generally a human-readable error\n                this.onConnectionShutdown_(payload);\n            } else if (cmd === CONTROL_RESET) {\n                // payload in this case is the host we should contact\n                this.onReset_(payload);\n            } else if (cmd === CONTROL_ERROR) {\n                error(\"Server Error: \" + payload);\n            } else if (cmd === CONTROL_PONG) {\n                this.log_(\"got pong on primary.\");\n                this.onPrimaryResponse_();\n                this.sendPingOnPrimaryIfNecessary_();\n            } else {\n                error(\"Unknown control packet command: \" + cmd);\n            }\n        }\n    }\n    /**\r\n     * @param handshake - The handshake data returned from the server\r\n     */ onHandshake_(handshake) {\n        const timestamp = handshake.ts;\n        const version = handshake.v;\n        const host = handshake.h;\n        this.sessionId = handshake.s;\n        this.repoInfo_.host = host;\n        // if we've already closed the connection, then don't bother trying to progress further\n        if (this.state_ === 0 /* RealtimeState.CONNECTING */ ) {\n            this.conn_.start();\n            this.onConnectionEstablished_(this.conn_, timestamp);\n            if (PROTOCOL_VERSION !== version) {\n                warn(\"Protocol version mismatch detected\");\n            }\n            // TODO: do we want to upgrade? when? maybe a delay?\n            this.tryStartUpgrade_();\n        }\n    }\n    tryStartUpgrade_() {\n        const conn = this.transportManager_.upgradeTransport();\n        if (conn) {\n            this.startUpgrade_(conn);\n        }\n    }\n    startUpgrade_(conn) {\n        this.secondaryConn_ = new conn(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, this.sessionId);\n        // For certain transports (WebSockets), we need to send and receive several messages back and forth before we\n        // can consider the transport healthy.\n        this.secondaryResponsesRequired_ = conn[\"responsesRequiredToBeHealthy\"] || 0;\n        const onMessage = this.connReceiver_(this.secondaryConn_);\n        const onDisconnect = this.disconnReceiver_(this.secondaryConn_);\n        this.secondaryConn_.open(onMessage, onDisconnect);\n        // If we haven't successfully upgraded after UPGRADE_TIMEOUT, give up and kill the secondary.\n        setTimeoutNonBlocking(()=>{\n            if (this.secondaryConn_) {\n                this.log_(\"Timed out trying to upgrade.\");\n                this.secondaryConn_.close();\n            }\n        }, Math.floor(UPGRADE_TIMEOUT));\n    }\n    onReset_(host) {\n        this.log_(\"Reset packet received.  New host: \" + host);\n        this.repoInfo_.host = host;\n        // TODO: if we're already \"connected\", we need to trigger a disconnect at the next layer up.\n        // We don't currently support resets after the connection has already been established\n        if (this.state_ === 1 /* RealtimeState.CONNECTED */ ) {\n            this.close();\n        } else {\n            // Close whatever connections we have open and start again.\n            this.closeConnections_();\n            this.start_();\n        }\n    }\n    onConnectionEstablished_(conn, timestamp) {\n        this.log_(\"Realtime connection established.\");\n        this.conn_ = conn;\n        this.state_ = 1 /* RealtimeState.CONNECTED */ ;\n        if (this.onReady_) {\n            this.onReady_(timestamp, this.sessionId);\n            this.onReady_ = null;\n        }\n        // If after 5 seconds we haven't sent enough requests to the server to get the connection healthy,\n        // send some pings.\n        if (this.primaryResponsesRequired_ === 0) {\n            this.log_(\"Primary connection is healthy.\");\n            this.isHealthy_ = true;\n        } else {\n            setTimeoutNonBlocking(()=>{\n                this.sendPingOnPrimaryIfNecessary_();\n            }, Math.floor(DELAY_BEFORE_SENDING_EXTRA_REQUESTS));\n        }\n    }\n    sendPingOnPrimaryIfNecessary_() {\n        // If the connection isn't considered healthy yet, we'll send a noop ping packet request.\n        if (!this.isHealthy_ && this.state_ === 1 /* RealtimeState.CONNECTED */ ) {\n            this.log_(\"sending ping on primary.\");\n            this.sendData_({\n                t: \"c\",\n                d: {\n                    t: PING,\n                    d: {}\n                }\n            });\n        }\n    }\n    onSecondaryConnectionLost_() {\n        const conn = this.secondaryConn_;\n        this.secondaryConn_ = null;\n        if (this.tx_ === conn || this.rx_ === conn) {\n            // we are relying on this connection already in some capacity. Therefore, a failure is real\n            this.close();\n        }\n    }\n    /**\r\n     * @param everConnected - Whether or not the connection ever reached a server. Used to determine if\r\n     * we should flush the host cache\r\n     */ onConnectionLost_(everConnected) {\n        this.conn_ = null;\n        // NOTE: IF you're seeing a Firefox error for this line, I think it might be because it's getting\n        // called on window close and RealtimeState.CONNECTING is no longer defined.  Just a guess.\n        if (!everConnected && this.state_ === 0 /* RealtimeState.CONNECTING */ ) {\n            this.log_(\"Realtime connection failed.\");\n            // Since we failed to connect at all, clear any cached entry for this namespace in case the machine went away\n            if (this.repoInfo_.isCacheableHost()) {\n                PersistentStorage.remove(\"host:\" + this.repoInfo_.host);\n                // reset the internal host to what we would show the user, i.e. <ns>.firebaseio.com\n                this.repoInfo_.internalHost = this.repoInfo_.host;\n            }\n        } else if (this.state_ === 1 /* RealtimeState.CONNECTED */ ) {\n            this.log_(\"Realtime connection lost.\");\n        }\n        this.close();\n    }\n    onConnectionShutdown_(reason) {\n        this.log_(\"Connection shutdown command received. Shutting down...\");\n        if (this.onKill_) {\n            this.onKill_(reason);\n            this.onKill_ = null;\n        }\n        // We intentionally don't want to fire onDisconnect (kill is a different case),\n        // so clear the callback.\n        this.onDisconnect_ = null;\n        this.close();\n    }\n    sendData_(data) {\n        if (this.state_ !== 1 /* RealtimeState.CONNECTED */ ) {\n            throw \"Connection is not connected\";\n        } else {\n            this.tx_.send(data);\n        }\n    }\n    /**\r\n     * Cleans up this connection, calling the appropriate callbacks\r\n     */ close() {\n        if (this.state_ !== 2 /* RealtimeState.DISCONNECTED */ ) {\n            this.log_(\"Closing realtime connection.\");\n            this.state_ = 2 /* RealtimeState.DISCONNECTED */ ;\n            this.closeConnections_();\n            if (this.onDisconnect_) {\n                this.onDisconnect_();\n                this.onDisconnect_ = null;\n            }\n        }\n    }\n    closeConnections_() {\n        this.log_(\"Shutting down all connections\");\n        if (this.conn_) {\n            this.conn_.close();\n            this.conn_ = null;\n        }\n        if (this.secondaryConn_) {\n            this.secondaryConn_.close();\n            this.secondaryConn_ = null;\n        }\n        if (this.healthyTimeout_) {\n            clearTimeout(this.healthyTimeout_);\n            this.healthyTimeout_ = null;\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Interface defining the set of actions that can be performed against the Firebase server\r\n * (basically corresponds to our wire protocol).\r\n *\r\n * @interface\r\n */ class ServerActions {\n    put(pathString, data, onComplete, hash) {}\n    merge(pathString, data, onComplete, hash) {}\n    /**\r\n     * Refreshes the auth token for the current connection.\r\n     * @param token - The authentication token\r\n     */ refreshAuthToken(token) {}\n    /**\r\n     * Refreshes the app check token for the current connection.\r\n     * @param token The app check token\r\n     */ refreshAppCheckToken(token) {}\n    onDisconnectPut(pathString, data, onComplete) {}\n    onDisconnectMerge(pathString, data, onComplete) {}\n    onDisconnectCancel(pathString, onComplete) {}\n    reportStats(stats) {}\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Base class to be used if you want to emit events. Call the constructor with\r\n * the set of allowed event names.\r\n */ class EventEmitter {\n    constructor(allowedEvents_){\n        this.allowedEvents_ = allowedEvents_;\n        this.listeners_ = {};\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(Array.isArray(allowedEvents_) && allowedEvents_.length > 0, \"Requires a non-empty array\");\n    }\n    /**\r\n     * To be called by derived classes to trigger events.\r\n     */ trigger(eventType, ...varArgs) {\n        if (Array.isArray(this.listeners_[eventType])) {\n            // Clone the list, since callbacks could add/remove listeners.\n            const listeners = [\n                ...this.listeners_[eventType]\n            ];\n            for(let i = 0; i < listeners.length; i++){\n                listeners[i].callback.apply(listeners[i].context, varArgs);\n            }\n        }\n    }\n    on(eventType, callback, context) {\n        this.validateEventType_(eventType);\n        this.listeners_[eventType] = this.listeners_[eventType] || [];\n        this.listeners_[eventType].push({\n            callback,\n            context\n        });\n        const eventData = this.getInitialEvent(eventType);\n        if (eventData) {\n            callback.apply(context, eventData);\n        }\n    }\n    off(eventType, callback, context) {\n        this.validateEventType_(eventType);\n        const listeners = this.listeners_[eventType] || [];\n        for(let i = 0; i < listeners.length; i++){\n            if (listeners[i].callback === callback && (!context || context === listeners[i].context)) {\n                listeners.splice(i, 1);\n                return;\n            }\n        }\n    }\n    validateEventType_(eventType) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(this.allowedEvents_.find((et)=>{\n            return et === eventType;\n        }), \"Unknown event: \" + eventType);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Monitors online state (as reported by window.online/offline events).\r\n *\r\n * The expectation is that this could have many false positives (thinks we are online\r\n * when we're not), but no false negatives.  So we can safely use it to determine when\r\n * we definitely cannot reach the internet.\r\n */ class OnlineMonitor extends EventEmitter {\n    constructor(){\n        super([\n            \"online\"\n        ]);\n        this.online_ = true;\n        // We've had repeated complaints that Cordova apps can get stuck \"offline\", e.g.\n        // https://forum.ionicframework.com/t/firebase-connection-is-lost-and-never-come-back/43810\n        // It would seem that the 'online' event does not always fire consistently. So we disable it\n        // for Cordova.\n        if (false) {}\n    }\n    static getInstance() {\n        return new OnlineMonitor();\n    }\n    getInitialEvent(eventType) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(eventType === \"online\", \"Unknown event type: \" + eventType);\n        return [\n            this.online_\n        ];\n    }\n    currentlyOnline() {\n        return this.online_;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /** Maximum key depth. */ const MAX_PATH_DEPTH = 32;\n/** Maximum number of (UTF8) bytes in a Firebase path. */ const MAX_PATH_LENGTH_BYTES = 768;\n/**\r\n * An immutable object representing a parsed path.  It's immutable so that you\r\n * can pass them around to other functions without worrying about them changing\r\n * it.\r\n */ class Path {\n    /**\r\n     * @param pathOrString - Path string to parse, or another path, or the raw\r\n     * tokens array\r\n     */ constructor(pathOrString, pieceNum){\n        if (pieceNum === void 0) {\n            this.pieces_ = pathOrString.split(\"/\");\n            // Remove empty pieces.\n            let copyTo = 0;\n            for(let i = 0; i < this.pieces_.length; i++){\n                if (this.pieces_[i].length > 0) {\n                    this.pieces_[copyTo] = this.pieces_[i];\n                    copyTo++;\n                }\n            }\n            this.pieces_.length = copyTo;\n            this.pieceNum_ = 0;\n        } else {\n            this.pieces_ = pathOrString;\n            this.pieceNum_ = pieceNum;\n        }\n    }\n    toString() {\n        let pathString = \"\";\n        for(let i = this.pieceNum_; i < this.pieces_.length; i++){\n            if (this.pieces_[i] !== \"\") {\n                pathString += \"/\" + this.pieces_[i];\n            }\n        }\n        return pathString || \"/\";\n    }\n}\nfunction newEmptyPath() {\n    return new Path(\"\");\n}\nfunction pathGetFront(path) {\n    if (path.pieceNum_ >= path.pieces_.length) {\n        return null;\n    }\n    return path.pieces_[path.pieceNum_];\n}\n/**\r\n * @returns The number of segments in this path\r\n */ function pathGetLength(path) {\n    return path.pieces_.length - path.pieceNum_;\n}\nfunction pathPopFront(path) {\n    let pieceNum = path.pieceNum_;\n    if (pieceNum < path.pieces_.length) {\n        pieceNum++;\n    }\n    return new Path(path.pieces_, pieceNum);\n}\nfunction pathGetBack(path) {\n    if (path.pieceNum_ < path.pieces_.length) {\n        return path.pieces_[path.pieces_.length - 1];\n    }\n    return null;\n}\nfunction pathToUrlEncodedString(path) {\n    let pathString = \"\";\n    for(let i = path.pieceNum_; i < path.pieces_.length; i++){\n        if (path.pieces_[i] !== \"\") {\n            pathString += \"/\" + encodeURIComponent(String(path.pieces_[i]));\n        }\n    }\n    return pathString || \"/\";\n}\n/**\r\n * Shallow copy of the parts of the path.\r\n *\r\n */ function pathSlice(path, begin = 0) {\n    return path.pieces_.slice(path.pieceNum_ + begin);\n}\nfunction pathParent(path) {\n    if (path.pieceNum_ >= path.pieces_.length) {\n        return null;\n    }\n    const pieces = [];\n    for(let i = path.pieceNum_; i < path.pieces_.length - 1; i++){\n        pieces.push(path.pieces_[i]);\n    }\n    return new Path(pieces, 0);\n}\nfunction pathChild(path, childPathObj) {\n    const pieces = [];\n    for(let i = path.pieceNum_; i < path.pieces_.length; i++){\n        pieces.push(path.pieces_[i]);\n    }\n    if (childPathObj instanceof Path) {\n        for(let i = childPathObj.pieceNum_; i < childPathObj.pieces_.length; i++){\n            pieces.push(childPathObj.pieces_[i]);\n        }\n    } else {\n        const childPieces = childPathObj.split(\"/\");\n        for(let i = 0; i < childPieces.length; i++){\n            if (childPieces[i].length > 0) {\n                pieces.push(childPieces[i]);\n            }\n        }\n    }\n    return new Path(pieces, 0);\n}\n/**\r\n * @returns True if there are no segments in this path\r\n */ function pathIsEmpty(path) {\n    return path.pieceNum_ >= path.pieces_.length;\n}\n/**\r\n * @returns The path from outerPath to innerPath\r\n */ function newRelativePath(outerPath, innerPath) {\n    const outer = pathGetFront(outerPath), inner = pathGetFront(innerPath);\n    if (outer === null) {\n        return innerPath;\n    } else if (outer === inner) {\n        return newRelativePath(pathPopFront(outerPath), pathPopFront(innerPath));\n    } else {\n        throw new Error(\"INTERNAL ERROR: innerPath (\" + innerPath + \") is not within \" + \"outerPath (\" + outerPath + \")\");\n    }\n}\n/**\r\n * @returns -1, 0, 1 if left is less, equal, or greater than the right.\r\n */ function pathCompare(left, right) {\n    const leftKeys = pathSlice(left, 0);\n    const rightKeys = pathSlice(right, 0);\n    for(let i = 0; i < leftKeys.length && i < rightKeys.length; i++){\n        const cmp = nameCompare(leftKeys[i], rightKeys[i]);\n        if (cmp !== 0) {\n            return cmp;\n        }\n    }\n    if (leftKeys.length === rightKeys.length) {\n        return 0;\n    }\n    return leftKeys.length < rightKeys.length ? -1 : 1;\n}\n/**\r\n * @returns true if paths are the same.\r\n */ function pathEquals(path, other) {\n    if (pathGetLength(path) !== pathGetLength(other)) {\n        return false;\n    }\n    for(let i = path.pieceNum_, j = other.pieceNum_; i <= path.pieces_.length; i++, j++){\n        if (path.pieces_[i] !== other.pieces_[j]) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\r\n * @returns True if this path is a parent of (or the same as) other\r\n */ function pathContains(path, other) {\n    let i = path.pieceNum_;\n    let j = other.pieceNum_;\n    if (pathGetLength(path) > pathGetLength(other)) {\n        return false;\n    }\n    while(i < path.pieces_.length){\n        if (path.pieces_[i] !== other.pieces_[j]) {\n            return false;\n        }\n        ++i;\n        ++j;\n    }\n    return true;\n}\n/**\r\n * Dynamic (mutable) path used to count path lengths.\r\n *\r\n * This class is used to efficiently check paths for valid\r\n * length (in UTF8 bytes) and depth (used in path validation).\r\n *\r\n * Throws Error exception if path is ever invalid.\r\n *\r\n * The definition of a path always begins with '/'.\r\n */ class ValidationPath {\n    /**\r\n     * @param path - Initial Path.\r\n     * @param errorPrefix_ - Prefix for any error messages.\r\n     */ constructor(path, errorPrefix_){\n        this.errorPrefix_ = errorPrefix_;\n        this.parts_ = pathSlice(path, 0);\n        /** Initialize to number of '/' chars needed in path. */ this.byteLength_ = Math.max(1, this.parts_.length);\n        for(let i = 0; i < this.parts_.length; i++){\n            this.byteLength_ += (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringLength)(this.parts_[i]);\n        }\n        validationPathCheckValid(this);\n    }\n}\nfunction validationPathPush(validationPath, child) {\n    // Count the needed '/'\n    if (validationPath.parts_.length > 0) {\n        validationPath.byteLength_ += 1;\n    }\n    validationPath.parts_.push(child);\n    validationPath.byteLength_ += (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringLength)(child);\n    validationPathCheckValid(validationPath);\n}\nfunction validationPathPop(validationPath) {\n    const last = validationPath.parts_.pop();\n    validationPath.byteLength_ -= (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringLength)(last);\n    // Un-count the previous '/'\n    if (validationPath.parts_.length > 0) {\n        validationPath.byteLength_ -= 1;\n    }\n}\nfunction validationPathCheckValid(validationPath) {\n    if (validationPath.byteLength_ > MAX_PATH_LENGTH_BYTES) {\n        throw new Error(validationPath.errorPrefix_ + \"has a key path longer than \" + MAX_PATH_LENGTH_BYTES + \" bytes (\" + validationPath.byteLength_ + \").\");\n    }\n    if (validationPath.parts_.length > MAX_PATH_DEPTH) {\n        throw new Error(validationPath.errorPrefix_ + \"path specified exceeds the maximum depth that can be written (\" + MAX_PATH_DEPTH + \") or object contains a cycle \" + validationPathToErrorString(validationPath));\n    }\n}\n/**\r\n * String for use in error messages - uses '.' notation for path.\r\n */ function validationPathToErrorString(validationPath) {\n    if (validationPath.parts_.length === 0) {\n        return \"\";\n    }\n    return \"in property '\" + validationPath.parts_.join(\".\") + \"'\";\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class VisibilityMonitor extends EventEmitter {\n    constructor(){\n        super([\n            \"visible\"\n        ]);\n        let hidden;\n        let visibilityChange;\n        if (typeof document !== \"undefined\" && typeof document.addEventListener !== \"undefined\") {\n            if (typeof document[\"hidden\"] !== \"undefined\") {\n                // Opera 12.10 and Firefox 18 and later support\n                visibilityChange = \"visibilitychange\";\n                hidden = \"hidden\";\n            } else if (typeof document[\"mozHidden\"] !== \"undefined\") {\n                visibilityChange = \"mozvisibilitychange\";\n                hidden = \"mozHidden\";\n            } else if (typeof document[\"msHidden\"] !== \"undefined\") {\n                visibilityChange = \"msvisibilitychange\";\n                hidden = \"msHidden\";\n            } else if (typeof document[\"webkitHidden\"] !== \"undefined\") {\n                visibilityChange = \"webkitvisibilitychange\";\n                hidden = \"webkitHidden\";\n            }\n        }\n        // Initially, we always assume we are visible. This ensures that in browsers\n        // without page visibility support or in cases where we are never visible\n        // (e.g. chrome extension), we act as if we are visible, i.e. don't delay\n        // reconnects\n        this.visible_ = true;\n        if (visibilityChange) {\n            document.addEventListener(visibilityChange, ()=>{\n                const visible = !document[hidden];\n                if (visible !== this.visible_) {\n                    this.visible_ = visible;\n                    this.trigger(\"visible\", visible);\n                }\n            }, false);\n        }\n    }\n    static getInstance() {\n        return new VisibilityMonitor();\n    }\n    getInitialEvent(eventType) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(eventType === \"visible\", \"Unknown event type: \" + eventType);\n        return [\n            this.visible_\n        ];\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const RECONNECT_MIN_DELAY = 1000;\nconst RECONNECT_MAX_DELAY_DEFAULT = 60 * 5 * 1000; // 5 minutes in milliseconds (Case: 1858)\nconst RECONNECT_MAX_DELAY_FOR_ADMINS = 30 * 1000; // 30 seconds for admin clients (likely to be a backend server)\nconst RECONNECT_DELAY_MULTIPLIER = 1.3;\nconst RECONNECT_DELAY_RESET_TIMEOUT = 30000; // Reset delay back to MIN_DELAY after being connected for 30sec.\nconst SERVER_KILL_INTERRUPT_REASON = \"server_kill\";\n// If auth fails repeatedly, we'll assume something is wrong and log a warning / back off.\nconst INVALID_TOKEN_THRESHOLD = 3;\n/**\r\n * Firebase connection.  Abstracts wire protocol and handles reconnecting.\r\n *\r\n * NOTE: All JSON objects sent to the realtime connection must have property names enclosed\r\n * in quotes to make sure the closure compiler does not minify them.\r\n */ class PersistentConnection extends ServerActions {\n    /**\r\n     * @param repoInfo_ - Data about the namespace we are connecting to\r\n     * @param applicationId_ - The Firebase App ID for this project\r\n     * @param onDataUpdate_ - A callback for new data from the server\r\n     */ constructor(repoInfo_, applicationId_, onDataUpdate_, onConnectStatus_, onServerInfoUpdate_, authTokenProvider_, appCheckTokenProvider_, authOverride_){\n        super();\n        this.repoInfo_ = repoInfo_;\n        this.applicationId_ = applicationId_;\n        this.onDataUpdate_ = onDataUpdate_;\n        this.onConnectStatus_ = onConnectStatus_;\n        this.onServerInfoUpdate_ = onServerInfoUpdate_;\n        this.authTokenProvider_ = authTokenProvider_;\n        this.appCheckTokenProvider_ = appCheckTokenProvider_;\n        this.authOverride_ = authOverride_;\n        // Used for diagnostic logging.\n        this.id = PersistentConnection.nextPersistentConnectionId_++;\n        this.log_ = logWrapper(\"p:\" + this.id + \":\");\n        this.interruptReasons_ = {};\n        this.listens = new Map();\n        this.outstandingPuts_ = [];\n        this.outstandingGets_ = [];\n        this.outstandingPutCount_ = 0;\n        this.outstandingGetCount_ = 0;\n        this.onDisconnectRequestQueue_ = [];\n        this.connected_ = false;\n        this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n        this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_DEFAULT;\n        this.securityDebugCallback_ = null;\n        this.lastSessionId = null;\n        this.establishConnectionTimer_ = null;\n        this.visible_ = false;\n        // Before we get connected, we keep a queue of pending messages to send.\n        this.requestCBHash_ = {};\n        this.requestNumber_ = 0;\n        this.realtime_ = null;\n        this.authToken_ = null;\n        this.appCheckToken_ = null;\n        this.forceTokenRefresh_ = false;\n        this.invalidAuthTokenCount_ = 0;\n        this.invalidAppCheckTokenCount_ = 0;\n        this.firstConnection_ = true;\n        this.lastConnectionAttemptTime_ = null;\n        this.lastConnectionEstablishedTime_ = null;\n        if (authOverride_ && !(0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isNodeSdk)()) {\n            throw new Error(\"Auth override specified in options, but not supported on non Node.js platforms\");\n        }\n        VisibilityMonitor.getInstance().on(\"visible\", this.onVisible_, this);\n        if (repoInfo_.host.indexOf(\"fblocal\") === -1) {\n            OnlineMonitor.getInstance().on(\"online\", this.onOnline_, this);\n        }\n    }\n    sendRequest(action, body, onResponse) {\n        const curReqNum = ++this.requestNumber_;\n        const msg = {\n            r: curReqNum,\n            a: action,\n            b: body\n        };\n        this.log_((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(msg));\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(this.connected_, \"sendRequest call when we're not connected not allowed.\");\n        this.realtime_.sendRequest(msg);\n        if (onResponse) {\n            this.requestCBHash_[curReqNum] = onResponse;\n        }\n    }\n    get(query) {\n        this.initConnection_();\n        const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n        const request = {\n            p: query._path.toString(),\n            q: query._queryObject\n        };\n        const outstandingGet = {\n            action: \"g\",\n            request,\n            onComplete: (message)=>{\n                const payload = message[\"d\"];\n                if (message[\"s\"] === \"ok\") {\n                    deferred.resolve(payload);\n                } else {\n                    deferred.reject(payload);\n                }\n            }\n        };\n        this.outstandingGets_.push(outstandingGet);\n        this.outstandingGetCount_++;\n        const index = this.outstandingGets_.length - 1;\n        if (this.connected_) {\n            this.sendGet_(index);\n        }\n        return deferred.promise;\n    }\n    listen(query, currentHashFn, tag, onComplete) {\n        this.initConnection_();\n        const queryId = query._queryIdentifier;\n        const pathString = query._path.toString();\n        this.log_(\"Listen called for \" + pathString + \" \" + queryId);\n        if (!this.listens.has(pathString)) {\n            this.listens.set(pathString, new Map());\n        }\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(query._queryParams.isDefault() || !query._queryParams.loadsAllData(), \"listen() called for non-default but complete query\");\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.listens.get(pathString).has(queryId), `listen() called twice for same path/queryId.`);\n        const listenSpec = {\n            onComplete,\n            hashFn: currentHashFn,\n            query,\n            tag\n        };\n        this.listens.get(pathString).set(queryId, listenSpec);\n        if (this.connected_) {\n            this.sendListen_(listenSpec);\n        }\n    }\n    sendGet_(index) {\n        const get = this.outstandingGets_[index];\n        this.sendRequest(\"g\", get.request, (message)=>{\n            delete this.outstandingGets_[index];\n            this.outstandingGetCount_--;\n            if (this.outstandingGetCount_ === 0) {\n                this.outstandingGets_ = [];\n            }\n            if (get.onComplete) {\n                get.onComplete(message);\n            }\n        });\n    }\n    sendListen_(listenSpec) {\n        const query = listenSpec.query;\n        const pathString = query._path.toString();\n        const queryId = query._queryIdentifier;\n        this.log_(\"Listen on \" + pathString + \" for \" + queryId);\n        const req = {\n            p: pathString\n        };\n        const action = \"q\";\n        // Only bother to send query if it's non-default.\n        if (listenSpec.tag) {\n            req[\"q\"] = query._queryObject;\n            req[\"t\"] = listenSpec.tag;\n        }\n        req[/*hash*/ \"h\"] = listenSpec.hashFn();\n        this.sendRequest(action, req, (message)=>{\n            const payload = message[/*data*/ \"d\"];\n            const status = message[/*status*/ \"s\"];\n            // print warnings in any case...\n            PersistentConnection.warnOnListenWarnings_(payload, query);\n            const currentListenSpec = this.listens.get(pathString) && this.listens.get(pathString).get(queryId);\n            // only trigger actions if the listen hasn't been removed and readded\n            if (currentListenSpec === listenSpec) {\n                this.log_(\"listen response\", message);\n                if (status !== \"ok\") {\n                    this.removeListen_(pathString, queryId);\n                }\n                if (listenSpec.onComplete) {\n                    listenSpec.onComplete(status, payload);\n                }\n            }\n        });\n    }\n    static warnOnListenWarnings_(payload, query) {\n        if (payload && typeof payload === \"object\" && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.contains)(payload, \"w\")) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const warnings = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.safeGet)(payload, \"w\");\n            if (Array.isArray(warnings) && ~warnings.indexOf(\"no_index\")) {\n                const indexSpec = '\".indexOn\": \"' + query._queryParams.getIndex().toString() + '\"';\n                const indexPath = query._path.toString();\n                warn(`Using an unspecified index. Your data will be downloaded and ` + `filtered on the client. Consider adding ${indexSpec} at ` + `${indexPath} to your security rules for better performance.`);\n            }\n        }\n    }\n    refreshAuthToken(token) {\n        this.authToken_ = token;\n        this.log_(\"Auth token refreshed\");\n        if (this.authToken_) {\n            this.tryAuth();\n        } else {\n            //If we're connected we want to let the server know to unauthenticate us. If we're not connected, simply delete\n            //the credential so we dont become authenticated next time we connect.\n            if (this.connected_) {\n                this.sendRequest(\"unauth\", {}, ()=>{});\n            }\n        }\n        this.reduceReconnectDelayIfAdminCredential_(token);\n    }\n    reduceReconnectDelayIfAdminCredential_(credential) {\n        // NOTE: This isn't intended to be bulletproof (a malicious developer can always just modify the client).\n        // Additionally, we don't bother resetting the max delay back to the default if auth fails / expires.\n        const isFirebaseSecret = credential && credential.length === 40;\n        if (isFirebaseSecret || (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isAdmin)(credential)) {\n            this.log_(\"Admin auth credential detected.  Reducing max reconnect time.\");\n            this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;\n        }\n    }\n    refreshAppCheckToken(token) {\n        this.appCheckToken_ = token;\n        this.log_(\"App check token refreshed\");\n        if (this.appCheckToken_) {\n            this.tryAppCheck();\n        } else {\n            //If we're connected we want to let the server know to unauthenticate us.\n            //If we're not connected, simply delete the credential so we dont become\n            // authenticated next time we connect.\n            if (this.connected_) {\n                this.sendRequest(\"unappeck\", {}, ()=>{});\n            }\n        }\n    }\n    /**\r\n     * Attempts to authenticate with the given credentials. If the authentication attempt fails, it's triggered like\r\n     * a auth revoked (the connection is closed).\r\n     */ tryAuth() {\n        if (this.connected_ && this.authToken_) {\n            const token = this.authToken_;\n            const authMethod = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isValidFormat)(token) ? \"auth\" : \"gauth\";\n            const requestData = {\n                cred: token\n            };\n            if (this.authOverride_ === null) {\n                requestData[\"noauth\"] = true;\n            } else if (typeof this.authOverride_ === \"object\") {\n                requestData[\"authvar\"] = this.authOverride_;\n            }\n            this.sendRequest(authMethod, requestData, (res)=>{\n                const status = res[/*status*/ \"s\"];\n                const data = res[/*data*/ \"d\"] || \"error\";\n                if (this.authToken_ === token) {\n                    if (status === \"ok\") {\n                        this.invalidAuthTokenCount_ = 0;\n                    } else {\n                        // Triggers reconnect and force refresh for auth token\n                        this.onAuthRevoked_(status, data);\n                    }\n                }\n            });\n        }\n    }\n    /**\r\n     * Attempts to authenticate with the given token. If the authentication\r\n     * attempt fails, it's triggered like the token was revoked (the connection is\r\n     * closed).\r\n     */ tryAppCheck() {\n        if (this.connected_ && this.appCheckToken_) {\n            this.sendRequest(\"appcheck\", {\n                \"token\": this.appCheckToken_\n            }, (res)=>{\n                const status = res[/*status*/ \"s\"];\n                const data = res[/*data*/ \"d\"] || \"error\";\n                if (status === \"ok\") {\n                    this.invalidAppCheckTokenCount_ = 0;\n                } else {\n                    this.onAppCheckRevoked_(status, data);\n                }\n            });\n        }\n    }\n    /**\r\n     * @inheritDoc\r\n     */ unlisten(query, tag) {\n        const pathString = query._path.toString();\n        const queryId = query._queryIdentifier;\n        this.log_(\"Unlisten called for \" + pathString + \" \" + queryId);\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(query._queryParams.isDefault() || !query._queryParams.loadsAllData(), \"unlisten() called for non-default but complete query\");\n        const listen = this.removeListen_(pathString, queryId);\n        if (listen && this.connected_) {\n            this.sendUnlisten_(pathString, queryId, query._queryObject, tag);\n        }\n    }\n    sendUnlisten_(pathString, queryId, queryObj, tag) {\n        this.log_(\"Unlisten on \" + pathString + \" for \" + queryId);\n        const req = {\n            p: pathString\n        };\n        const action = \"n\";\n        // Only bother sending queryId if it's non-default.\n        if (tag) {\n            req[\"q\"] = queryObj;\n            req[\"t\"] = tag;\n        }\n        this.sendRequest(action, req);\n    }\n    onDisconnectPut(pathString, data, onComplete) {\n        this.initConnection_();\n        if (this.connected_) {\n            this.sendOnDisconnect_(\"o\", pathString, data, onComplete);\n        } else {\n            this.onDisconnectRequestQueue_.push({\n                pathString,\n                action: \"o\",\n                data,\n                onComplete\n            });\n        }\n    }\n    onDisconnectMerge(pathString, data, onComplete) {\n        this.initConnection_();\n        if (this.connected_) {\n            this.sendOnDisconnect_(\"om\", pathString, data, onComplete);\n        } else {\n            this.onDisconnectRequestQueue_.push({\n                pathString,\n                action: \"om\",\n                data,\n                onComplete\n            });\n        }\n    }\n    onDisconnectCancel(pathString, onComplete) {\n        this.initConnection_();\n        if (this.connected_) {\n            this.sendOnDisconnect_(\"oc\", pathString, null, onComplete);\n        } else {\n            this.onDisconnectRequestQueue_.push({\n                pathString,\n                action: \"oc\",\n                data: null,\n                onComplete\n            });\n        }\n    }\n    sendOnDisconnect_(action, pathString, data, onComplete) {\n        const request = {\n            p: pathString,\n            /*data*/ d: data\n        };\n        this.log_(\"onDisconnect \" + action, request);\n        this.sendRequest(action, request, (response)=>{\n            if (onComplete) {\n                setTimeout(()=>{\n                    onComplete(response[/*status*/ \"s\"], response[/* data */ \"d\"]);\n                }, Math.floor(0));\n            }\n        });\n    }\n    put(pathString, data, onComplete, hash) {\n        this.putInternal(\"p\", pathString, data, onComplete, hash);\n    }\n    merge(pathString, data, onComplete, hash) {\n        this.putInternal(\"m\", pathString, data, onComplete, hash);\n    }\n    putInternal(action, pathString, data, onComplete, hash) {\n        this.initConnection_();\n        const request = {\n            /*path*/ p: pathString,\n            /*data*/ d: data\n        };\n        if (hash !== undefined) {\n            request[/*hash*/ \"h\"] = hash;\n        }\n        // TODO: Only keep track of the most recent put for a given path?\n        this.outstandingPuts_.push({\n            action,\n            request,\n            onComplete\n        });\n        this.outstandingPutCount_++;\n        const index = this.outstandingPuts_.length - 1;\n        if (this.connected_) {\n            this.sendPut_(index);\n        } else {\n            this.log_(\"Buffering put: \" + pathString);\n        }\n    }\n    sendPut_(index) {\n        const action = this.outstandingPuts_[index].action;\n        const request = this.outstandingPuts_[index].request;\n        const onComplete = this.outstandingPuts_[index].onComplete;\n        this.outstandingPuts_[index].queued = this.connected_;\n        this.sendRequest(action, request, (message)=>{\n            this.log_(action + \" response\", message);\n            delete this.outstandingPuts_[index];\n            this.outstandingPutCount_--;\n            // Clean up array occasionally.\n            if (this.outstandingPutCount_ === 0) {\n                this.outstandingPuts_ = [];\n            }\n            if (onComplete) {\n                onComplete(message[/*status*/ \"s\"], message[/* data */ \"d\"]);\n            }\n        });\n    }\n    reportStats(stats) {\n        // If we're not connected, we just drop the stats.\n        if (this.connected_) {\n            const request = {\n                c: stats\n            };\n            this.log_(\"reportStats\", request);\n            this.sendRequest(/*stats*/ \"s\", request, (result)=>{\n                const status = result[/*status*/ \"s\"];\n                if (status !== \"ok\") {\n                    const errorReason = result[/* data */ \"d\"];\n                    this.log_(\"reportStats\", \"Error sending stats: \" + errorReason);\n                }\n            });\n        }\n    }\n    onDataMessage_(message) {\n        if (\"r\" in message) {\n            // this is a response\n            this.log_(\"from server: \" + (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(message));\n            const reqNum = message[\"r\"];\n            const onResponse = this.requestCBHash_[reqNum];\n            if (onResponse) {\n                delete this.requestCBHash_[reqNum];\n                onResponse(message[/*body*/ \"b\"]);\n            }\n        } else if (\"error\" in message) {\n            throw \"A server-side error has occurred: \" + message[\"error\"];\n        } else if (\"a\" in message) {\n            // a and b are action and body, respectively\n            this.onDataPush_(message[\"a\"], message[\"b\"]);\n        }\n    }\n    onDataPush_(action, body) {\n        this.log_(\"handleServerMessage\", action, body);\n        if (action === \"d\") {\n            this.onDataUpdate_(body[/*path*/ \"p\"], body[/*data*/ \"d\"], /*isMerge*/ false, body[\"t\"]);\n        } else if (action === \"m\") {\n            this.onDataUpdate_(body[/*path*/ \"p\"], body[/*data*/ \"d\"], /*isMerge=*/ true, body[\"t\"]);\n        } else if (action === \"c\") {\n            this.onListenRevoked_(body[/*path*/ \"p\"], body[/*query*/ \"q\"]);\n        } else if (action === \"ac\") {\n            this.onAuthRevoked_(body[/*status code*/ \"s\"], body[/* explanation */ \"d\"]);\n        } else if (action === \"apc\") {\n            this.onAppCheckRevoked_(body[/*status code*/ \"s\"], body[/* explanation */ \"d\"]);\n        } else if (action === \"sd\") {\n            this.onSecurityDebugPacket_(body);\n        } else {\n            error(\"Unrecognized action received from server: \" + (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(action) + \"\\nAre you using the latest client?\");\n        }\n    }\n    onReady_(timestamp, sessionId) {\n        this.log_(\"connection ready\");\n        this.connected_ = true;\n        this.lastConnectionEstablishedTime_ = new Date().getTime();\n        this.handleTimestamp_(timestamp);\n        this.lastSessionId = sessionId;\n        if (this.firstConnection_) {\n            this.sendConnectStats_();\n        }\n        this.restoreState_();\n        this.firstConnection_ = false;\n        this.onConnectStatus_(true);\n    }\n    scheduleConnect_(timeout) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.realtime_, \"Scheduling a connect when we're already connected/ing?\");\n        if (this.establishConnectionTimer_) {\n            clearTimeout(this.establishConnectionTimer_);\n        }\n        // NOTE: Even when timeout is 0, it's important to do a setTimeout to work around an infuriating \"Security Error\" in\n        // Firefox when trying to write to our long-polling iframe in some scenarios (e.g. Forge or our unit tests).\n        this.establishConnectionTimer_ = setTimeout(()=>{\n            this.establishConnectionTimer_ = null;\n            this.establishConnection_();\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }, Math.floor(timeout));\n    }\n    initConnection_() {\n        if (!this.realtime_ && this.firstConnection_) {\n            this.scheduleConnect_(0);\n        }\n    }\n    onVisible_(visible) {\n        // NOTE: Tabbing away and back to a window will defeat our reconnect backoff, but I think that's fine.\n        if (visible && !this.visible_ && this.reconnectDelay_ === this.maxReconnectDelay_) {\n            this.log_(\"Window became visible.  Reducing delay.\");\n            this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n            if (!this.realtime_) {\n                this.scheduleConnect_(0);\n            }\n        }\n        this.visible_ = visible;\n    }\n    onOnline_(online) {\n        if (online) {\n            this.log_(\"Browser went online.\");\n            this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n            if (!this.realtime_) {\n                this.scheduleConnect_(0);\n            }\n        } else {\n            this.log_(\"Browser went offline.  Killing connection.\");\n            if (this.realtime_) {\n                this.realtime_.close();\n            }\n        }\n    }\n    onRealtimeDisconnect_() {\n        this.log_(\"data client disconnected\");\n        this.connected_ = false;\n        this.realtime_ = null;\n        // Since we don't know if our sent transactions succeeded or not, we need to cancel them.\n        this.cancelSentTransactions_();\n        // Clear out the pending requests.\n        this.requestCBHash_ = {};\n        if (this.shouldReconnect_()) {\n            if (!this.visible_) {\n                this.log_(\"Window isn't visible.  Delaying reconnect.\");\n                this.reconnectDelay_ = this.maxReconnectDelay_;\n                this.lastConnectionAttemptTime_ = new Date().getTime();\n            } else if (this.lastConnectionEstablishedTime_) {\n                // If we've been connected long enough, reset reconnect delay to minimum.\n                const timeSinceLastConnectSucceeded = new Date().getTime() - this.lastConnectionEstablishedTime_;\n                if (timeSinceLastConnectSucceeded > RECONNECT_DELAY_RESET_TIMEOUT) {\n                    this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n                }\n                this.lastConnectionEstablishedTime_ = null;\n            }\n            const timeSinceLastConnectAttempt = new Date().getTime() - this.lastConnectionAttemptTime_;\n            let reconnectDelay = Math.max(0, this.reconnectDelay_ - timeSinceLastConnectAttempt);\n            reconnectDelay = Math.random() * reconnectDelay;\n            this.log_(\"Trying to reconnect in \" + reconnectDelay + \"ms\");\n            this.scheduleConnect_(reconnectDelay);\n            // Adjust reconnect delay for next time.\n            this.reconnectDelay_ = Math.min(this.maxReconnectDelay_, this.reconnectDelay_ * RECONNECT_DELAY_MULTIPLIER);\n        }\n        this.onConnectStatus_(false);\n    }\n    async establishConnection_() {\n        if (this.shouldReconnect_()) {\n            this.log_(\"Making a connection attempt\");\n            this.lastConnectionAttemptTime_ = new Date().getTime();\n            this.lastConnectionEstablishedTime_ = null;\n            const onDataMessage = this.onDataMessage_.bind(this);\n            const onReady = this.onReady_.bind(this);\n            const onDisconnect = this.onRealtimeDisconnect_.bind(this);\n            const connId = this.id + \":\" + PersistentConnection.nextConnectionId_++;\n            const lastSessionId = this.lastSessionId;\n            let canceled = false;\n            let connection = null;\n            const closeFn = function() {\n                if (connection) {\n                    connection.close();\n                } else {\n                    canceled = true;\n                    onDisconnect();\n                }\n            };\n            const sendRequestFn = function(msg) {\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(connection, \"sendRequest call when we're not connected not allowed.\");\n                connection.sendRequest(msg);\n            };\n            this.realtime_ = {\n                close: closeFn,\n                sendRequest: sendRequestFn\n            };\n            const forceRefresh = this.forceTokenRefresh_;\n            this.forceTokenRefresh_ = false;\n            try {\n                // First fetch auth and app check token, and establish connection after\n                // fetching the token was successful\n                const [authToken, appCheckToken] = await Promise.all([\n                    this.authTokenProvider_.getToken(forceRefresh),\n                    this.appCheckTokenProvider_.getToken(forceRefresh)\n                ]);\n                if (!canceled) {\n                    log(\"getToken() completed. Creating connection.\");\n                    this.authToken_ = authToken && authToken.accessToken;\n                    this.appCheckToken_ = appCheckToken && appCheckToken.token;\n                    connection = new Connection(connId, this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, onDataMessage, onReady, onDisconnect, /* onKill= */ (reason)=>{\n                        warn(reason + \" (\" + this.repoInfo_.toString() + \")\");\n                        this.interrupt(SERVER_KILL_INTERRUPT_REASON);\n                    }, lastSessionId);\n                } else {\n                    log(\"getToken() completed but was canceled\");\n                }\n            } catch (error) {\n                this.log_(\"Failed to get token: \" + error);\n                if (!canceled) {\n                    if (this.repoInfo_.nodeAdmin) {\n                        // This may be a critical error for the Admin Node.js SDK, so log a warning.\n                        // But getToken() may also just have temporarily failed, so we still want to\n                        // continue retrying.\n                        warn(error);\n                    }\n                    closeFn();\n                }\n            }\n        }\n    }\n    interrupt(reason) {\n        log(\"Interrupting connection for reason: \" + reason);\n        this.interruptReasons_[reason] = true;\n        if (this.realtime_) {\n            this.realtime_.close();\n        } else {\n            if (this.establishConnectionTimer_) {\n                clearTimeout(this.establishConnectionTimer_);\n                this.establishConnectionTimer_ = null;\n            }\n            if (this.connected_) {\n                this.onRealtimeDisconnect_();\n            }\n        }\n    }\n    resume(reason) {\n        log(\"Resuming connection for reason: \" + reason);\n        delete this.interruptReasons_[reason];\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(this.interruptReasons_)) {\n            this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n            if (!this.realtime_) {\n                this.scheduleConnect_(0);\n            }\n        }\n    }\n    handleTimestamp_(timestamp) {\n        const delta = timestamp - new Date().getTime();\n        this.onServerInfoUpdate_({\n            serverTimeOffset: delta\n        });\n    }\n    cancelSentTransactions_() {\n        for(let i = 0; i < this.outstandingPuts_.length; i++){\n            const put = this.outstandingPuts_[i];\n            if (put && /*hash*/ \"h\" in put.request && put.queued) {\n                if (put.onComplete) {\n                    put.onComplete(\"disconnect\");\n                }\n                delete this.outstandingPuts_[i];\n                this.outstandingPutCount_--;\n            }\n        }\n        // Clean up array occasionally.\n        if (this.outstandingPutCount_ === 0) {\n            this.outstandingPuts_ = [];\n        }\n    }\n    onListenRevoked_(pathString, query) {\n        // Remove the listen and manufacture a \"permission_denied\" error for the failed listen.\n        let queryId;\n        if (!query) {\n            queryId = \"default\";\n        } else {\n            queryId = query.map((q)=>ObjectToUniqueKey(q)).join(\"$\");\n        }\n        const listen = this.removeListen_(pathString, queryId);\n        if (listen && listen.onComplete) {\n            listen.onComplete(\"permission_denied\");\n        }\n    }\n    removeListen_(pathString, queryId) {\n        const normalizedPathString = new Path(pathString).toString(); // normalize path.\n        let listen;\n        if (this.listens.has(normalizedPathString)) {\n            const map = this.listens.get(normalizedPathString);\n            listen = map.get(queryId);\n            map.delete(queryId);\n            if (map.size === 0) {\n                this.listens.delete(normalizedPathString);\n            }\n        } else {\n            // all listens for this path has already been removed\n            listen = undefined;\n        }\n        return listen;\n    }\n    onAuthRevoked_(statusCode, explanation) {\n        log(\"Auth token revoked: \" + statusCode + \"/\" + explanation);\n        this.authToken_ = null;\n        this.forceTokenRefresh_ = true;\n        this.realtime_.close();\n        if (statusCode === \"invalid_token\" || statusCode === \"permission_denied\") {\n            // We'll wait a couple times before logging the warning / increasing the\n            // retry period since oauth tokens will report as \"invalid\" if they're\n            // just expired. Plus there may be transient issues that resolve themselves.\n            this.invalidAuthTokenCount_++;\n            if (this.invalidAuthTokenCount_ >= INVALID_TOKEN_THRESHOLD) {\n                // Set a long reconnect delay because recovery is unlikely\n                this.reconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;\n                // Notify the auth token provider that the token is invalid, which will log\n                // a warning\n                this.authTokenProvider_.notifyForInvalidToken();\n            }\n        }\n    }\n    onAppCheckRevoked_(statusCode, explanation) {\n        log(\"App check token revoked: \" + statusCode + \"/\" + explanation);\n        this.appCheckToken_ = null;\n        this.forceTokenRefresh_ = true;\n        // Note: We don't close the connection as the developer may not have\n        // enforcement enabled. The backend closes connections with enforcements.\n        if (statusCode === \"invalid_token\" || statusCode === \"permission_denied\") {\n            // We'll wait a couple times before logging the warning / increasing the\n            // retry period since oauth tokens will report as \"invalid\" if they're\n            // just expired. Plus there may be transient issues that resolve themselves.\n            this.invalidAppCheckTokenCount_++;\n            if (this.invalidAppCheckTokenCount_ >= INVALID_TOKEN_THRESHOLD) {\n                this.appCheckTokenProvider_.notifyForInvalidToken();\n            }\n        }\n    }\n    onSecurityDebugPacket_(body) {\n        if (this.securityDebugCallback_) {\n            this.securityDebugCallback_(body);\n        } else {\n            if (\"msg\" in body) {\n                console.log(\"FIREBASE: \" + body[\"msg\"].replace(\"\\n\", \"\\nFIREBASE: \"));\n            }\n        }\n    }\n    restoreState_() {\n        //Re-authenticate ourselves if we have a credential stored.\n        this.tryAuth();\n        this.tryAppCheck();\n        // Puts depend on having received the corresponding data update from the server before they complete, so we must\n        // make sure to send listens before puts.\n        for (const queries of this.listens.values()){\n            for (const listenSpec of queries.values()){\n                this.sendListen_(listenSpec);\n            }\n        }\n        for(let i = 0; i < this.outstandingPuts_.length; i++){\n            if (this.outstandingPuts_[i]) {\n                this.sendPut_(i);\n            }\n        }\n        while(this.onDisconnectRequestQueue_.length){\n            const request = this.onDisconnectRequestQueue_.shift();\n            this.sendOnDisconnect_(request.action, request.pathString, request.data, request.onComplete);\n        }\n        for(let i = 0; i < this.outstandingGets_.length; i++){\n            if (this.outstandingGets_[i]) {\n                this.sendGet_(i);\n            }\n        }\n    }\n    /**\r\n     * Sends client stats for first connection\r\n     */ sendConnectStats_() {\n        const stats = {};\n        let clientName = \"js\";\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isNodeSdk)()) {\n            if (this.repoInfo_.nodeAdmin) {\n                clientName = \"admin_node\";\n            } else {\n                clientName = \"node\";\n            }\n        }\n        stats[\"sdk.\" + clientName + \".\" + SDK_VERSION.replace(/\\./g, \"-\")] = 1;\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isMobileCordova)()) {\n            stats[\"framework.cordova\"] = 1;\n        } else if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isReactNative)()) {\n            stats[\"framework.reactnative\"] = 1;\n        }\n        this.reportStats(stats);\n    }\n    shouldReconnect_() {\n        const online = OnlineMonitor.getInstance().currentlyOnline();\n        return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(this.interruptReasons_) && online;\n    }\n}\nPersistentConnection.nextPersistentConnectionId_ = 0;\n/**\r\n * Counter for number of connections created. Mainly used for tagging in the logs\r\n */ PersistentConnection.nextConnectionId_ = 0;\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class NamedNode {\n    constructor(name, node){\n        this.name = name;\n        this.node = node;\n    }\n    static Wrap(name, node) {\n        return new NamedNode(name, node);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class Index {\n    /**\r\n     * @returns A standalone comparison function for\r\n     * this index\r\n     */ getCompare() {\n        return this.compare.bind(this);\n    }\n    /**\r\n     * Given a before and after value for a node, determine if the indexed value has changed. Even if they are different,\r\n     * it's possible that the changes are isolated to parts of the snapshot that are not indexed.\r\n     *\r\n     *\r\n     * @returns True if the portion of the snapshot being indexed changed between oldNode and newNode\r\n     */ indexedValueChanged(oldNode, newNode) {\n        const oldWrapped = new NamedNode(MIN_NAME, oldNode);\n        const newWrapped = new NamedNode(MIN_NAME, newNode);\n        return this.compare(oldWrapped, newWrapped) !== 0;\n    }\n    /**\r\n     * @returns a node wrapper that will sort equal to or less than\r\n     * any other node wrapper, using this index\r\n     */ minPost() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return NamedNode.MIN;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ let __EMPTY_NODE;\nclass KeyIndex extends Index {\n    static get __EMPTY_NODE() {\n        return __EMPTY_NODE;\n    }\n    static set __EMPTY_NODE(val) {\n        __EMPTY_NODE = val;\n    }\n    compare(a, b) {\n        return nameCompare(a.name, b.name);\n    }\n    isDefinedOn(node) {\n        // We could probably return true here (since every node has a key), but it's never called\n        // so just leaving unimplemented for now.\n        throw (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assertionError)(\"KeyIndex.isDefinedOn not expected to be called.\");\n    }\n    indexedValueChanged(oldNode, newNode) {\n        return false; // The key for a node never changes.\n    }\n    minPost() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return NamedNode.MIN;\n    }\n    maxPost() {\n        // TODO: This should really be created once and cached in a static property, but\n        // NamedNode isn't defined yet, so I can't use it in a static.  Bleh.\n        return new NamedNode(MAX_NAME, __EMPTY_NODE);\n    }\n    makePost(indexValue, name) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(typeof indexValue === \"string\", \"KeyIndex indexValue must always be a string.\");\n        // We just use empty node, but it'll never be compared, since our comparator only looks at name.\n        return new NamedNode(indexValue, __EMPTY_NODE);\n    }\n    /**\r\n     * @returns String representation for inclusion in a query spec\r\n     */ toString() {\n        return \".key\";\n    }\n}\nconst KEY_INDEX = new KeyIndex();\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * An iterator over an LLRBNode.\r\n */ class SortedMapIterator {\n    /**\r\n     * @param node - Node to iterate.\r\n     * @param isReverse_ - Whether or not to iterate in reverse\r\n     */ constructor(node, startKey, comparator, isReverse_, resultGenerator_ = null){\n        this.isReverse_ = isReverse_;\n        this.resultGenerator_ = resultGenerator_;\n        this.nodeStack_ = [];\n        let cmp = 1;\n        while(!node.isEmpty()){\n            node = node;\n            cmp = startKey ? comparator(node.key, startKey) : 1;\n            // flip the comparison if we're going in reverse\n            if (isReverse_) {\n                cmp *= -1;\n            }\n            if (cmp < 0) {\n                // This node is less than our start key. ignore it\n                if (this.isReverse_) {\n                    node = node.left;\n                } else {\n                    node = node.right;\n                }\n            } else if (cmp === 0) {\n                // This node is exactly equal to our start key. Push it on the stack, but stop iterating;\n                this.nodeStack_.push(node);\n                break;\n            } else {\n                // This node is greater than our start key, add it to the stack and move to the next one\n                this.nodeStack_.push(node);\n                if (this.isReverse_) {\n                    node = node.right;\n                } else {\n                    node = node.left;\n                }\n            }\n        }\n    }\n    getNext() {\n        if (this.nodeStack_.length === 0) {\n            return null;\n        }\n        let node = this.nodeStack_.pop();\n        let result;\n        if (this.resultGenerator_) {\n            result = this.resultGenerator_(node.key, node.value);\n        } else {\n            result = {\n                key: node.key,\n                value: node.value\n            };\n        }\n        if (this.isReverse_) {\n            node = node.left;\n            while(!node.isEmpty()){\n                this.nodeStack_.push(node);\n                node = node.right;\n            }\n        } else {\n            node = node.right;\n            while(!node.isEmpty()){\n                this.nodeStack_.push(node);\n                node = node.left;\n            }\n        }\n        return result;\n    }\n    hasNext() {\n        return this.nodeStack_.length > 0;\n    }\n    peek() {\n        if (this.nodeStack_.length === 0) {\n            return null;\n        }\n        const node = this.nodeStack_[this.nodeStack_.length - 1];\n        if (this.resultGenerator_) {\n            return this.resultGenerator_(node.key, node.value);\n        } else {\n            return {\n                key: node.key,\n                value: node.value\n            };\n        }\n    }\n}\n/**\r\n * Represents a node in a Left-leaning Red-Black tree.\r\n */ class LLRBNode {\n    /**\r\n     * @param key - Key associated with this node.\r\n     * @param value - Value associated with this node.\r\n     * @param color - Whether this node is red.\r\n     * @param left - Left child.\r\n     * @param right - Right child.\r\n     */ constructor(key, value, color, left, right){\n        this.key = key;\n        this.value = value;\n        this.color = color != null ? color : LLRBNode.RED;\n        this.left = left != null ? left : SortedMap.EMPTY_NODE;\n        this.right = right != null ? right : SortedMap.EMPTY_NODE;\n    }\n    /**\r\n     * Returns a copy of the current node, optionally replacing pieces of it.\r\n     *\r\n     * @param key - New key for the node, or null.\r\n     * @param value - New value for the node, or null.\r\n     * @param color - New color for the node, or null.\r\n     * @param left - New left child for the node, or null.\r\n     * @param right - New right child for the node, or null.\r\n     * @returns The node copy.\r\n     */ copy(key, value, color, left, right) {\n        return new LLRBNode(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);\n    }\n    /**\r\n     * @returns The total number of nodes in the tree.\r\n     */ count() {\n        return this.left.count() + 1 + this.right.count();\n    }\n    /**\r\n     * @returns True if the tree is empty.\r\n     */ isEmpty() {\n        return false;\n    }\n    /**\r\n     * Traverses the tree in key order and calls the specified action function\r\n     * for each node.\r\n     *\r\n     * @param action - Callback function to be called for each\r\n     *   node.  If it returns true, traversal is aborted.\r\n     * @returns The first truthy value returned by action, or the last falsey\r\n     *   value returned by action\r\n     */ inorderTraversal(action) {\n        return this.left.inorderTraversal(action) || !!action(this.key, this.value) || this.right.inorderTraversal(action);\n    }\n    /**\r\n     * Traverses the tree in reverse key order and calls the specified action function\r\n     * for each node.\r\n     *\r\n     * @param action - Callback function to be called for each\r\n     * node.  If it returns true, traversal is aborted.\r\n     * @returns True if traversal was aborted.\r\n     */ reverseTraversal(action) {\n        return this.right.reverseTraversal(action) || action(this.key, this.value) || this.left.reverseTraversal(action);\n    }\n    /**\r\n     * @returns The minimum node in the tree.\r\n     */ min_() {\n        if (this.left.isEmpty()) {\n            return this;\n        } else {\n            return this.left.min_();\n        }\n    }\n    /**\r\n     * @returns The maximum key in the tree.\r\n     */ minKey() {\n        return this.min_().key;\n    }\n    /**\r\n     * @returns The maximum key in the tree.\r\n     */ maxKey() {\n        if (this.right.isEmpty()) {\n            return this.key;\n        } else {\n            return this.right.maxKey();\n        }\n    }\n    /**\r\n     * @param key - Key to insert.\r\n     * @param value - Value to insert.\r\n     * @param comparator - Comparator.\r\n     * @returns New tree, with the key/value added.\r\n     */ insert(key, value, comparator) {\n        let n = this;\n        const cmp = comparator(key, n.key);\n        if (cmp < 0) {\n            n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);\n        } else if (cmp === 0) {\n            n = n.copy(null, value, null, null, null);\n        } else {\n            n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));\n        }\n        return n.fixUp_();\n    }\n    /**\r\n     * @returns New tree, with the minimum key removed.\r\n     */ removeMin_() {\n        if (this.left.isEmpty()) {\n            return SortedMap.EMPTY_NODE;\n        }\n        let n = this;\n        if (!n.left.isRed_() && !n.left.left.isRed_()) {\n            n = n.moveRedLeft_();\n        }\n        n = n.copy(null, null, null, n.left.removeMin_(), null);\n        return n.fixUp_();\n    }\n    /**\r\n     * @param key - The key of the item to remove.\r\n     * @param comparator - Comparator.\r\n     * @returns New tree, with the specified item removed.\r\n     */ remove(key, comparator) {\n        let n, smallest;\n        n = this;\n        if (comparator(key, n.key) < 0) {\n            if (!n.left.isEmpty() && !n.left.isRed_() && !n.left.left.isRed_()) {\n                n = n.moveRedLeft_();\n            }\n            n = n.copy(null, null, null, n.left.remove(key, comparator), null);\n        } else {\n            if (n.left.isRed_()) {\n                n = n.rotateRight_();\n            }\n            if (!n.right.isEmpty() && !n.right.isRed_() && !n.right.left.isRed_()) {\n                n = n.moveRedRight_();\n            }\n            if (comparator(key, n.key) === 0) {\n                if (n.right.isEmpty()) {\n                    return SortedMap.EMPTY_NODE;\n                } else {\n                    smallest = n.right.min_();\n                    n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin_());\n                }\n            }\n            n = n.copy(null, null, null, null, n.right.remove(key, comparator));\n        }\n        return n.fixUp_();\n    }\n    /**\r\n     * @returns Whether this is a RED node.\r\n     */ isRed_() {\n        return this.color;\n    }\n    /**\r\n     * @returns New tree after performing any needed rotations.\r\n     */ fixUp_() {\n        let n = this;\n        if (n.right.isRed_() && !n.left.isRed_()) {\n            n = n.rotateLeft_();\n        }\n        if (n.left.isRed_() && n.left.left.isRed_()) {\n            n = n.rotateRight_();\n        }\n        if (n.left.isRed_() && n.right.isRed_()) {\n            n = n.colorFlip_();\n        }\n        return n;\n    }\n    /**\r\n     * @returns New tree, after moveRedLeft.\r\n     */ moveRedLeft_() {\n        let n = this.colorFlip_();\n        if (n.right.left.isRed_()) {\n            n = n.copy(null, null, null, null, n.right.rotateRight_());\n            n = n.rotateLeft_();\n            n = n.colorFlip_();\n        }\n        return n;\n    }\n    /**\r\n     * @returns New tree, after moveRedRight.\r\n     */ moveRedRight_() {\n        let n = this.colorFlip_();\n        if (n.left.left.isRed_()) {\n            n = n.rotateRight_();\n            n = n.colorFlip_();\n        }\n        return n;\n    }\n    /**\r\n     * @returns New tree, after rotateLeft.\r\n     */ rotateLeft_() {\n        const nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);\n        return this.right.copy(null, null, this.color, nl, null);\n    }\n    /**\r\n     * @returns New tree, after rotateRight.\r\n     */ rotateRight_() {\n        const nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);\n        return this.left.copy(null, null, this.color, null, nr);\n    }\n    /**\r\n     * @returns Newt ree, after colorFlip.\r\n     */ colorFlip_() {\n        const left = this.left.copy(null, null, !this.left.color, null, null);\n        const right = this.right.copy(null, null, !this.right.color, null, null);\n        return this.copy(null, null, !this.color, left, right);\n    }\n    /**\r\n     * For testing.\r\n     *\r\n     * @returns True if all is well.\r\n     */ checkMaxDepth_() {\n        const blackDepth = this.check_();\n        return Math.pow(2.0, blackDepth) <= this.count() + 1;\n    }\n    check_() {\n        if (this.isRed_() && this.left.isRed_()) {\n            throw new Error(\"Red node has red child(\" + this.key + \",\" + this.value + \")\");\n        }\n        if (this.right.isRed_()) {\n            throw new Error(\"Right child of (\" + this.key + \",\" + this.value + \") is red\");\n        }\n        const blackDepth = this.left.check_();\n        if (blackDepth !== this.right.check_()) {\n            throw new Error(\"Black depths differ\");\n        } else {\n            return blackDepth + (this.isRed_() ? 0 : 1);\n        }\n    }\n}\nLLRBNode.RED = true;\nLLRBNode.BLACK = false;\n/**\r\n * Represents an empty node (a leaf node in the Red-Black Tree).\r\n */ class LLRBEmptyNode {\n    /**\r\n     * Returns a copy of the current node.\r\n     *\r\n     * @returns The node copy.\r\n     */ copy(key, value, color, left, right) {\n        return this;\n    }\n    /**\r\n     * Returns a copy of the tree, with the specified key/value added.\r\n     *\r\n     * @param key - Key to be added.\r\n     * @param value - Value to be added.\r\n     * @param comparator - Comparator.\r\n     * @returns New tree, with item added.\r\n     */ insert(key, value, comparator) {\n        return new LLRBNode(key, value, null);\n    }\n    /**\r\n     * Returns a copy of the tree, with the specified key removed.\r\n     *\r\n     * @param key - The key to remove.\r\n     * @param comparator - Comparator.\r\n     * @returns New tree, with item removed.\r\n     */ remove(key, comparator) {\n        return this;\n    }\n    /**\r\n     * @returns The total number of nodes in the tree.\r\n     */ count() {\n        return 0;\n    }\n    /**\r\n     * @returns True if the tree is empty.\r\n     */ isEmpty() {\n        return true;\n    }\n    /**\r\n     * Traverses the tree in key order and calls the specified action function\r\n     * for each node.\r\n     *\r\n     * @param action - Callback function to be called for each\r\n     * node.  If it returns true, traversal is aborted.\r\n     * @returns True if traversal was aborted.\r\n     */ inorderTraversal(action) {\n        return false;\n    }\n    /**\r\n     * Traverses the tree in reverse key order and calls the specified action function\r\n     * for each node.\r\n     *\r\n     * @param action - Callback function to be called for each\r\n     * node.  If it returns true, traversal is aborted.\r\n     * @returns True if traversal was aborted.\r\n     */ reverseTraversal(action) {\n        return false;\n    }\n    minKey() {\n        return null;\n    }\n    maxKey() {\n        return null;\n    }\n    check_() {\n        return 0;\n    }\n    /**\r\n     * @returns Whether this node is red.\r\n     */ isRed_() {\n        return false;\n    }\n}\n/**\r\n * An immutable sorted map implementation, based on a Left-leaning Red-Black\r\n * tree.\r\n */ class SortedMap {\n    /**\r\n     * @param comparator_ - Key comparator.\r\n     * @param root_ - Optional root node for the map.\r\n     */ constructor(comparator_, root_ = SortedMap.EMPTY_NODE){\n        this.comparator_ = comparator_;\n        this.root_ = root_;\n    }\n    /**\r\n     * Returns a copy of the map, with the specified key/value added or replaced.\r\n     * (TODO: We should perhaps rename this method to 'put')\r\n     *\r\n     * @param key - Key to be added.\r\n     * @param value - Value to be added.\r\n     * @returns New map, with item added.\r\n     */ insert(key, value) {\n        return new SortedMap(this.comparator_, this.root_.insert(key, value, this.comparator_).copy(null, null, LLRBNode.BLACK, null, null));\n    }\n    /**\r\n     * Returns a copy of the map, with the specified key removed.\r\n     *\r\n     * @param key - The key to remove.\r\n     * @returns New map, with item removed.\r\n     */ remove(key) {\n        return new SortedMap(this.comparator_, this.root_.remove(key, this.comparator_).copy(null, null, LLRBNode.BLACK, null, null));\n    }\n    /**\r\n     * Returns the value of the node with the given key, or null.\r\n     *\r\n     * @param key - The key to look up.\r\n     * @returns The value of the node with the given key, or null if the\r\n     * key doesn't exist.\r\n     */ get(key) {\n        let cmp;\n        let node = this.root_;\n        while(!node.isEmpty()){\n            cmp = this.comparator_(key, node.key);\n            if (cmp === 0) {\n                return node.value;\n            } else if (cmp < 0) {\n                node = node.left;\n            } else if (cmp > 0) {\n                node = node.right;\n            }\n        }\n        return null;\n    }\n    /**\r\n     * Returns the key of the item *before* the specified key, or null if key is the first item.\r\n     * @param key - The key to find the predecessor of\r\n     * @returns The predecessor key.\r\n     */ getPredecessorKey(key) {\n        let cmp, node = this.root_, rightParent = null;\n        while(!node.isEmpty()){\n            cmp = this.comparator_(key, node.key);\n            if (cmp === 0) {\n                if (!node.left.isEmpty()) {\n                    node = node.left;\n                    while(!node.right.isEmpty()){\n                        node = node.right;\n                    }\n                    return node.key;\n                } else if (rightParent) {\n                    return rightParent.key;\n                } else {\n                    return null; // first item.\n                }\n            } else if (cmp < 0) {\n                node = node.left;\n            } else if (cmp > 0) {\n                rightParent = node;\n                node = node.right;\n            }\n        }\n        throw new Error(\"Attempted to find predecessor key for a nonexistent key.  What gives?\");\n    }\n    /**\r\n     * @returns True if the map is empty.\r\n     */ isEmpty() {\n        return this.root_.isEmpty();\n    }\n    /**\r\n     * @returns The total number of nodes in the map.\r\n     */ count() {\n        return this.root_.count();\n    }\n    /**\r\n     * @returns The minimum key in the map.\r\n     */ minKey() {\n        return this.root_.minKey();\n    }\n    /**\r\n     * @returns The maximum key in the map.\r\n     */ maxKey() {\n        return this.root_.maxKey();\n    }\n    /**\r\n     * Traverses the map in key order and calls the specified action function\r\n     * for each key/value pair.\r\n     *\r\n     * @param action - Callback function to be called\r\n     * for each key/value pair.  If action returns true, traversal is aborted.\r\n     * @returns The first truthy value returned by action, or the last falsey\r\n     *   value returned by action\r\n     */ inorderTraversal(action) {\n        return this.root_.inorderTraversal(action);\n    }\n    /**\r\n     * Traverses the map in reverse key order and calls the specified action function\r\n     * for each key/value pair.\r\n     *\r\n     * @param action - Callback function to be called\r\n     * for each key/value pair.  If action returns true, traversal is aborted.\r\n     * @returns True if the traversal was aborted.\r\n     */ reverseTraversal(action) {\n        return this.root_.reverseTraversal(action);\n    }\n    /**\r\n     * Returns an iterator over the SortedMap.\r\n     * @returns The iterator.\r\n     */ getIterator(resultGenerator) {\n        return new SortedMapIterator(this.root_, null, this.comparator_, false, resultGenerator);\n    }\n    getIteratorFrom(key, resultGenerator) {\n        return new SortedMapIterator(this.root_, key, this.comparator_, false, resultGenerator);\n    }\n    getReverseIteratorFrom(key, resultGenerator) {\n        return new SortedMapIterator(this.root_, key, this.comparator_, true, resultGenerator);\n    }\n    getReverseIterator(resultGenerator) {\n        return new SortedMapIterator(this.root_, null, this.comparator_, true, resultGenerator);\n    }\n}\n/**\r\n * Always use the same empty node, to reduce memory.\r\n */ SortedMap.EMPTY_NODE = new LLRBEmptyNode();\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function NAME_ONLY_COMPARATOR(left, right) {\n    return nameCompare(left.name, right.name);\n}\nfunction NAME_COMPARATOR(left, right) {\n    return nameCompare(left, right);\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ let MAX_NODE$2;\nfunction setMaxNode$1(val) {\n    MAX_NODE$2 = val;\n}\nconst priorityHashText = function(priority) {\n    if (typeof priority === \"number\") {\n        return \"number:\" + doubleToIEEE754String(priority);\n    } else {\n        return \"string:\" + priority;\n    }\n};\n/**\r\n * Validates that a priority snapshot Node is valid.\r\n */ const validatePriorityNode = function(priorityNode) {\n    if (priorityNode.isLeafNode()) {\n        const val = priorityNode.val();\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(typeof val === \"string\" || typeof val === \"number\" || typeof val === \"object\" && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.contains)(val, \".sv\"), \"Priority must be a string or number.\");\n    } else {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(priorityNode === MAX_NODE$2 || priorityNode.isEmpty(), \"priority of unexpected type.\");\n    }\n    // Don't call getPriority() on MAX_NODE to avoid hitting assertion.\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(priorityNode === MAX_NODE$2 || priorityNode.getPriority().isEmpty(), \"Priority nodes can't have a priority of their own.\");\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ let __childrenNodeConstructor;\n/**\r\n * LeafNode is a class for storing leaf nodes in a DataSnapshot.  It\r\n * implements Node and stores the value of the node (a string,\r\n * number, or boolean) accessible via getValue().\r\n */ class LeafNode {\n    /**\r\n     * @param value_ - The value to store in this leaf node. The object type is\r\n     * possible in the event of a deferred value\r\n     * @param priorityNode_ - The priority of this node.\r\n     */ constructor(value_, priorityNode_ = LeafNode.__childrenNodeConstructor.EMPTY_NODE){\n        this.value_ = value_;\n        this.priorityNode_ = priorityNode_;\n        this.lazyHash_ = null;\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(this.value_ !== undefined && this.value_ !== null, \"LeafNode shouldn't be created with null/undefined value.\");\n        validatePriorityNode(this.priorityNode_);\n    }\n    static set __childrenNodeConstructor(val) {\n        __childrenNodeConstructor = val;\n    }\n    static get __childrenNodeConstructor() {\n        return __childrenNodeConstructor;\n    }\n    /** @inheritDoc */ isLeafNode() {\n        return true;\n    }\n    /** @inheritDoc */ getPriority() {\n        return this.priorityNode_;\n    }\n    /** @inheritDoc */ updatePriority(newPriorityNode) {\n        return new LeafNode(this.value_, newPriorityNode);\n    }\n    /** @inheritDoc */ getImmediateChild(childName) {\n        // Hack to treat priority as a regular child\n        if (childName === \".priority\") {\n            return this.priorityNode_;\n        } else {\n            return LeafNode.__childrenNodeConstructor.EMPTY_NODE;\n        }\n    }\n    /** @inheritDoc */ getChild(path) {\n        if (pathIsEmpty(path)) {\n            return this;\n        } else if (pathGetFront(path) === \".priority\") {\n            return this.priorityNode_;\n        } else {\n            return LeafNode.__childrenNodeConstructor.EMPTY_NODE;\n        }\n    }\n    hasChild() {\n        return false;\n    }\n    /** @inheritDoc */ getPredecessorChildName(childName, childNode) {\n        return null;\n    }\n    /** @inheritDoc */ updateImmediateChild(childName, newChildNode) {\n        if (childName === \".priority\") {\n            return this.updatePriority(newChildNode);\n        } else if (newChildNode.isEmpty() && childName !== \".priority\") {\n            return this;\n        } else {\n            return LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(childName, newChildNode).updatePriority(this.priorityNode_);\n        }\n    }\n    /** @inheritDoc */ updateChild(path, newChildNode) {\n        const front = pathGetFront(path);\n        if (front === null) {\n            return newChildNode;\n        } else if (newChildNode.isEmpty() && front !== \".priority\") {\n            return this;\n        } else {\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(front !== \".priority\" || pathGetLength(path) === 1, \".priority must be the last token in a path\");\n            return this.updateImmediateChild(front, LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateChild(pathPopFront(path), newChildNode));\n        }\n    }\n    /** @inheritDoc */ isEmpty() {\n        return false;\n    }\n    /** @inheritDoc */ numChildren() {\n        return 0;\n    }\n    /** @inheritDoc */ forEachChild(index, action) {\n        return false;\n    }\n    val(exportFormat) {\n        if (exportFormat && !this.getPriority().isEmpty()) {\n            return {\n                \".value\": this.getValue(),\n                \".priority\": this.getPriority().val()\n            };\n        } else {\n            return this.getValue();\n        }\n    }\n    /** @inheritDoc */ hash() {\n        if (this.lazyHash_ === null) {\n            let toHash = \"\";\n            if (!this.priorityNode_.isEmpty()) {\n                toHash += \"priority:\" + priorityHashText(this.priorityNode_.val()) + \":\";\n            }\n            const type = typeof this.value_;\n            toHash += type + \":\";\n            if (type === \"number\") {\n                toHash += doubleToIEEE754String(this.value_);\n            } else {\n                toHash += this.value_;\n            }\n            this.lazyHash_ = sha1(toHash);\n        }\n        return this.lazyHash_;\n    }\n    /**\r\n     * Returns the value of the leaf node.\r\n     * @returns The value of the node.\r\n     */ getValue() {\n        return this.value_;\n    }\n    compareTo(other) {\n        if (other === LeafNode.__childrenNodeConstructor.EMPTY_NODE) {\n            return 1;\n        } else if (other instanceof LeafNode.__childrenNodeConstructor) {\n            return -1;\n        } else {\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(other.isLeafNode(), \"Unknown node type\");\n            return this.compareToLeafNode_(other);\n        }\n    }\n    /**\r\n     * Comparison specifically for two leaf nodes\r\n     */ compareToLeafNode_(otherLeaf) {\n        const otherLeafType = typeof otherLeaf.value_;\n        const thisLeafType = typeof this.value_;\n        const otherIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(otherLeafType);\n        const thisIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(thisLeafType);\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(otherIndex >= 0, \"Unknown leaf type: \" + otherLeafType);\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(thisIndex >= 0, \"Unknown leaf type: \" + thisLeafType);\n        if (otherIndex === thisIndex) {\n            // Same type, compare values\n            if (thisLeafType === \"object\") {\n                // Deferred value nodes are all equal, but we should also never get to this point...\n                return 0;\n            } else {\n                // Note that this works because true > false, all others are number or string comparisons\n                if (this.value_ < otherLeaf.value_) {\n                    return -1;\n                } else if (this.value_ === otherLeaf.value_) {\n                    return 0;\n                } else {\n                    return 1;\n                }\n            }\n        } else {\n            return thisIndex - otherIndex;\n        }\n    }\n    withIndex() {\n        return this;\n    }\n    isIndexed() {\n        return true;\n    }\n    equals(other) {\n        if (other === this) {\n            return true;\n        } else if (other.isLeafNode()) {\n            const otherLeaf = other;\n            return this.value_ === otherLeaf.value_ && this.priorityNode_.equals(otherLeaf.priorityNode_);\n        } else {\n            return false;\n        }\n    }\n}\n/**\r\n * The sort order for comparing leaf nodes of different types. If two leaf nodes have\r\n * the same type, the comparison falls back to their value\r\n */ LeafNode.VALUE_TYPE_ORDER = [\n    \"object\",\n    \"boolean\",\n    \"number\",\n    \"string\"\n];\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ let nodeFromJSON$1;\nlet MAX_NODE$1;\nfunction setNodeFromJSON(val) {\n    nodeFromJSON$1 = val;\n}\nfunction setMaxNode(val) {\n    MAX_NODE$1 = val;\n}\nclass PriorityIndex extends Index {\n    compare(a, b) {\n        const aPriority = a.node.getPriority();\n        const bPriority = b.node.getPriority();\n        const indexCmp = aPriority.compareTo(bPriority);\n        if (indexCmp === 0) {\n            return nameCompare(a.name, b.name);\n        } else {\n            return indexCmp;\n        }\n    }\n    isDefinedOn(node) {\n        return !node.getPriority().isEmpty();\n    }\n    indexedValueChanged(oldNode, newNode) {\n        return !oldNode.getPriority().equals(newNode.getPriority());\n    }\n    minPost() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return NamedNode.MIN;\n    }\n    maxPost() {\n        return new NamedNode(MAX_NAME, new LeafNode(\"[PRIORITY-POST]\", MAX_NODE$1));\n    }\n    makePost(indexValue, name) {\n        const priorityNode = nodeFromJSON$1(indexValue);\n        return new NamedNode(name, new LeafNode(\"[PRIORITY-POST]\", priorityNode));\n    }\n    /**\r\n     * @returns String representation for inclusion in a query spec\r\n     */ toString() {\n        return \".priority\";\n    }\n}\nconst PRIORITY_INDEX = new PriorityIndex();\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const LOG_2 = Math.log(2);\nclass Base12Num {\n    constructor(length){\n        const logBase2 = (num)=>// eslint-disable-next-line @typescript-eslint/no-explicit-any\n            parseInt(Math.log(num) / LOG_2, 10);\n        const bitMask = (bits)=>parseInt(Array(bits + 1).join(\"1\"), 2);\n        this.count = logBase2(length + 1);\n        this.current_ = this.count - 1;\n        const mask = bitMask(this.count);\n        this.bits_ = length + 1 & mask;\n    }\n    nextBitIsOne() {\n        //noinspection JSBitwiseOperatorUsage\n        const result = !(this.bits_ & 0x1 << this.current_);\n        this.current_--;\n        return result;\n    }\n}\n/**\r\n * Takes a list of child nodes and constructs a SortedSet using the given comparison\r\n * function\r\n *\r\n * Uses the algorithm described in the paper linked here:\r\n * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.1458\r\n *\r\n * @param childList - Unsorted list of children\r\n * @param cmp - The comparison method to be used\r\n * @param keyFn - An optional function to extract K from a node wrapper, if K's\r\n * type is not NamedNode\r\n * @param mapSortFn - An optional override for comparator used by the generated sorted map\r\n */ const buildChildSet = function(childList, cmp, keyFn, mapSortFn) {\n    childList.sort(cmp);\n    const buildBalancedTree = function(low, high) {\n        const length = high - low;\n        let namedNode;\n        let key;\n        if (length === 0) {\n            return null;\n        } else if (length === 1) {\n            namedNode = childList[low];\n            key = keyFn ? keyFn(namedNode) : namedNode;\n            return new LLRBNode(key, namedNode.node, LLRBNode.BLACK, null, null);\n        } else {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const middle = parseInt(length / 2, 10) + low;\n            const left = buildBalancedTree(low, middle);\n            const right = buildBalancedTree(middle + 1, high);\n            namedNode = childList[middle];\n            key = keyFn ? keyFn(namedNode) : namedNode;\n            return new LLRBNode(key, namedNode.node, LLRBNode.BLACK, left, right);\n        }\n    };\n    const buildFrom12Array = function(base12) {\n        let node = null;\n        let root = null;\n        let index = childList.length;\n        const buildPennant = function(chunkSize, color) {\n            const low = index - chunkSize;\n            const high = index;\n            index -= chunkSize;\n            const childTree = buildBalancedTree(low + 1, high);\n            const namedNode = childList[low];\n            const key = keyFn ? keyFn(namedNode) : namedNode;\n            attachPennant(new LLRBNode(key, namedNode.node, color, null, childTree));\n        };\n        const attachPennant = function(pennant) {\n            if (node) {\n                node.left = pennant;\n                node = pennant;\n            } else {\n                root = pennant;\n                node = pennant;\n            }\n        };\n        for(let i = 0; i < base12.count; ++i){\n            const isOne = base12.nextBitIsOne();\n            // The number of nodes taken in each slice is 2^(arr.length - (i + 1))\n            const chunkSize = Math.pow(2, base12.count - (i + 1));\n            if (isOne) {\n                buildPennant(chunkSize, LLRBNode.BLACK);\n            } else {\n                // current == 2\n                buildPennant(chunkSize, LLRBNode.BLACK);\n                buildPennant(chunkSize, LLRBNode.RED);\n            }\n        }\n        return root;\n    };\n    const base12 = new Base12Num(childList.length);\n    const root = buildFrom12Array(base12);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return new SortedMap(mapSortFn || cmp, root);\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ let _defaultIndexMap;\nconst fallbackObject = {};\nclass IndexMap {\n    constructor(indexes_, indexSet_){\n        this.indexes_ = indexes_;\n        this.indexSet_ = indexSet_;\n    }\n    /**\r\n     * The default IndexMap for nodes without a priority\r\n     */ static get Default() {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(fallbackObject && PRIORITY_INDEX, \"ChildrenNode.ts has not been loaded\");\n        _defaultIndexMap = _defaultIndexMap || new IndexMap({\n            \".priority\": fallbackObject\n        }, {\n            \".priority\": PRIORITY_INDEX\n        });\n        return _defaultIndexMap;\n    }\n    get(indexKey) {\n        const sortedMap = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.safeGet)(this.indexes_, indexKey);\n        if (!sortedMap) {\n            throw new Error(\"No index defined for \" + indexKey);\n        }\n        if (sortedMap instanceof SortedMap) {\n            return sortedMap;\n        } else {\n            // The index exists, but it falls back to just name comparison. Return null so that the calling code uses the\n            // regular child map\n            return null;\n        }\n    }\n    hasIndex(indexDefinition) {\n        return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.contains)(this.indexSet_, indexDefinition.toString());\n    }\n    addIndex(indexDefinition, existingChildren) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(indexDefinition !== KEY_INDEX, \"KeyIndex always exists and isn't meant to be added to the IndexMap.\");\n        const childList = [];\n        let sawIndexedValue = false;\n        const iter = existingChildren.getIterator(NamedNode.Wrap);\n        let next = iter.getNext();\n        while(next){\n            sawIndexedValue = sawIndexedValue || indexDefinition.isDefinedOn(next.node);\n            childList.push(next);\n            next = iter.getNext();\n        }\n        let newIndex;\n        if (sawIndexedValue) {\n            newIndex = buildChildSet(childList, indexDefinition.getCompare());\n        } else {\n            newIndex = fallbackObject;\n        }\n        const indexName = indexDefinition.toString();\n        const newIndexSet = Object.assign({}, this.indexSet_);\n        newIndexSet[indexName] = indexDefinition;\n        const newIndexes = Object.assign({}, this.indexes_);\n        newIndexes[indexName] = newIndex;\n        return new IndexMap(newIndexes, newIndexSet);\n    }\n    /**\r\n     * Ensure that this node is properly tracked in any indexes that we're maintaining\r\n     */ addToIndexes(namedNode, existingChildren) {\n        const newIndexes = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.map)(this.indexes_, (indexedChildren, indexName)=>{\n            const index = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.safeGet)(this.indexSet_, indexName);\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(index, \"Missing index implementation for \" + indexName);\n            if (indexedChildren === fallbackObject) {\n                // Check to see if we need to index everything\n                if (index.isDefinedOn(namedNode.node)) {\n                    // We need to build this index\n                    const childList = [];\n                    const iter = existingChildren.getIterator(NamedNode.Wrap);\n                    let next = iter.getNext();\n                    while(next){\n                        if (next.name !== namedNode.name) {\n                            childList.push(next);\n                        }\n                        next = iter.getNext();\n                    }\n                    childList.push(namedNode);\n                    return buildChildSet(childList, index.getCompare());\n                } else {\n                    // No change, this remains a fallback\n                    return fallbackObject;\n                }\n            } else {\n                const existingSnap = existingChildren.get(namedNode.name);\n                let newChildren = indexedChildren;\n                if (existingSnap) {\n                    newChildren = newChildren.remove(new NamedNode(namedNode.name, existingSnap));\n                }\n                return newChildren.insert(namedNode, namedNode.node);\n            }\n        });\n        return new IndexMap(newIndexes, this.indexSet_);\n    }\n    /**\r\n     * Create a new IndexMap instance with the given value removed\r\n     */ removeFromIndexes(namedNode, existingChildren) {\n        const newIndexes = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.map)(this.indexes_, (indexedChildren)=>{\n            if (indexedChildren === fallbackObject) {\n                // This is the fallback. Just return it, nothing to do in this case\n                return indexedChildren;\n            } else {\n                const existingSnap = existingChildren.get(namedNode.name);\n                if (existingSnap) {\n                    return indexedChildren.remove(new NamedNode(namedNode.name, existingSnap));\n                } else {\n                    // No record of this child\n                    return indexedChildren;\n                }\n            }\n        });\n        return new IndexMap(newIndexes, this.indexSet_);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // TODO: For memory savings, don't store priorityNode_ if it's empty.\nlet EMPTY_NODE;\n/**\r\n * ChildrenNode is a class for storing internal nodes in a DataSnapshot\r\n * (i.e. nodes with children).  It implements Node and stores the\r\n * list of children in the children property, sorted by child name.\r\n */ class ChildrenNode {\n    /**\r\n     * @param children_ - List of children of this node..\r\n     * @param priorityNode_ - The priority of this node (as a snapshot node).\r\n     */ constructor(children_, priorityNode_, indexMap_){\n        this.children_ = children_;\n        this.priorityNode_ = priorityNode_;\n        this.indexMap_ = indexMap_;\n        this.lazyHash_ = null;\n        /**\r\n         * Note: The only reason we allow null priority is for EMPTY_NODE, since we can't use\r\n         * EMPTY_NODE as the priority of EMPTY_NODE.  We might want to consider making EMPTY_NODE its own\r\n         * class instead of an empty ChildrenNode.\r\n         */ if (this.priorityNode_) {\n            validatePriorityNode(this.priorityNode_);\n        }\n        if (this.children_.isEmpty()) {\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(!this.priorityNode_ || this.priorityNode_.isEmpty(), \"An empty node cannot have a priority\");\n        }\n    }\n    static get EMPTY_NODE() {\n        return EMPTY_NODE || (EMPTY_NODE = new ChildrenNode(new SortedMap(NAME_COMPARATOR), null, IndexMap.Default));\n    }\n    /** @inheritDoc */ isLeafNode() {\n        return false;\n    }\n    /** @inheritDoc */ getPriority() {\n        return this.priorityNode_ || EMPTY_NODE;\n    }\n    /** @inheritDoc */ updatePriority(newPriorityNode) {\n        if (this.children_.isEmpty()) {\n            // Don't allow priorities on empty nodes\n            return this;\n        } else {\n            return new ChildrenNode(this.children_, newPriorityNode, this.indexMap_);\n        }\n    }\n    /** @inheritDoc */ getImmediateChild(childName) {\n        // Hack to treat priority as a regular child\n        if (childName === \".priority\") {\n            return this.getPriority();\n        } else {\n            const child = this.children_.get(childName);\n            return child === null ? EMPTY_NODE : child;\n        }\n    }\n    /** @inheritDoc */ getChild(path) {\n        const front = pathGetFront(path);\n        if (front === null) {\n            return this;\n        }\n        return this.getImmediateChild(front).getChild(pathPopFront(path));\n    }\n    /** @inheritDoc */ hasChild(childName) {\n        return this.children_.get(childName) !== null;\n    }\n    /** @inheritDoc */ updateImmediateChild(childName, newChildNode) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(newChildNode, \"We should always be passing snapshot nodes\");\n        if (childName === \".priority\") {\n            return this.updatePriority(newChildNode);\n        } else {\n            const namedNode = new NamedNode(childName, newChildNode);\n            let newChildren, newIndexMap;\n            if (newChildNode.isEmpty()) {\n                newChildren = this.children_.remove(childName);\n                newIndexMap = this.indexMap_.removeFromIndexes(namedNode, this.children_);\n            } else {\n                newChildren = this.children_.insert(childName, newChildNode);\n                newIndexMap = this.indexMap_.addToIndexes(namedNode, this.children_);\n            }\n            const newPriority = newChildren.isEmpty() ? EMPTY_NODE : this.priorityNode_;\n            return new ChildrenNode(newChildren, newPriority, newIndexMap);\n        }\n    }\n    /** @inheritDoc */ updateChild(path, newChildNode) {\n        const front = pathGetFront(path);\n        if (front === null) {\n            return newChildNode;\n        } else {\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(pathGetFront(path) !== \".priority\" || pathGetLength(path) === 1, \".priority must be the last token in a path\");\n            const newImmediateChild = this.getImmediateChild(front).updateChild(pathPopFront(path), newChildNode);\n            return this.updateImmediateChild(front, newImmediateChild);\n        }\n    }\n    /** @inheritDoc */ isEmpty() {\n        return this.children_.isEmpty();\n    }\n    /** @inheritDoc */ numChildren() {\n        return this.children_.count();\n    }\n    /** @inheritDoc */ val(exportFormat) {\n        if (this.isEmpty()) {\n            return null;\n        }\n        const obj = {};\n        let numKeys = 0, maxKey = 0, allIntegerKeys = true;\n        this.forEachChild(PRIORITY_INDEX, (key, childNode)=>{\n            obj[key] = childNode.val(exportFormat);\n            numKeys++;\n            if (allIntegerKeys && ChildrenNode.INTEGER_REGEXP_.test(key)) {\n                maxKey = Math.max(maxKey, Number(key));\n            } else {\n                allIntegerKeys = false;\n            }\n        });\n        if (!exportFormat && allIntegerKeys && maxKey < 2 * numKeys) {\n            // convert to array.\n            const array = [];\n            // eslint-disable-next-line guard-for-in\n            for(const key in obj){\n                array[key] = obj[key];\n            }\n            return array;\n        } else {\n            if (exportFormat && !this.getPriority().isEmpty()) {\n                obj[\".priority\"] = this.getPriority().val();\n            }\n            return obj;\n        }\n    }\n    /** @inheritDoc */ hash() {\n        if (this.lazyHash_ === null) {\n            let toHash = \"\";\n            if (!this.getPriority().isEmpty()) {\n                toHash += \"priority:\" + priorityHashText(this.getPriority().val()) + \":\";\n            }\n            this.forEachChild(PRIORITY_INDEX, (key, childNode)=>{\n                const childHash = childNode.hash();\n                if (childHash !== \"\") {\n                    toHash += \":\" + key + \":\" + childHash;\n                }\n            });\n            this.lazyHash_ = toHash === \"\" ? \"\" : sha1(toHash);\n        }\n        return this.lazyHash_;\n    }\n    /** @inheritDoc */ getPredecessorChildName(childName, childNode, index) {\n        const idx = this.resolveIndex_(index);\n        if (idx) {\n            const predecessor = idx.getPredecessorKey(new NamedNode(childName, childNode));\n            return predecessor ? predecessor.name : null;\n        } else {\n            return this.children_.getPredecessorKey(childName);\n        }\n    }\n    getFirstChildName(indexDefinition) {\n        const idx = this.resolveIndex_(indexDefinition);\n        if (idx) {\n            const minKey = idx.minKey();\n            return minKey && minKey.name;\n        } else {\n            return this.children_.minKey();\n        }\n    }\n    getFirstChild(indexDefinition) {\n        const minKey = this.getFirstChildName(indexDefinition);\n        if (minKey) {\n            return new NamedNode(minKey, this.children_.get(minKey));\n        } else {\n            return null;\n        }\n    }\n    /**\r\n     * Given an index, return the key name of the largest value we have, according to that index\r\n     */ getLastChildName(indexDefinition) {\n        const idx = this.resolveIndex_(indexDefinition);\n        if (idx) {\n            const maxKey = idx.maxKey();\n            return maxKey && maxKey.name;\n        } else {\n            return this.children_.maxKey();\n        }\n    }\n    getLastChild(indexDefinition) {\n        const maxKey = this.getLastChildName(indexDefinition);\n        if (maxKey) {\n            return new NamedNode(maxKey, this.children_.get(maxKey));\n        } else {\n            return null;\n        }\n    }\n    forEachChild(index, action) {\n        const idx = this.resolveIndex_(index);\n        if (idx) {\n            return idx.inorderTraversal((wrappedNode)=>{\n                return action(wrappedNode.name, wrappedNode.node);\n            });\n        } else {\n            return this.children_.inorderTraversal(action);\n        }\n    }\n    getIterator(indexDefinition) {\n        return this.getIteratorFrom(indexDefinition.minPost(), indexDefinition);\n    }\n    getIteratorFrom(startPost, indexDefinition) {\n        const idx = this.resolveIndex_(indexDefinition);\n        if (idx) {\n            return idx.getIteratorFrom(startPost, (key)=>key);\n        } else {\n            const iterator = this.children_.getIteratorFrom(startPost.name, NamedNode.Wrap);\n            let next = iterator.peek();\n            while(next != null && indexDefinition.compare(next, startPost) < 0){\n                iterator.getNext();\n                next = iterator.peek();\n            }\n            return iterator;\n        }\n    }\n    getReverseIterator(indexDefinition) {\n        return this.getReverseIteratorFrom(indexDefinition.maxPost(), indexDefinition);\n    }\n    getReverseIteratorFrom(endPost, indexDefinition) {\n        const idx = this.resolveIndex_(indexDefinition);\n        if (idx) {\n            return idx.getReverseIteratorFrom(endPost, (key)=>{\n                return key;\n            });\n        } else {\n            const iterator = this.children_.getReverseIteratorFrom(endPost.name, NamedNode.Wrap);\n            let next = iterator.peek();\n            while(next != null && indexDefinition.compare(next, endPost) > 0){\n                iterator.getNext();\n                next = iterator.peek();\n            }\n            return iterator;\n        }\n    }\n    compareTo(other) {\n        if (this.isEmpty()) {\n            if (other.isEmpty()) {\n                return 0;\n            } else {\n                return -1;\n            }\n        } else if (other.isLeafNode() || other.isEmpty()) {\n            return 1;\n        } else if (other === MAX_NODE) {\n            return -1;\n        } else {\n            // Must be another node with children.\n            return 0;\n        }\n    }\n    withIndex(indexDefinition) {\n        if (indexDefinition === KEY_INDEX || this.indexMap_.hasIndex(indexDefinition)) {\n            return this;\n        } else {\n            const newIndexMap = this.indexMap_.addIndex(indexDefinition, this.children_);\n            return new ChildrenNode(this.children_, this.priorityNode_, newIndexMap);\n        }\n    }\n    isIndexed(index) {\n        return index === KEY_INDEX || this.indexMap_.hasIndex(index);\n    }\n    equals(other) {\n        if (other === this) {\n            return true;\n        } else if (other.isLeafNode()) {\n            return false;\n        } else {\n            const otherChildrenNode = other;\n            if (!this.getPriority().equals(otherChildrenNode.getPriority())) {\n                return false;\n            } else if (this.children_.count() === otherChildrenNode.children_.count()) {\n                const thisIter = this.getIterator(PRIORITY_INDEX);\n                const otherIter = otherChildrenNode.getIterator(PRIORITY_INDEX);\n                let thisCurrent = thisIter.getNext();\n                let otherCurrent = otherIter.getNext();\n                while(thisCurrent && otherCurrent){\n                    if (thisCurrent.name !== otherCurrent.name || !thisCurrent.node.equals(otherCurrent.node)) {\n                        return false;\n                    }\n                    thisCurrent = thisIter.getNext();\n                    otherCurrent = otherIter.getNext();\n                }\n                return thisCurrent === null && otherCurrent === null;\n            } else {\n                return false;\n            }\n        }\n    }\n    /**\r\n     * Returns a SortedMap ordered by index, or null if the default (by-key) ordering can be used\r\n     * instead.\r\n     *\r\n     */ resolveIndex_(indexDefinition) {\n        if (indexDefinition === KEY_INDEX) {\n            return null;\n        } else {\n            return this.indexMap_.get(indexDefinition.toString());\n        }\n    }\n}\nChildrenNode.INTEGER_REGEXP_ = /^(0|[1-9]\\d*)$/;\nclass MaxNode extends ChildrenNode {\n    constructor(){\n        super(new SortedMap(NAME_COMPARATOR), ChildrenNode.EMPTY_NODE, IndexMap.Default);\n    }\n    compareTo(other) {\n        if (other === this) {\n            return 0;\n        } else {\n            return 1;\n        }\n    }\n    equals(other) {\n        // Not that we every compare it, but MAX_NODE is only ever equal to itself\n        return other === this;\n    }\n    getPriority() {\n        return this;\n    }\n    getImmediateChild(childName) {\n        return ChildrenNode.EMPTY_NODE;\n    }\n    isEmpty() {\n        return false;\n    }\n}\n/**\r\n * Marker that will sort higher than any other snapshot.\r\n */ const MAX_NODE = new MaxNode();\nObject.defineProperties(NamedNode, {\n    MIN: {\n        value: new NamedNode(MIN_NAME, ChildrenNode.EMPTY_NODE)\n    },\n    MAX: {\n        value: new NamedNode(MAX_NAME, MAX_NODE)\n    }\n});\n/**\r\n * Reference Extensions\r\n */ KeyIndex.__EMPTY_NODE = ChildrenNode.EMPTY_NODE;\nLeafNode.__childrenNodeConstructor = ChildrenNode;\nsetMaxNode$1(MAX_NODE);\nsetMaxNode(MAX_NODE);\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const USE_HINZE = true;\n/**\r\n * Constructs a snapshot node representing the passed JSON and returns it.\r\n * @param json - JSON to create a node for.\r\n * @param priority - Optional priority to use.  This will be ignored if the\r\n * passed JSON contains a .priority property.\r\n */ function nodeFromJSON(json, priority = null) {\n    if (json === null) {\n        return ChildrenNode.EMPTY_NODE;\n    }\n    if (typeof json === \"object\" && \".priority\" in json) {\n        priority = json[\".priority\"];\n    }\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(priority === null || typeof priority === \"string\" || typeof priority === \"number\" || typeof priority === \"object\" && \".sv\" in priority, \"Invalid priority type found: \" + typeof priority);\n    if (typeof json === \"object\" && \".value\" in json && json[\".value\"] !== null) {\n        json = json[\".value\"];\n    }\n    // Valid leaf nodes include non-objects or server-value wrapper objects\n    if (typeof json !== \"object\" || \".sv\" in json) {\n        const jsonLeaf = json;\n        return new LeafNode(jsonLeaf, nodeFromJSON(priority));\n    }\n    if (!(json instanceof Array) && USE_HINZE) {\n        const children = [];\n        let childrenHavePriority = false;\n        const hinzeJsonObj = json;\n        each(hinzeJsonObj, (key, child)=>{\n            if (key.substring(0, 1) !== \".\") {\n                // Ignore metadata nodes\n                const childNode = nodeFromJSON(child);\n                if (!childNode.isEmpty()) {\n                    childrenHavePriority = childrenHavePriority || !childNode.getPriority().isEmpty();\n                    children.push(new NamedNode(key, childNode));\n                }\n            }\n        });\n        if (children.length === 0) {\n            return ChildrenNode.EMPTY_NODE;\n        }\n        const childSet = buildChildSet(children, NAME_ONLY_COMPARATOR, (namedNode)=>namedNode.name, NAME_COMPARATOR);\n        if (childrenHavePriority) {\n            const sortedChildSet = buildChildSet(children, PRIORITY_INDEX.getCompare());\n            return new ChildrenNode(childSet, nodeFromJSON(priority), new IndexMap({\n                \".priority\": sortedChildSet\n            }, {\n                \".priority\": PRIORITY_INDEX\n            }));\n        } else {\n            return new ChildrenNode(childSet, nodeFromJSON(priority), IndexMap.Default);\n        }\n    } else {\n        let node = ChildrenNode.EMPTY_NODE;\n        each(json, (key, childData)=>{\n            if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.contains)(json, key)) {\n                if (key.substring(0, 1) !== \".\") {\n                    // ignore metadata nodes.\n                    const childNode = nodeFromJSON(childData);\n                    if (childNode.isLeafNode() || !childNode.isEmpty()) {\n                        node = node.updateImmediateChild(key, childNode);\n                    }\n                }\n            }\n        });\n        return node.updatePriority(nodeFromJSON(priority));\n    }\n}\nsetNodeFromJSON(nodeFromJSON);\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class PathIndex extends Index {\n    constructor(indexPath_){\n        super();\n        this.indexPath_ = indexPath_;\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(!pathIsEmpty(indexPath_) && pathGetFront(indexPath_) !== \".priority\", \"Can't create PathIndex with empty path or .priority key\");\n    }\n    extractChild(snap) {\n        return snap.getChild(this.indexPath_);\n    }\n    isDefinedOn(node) {\n        return !node.getChild(this.indexPath_).isEmpty();\n    }\n    compare(a, b) {\n        const aChild = this.extractChild(a.node);\n        const bChild = this.extractChild(b.node);\n        const indexCmp = aChild.compareTo(bChild);\n        if (indexCmp === 0) {\n            return nameCompare(a.name, b.name);\n        } else {\n            return indexCmp;\n        }\n    }\n    makePost(indexValue, name) {\n        const valueNode = nodeFromJSON(indexValue);\n        const node = ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, valueNode);\n        return new NamedNode(name, node);\n    }\n    maxPost() {\n        const node = ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, MAX_NODE);\n        return new NamedNode(MAX_NAME, node);\n    }\n    toString() {\n        return pathSlice(this.indexPath_, 0).join(\"/\");\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class ValueIndex extends Index {\n    compare(a, b) {\n        const indexCmp = a.node.compareTo(b.node);\n        if (indexCmp === 0) {\n            return nameCompare(a.name, b.name);\n        } else {\n            return indexCmp;\n        }\n    }\n    isDefinedOn(node) {\n        return true;\n    }\n    indexedValueChanged(oldNode, newNode) {\n        return !oldNode.equals(newNode);\n    }\n    minPost() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return NamedNode.MIN;\n    }\n    maxPost() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return NamedNode.MAX;\n    }\n    makePost(indexValue, name) {\n        const valueNode = nodeFromJSON(indexValue);\n        return new NamedNode(name, valueNode);\n    }\n    /**\r\n     * @returns String representation for inclusion in a query spec\r\n     */ toString() {\n        return \".value\";\n    }\n}\nconst VALUE_INDEX = new ValueIndex();\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function changeValue(snapshotNode) {\n    return {\n        type: \"value\" /* ChangeType.VALUE */ ,\n        snapshotNode\n    };\n}\nfunction changeChildAdded(childName, snapshotNode) {\n    return {\n        type: \"child_added\" /* ChangeType.CHILD_ADDED */ ,\n        snapshotNode,\n        childName\n    };\n}\nfunction changeChildRemoved(childName, snapshotNode) {\n    return {\n        type: \"child_removed\" /* ChangeType.CHILD_REMOVED */ ,\n        snapshotNode,\n        childName\n    };\n}\nfunction changeChildChanged(childName, snapshotNode, oldSnap) {\n    return {\n        type: \"child_changed\" /* ChangeType.CHILD_CHANGED */ ,\n        snapshotNode,\n        childName,\n        oldSnap\n    };\n}\nfunction changeChildMoved(childName, snapshotNode) {\n    return {\n        type: \"child_moved\" /* ChangeType.CHILD_MOVED */ ,\n        snapshotNode,\n        childName\n    };\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Doesn't really filter nodes but applies an index to the node and keeps track of any changes\r\n */ class IndexedFilter {\n    constructor(index_){\n        this.index_ = index_;\n    }\n    updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(snap.isIndexed(this.index_), \"A node must be indexed if only a child is updated\");\n        const oldChild = snap.getImmediateChild(key);\n        // Check if anything actually changed.\n        if (oldChild.getChild(affectedPath).equals(newChild.getChild(affectedPath))) {\n            // There's an edge case where a child can enter or leave the view because affectedPath was set to null.\n            // In this case, affectedPath will appear null in both the old and new snapshots.  So we need\n            // to avoid treating these cases as \"nothing changed.\"\n            if (oldChild.isEmpty() === newChild.isEmpty()) {\n                // Nothing changed.\n                // This assert should be valid, but it's expensive (can dominate perf testing) so don't actually do it.\n                //assert(oldChild.equals(newChild), 'Old and new snapshots should be equal.');\n                return snap;\n            }\n        }\n        if (optChangeAccumulator != null) {\n            if (newChild.isEmpty()) {\n                if (snap.hasChild(key)) {\n                    optChangeAccumulator.trackChildChange(changeChildRemoved(key, oldChild));\n                } else {\n                    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(snap.isLeafNode(), \"A child remove without an old child only makes sense on a leaf node\");\n                }\n            } else if (oldChild.isEmpty()) {\n                optChangeAccumulator.trackChildChange(changeChildAdded(key, newChild));\n            } else {\n                optChangeAccumulator.trackChildChange(changeChildChanged(key, newChild, oldChild));\n            }\n        }\n        if (snap.isLeafNode() && newChild.isEmpty()) {\n            return snap;\n        } else {\n            // Make sure the node is indexed\n            return snap.updateImmediateChild(key, newChild).withIndex(this.index_);\n        }\n    }\n    updateFullNode(oldSnap, newSnap, optChangeAccumulator) {\n        if (optChangeAccumulator != null) {\n            if (!oldSnap.isLeafNode()) {\n                oldSnap.forEachChild(PRIORITY_INDEX, (key, childNode)=>{\n                    if (!newSnap.hasChild(key)) {\n                        optChangeAccumulator.trackChildChange(changeChildRemoved(key, childNode));\n                    }\n                });\n            }\n            if (!newSnap.isLeafNode()) {\n                newSnap.forEachChild(PRIORITY_INDEX, (key, childNode)=>{\n                    if (oldSnap.hasChild(key)) {\n                        const oldChild = oldSnap.getImmediateChild(key);\n                        if (!oldChild.equals(childNode)) {\n                            optChangeAccumulator.trackChildChange(changeChildChanged(key, childNode, oldChild));\n                        }\n                    } else {\n                        optChangeAccumulator.trackChildChange(changeChildAdded(key, childNode));\n                    }\n                });\n            }\n        }\n        return newSnap.withIndex(this.index_);\n    }\n    updatePriority(oldSnap, newPriority) {\n        if (oldSnap.isEmpty()) {\n            return ChildrenNode.EMPTY_NODE;\n        } else {\n            return oldSnap.updatePriority(newPriority);\n        }\n    }\n    filtersNodes() {\n        return false;\n    }\n    getIndexedFilter() {\n        return this;\n    }\n    getIndex() {\n        return this.index_;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Filters nodes by range and uses an IndexFilter to track any changes after filtering the node\r\n */ class RangedFilter {\n    constructor(params){\n        this.indexedFilter_ = new IndexedFilter(params.getIndex());\n        this.index_ = params.getIndex();\n        this.startPost_ = RangedFilter.getStartPost_(params);\n        this.endPost_ = RangedFilter.getEndPost_(params);\n        this.startIsInclusive_ = !params.startAfterSet_;\n        this.endIsInclusive_ = !params.endBeforeSet_;\n    }\n    getStartPost() {\n        return this.startPost_;\n    }\n    getEndPost() {\n        return this.endPost_;\n    }\n    matches(node) {\n        const isWithinStart = this.startIsInclusive_ ? this.index_.compare(this.getStartPost(), node) <= 0 : this.index_.compare(this.getStartPost(), node) < 0;\n        const isWithinEnd = this.endIsInclusive_ ? this.index_.compare(node, this.getEndPost()) <= 0 : this.index_.compare(node, this.getEndPost()) < 0;\n        return isWithinStart && isWithinEnd;\n    }\n    updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator) {\n        if (!this.matches(new NamedNode(key, newChild))) {\n            newChild = ChildrenNode.EMPTY_NODE;\n        }\n        return this.indexedFilter_.updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);\n    }\n    updateFullNode(oldSnap, newSnap, optChangeAccumulator) {\n        if (newSnap.isLeafNode()) {\n            // Make sure we have a children node with the correct index, not a leaf node;\n            newSnap = ChildrenNode.EMPTY_NODE;\n        }\n        let filtered = newSnap.withIndex(this.index_);\n        // Don't support priorities on queries\n        filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);\n        const self = this;\n        newSnap.forEachChild(PRIORITY_INDEX, (key, childNode)=>{\n            if (!self.matches(new NamedNode(key, childNode))) {\n                filtered = filtered.updateImmediateChild(key, ChildrenNode.EMPTY_NODE);\n            }\n        });\n        return this.indexedFilter_.updateFullNode(oldSnap, filtered, optChangeAccumulator);\n    }\n    updatePriority(oldSnap, newPriority) {\n        // Don't support priorities on queries\n        return oldSnap;\n    }\n    filtersNodes() {\n        return true;\n    }\n    getIndexedFilter() {\n        return this.indexedFilter_;\n    }\n    getIndex() {\n        return this.index_;\n    }\n    static getStartPost_(params) {\n        if (params.hasStart()) {\n            const startName = params.getIndexStartName();\n            return params.getIndex().makePost(params.getIndexStartValue(), startName);\n        } else {\n            return params.getIndex().minPost();\n        }\n    }\n    static getEndPost_(params) {\n        if (params.hasEnd()) {\n            const endName = params.getIndexEndName();\n            return params.getIndex().makePost(params.getIndexEndValue(), endName);\n        } else {\n            return params.getIndex().maxPost();\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Applies a limit and a range to a node and uses RangedFilter to do the heavy lifting where possible\r\n */ class LimitedFilter {\n    constructor(params){\n        this.withinDirectionalStart = (node)=>this.reverse_ ? this.withinEndPost(node) : this.withinStartPost(node);\n        this.withinDirectionalEnd = (node)=>this.reverse_ ? this.withinStartPost(node) : this.withinEndPost(node);\n        this.withinStartPost = (node)=>{\n            const compareRes = this.index_.compare(this.rangedFilter_.getStartPost(), node);\n            return this.startIsInclusive_ ? compareRes <= 0 : compareRes < 0;\n        };\n        this.withinEndPost = (node)=>{\n            const compareRes = this.index_.compare(node, this.rangedFilter_.getEndPost());\n            return this.endIsInclusive_ ? compareRes <= 0 : compareRes < 0;\n        };\n        this.rangedFilter_ = new RangedFilter(params);\n        this.index_ = params.getIndex();\n        this.limit_ = params.getLimit();\n        this.reverse_ = !params.isViewFromLeft();\n        this.startIsInclusive_ = !params.startAfterSet_;\n        this.endIsInclusive_ = !params.endBeforeSet_;\n    }\n    updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator) {\n        if (!this.rangedFilter_.matches(new NamedNode(key, newChild))) {\n            newChild = ChildrenNode.EMPTY_NODE;\n        }\n        if (snap.getImmediateChild(key).equals(newChild)) {\n            // No change\n            return snap;\n        } else if (snap.numChildren() < this.limit_) {\n            return this.rangedFilter_.getIndexedFilter().updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);\n        } else {\n            return this.fullLimitUpdateChild_(snap, key, newChild, source, optChangeAccumulator);\n        }\n    }\n    updateFullNode(oldSnap, newSnap, optChangeAccumulator) {\n        let filtered;\n        if (newSnap.isLeafNode() || newSnap.isEmpty()) {\n            // Make sure we have a children node with the correct index, not a leaf node;\n            filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);\n        } else {\n            if (this.limit_ * 2 < newSnap.numChildren() && newSnap.isIndexed(this.index_)) {\n                // Easier to build up a snapshot, since what we're given has more than twice the elements we want\n                filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);\n                // anchor to the startPost, endPost, or last element as appropriate\n                let iterator;\n                if (this.reverse_) {\n                    iterator = newSnap.getReverseIteratorFrom(this.rangedFilter_.getEndPost(), this.index_);\n                } else {\n                    iterator = newSnap.getIteratorFrom(this.rangedFilter_.getStartPost(), this.index_);\n                }\n                let count = 0;\n                while(iterator.hasNext() && count < this.limit_){\n                    const next = iterator.getNext();\n                    if (!this.withinDirectionalStart(next)) {\n                        continue;\n                    } else if (!this.withinDirectionalEnd(next)) {\n                        break;\n                    } else {\n                        filtered = filtered.updateImmediateChild(next.name, next.node);\n                        count++;\n                    }\n                }\n            } else {\n                // The snap contains less than twice the limit. Faster to delete from the snap than build up a new one\n                filtered = newSnap.withIndex(this.index_);\n                // Don't support priorities on queries\n                filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);\n                let iterator;\n                if (this.reverse_) {\n                    iterator = filtered.getReverseIterator(this.index_);\n                } else {\n                    iterator = filtered.getIterator(this.index_);\n                }\n                let count = 0;\n                while(iterator.hasNext()){\n                    const next = iterator.getNext();\n                    const inRange = count < this.limit_ && this.withinDirectionalStart(next) && this.withinDirectionalEnd(next);\n                    if (inRange) {\n                        count++;\n                    } else {\n                        filtered = filtered.updateImmediateChild(next.name, ChildrenNode.EMPTY_NODE);\n                    }\n                }\n            }\n        }\n        return this.rangedFilter_.getIndexedFilter().updateFullNode(oldSnap, filtered, optChangeAccumulator);\n    }\n    updatePriority(oldSnap, newPriority) {\n        // Don't support priorities on queries\n        return oldSnap;\n    }\n    filtersNodes() {\n        return true;\n    }\n    getIndexedFilter() {\n        return this.rangedFilter_.getIndexedFilter();\n    }\n    getIndex() {\n        return this.index_;\n    }\n    fullLimitUpdateChild_(snap, childKey, childSnap, source, changeAccumulator) {\n        // TODO: rename all cache stuff etc to general snap terminology\n        let cmp;\n        if (this.reverse_) {\n            const indexCmp = this.index_.getCompare();\n            cmp = (a, b)=>indexCmp(b, a);\n        } else {\n            cmp = this.index_.getCompare();\n        }\n        const oldEventCache = snap;\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(oldEventCache.numChildren() === this.limit_, \"\");\n        const newChildNamedNode = new NamedNode(childKey, childSnap);\n        const windowBoundary = this.reverse_ ? oldEventCache.getFirstChild(this.index_) : oldEventCache.getLastChild(this.index_);\n        const inRange = this.rangedFilter_.matches(newChildNamedNode);\n        if (oldEventCache.hasChild(childKey)) {\n            const oldChildSnap = oldEventCache.getImmediateChild(childKey);\n            let nextChild = source.getChildAfterChild(this.index_, windowBoundary, this.reverse_);\n            while(nextChild != null && (nextChild.name === childKey || oldEventCache.hasChild(nextChild.name))){\n                // There is a weird edge case where a node is updated as part of a merge in the write tree, but hasn't\n                // been applied to the limited filter yet. Ignore this next child which will be updated later in\n                // the limited filter...\n                nextChild = source.getChildAfterChild(this.index_, nextChild, this.reverse_);\n            }\n            const compareNext = nextChild == null ? 1 : cmp(nextChild, newChildNamedNode);\n            const remainsInWindow = inRange && !childSnap.isEmpty() && compareNext >= 0;\n            if (remainsInWindow) {\n                if (changeAccumulator != null) {\n                    changeAccumulator.trackChildChange(changeChildChanged(childKey, childSnap, oldChildSnap));\n                }\n                return oldEventCache.updateImmediateChild(childKey, childSnap);\n            } else {\n                if (changeAccumulator != null) {\n                    changeAccumulator.trackChildChange(changeChildRemoved(childKey, oldChildSnap));\n                }\n                const newEventCache = oldEventCache.updateImmediateChild(childKey, ChildrenNode.EMPTY_NODE);\n                const nextChildInRange = nextChild != null && this.rangedFilter_.matches(nextChild);\n                if (nextChildInRange) {\n                    if (changeAccumulator != null) {\n                        changeAccumulator.trackChildChange(changeChildAdded(nextChild.name, nextChild.node));\n                    }\n                    return newEventCache.updateImmediateChild(nextChild.name, nextChild.node);\n                } else {\n                    return newEventCache;\n                }\n            }\n        } else if (childSnap.isEmpty()) {\n            // we're deleting a node, but it was not in the window, so ignore it\n            return snap;\n        } else if (inRange) {\n            if (cmp(windowBoundary, newChildNamedNode) >= 0) {\n                if (changeAccumulator != null) {\n                    changeAccumulator.trackChildChange(changeChildRemoved(windowBoundary.name, windowBoundary.node));\n                    changeAccumulator.trackChildChange(changeChildAdded(childKey, childSnap));\n                }\n                return oldEventCache.updateImmediateChild(childKey, childSnap).updateImmediateChild(windowBoundary.name, ChildrenNode.EMPTY_NODE);\n            } else {\n                return snap;\n            }\n        } else {\n            return snap;\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * This class is an immutable-from-the-public-api struct containing a set of query parameters defining a\r\n * range to be returned for a particular location. It is assumed that validation of parameters is done at the\r\n * user-facing API level, so it is not done here.\r\n *\r\n * @internal\r\n */ class QueryParams {\n    constructor(){\n        this.limitSet_ = false;\n        this.startSet_ = false;\n        this.startNameSet_ = false;\n        this.startAfterSet_ = false; // can only be true if startSet_ is true\n        this.endSet_ = false;\n        this.endNameSet_ = false;\n        this.endBeforeSet_ = false; // can only be true if endSet_ is true\n        this.limit_ = 0;\n        this.viewFrom_ = \"\";\n        this.indexStartValue_ = null;\n        this.indexStartName_ = \"\";\n        this.indexEndValue_ = null;\n        this.indexEndName_ = \"\";\n        this.index_ = PRIORITY_INDEX;\n    }\n    hasStart() {\n        return this.startSet_;\n    }\n    /**\r\n     * @returns True if it would return from left.\r\n     */ isViewFromLeft() {\n        if (this.viewFrom_ === \"\") {\n            // limit(), rather than limitToFirst or limitToLast was called.\n            // This means that only one of startSet_ and endSet_ is true. Use them\n            // to calculate which side of the view to anchor to. If neither is set,\n            // anchor to the end.\n            return this.startSet_;\n        } else {\n            return this.viewFrom_ === \"l\" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_LEFT */ ;\n        }\n    }\n    /**\r\n     * Only valid to call if hasStart() returns true\r\n     */ getIndexStartValue() {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(this.startSet_, \"Only valid if start has been set\");\n        return this.indexStartValue_;\n    }\n    /**\r\n     * Only valid to call if hasStart() returns true.\r\n     * Returns the starting key name for the range defined by these query parameters\r\n     */ getIndexStartName() {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(this.startSet_, \"Only valid if start has been set\");\n        if (this.startNameSet_) {\n            return this.indexStartName_;\n        } else {\n            return MIN_NAME;\n        }\n    }\n    hasEnd() {\n        return this.endSet_;\n    }\n    /**\r\n     * Only valid to call if hasEnd() returns true.\r\n     */ getIndexEndValue() {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(this.endSet_, \"Only valid if end has been set\");\n        return this.indexEndValue_;\n    }\n    /**\r\n     * Only valid to call if hasEnd() returns true.\r\n     * Returns the end key name for the range defined by these query parameters\r\n     */ getIndexEndName() {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(this.endSet_, \"Only valid if end has been set\");\n        if (this.endNameSet_) {\n            return this.indexEndName_;\n        } else {\n            return MAX_NAME;\n        }\n    }\n    hasLimit() {\n        return this.limitSet_;\n    }\n    /**\r\n     * @returns True if a limit has been set and it has been explicitly anchored\r\n     */ hasAnchoredLimit() {\n        return this.limitSet_ && this.viewFrom_ !== \"\";\n    }\n    /**\r\n     * Only valid to call if hasLimit() returns true\r\n     */ getLimit() {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(this.limitSet_, \"Only valid if limit has been set\");\n        return this.limit_;\n    }\n    getIndex() {\n        return this.index_;\n    }\n    loadsAllData() {\n        return !(this.startSet_ || this.endSet_ || this.limitSet_);\n    }\n    isDefault() {\n        return this.loadsAllData() && this.index_ === PRIORITY_INDEX;\n    }\n    copy() {\n        const copy = new QueryParams();\n        copy.limitSet_ = this.limitSet_;\n        copy.limit_ = this.limit_;\n        copy.startSet_ = this.startSet_;\n        copy.startAfterSet_ = this.startAfterSet_;\n        copy.indexStartValue_ = this.indexStartValue_;\n        copy.startNameSet_ = this.startNameSet_;\n        copy.indexStartName_ = this.indexStartName_;\n        copy.endSet_ = this.endSet_;\n        copy.endBeforeSet_ = this.endBeforeSet_;\n        copy.indexEndValue_ = this.indexEndValue_;\n        copy.endNameSet_ = this.endNameSet_;\n        copy.indexEndName_ = this.indexEndName_;\n        copy.index_ = this.index_;\n        copy.viewFrom_ = this.viewFrom_;\n        return copy;\n    }\n}\nfunction queryParamsGetNodeFilter(queryParams) {\n    if (queryParams.loadsAllData()) {\n        return new IndexedFilter(queryParams.getIndex());\n    } else if (queryParams.hasLimit()) {\n        return new LimitedFilter(queryParams);\n    } else {\n        return new RangedFilter(queryParams);\n    }\n}\nfunction queryParamsLimitToFirst(queryParams, newLimit) {\n    const newParams = queryParams.copy();\n    newParams.limitSet_ = true;\n    newParams.limit_ = newLimit;\n    newParams.viewFrom_ = \"l\" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_LEFT */ ;\n    return newParams;\n}\nfunction queryParamsLimitToLast(queryParams, newLimit) {\n    const newParams = queryParams.copy();\n    newParams.limitSet_ = true;\n    newParams.limit_ = newLimit;\n    newParams.viewFrom_ = \"r\" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_RIGHT */ ;\n    return newParams;\n}\nfunction queryParamsStartAt(queryParams, indexValue, key) {\n    const newParams = queryParams.copy();\n    newParams.startSet_ = true;\n    if (indexValue === undefined) {\n        indexValue = null;\n    }\n    newParams.indexStartValue_ = indexValue;\n    if (key != null) {\n        newParams.startNameSet_ = true;\n        newParams.indexStartName_ = key;\n    } else {\n        newParams.startNameSet_ = false;\n        newParams.indexStartName_ = \"\";\n    }\n    return newParams;\n}\nfunction queryParamsStartAfter(queryParams, indexValue, key) {\n    let params;\n    if (queryParams.index_ === KEY_INDEX || !!key) {\n        params = queryParamsStartAt(queryParams, indexValue, key);\n    } else {\n        params = queryParamsStartAt(queryParams, indexValue, MAX_NAME);\n    }\n    params.startAfterSet_ = true;\n    return params;\n}\nfunction queryParamsEndAt(queryParams, indexValue, key) {\n    const newParams = queryParams.copy();\n    newParams.endSet_ = true;\n    if (indexValue === undefined) {\n        indexValue = null;\n    }\n    newParams.indexEndValue_ = indexValue;\n    if (key !== undefined) {\n        newParams.endNameSet_ = true;\n        newParams.indexEndName_ = key;\n    } else {\n        newParams.endNameSet_ = false;\n        newParams.indexEndName_ = \"\";\n    }\n    return newParams;\n}\nfunction queryParamsEndBefore(queryParams, indexValue, key) {\n    let params;\n    if (queryParams.index_ === KEY_INDEX || !!key) {\n        params = queryParamsEndAt(queryParams, indexValue, key);\n    } else {\n        params = queryParamsEndAt(queryParams, indexValue, MIN_NAME);\n    }\n    params.endBeforeSet_ = true;\n    return params;\n}\nfunction queryParamsOrderBy(queryParams, index) {\n    const newParams = queryParams.copy();\n    newParams.index_ = index;\n    return newParams;\n}\n/**\r\n * Returns a set of REST query string parameters representing this query.\r\n *\r\n * @returns query string parameters\r\n */ function queryParamsToRestQueryStringParameters(queryParams) {\n    const qs = {};\n    if (queryParams.isDefault()) {\n        return qs;\n    }\n    let orderBy;\n    if (queryParams.index_ === PRIORITY_INDEX) {\n        orderBy = \"$priority\" /* REST_QUERY_CONSTANTS.PRIORITY_INDEX */ ;\n    } else if (queryParams.index_ === VALUE_INDEX) {\n        orderBy = \"$value\" /* REST_QUERY_CONSTANTS.VALUE_INDEX */ ;\n    } else if (queryParams.index_ === KEY_INDEX) {\n        orderBy = \"$key\" /* REST_QUERY_CONSTANTS.KEY_INDEX */ ;\n    } else {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(queryParams.index_ instanceof PathIndex, \"Unrecognized index type!\");\n        orderBy = queryParams.index_.toString();\n    }\n    qs[\"orderBy\" /* REST_QUERY_CONSTANTS.ORDER_BY */ ] = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(orderBy);\n    if (queryParams.startSet_) {\n        const startParam = queryParams.startAfterSet_ ? \"startAfter\" /* REST_QUERY_CONSTANTS.START_AFTER */  : \"startAt\" /* REST_QUERY_CONSTANTS.START_AT */ ;\n        qs[startParam] = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(queryParams.indexStartValue_);\n        if (queryParams.startNameSet_) {\n            qs[startParam] += \",\" + (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(queryParams.indexStartName_);\n        }\n    }\n    if (queryParams.endSet_) {\n        const endParam = queryParams.endBeforeSet_ ? \"endBefore\" /* REST_QUERY_CONSTANTS.END_BEFORE */  : \"endAt\" /* REST_QUERY_CONSTANTS.END_AT */ ;\n        qs[endParam] = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(queryParams.indexEndValue_);\n        if (queryParams.endNameSet_) {\n            qs[endParam] += \",\" + (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(queryParams.indexEndName_);\n        }\n    }\n    if (queryParams.limitSet_) {\n        if (queryParams.isViewFromLeft()) {\n            qs[\"limitToFirst\" /* REST_QUERY_CONSTANTS.LIMIT_TO_FIRST */ ] = queryParams.limit_;\n        } else {\n            qs[\"limitToLast\" /* REST_QUERY_CONSTANTS.LIMIT_TO_LAST */ ] = queryParams.limit_;\n        }\n    }\n    return qs;\n}\nfunction queryParamsGetQueryObject(queryParams) {\n    const obj = {};\n    if (queryParams.startSet_) {\n        obj[\"sp\" /* WIRE_PROTOCOL_CONSTANTS.INDEX_START_VALUE */ ] = queryParams.indexStartValue_;\n        if (queryParams.startNameSet_) {\n            obj[\"sn\" /* WIRE_PROTOCOL_CONSTANTS.INDEX_START_NAME */ ] = queryParams.indexStartName_;\n        }\n        obj[\"sin\" /* WIRE_PROTOCOL_CONSTANTS.INDEX_START_IS_INCLUSIVE */ ] = !queryParams.startAfterSet_;\n    }\n    if (queryParams.endSet_) {\n        obj[\"ep\" /* WIRE_PROTOCOL_CONSTANTS.INDEX_END_VALUE */ ] = queryParams.indexEndValue_;\n        if (queryParams.endNameSet_) {\n            obj[\"en\" /* WIRE_PROTOCOL_CONSTANTS.INDEX_END_NAME */ ] = queryParams.indexEndName_;\n        }\n        obj[\"ein\" /* WIRE_PROTOCOL_CONSTANTS.INDEX_END_IS_INCLUSIVE */ ] = !queryParams.endBeforeSet_;\n    }\n    if (queryParams.limitSet_) {\n        obj[\"l\" /* WIRE_PROTOCOL_CONSTANTS.LIMIT */ ] = queryParams.limit_;\n        let viewFrom = queryParams.viewFrom_;\n        if (viewFrom === \"\") {\n            if (queryParams.isViewFromLeft()) {\n                viewFrom = \"l\" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_LEFT */ ;\n            } else {\n                viewFrom = \"r\" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_RIGHT */ ;\n            }\n        }\n        obj[\"vf\" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM */ ] = viewFrom;\n    }\n    // For now, priority index is the default, so we only specify if it's some other index\n    if (queryParams.index_ !== PRIORITY_INDEX) {\n        obj[\"i\" /* WIRE_PROTOCOL_CONSTANTS.INDEX */ ] = queryParams.index_.toString();\n    }\n    return obj;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * An implementation of ServerActions that communicates with the server via REST requests.\r\n * This is mostly useful for compatibility with crawlers, where we don't want to spin up a full\r\n * persistent connection (using WebSockets or long-polling)\r\n */ class ReadonlyRestClient extends ServerActions {\n    /**\r\n     * @param repoInfo_ - Data about the namespace we are connecting to\r\n     * @param onDataUpdate_ - A callback for new data from the server\r\n     */ constructor(repoInfo_, onDataUpdate_, authTokenProvider_, appCheckTokenProvider_){\n        super();\n        this.repoInfo_ = repoInfo_;\n        this.onDataUpdate_ = onDataUpdate_;\n        this.authTokenProvider_ = authTokenProvider_;\n        this.appCheckTokenProvider_ = appCheckTokenProvider_;\n        /** @private {function(...[*])} */ this.log_ = logWrapper(\"p:rest:\");\n        /**\r\n         * We don't actually need to track listens, except to prevent us calling an onComplete for a listen\r\n         * that's been removed. :-/\r\n         */ this.listens_ = {};\n    }\n    reportStats(stats) {\n        throw new Error(\"Method not implemented.\");\n    }\n    static getListenId_(query, tag) {\n        if (tag !== undefined) {\n            return \"tag$\" + tag;\n        } else {\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(query._queryParams.isDefault(), \"should have a tag if it's not a default query.\");\n            return query._path.toString();\n        }\n    }\n    /** @inheritDoc */ listen(query, currentHashFn, tag, onComplete) {\n        const pathString = query._path.toString();\n        this.log_(\"Listen called for \" + pathString + \" \" + query._queryIdentifier);\n        // Mark this listener so we can tell if it's removed.\n        const listenId = ReadonlyRestClient.getListenId_(query, tag);\n        const thisListen = {};\n        this.listens_[listenId] = thisListen;\n        const queryStringParameters = queryParamsToRestQueryStringParameters(query._queryParams);\n        this.restRequest_(pathString + \".json\", queryStringParameters, (error, result)=>{\n            let data = result;\n            if (error === 404) {\n                data = null;\n                error = null;\n            }\n            if (error === null) {\n                this.onDataUpdate_(pathString, data, /*isMerge=*/ false, tag);\n            }\n            if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.safeGet)(this.listens_, listenId) === thisListen) {\n                let status;\n                if (!error) {\n                    status = \"ok\";\n                } else if (error === 401) {\n                    status = \"permission_denied\";\n                } else {\n                    status = \"rest_error:\" + error;\n                }\n                onComplete(status, null);\n            }\n        });\n    }\n    /** @inheritDoc */ unlisten(query, tag) {\n        const listenId = ReadonlyRestClient.getListenId_(query, tag);\n        delete this.listens_[listenId];\n    }\n    get(query) {\n        const queryStringParameters = queryParamsToRestQueryStringParameters(query._queryParams);\n        const pathString = query._path.toString();\n        const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n        this.restRequest_(pathString + \".json\", queryStringParameters, (error, result)=>{\n            let data = result;\n            if (error === 404) {\n                data = null;\n                error = null;\n            }\n            if (error === null) {\n                this.onDataUpdate_(pathString, data, /*isMerge=*/ false, /*tag=*/ null);\n                deferred.resolve(data);\n            } else {\n                deferred.reject(new Error(data));\n            }\n        });\n        return deferred.promise;\n    }\n    /** @inheritDoc */ refreshAuthToken(token) {\n    // no-op since we just always call getToken.\n    }\n    /**\r\n     * Performs a REST request to the given path, with the provided query string parameters,\r\n     * and any auth credentials we have.\r\n     */ restRequest_(pathString, queryStringParameters = {}, callback) {\n        queryStringParameters[\"format\"] = \"export\";\n        return Promise.all([\n            this.authTokenProvider_.getToken(/*forceRefresh=*/ false),\n            this.appCheckTokenProvider_.getToken(/*forceRefresh=*/ false)\n        ]).then(([authToken, appCheckToken])=>{\n            if (authToken && authToken.accessToken) {\n                queryStringParameters[\"auth\"] = authToken.accessToken;\n            }\n            if (appCheckToken && appCheckToken.token) {\n                queryStringParameters[\"ac\"] = appCheckToken.token;\n            }\n            const url = (this.repoInfo_.secure ? \"https://\" : \"http://\") + this.repoInfo_.host + pathString + \"?\" + \"ns=\" + this.repoInfo_.namespace + (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystring)(queryStringParameters);\n            this.log_(\"Sending REST request for \" + url);\n            const xhr = new XMLHttpRequest();\n            xhr.onreadystatechange = ()=>{\n                if (callback && xhr.readyState === 4) {\n                    this.log_(\"REST Response for \" + url + \" received. status:\", xhr.status, \"response:\", xhr.responseText);\n                    let res = null;\n                    if (xhr.status >= 200 && xhr.status < 300) {\n                        try {\n                            res = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.jsonEval)(xhr.responseText);\n                        } catch (e) {\n                            warn(\"Failed to parse JSON response for \" + url + \": \" + xhr.responseText);\n                        }\n                        callback(null, res);\n                    } else {\n                        // 401 and 404 are expected.\n                        if (xhr.status !== 401 && xhr.status !== 404) {\n                            warn(\"Got unsuccessful REST response for \" + url + \" Status: \" + xhr.status);\n                        }\n                        callback(xhr.status);\n                    }\n                    callback = null;\n                }\n            };\n            xhr.open(\"GET\", url, /*asynchronous=*/ true);\n            xhr.send();\n        });\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Mutable object which basically just stores a reference to the \"latest\" immutable snapshot.\r\n */ class SnapshotHolder {\n    constructor(){\n        this.rootNode_ = ChildrenNode.EMPTY_NODE;\n    }\n    getNode(path) {\n        return this.rootNode_.getChild(path);\n    }\n    updateSnapshot(path, newSnapshotNode) {\n        this.rootNode_ = this.rootNode_.updateChild(path, newSnapshotNode);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function newSparseSnapshotTree() {\n    return {\n        value: null,\n        children: new Map()\n    };\n}\n/**\r\n * Stores the given node at the specified path. If there is already a node\r\n * at a shallower path, it merges the new data into that snapshot node.\r\n *\r\n * @param path - Path to look up snapshot for.\r\n * @param data - The new data, or null.\r\n */ function sparseSnapshotTreeRemember(sparseSnapshotTree, path, data) {\n    if (pathIsEmpty(path)) {\n        sparseSnapshotTree.value = data;\n        sparseSnapshotTree.children.clear();\n    } else if (sparseSnapshotTree.value !== null) {\n        sparseSnapshotTree.value = sparseSnapshotTree.value.updateChild(path, data);\n    } else {\n        const childKey = pathGetFront(path);\n        if (!sparseSnapshotTree.children.has(childKey)) {\n            sparseSnapshotTree.children.set(childKey, newSparseSnapshotTree());\n        }\n        const child = sparseSnapshotTree.children.get(childKey);\n        path = pathPopFront(path);\n        sparseSnapshotTreeRemember(child, path, data);\n    }\n}\n/**\r\n * Purge the data at path from the cache.\r\n *\r\n * @param path - Path to look up snapshot for.\r\n * @returns True if this node should now be removed.\r\n */ function sparseSnapshotTreeForget(sparseSnapshotTree, path) {\n    if (pathIsEmpty(path)) {\n        sparseSnapshotTree.value = null;\n        sparseSnapshotTree.children.clear();\n        return true;\n    } else {\n        if (sparseSnapshotTree.value !== null) {\n            if (sparseSnapshotTree.value.isLeafNode()) {\n                // We're trying to forget a node that doesn't exist\n                return false;\n            } else {\n                const value = sparseSnapshotTree.value;\n                sparseSnapshotTree.value = null;\n                value.forEachChild(PRIORITY_INDEX, (key, tree)=>{\n                    sparseSnapshotTreeRemember(sparseSnapshotTree, new Path(key), tree);\n                });\n                return sparseSnapshotTreeForget(sparseSnapshotTree, path);\n            }\n        } else if (sparseSnapshotTree.children.size > 0) {\n            const childKey = pathGetFront(path);\n            path = pathPopFront(path);\n            if (sparseSnapshotTree.children.has(childKey)) {\n                const safeToRemove = sparseSnapshotTreeForget(sparseSnapshotTree.children.get(childKey), path);\n                if (safeToRemove) {\n                    sparseSnapshotTree.children.delete(childKey);\n                }\n            }\n            return sparseSnapshotTree.children.size === 0;\n        } else {\n            return true;\n        }\n    }\n}\n/**\r\n * Recursively iterates through all of the stored tree and calls the\r\n * callback on each one.\r\n *\r\n * @param prefixPath - Path to look up node for.\r\n * @param func - The function to invoke for each tree.\r\n */ function sparseSnapshotTreeForEachTree(sparseSnapshotTree, prefixPath, func) {\n    if (sparseSnapshotTree.value !== null) {\n        func(prefixPath, sparseSnapshotTree.value);\n    } else {\n        sparseSnapshotTreeForEachChild(sparseSnapshotTree, (key, tree)=>{\n            const path = new Path(prefixPath.toString() + \"/\" + key);\n            sparseSnapshotTreeForEachTree(tree, path, func);\n        });\n    }\n}\n/**\r\n * Iterates through each immediate child and triggers the callback.\r\n * Only seems to be used in tests.\r\n *\r\n * @param func - The function to invoke for each child.\r\n */ function sparseSnapshotTreeForEachChild(sparseSnapshotTree, func) {\n    sparseSnapshotTree.children.forEach((tree, key)=>{\n        func(key, tree);\n    });\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Returns the delta from the previous call to get stats.\r\n *\r\n * @param collection_ - The collection to \"listen\" to.\r\n */ class StatsListener {\n    constructor(collection_){\n        this.collection_ = collection_;\n        this.last_ = null;\n    }\n    get() {\n        const newStats = this.collection_.get();\n        const delta = Object.assign({}, newStats);\n        if (this.last_) {\n            each(this.last_, (stat, value)=>{\n                delta[stat] = delta[stat] - value;\n            });\n        }\n        this.last_ = newStats;\n        return delta;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // Assuming some apps may have a short amount of time on page, and a bulk of firebase operations probably\n// happen on page load, we try to report our first set of stats pretty quickly, but we wait at least 10\n// seconds to try to ensure the Firebase connection is established / settled.\nconst FIRST_STATS_MIN_TIME = 10 * 1000;\nconst FIRST_STATS_MAX_TIME = 30 * 1000;\n// We'll continue to report stats on average every 5 minutes.\nconst REPORT_STATS_INTERVAL = 5 * 60 * 1000;\nclass StatsReporter {\n    constructor(collection, server_){\n        this.server_ = server_;\n        this.statsToReport_ = {};\n        this.statsListener_ = new StatsListener(collection);\n        const timeout = FIRST_STATS_MIN_TIME + (FIRST_STATS_MAX_TIME - FIRST_STATS_MIN_TIME) * Math.random();\n        setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(timeout));\n    }\n    reportStats_() {\n        const stats = this.statsListener_.get();\n        const reportedStats = {};\n        let haveStatsToReport = false;\n        each(stats, (stat, value)=>{\n            if (value > 0 && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.contains)(this.statsToReport_, stat)) {\n                reportedStats[stat] = value;\n                haveStatsToReport = true;\n            }\n        });\n        if (haveStatsToReport) {\n            this.server_.reportStats(reportedStats);\n        }\n        // queue our next run.\n        setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(Math.random() * 2 * REPORT_STATS_INTERVAL));\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n *\r\n * @enum\r\n */ var OperationType;\n(function(OperationType) {\n    OperationType[OperationType[\"OVERWRITE\"] = 0] = \"OVERWRITE\";\n    OperationType[OperationType[\"MERGE\"] = 1] = \"MERGE\";\n    OperationType[OperationType[\"ACK_USER_WRITE\"] = 2] = \"ACK_USER_WRITE\";\n    OperationType[OperationType[\"LISTEN_COMPLETE\"] = 3] = \"LISTEN_COMPLETE\";\n})(OperationType || (OperationType = {}));\nfunction newOperationSourceUser() {\n    return {\n        fromUser: true,\n        fromServer: false,\n        queryId: null,\n        tagged: false\n    };\n}\nfunction newOperationSourceServer() {\n    return {\n        fromUser: false,\n        fromServer: true,\n        queryId: null,\n        tagged: false\n    };\n}\nfunction newOperationSourceServerTaggedQuery(queryId) {\n    return {\n        fromUser: false,\n        fromServer: true,\n        queryId,\n        tagged: true\n    };\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class AckUserWrite {\n    /**\r\n     * @param affectedTree - A tree containing true for each affected path. Affected paths can't overlap.\r\n     */ constructor(/** @inheritDoc */ path, /** @inheritDoc */ affectedTree, /** @inheritDoc */ revert){\n        this.path = path;\n        this.affectedTree = affectedTree;\n        this.revert = revert;\n        /** @inheritDoc */ this.type = OperationType.ACK_USER_WRITE;\n        /** @inheritDoc */ this.source = newOperationSourceUser();\n    }\n    operationForChild(childName) {\n        if (!pathIsEmpty(this.path)) {\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(pathGetFront(this.path) === childName, \"operationForChild called for unrelated child.\");\n            return new AckUserWrite(pathPopFront(this.path), this.affectedTree, this.revert);\n        } else if (this.affectedTree.value != null) {\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(this.affectedTree.children.isEmpty(), \"affectedTree should not have overlapping affected paths.\");\n            // All child locations are affected as well; just return same operation.\n            return this;\n        } else {\n            const childTree = this.affectedTree.subtree(new Path(childName));\n            return new AckUserWrite(newEmptyPath(), childTree, this.revert);\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class ListenComplete {\n    constructor(source, path){\n        this.source = source;\n        this.path = path;\n        /** @inheritDoc */ this.type = OperationType.LISTEN_COMPLETE;\n    }\n    operationForChild(childName) {\n        if (pathIsEmpty(this.path)) {\n            return new ListenComplete(this.source, newEmptyPath());\n        } else {\n            return new ListenComplete(this.source, pathPopFront(this.path));\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class Overwrite {\n    constructor(source, path, snap){\n        this.source = source;\n        this.path = path;\n        this.snap = snap;\n        /** @inheritDoc */ this.type = OperationType.OVERWRITE;\n    }\n    operationForChild(childName) {\n        if (pathIsEmpty(this.path)) {\n            return new Overwrite(this.source, newEmptyPath(), this.snap.getImmediateChild(childName));\n        } else {\n            return new Overwrite(this.source, pathPopFront(this.path), this.snap);\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class Merge {\n    constructor(/** @inheritDoc */ source, /** @inheritDoc */ path, /** @inheritDoc */ children){\n        this.source = source;\n        this.path = path;\n        this.children = children;\n        /** @inheritDoc */ this.type = OperationType.MERGE;\n    }\n    operationForChild(childName) {\n        if (pathIsEmpty(this.path)) {\n            const childTree = this.children.subtree(new Path(childName));\n            if (childTree.isEmpty()) {\n                // This child is unaffected\n                return null;\n            } else if (childTree.value) {\n                // We have a snapshot for the child in question.  This becomes an overwrite of the child.\n                return new Overwrite(this.source, newEmptyPath(), childTree.value);\n            } else {\n                // This is a merge at a deeper level\n                return new Merge(this.source, newEmptyPath(), childTree);\n            }\n        } else {\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(pathGetFront(this.path) === childName, \"Can't get a merge for a child not on the path of the operation\");\n            return new Merge(this.source, pathPopFront(this.path), this.children);\n        }\n    }\n    toString() {\n        return \"Operation(\" + this.path + \": \" + this.source.toString() + \" merge: \" + this.children.toString() + \")\";\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * A cache node only stores complete children. Additionally it holds a flag whether the node can be considered fully\r\n * initialized in the sense that we know at one point in time this represented a valid state of the world, e.g.\r\n * initialized with data from the server, or a complete overwrite by the client. The filtered flag also tracks\r\n * whether a node potentially had children removed due to a filter.\r\n */ class CacheNode {\n    constructor(node_, fullyInitialized_, filtered_){\n        this.node_ = node_;\n        this.fullyInitialized_ = fullyInitialized_;\n        this.filtered_ = filtered_;\n    }\n    /**\r\n     * Returns whether this node was fully initialized with either server data or a complete overwrite by the client\r\n     */ isFullyInitialized() {\n        return this.fullyInitialized_;\n    }\n    /**\r\n     * Returns whether this node is potentially missing children due to a filter applied to the node\r\n     */ isFiltered() {\n        return this.filtered_;\n    }\n    isCompleteForPath(path) {\n        if (pathIsEmpty(path)) {\n            return this.isFullyInitialized() && !this.filtered_;\n        }\n        const childKey = pathGetFront(path);\n        return this.isCompleteForChild(childKey);\n    }\n    isCompleteForChild(key) {\n        return this.isFullyInitialized() && !this.filtered_ || this.node_.hasChild(key);\n    }\n    getNode() {\n        return this.node_;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * An EventGenerator is used to convert \"raw\" changes (Change) as computed by the\r\n * CacheDiffer into actual events (Event) that can be raised.  See generateEventsForChanges()\r\n * for details.\r\n *\r\n */ class EventGenerator {\n    constructor(query_){\n        this.query_ = query_;\n        this.index_ = this.query_._queryParams.getIndex();\n    }\n}\n/**\r\n * Given a set of raw changes (no moved events and prevName not specified yet), and a set of\r\n * EventRegistrations that should be notified of these changes, generate the actual events to be raised.\r\n *\r\n * Notes:\r\n *  - child_moved events will be synthesized at this time for any child_changed events that affect\r\n *    our index.\r\n *  - prevName will be calculated based on the index ordering.\r\n */ function eventGeneratorGenerateEventsForChanges(eventGenerator, changes, eventCache, eventRegistrations) {\n    const events = [];\n    const moves = [];\n    changes.forEach((change)=>{\n        if (change.type === \"child_changed\" /* ChangeType.CHILD_CHANGED */  && eventGenerator.index_.indexedValueChanged(change.oldSnap, change.snapshotNode)) {\n            moves.push(changeChildMoved(change.childName, change.snapshotNode));\n        }\n    });\n    eventGeneratorGenerateEventsForType(eventGenerator, events, \"child_removed\" /* ChangeType.CHILD_REMOVED */ , changes, eventRegistrations, eventCache);\n    eventGeneratorGenerateEventsForType(eventGenerator, events, \"child_added\" /* ChangeType.CHILD_ADDED */ , changes, eventRegistrations, eventCache);\n    eventGeneratorGenerateEventsForType(eventGenerator, events, \"child_moved\" /* ChangeType.CHILD_MOVED */ , moves, eventRegistrations, eventCache);\n    eventGeneratorGenerateEventsForType(eventGenerator, events, \"child_changed\" /* ChangeType.CHILD_CHANGED */ , changes, eventRegistrations, eventCache);\n    eventGeneratorGenerateEventsForType(eventGenerator, events, \"value\" /* ChangeType.VALUE */ , changes, eventRegistrations, eventCache);\n    return events;\n}\n/**\r\n * Given changes of a single change type, generate the corresponding events.\r\n */ function eventGeneratorGenerateEventsForType(eventGenerator, events, eventType, changes, registrations, eventCache) {\n    const filteredChanges = changes.filter((change)=>change.type === eventType);\n    filteredChanges.sort((a, b)=>eventGeneratorCompareChanges(eventGenerator, a, b));\n    filteredChanges.forEach((change)=>{\n        const materializedChange = eventGeneratorMaterializeSingleChange(eventGenerator, change, eventCache);\n        registrations.forEach((registration)=>{\n            if (registration.respondsTo(change.type)) {\n                events.push(registration.createEvent(materializedChange, eventGenerator.query_));\n            }\n        });\n    });\n}\nfunction eventGeneratorMaterializeSingleChange(eventGenerator, change, eventCache) {\n    if (change.type === \"value\" || change.type === \"child_removed\") {\n        return change;\n    } else {\n        change.prevName = eventCache.getPredecessorChildName(change.childName, change.snapshotNode, eventGenerator.index_);\n        return change;\n    }\n}\nfunction eventGeneratorCompareChanges(eventGenerator, a, b) {\n    if (a.childName == null || b.childName == null) {\n        throw (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assertionError)(\"Should only compare child_ events.\");\n    }\n    const aWrapped = new NamedNode(a.childName, a.snapshotNode);\n    const bWrapped = new NamedNode(b.childName, b.snapshotNode);\n    return eventGenerator.index_.compare(aWrapped, bWrapped);\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function newViewCache(eventCache, serverCache) {\n    return {\n        eventCache,\n        serverCache\n    };\n}\nfunction viewCacheUpdateEventSnap(viewCache, eventSnap, complete, filtered) {\n    return newViewCache(new CacheNode(eventSnap, complete, filtered), viewCache.serverCache);\n}\nfunction viewCacheUpdateServerSnap(viewCache, serverSnap, complete, filtered) {\n    return newViewCache(viewCache.eventCache, new CacheNode(serverSnap, complete, filtered));\n}\nfunction viewCacheGetCompleteEventSnap(viewCache) {\n    return viewCache.eventCache.isFullyInitialized() ? viewCache.eventCache.getNode() : null;\n}\nfunction viewCacheGetCompleteServerSnap(viewCache) {\n    return viewCache.serverCache.isFullyInitialized() ? viewCache.serverCache.getNode() : null;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ let emptyChildrenSingleton;\n/**\r\n * Singleton empty children collection.\r\n *\r\n */ const EmptyChildren = ()=>{\n    if (!emptyChildrenSingleton) {\n        emptyChildrenSingleton = new SortedMap(stringCompare);\n    }\n    return emptyChildrenSingleton;\n};\n/**\r\n * A tree with immutable elements.\r\n */ class ImmutableTree {\n    constructor(value, children = EmptyChildren()){\n        this.value = value;\n        this.children = children;\n    }\n    static fromObject(obj) {\n        let tree = new ImmutableTree(null);\n        each(obj, (childPath, childSnap)=>{\n            tree = tree.set(new Path(childPath), childSnap);\n        });\n        return tree;\n    }\n    /**\r\n     * True if the value is empty and there are no children\r\n     */ isEmpty() {\n        return this.value === null && this.children.isEmpty();\n    }\n    /**\r\n     * Given a path and predicate, return the first node and the path to that node\r\n     * where the predicate returns true.\r\n     *\r\n     * TODO Do a perf test -- If we're creating a bunch of `{path: value:}`\r\n     * objects on the way back out, it may be better to pass down a pathSoFar obj.\r\n     *\r\n     * @param relativePath - The remainder of the path\r\n     * @param predicate - The predicate to satisfy to return a node\r\n     */ findRootMostMatchingPathAndValue(relativePath, predicate) {\n        if (this.value != null && predicate(this.value)) {\n            return {\n                path: newEmptyPath(),\n                value: this.value\n            };\n        } else {\n            if (pathIsEmpty(relativePath)) {\n                return null;\n            } else {\n                const front = pathGetFront(relativePath);\n                const child = this.children.get(front);\n                if (child !== null) {\n                    const childExistingPathAndValue = child.findRootMostMatchingPathAndValue(pathPopFront(relativePath), predicate);\n                    if (childExistingPathAndValue != null) {\n                        const fullPath = pathChild(new Path(front), childExistingPathAndValue.path);\n                        return {\n                            path: fullPath,\n                            value: childExistingPathAndValue.value\n                        };\n                    } else {\n                        return null;\n                    }\n                } else {\n                    return null;\n                }\n            }\n        }\n    }\n    /**\r\n     * Find, if it exists, the shortest subpath of the given path that points a defined\r\n     * value in the tree\r\n     */ findRootMostValueAndPath(relativePath) {\n        return this.findRootMostMatchingPathAndValue(relativePath, ()=>true);\n    }\n    /**\r\n     * @returns The subtree at the given path\r\n     */ subtree(relativePath) {\n        if (pathIsEmpty(relativePath)) {\n            return this;\n        } else {\n            const front = pathGetFront(relativePath);\n            const childTree = this.children.get(front);\n            if (childTree !== null) {\n                return childTree.subtree(pathPopFront(relativePath));\n            } else {\n                return new ImmutableTree(null);\n            }\n        }\n    }\n    /**\r\n     * Sets a value at the specified path.\r\n     *\r\n     * @param relativePath - Path to set value at.\r\n     * @param toSet - Value to set.\r\n     * @returns Resulting tree.\r\n     */ set(relativePath, toSet) {\n        if (pathIsEmpty(relativePath)) {\n            return new ImmutableTree(toSet, this.children);\n        } else {\n            const front = pathGetFront(relativePath);\n            const child = this.children.get(front) || new ImmutableTree(null);\n            const newChild = child.set(pathPopFront(relativePath), toSet);\n            const newChildren = this.children.insert(front, newChild);\n            return new ImmutableTree(this.value, newChildren);\n        }\n    }\n    /**\r\n     * Removes the value at the specified path.\r\n     *\r\n     * @param relativePath - Path to value to remove.\r\n     * @returns Resulting tree.\r\n     */ remove(relativePath) {\n        if (pathIsEmpty(relativePath)) {\n            if (this.children.isEmpty()) {\n                return new ImmutableTree(null);\n            } else {\n                return new ImmutableTree(null, this.children);\n            }\n        } else {\n            const front = pathGetFront(relativePath);\n            const child = this.children.get(front);\n            if (child) {\n                const newChild = child.remove(pathPopFront(relativePath));\n                let newChildren;\n                if (newChild.isEmpty()) {\n                    newChildren = this.children.remove(front);\n                } else {\n                    newChildren = this.children.insert(front, newChild);\n                }\n                if (this.value === null && newChildren.isEmpty()) {\n                    return new ImmutableTree(null);\n                } else {\n                    return new ImmutableTree(this.value, newChildren);\n                }\n            } else {\n                return this;\n            }\n        }\n    }\n    /**\r\n     * Gets a value from the tree.\r\n     *\r\n     * @param relativePath - Path to get value for.\r\n     * @returns Value at path, or null.\r\n     */ get(relativePath) {\n        if (pathIsEmpty(relativePath)) {\n            return this.value;\n        } else {\n            const front = pathGetFront(relativePath);\n            const child = this.children.get(front);\n            if (child) {\n                return child.get(pathPopFront(relativePath));\n            } else {\n                return null;\n            }\n        }\n    }\n    /**\r\n     * Replace the subtree at the specified path with the given new tree.\r\n     *\r\n     * @param relativePath - Path to replace subtree for.\r\n     * @param newTree - New tree.\r\n     * @returns Resulting tree.\r\n     */ setTree(relativePath, newTree) {\n        if (pathIsEmpty(relativePath)) {\n            return newTree;\n        } else {\n            const front = pathGetFront(relativePath);\n            const child = this.children.get(front) || new ImmutableTree(null);\n            const newChild = child.setTree(pathPopFront(relativePath), newTree);\n            let newChildren;\n            if (newChild.isEmpty()) {\n                newChildren = this.children.remove(front);\n            } else {\n                newChildren = this.children.insert(front, newChild);\n            }\n            return new ImmutableTree(this.value, newChildren);\n        }\n    }\n    /**\r\n     * Performs a depth first fold on this tree. Transforms a tree into a single\r\n     * value, given a function that operates on the path to a node, an optional\r\n     * current value, and a map of child names to folded subtrees\r\n     */ fold(fn) {\n        return this.fold_(newEmptyPath(), fn);\n    }\n    /**\r\n     * Recursive helper for public-facing fold() method\r\n     */ fold_(pathSoFar, fn) {\n        const accum = {};\n        this.children.inorderTraversal((childKey, childTree)=>{\n            accum[childKey] = childTree.fold_(pathChild(pathSoFar, childKey), fn);\n        });\n        return fn(pathSoFar, this.value, accum);\n    }\n    /**\r\n     * Find the first matching value on the given path. Return the result of applying f to it.\r\n     */ findOnPath(path, f) {\n        return this.findOnPath_(path, newEmptyPath(), f);\n    }\n    findOnPath_(pathToFollow, pathSoFar, f) {\n        const result = this.value ? f(pathSoFar, this.value) : false;\n        if (result) {\n            return result;\n        } else {\n            if (pathIsEmpty(pathToFollow)) {\n                return null;\n            } else {\n                const front = pathGetFront(pathToFollow);\n                const nextChild = this.children.get(front);\n                if (nextChild) {\n                    return nextChild.findOnPath_(pathPopFront(pathToFollow), pathChild(pathSoFar, front), f);\n                } else {\n                    return null;\n                }\n            }\n        }\n    }\n    foreachOnPath(path, f) {\n        return this.foreachOnPath_(path, newEmptyPath(), f);\n    }\n    foreachOnPath_(pathToFollow, currentRelativePath, f) {\n        if (pathIsEmpty(pathToFollow)) {\n            return this;\n        } else {\n            if (this.value) {\n                f(currentRelativePath, this.value);\n            }\n            const front = pathGetFront(pathToFollow);\n            const nextChild = this.children.get(front);\n            if (nextChild) {\n                return nextChild.foreachOnPath_(pathPopFront(pathToFollow), pathChild(currentRelativePath, front), f);\n            } else {\n                return new ImmutableTree(null);\n            }\n        }\n    }\n    /**\r\n     * Calls the given function for each node in the tree that has a value.\r\n     *\r\n     * @param f - A function to be called with the path from the root of the tree to\r\n     * a node, and the value at that node. Called in depth-first order.\r\n     */ foreach(f) {\n        this.foreach_(newEmptyPath(), f);\n    }\n    foreach_(currentRelativePath, f) {\n        this.children.inorderTraversal((childName, childTree)=>{\n            childTree.foreach_(pathChild(currentRelativePath, childName), f);\n        });\n        if (this.value) {\n            f(currentRelativePath, this.value);\n        }\n    }\n    foreachChild(f) {\n        this.children.inorderTraversal((childName, childTree)=>{\n            if (childTree.value) {\n                f(childName, childTree.value);\n            }\n        });\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * This class holds a collection of writes that can be applied to nodes in unison. It abstracts away the logic with\r\n * dealing with priority writes and multiple nested writes. At any given path there is only allowed to be one write\r\n * modifying that path. Any write to an existing path or shadowing an existing path will modify that existing write\r\n * to reflect the write added.\r\n */ class CompoundWrite {\n    constructor(writeTree_){\n        this.writeTree_ = writeTree_;\n    }\n    static empty() {\n        return new CompoundWrite(new ImmutableTree(null));\n    }\n}\nfunction compoundWriteAddWrite(compoundWrite, path, node) {\n    if (pathIsEmpty(path)) {\n        return new CompoundWrite(new ImmutableTree(node));\n    } else {\n        const rootmost = compoundWrite.writeTree_.findRootMostValueAndPath(path);\n        if (rootmost != null) {\n            const rootMostPath = rootmost.path;\n            let value = rootmost.value;\n            const relativePath = newRelativePath(rootMostPath, path);\n            value = value.updateChild(relativePath, node);\n            return new CompoundWrite(compoundWrite.writeTree_.set(rootMostPath, value));\n        } else {\n            const subtree = new ImmutableTree(node);\n            const newWriteTree = compoundWrite.writeTree_.setTree(path, subtree);\n            return new CompoundWrite(newWriteTree);\n        }\n    }\n}\nfunction compoundWriteAddWrites(compoundWrite, path, updates) {\n    let newWrite = compoundWrite;\n    each(updates, (childKey, node)=>{\n        newWrite = compoundWriteAddWrite(newWrite, pathChild(path, childKey), node);\n    });\n    return newWrite;\n}\n/**\r\n * Will remove a write at the given path and deeper paths. This will <em>not</em> modify a write at a higher\r\n * location, which must be removed by calling this method with that path.\r\n *\r\n * @param compoundWrite - The CompoundWrite to remove.\r\n * @param path - The path at which a write and all deeper writes should be removed\r\n * @returns The new CompoundWrite with the removed path\r\n */ function compoundWriteRemoveWrite(compoundWrite, path) {\n    if (pathIsEmpty(path)) {\n        return CompoundWrite.empty();\n    } else {\n        const newWriteTree = compoundWrite.writeTree_.setTree(path, new ImmutableTree(null));\n        return new CompoundWrite(newWriteTree);\n    }\n}\n/**\r\n * Returns whether this CompoundWrite will fully overwrite a node at a given location and can therefore be\r\n * considered \"complete\".\r\n *\r\n * @param compoundWrite - The CompoundWrite to check.\r\n * @param path - The path to check for\r\n * @returns Whether there is a complete write at that path\r\n */ function compoundWriteHasCompleteWrite(compoundWrite, path) {\n    return compoundWriteGetCompleteNode(compoundWrite, path) != null;\n}\n/**\r\n * Returns a node for a path if and only if the node is a \"complete\" overwrite at that path. This will not aggregate\r\n * writes from deeper paths, but will return child nodes from a more shallow path.\r\n *\r\n * @param compoundWrite - The CompoundWrite to get the node from.\r\n * @param path - The path to get a complete write\r\n * @returns The node if complete at that path, or null otherwise.\r\n */ function compoundWriteGetCompleteNode(compoundWrite, path) {\n    const rootmost = compoundWrite.writeTree_.findRootMostValueAndPath(path);\n    if (rootmost != null) {\n        return compoundWrite.writeTree_.get(rootmost.path).getChild(newRelativePath(rootmost.path, path));\n    } else {\n        return null;\n    }\n}\n/**\r\n * Returns all children that are guaranteed to be a complete overwrite.\r\n *\r\n * @param compoundWrite - The CompoundWrite to get children from.\r\n * @returns A list of all complete children.\r\n */ function compoundWriteGetCompleteChildren(compoundWrite) {\n    const children = [];\n    const node = compoundWrite.writeTree_.value;\n    if (node != null) {\n        // If it's a leaf node, it has no children; so nothing to do.\n        if (!node.isLeafNode()) {\n            node.forEachChild(PRIORITY_INDEX, (childName, childNode)=>{\n                children.push(new NamedNode(childName, childNode));\n            });\n        }\n    } else {\n        compoundWrite.writeTree_.children.inorderTraversal((childName, childTree)=>{\n            if (childTree.value != null) {\n                children.push(new NamedNode(childName, childTree.value));\n            }\n        });\n    }\n    return children;\n}\nfunction compoundWriteChildCompoundWrite(compoundWrite, path) {\n    if (pathIsEmpty(path)) {\n        return compoundWrite;\n    } else {\n        const shadowingNode = compoundWriteGetCompleteNode(compoundWrite, path);\n        if (shadowingNode != null) {\n            return new CompoundWrite(new ImmutableTree(shadowingNode));\n        } else {\n            return new CompoundWrite(compoundWrite.writeTree_.subtree(path));\n        }\n    }\n}\n/**\r\n * Returns true if this CompoundWrite is empty and therefore does not modify any nodes.\r\n * @returns Whether this CompoundWrite is empty\r\n */ function compoundWriteIsEmpty(compoundWrite) {\n    return compoundWrite.writeTree_.isEmpty();\n}\n/**\r\n * Applies this CompoundWrite to a node. The node is returned with all writes from this CompoundWrite applied to the\r\n * node\r\n * @param node - The node to apply this CompoundWrite to\r\n * @returns The node with all writes applied\r\n */ function compoundWriteApply(compoundWrite, node) {\n    return applySubtreeWrite(newEmptyPath(), compoundWrite.writeTree_, node);\n}\nfunction applySubtreeWrite(relativePath, writeTree, node) {\n    if (writeTree.value != null) {\n        // Since there a write is always a leaf, we're done here\n        return node.updateChild(relativePath, writeTree.value);\n    } else {\n        let priorityWrite = null;\n        writeTree.children.inorderTraversal((childKey, childTree)=>{\n            if (childKey === \".priority\") {\n                // Apply priorities at the end so we don't update priorities for either empty nodes or forget\n                // to apply priorities to empty nodes that are later filled\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(childTree.value !== null, \"Priority writes must always be leaf nodes\");\n                priorityWrite = childTree.value;\n            } else {\n                node = applySubtreeWrite(pathChild(relativePath, childKey), childTree, node);\n            }\n        });\n        // If there was a priority write, we only apply it if the node is not empty\n        if (!node.getChild(relativePath).isEmpty() && priorityWrite !== null) {\n            node = node.updateChild(pathChild(relativePath, \".priority\"), priorityWrite);\n        }\n        return node;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Create a new WriteTreeRef for the given path. For use with a new sync point at the given path.\r\n *\r\n */ function writeTreeChildWrites(writeTree, path) {\n    return newWriteTreeRef(path, writeTree);\n}\n/**\r\n * Record a new overwrite from user code.\r\n *\r\n * @param visible - This is set to false by some transactions. It should be excluded from event caches\r\n */ function writeTreeAddOverwrite(writeTree, path, snap, writeId, visible) {\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(writeId > writeTree.lastWriteId, \"Stacking an older write on top of newer ones\");\n    if (visible === undefined) {\n        visible = true;\n    }\n    writeTree.allWrites.push({\n        path,\n        snap,\n        writeId,\n        visible\n    });\n    if (visible) {\n        writeTree.visibleWrites = compoundWriteAddWrite(writeTree.visibleWrites, path, snap);\n    }\n    writeTree.lastWriteId = writeId;\n}\n/**\r\n * Record a new merge from user code.\r\n */ function writeTreeAddMerge(writeTree, path, changedChildren, writeId) {\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(writeId > writeTree.lastWriteId, \"Stacking an older merge on top of newer ones\");\n    writeTree.allWrites.push({\n        path,\n        children: changedChildren,\n        writeId,\n        visible: true\n    });\n    writeTree.visibleWrites = compoundWriteAddWrites(writeTree.visibleWrites, path, changedChildren);\n    writeTree.lastWriteId = writeId;\n}\nfunction writeTreeGetWrite(writeTree, writeId) {\n    for(let i = 0; i < writeTree.allWrites.length; i++){\n        const record = writeTree.allWrites[i];\n        if (record.writeId === writeId) {\n            return record;\n        }\n    }\n    return null;\n}\n/**\r\n * Remove a write (either an overwrite or merge) that has been successfully acknowledge by the server. Recalculates\r\n * the tree if necessary.  We return true if it may have been visible, meaning views need to reevaluate.\r\n *\r\n * @returns true if the write may have been visible (meaning we'll need to reevaluate / raise\r\n * events as a result).\r\n */ function writeTreeRemoveWrite(writeTree, writeId) {\n    // Note: disabling this check. It could be a transaction that preempted another transaction, and thus was applied\n    // out of order.\n    //const validClear = revert || this.allWrites_.length === 0 || writeId <= this.allWrites_[0].writeId;\n    //assert(validClear, \"Either we don't have this write, or it's the first one in the queue\");\n    const idx = writeTree.allWrites.findIndex((s)=>{\n        return s.writeId === writeId;\n    });\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(idx >= 0, \"removeWrite called with nonexistent writeId.\");\n    const writeToRemove = writeTree.allWrites[idx];\n    writeTree.allWrites.splice(idx, 1);\n    let removedWriteWasVisible = writeToRemove.visible;\n    let removedWriteOverlapsWithOtherWrites = false;\n    let i = writeTree.allWrites.length - 1;\n    while(removedWriteWasVisible && i >= 0){\n        const currentWrite = writeTree.allWrites[i];\n        if (currentWrite.visible) {\n            if (i >= idx && writeTreeRecordContainsPath_(currentWrite, writeToRemove.path)) {\n                // The removed write was completely shadowed by a subsequent write.\n                removedWriteWasVisible = false;\n            } else if (pathContains(writeToRemove.path, currentWrite.path)) {\n                // Either we're covering some writes or they're covering part of us (depending on which came first).\n                removedWriteOverlapsWithOtherWrites = true;\n            }\n        }\n        i--;\n    }\n    if (!removedWriteWasVisible) {\n        return false;\n    } else if (removedWriteOverlapsWithOtherWrites) {\n        // There's some shadowing going on. Just rebuild the visible writes from scratch.\n        writeTreeResetTree_(writeTree);\n        return true;\n    } else {\n        // There's no shadowing.  We can safely just remove the write(s) from visibleWrites.\n        if (writeToRemove.snap) {\n            writeTree.visibleWrites = compoundWriteRemoveWrite(writeTree.visibleWrites, writeToRemove.path);\n        } else {\n            const children = writeToRemove.children;\n            each(children, (childName)=>{\n                writeTree.visibleWrites = compoundWriteRemoveWrite(writeTree.visibleWrites, pathChild(writeToRemove.path, childName));\n            });\n        }\n        return true;\n    }\n}\nfunction writeTreeRecordContainsPath_(writeRecord, path) {\n    if (writeRecord.snap) {\n        return pathContains(writeRecord.path, path);\n    } else {\n        for(const childName in writeRecord.children){\n            if (writeRecord.children.hasOwnProperty(childName) && pathContains(pathChild(writeRecord.path, childName), path)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n/**\r\n * Re-layer the writes and merges into a tree so we can efficiently calculate event snapshots\r\n */ function writeTreeResetTree_(writeTree) {\n    writeTree.visibleWrites = writeTreeLayerTree_(writeTree.allWrites, writeTreeDefaultFilter_, newEmptyPath());\n    if (writeTree.allWrites.length > 0) {\n        writeTree.lastWriteId = writeTree.allWrites[writeTree.allWrites.length - 1].writeId;\n    } else {\n        writeTree.lastWriteId = -1;\n    }\n}\n/**\r\n * The default filter used when constructing the tree. Keep everything that's visible.\r\n */ function writeTreeDefaultFilter_(write) {\n    return write.visible;\n}\n/**\r\n * Static method. Given an array of WriteRecords, a filter for which ones to include, and a path, construct the tree of\r\n * event data at that path.\r\n */ function writeTreeLayerTree_(writes, filter, treeRoot) {\n    let compoundWrite = CompoundWrite.empty();\n    for(let i = 0; i < writes.length; ++i){\n        const write = writes[i];\n        // Theory, a later set will either:\n        // a) abort a relevant transaction, so no need to worry about excluding it from calculating that transaction\n        // b) not be relevant to a transaction (separate branch), so again will not affect the data for that transaction\n        if (filter(write)) {\n            const writePath = write.path;\n            let relativePath;\n            if (write.snap) {\n                if (pathContains(treeRoot, writePath)) {\n                    relativePath = newRelativePath(treeRoot, writePath);\n                    compoundWrite = compoundWriteAddWrite(compoundWrite, relativePath, write.snap);\n                } else if (pathContains(writePath, treeRoot)) {\n                    relativePath = newRelativePath(writePath, treeRoot);\n                    compoundWrite = compoundWriteAddWrite(compoundWrite, newEmptyPath(), write.snap.getChild(relativePath));\n                } else ;\n            } else if (write.children) {\n                if (pathContains(treeRoot, writePath)) {\n                    relativePath = newRelativePath(treeRoot, writePath);\n                    compoundWrite = compoundWriteAddWrites(compoundWrite, relativePath, write.children);\n                } else if (pathContains(writePath, treeRoot)) {\n                    relativePath = newRelativePath(writePath, treeRoot);\n                    if (pathIsEmpty(relativePath)) {\n                        compoundWrite = compoundWriteAddWrites(compoundWrite, newEmptyPath(), write.children);\n                    } else {\n                        const child = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.safeGet)(write.children, pathGetFront(relativePath));\n                        if (child) {\n                            // There exists a child in this node that matches the root path\n                            const deepNode = child.getChild(pathPopFront(relativePath));\n                            compoundWrite = compoundWriteAddWrite(compoundWrite, newEmptyPath(), deepNode);\n                        }\n                    }\n                } else ;\n            } else {\n                throw (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assertionError)(\"WriteRecord should have .snap or .children\");\n            }\n        }\n    }\n    return compoundWrite;\n}\n/**\r\n * Given optional, underlying server data, and an optional set of constraints (exclude some sets, include hidden\r\n * writes), attempt to calculate a complete snapshot for the given path\r\n *\r\n * @param writeIdsToExclude - An optional set to be excluded\r\n * @param includeHiddenWrites - Defaults to false, whether or not to layer on writes with visible set to false\r\n */ function writeTreeCalcCompleteEventCache(writeTree, treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites) {\n    if (!writeIdsToExclude && !includeHiddenWrites) {\n        const shadowingNode = compoundWriteGetCompleteNode(writeTree.visibleWrites, treePath);\n        if (shadowingNode != null) {\n            return shadowingNode;\n        } else {\n            const subMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);\n            if (compoundWriteIsEmpty(subMerge)) {\n                return completeServerCache;\n            } else if (completeServerCache == null && !compoundWriteHasCompleteWrite(subMerge, newEmptyPath())) {\n                // We wouldn't have a complete snapshot, since there's no underlying data and no complete shadow\n                return null;\n            } else {\n                const layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;\n                return compoundWriteApply(subMerge, layeredCache);\n            }\n        }\n    } else {\n        const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);\n        if (!includeHiddenWrites && compoundWriteIsEmpty(merge)) {\n            return completeServerCache;\n        } else {\n            // If the server cache is null, and we don't have a complete cache, we need to return null\n            if (!includeHiddenWrites && completeServerCache == null && !compoundWriteHasCompleteWrite(merge, newEmptyPath())) {\n                return null;\n            } else {\n                const filter = function(write) {\n                    return (write.visible || includeHiddenWrites) && (!writeIdsToExclude || !~writeIdsToExclude.indexOf(write.writeId)) && (pathContains(write.path, treePath) || pathContains(treePath, write.path));\n                };\n                const mergeAtPath = writeTreeLayerTree_(writeTree.allWrites, filter, treePath);\n                const layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;\n                return compoundWriteApply(mergeAtPath, layeredCache);\n            }\n        }\n    }\n}\n/**\r\n * With optional, underlying server data, attempt to return a children node of children that we have complete data for.\r\n * Used when creating new views, to pre-fill their complete event children snapshot.\r\n */ function writeTreeCalcCompleteEventChildren(writeTree, treePath, completeServerChildren) {\n    let completeChildren = ChildrenNode.EMPTY_NODE;\n    const topLevelSet = compoundWriteGetCompleteNode(writeTree.visibleWrites, treePath);\n    if (topLevelSet) {\n        if (!topLevelSet.isLeafNode()) {\n            // we're shadowing everything. Return the children.\n            topLevelSet.forEachChild(PRIORITY_INDEX, (childName, childSnap)=>{\n                completeChildren = completeChildren.updateImmediateChild(childName, childSnap);\n            });\n        }\n        return completeChildren;\n    } else if (completeServerChildren) {\n        // Layer any children we have on top of this\n        // We know we don't have a top-level set, so just enumerate existing children\n        const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);\n        completeServerChildren.forEachChild(PRIORITY_INDEX, (childName, childNode)=>{\n            const node = compoundWriteApply(compoundWriteChildCompoundWrite(merge, new Path(childName)), childNode);\n            completeChildren = completeChildren.updateImmediateChild(childName, node);\n        });\n        // Add any complete children we have from the set\n        compoundWriteGetCompleteChildren(merge).forEach((namedNode)=>{\n            completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);\n        });\n        return completeChildren;\n    } else {\n        // We don't have anything to layer on top of. Layer on any children we have\n        // Note that we can return an empty snap if we have a defined delete\n        const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);\n        compoundWriteGetCompleteChildren(merge).forEach((namedNode)=>{\n            completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);\n        });\n        return completeChildren;\n    }\n}\n/**\r\n * Given that the underlying server data has updated, determine what, if anything, needs to be\r\n * applied to the event cache.\r\n *\r\n * Possibilities:\r\n *\r\n * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data\r\n *\r\n * 2. Some write is completely shadowing. No events to be raised\r\n *\r\n * 3. Is partially shadowed. Events\r\n *\r\n * Either existingEventSnap or existingServerSnap must exist\r\n */ function writeTreeCalcEventCacheAfterServerOverwrite(writeTree, treePath, childPath, existingEventSnap, existingServerSnap) {\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(existingEventSnap || existingServerSnap, \"Either existingEventSnap or existingServerSnap must exist\");\n    const path = pathChild(treePath, childPath);\n    if (compoundWriteHasCompleteWrite(writeTree.visibleWrites, path)) {\n        // At this point we can probably guarantee that we're in case 2, meaning no events\n        // May need to check visibility while doing the findRootMostValueAndPath call\n        return null;\n    } else {\n        // No complete shadowing. We're either partially shadowing or not shadowing at all.\n        const childMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, path);\n        if (compoundWriteIsEmpty(childMerge)) {\n            // We're not shadowing at all. Case 1\n            return existingServerSnap.getChild(childPath);\n        } else {\n            // This could be more efficient if the serverNode + updates doesn't change the eventSnap\n            // However this is tricky to find out, since user updates don't necessary change the server\n            // snap, e.g. priority updates on empty nodes, or deep deletes. Another special case is if the server\n            // adds nodes, but doesn't change any existing writes. It is therefore not enough to\n            // only check if the updates change the serverNode.\n            // Maybe check if the merge tree contains these special cases and only do a full overwrite in that case?\n            return compoundWriteApply(childMerge, existingServerSnap.getChild(childPath));\n        }\n    }\n}\n/**\r\n * Returns a complete child for a given server snap after applying all user writes or null if there is no\r\n * complete child for this ChildKey.\r\n */ function writeTreeCalcCompleteChild(writeTree, treePath, childKey, existingServerSnap) {\n    const path = pathChild(treePath, childKey);\n    const shadowingNode = compoundWriteGetCompleteNode(writeTree.visibleWrites, path);\n    if (shadowingNode != null) {\n        return shadowingNode;\n    } else {\n        if (existingServerSnap.isCompleteForChild(childKey)) {\n            const childMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, path);\n            return compoundWriteApply(childMerge, existingServerSnap.getNode().getImmediateChild(childKey));\n        } else {\n            return null;\n        }\n    }\n}\n/**\r\n * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at\r\n * a higher path, this will return the child of that write relative to the write and this path.\r\n * Returns null if there is no write at this path.\r\n */ function writeTreeShadowingWrite(writeTree, path) {\n    return compoundWriteGetCompleteNode(writeTree.visibleWrites, path);\n}\n/**\r\n * This method is used when processing child remove events on a query. If we can, we pull in children that were outside\r\n * the window, but may now be in the window.\r\n */ function writeTreeCalcIndexedSlice(writeTree, treePath, completeServerData, startPost, count, reverse, index) {\n    let toIterate;\n    const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);\n    const shadowingNode = compoundWriteGetCompleteNode(merge, newEmptyPath());\n    if (shadowingNode != null) {\n        toIterate = shadowingNode;\n    } else if (completeServerData != null) {\n        toIterate = compoundWriteApply(merge, completeServerData);\n    } else {\n        // no children to iterate on\n        return [];\n    }\n    toIterate = toIterate.withIndex(index);\n    if (!toIterate.isEmpty() && !toIterate.isLeafNode()) {\n        const nodes = [];\n        const cmp = index.getCompare();\n        const iter = reverse ? toIterate.getReverseIteratorFrom(startPost, index) : toIterate.getIteratorFrom(startPost, index);\n        let next = iter.getNext();\n        while(next && nodes.length < count){\n            if (cmp(next, startPost) !== 0) {\n                nodes.push(next);\n            }\n            next = iter.getNext();\n        }\n        return nodes;\n    } else {\n        return [];\n    }\n}\nfunction newWriteTree() {\n    return {\n        visibleWrites: CompoundWrite.empty(),\n        allWrites: [],\n        lastWriteId: -1\n    };\n}\n/**\r\n * If possible, returns a complete event cache, using the underlying server data if possible. In addition, can be used\r\n * to get a cache that includes hidden writes, and excludes arbitrary writes. Note that customizing the returned node\r\n * can lead to a more expensive calculation.\r\n *\r\n * @param writeIdsToExclude - Optional writes to exclude.\r\n * @param includeHiddenWrites - Defaults to false, whether or not to layer on writes with visible set to false\r\n */ function writeTreeRefCalcCompleteEventCache(writeTreeRef, completeServerCache, writeIdsToExclude, includeHiddenWrites) {\n    return writeTreeCalcCompleteEventCache(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites);\n}\n/**\r\n * If possible, returns a children node containing all of the complete children we have data for. The returned data is a\r\n * mix of the given server data and write data.\r\n *\r\n */ function writeTreeRefCalcCompleteEventChildren(writeTreeRef, completeServerChildren) {\n    return writeTreeCalcCompleteEventChildren(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerChildren);\n}\n/**\r\n * Given that either the underlying server data has updated or the outstanding writes have updated, determine what,\r\n * if anything, needs to be applied to the event cache.\r\n *\r\n * Possibilities:\r\n *\r\n * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data\r\n *\r\n * 2. Some write is completely shadowing. No events to be raised\r\n *\r\n * 3. Is partially shadowed. Events should be raised\r\n *\r\n * Either existingEventSnap or existingServerSnap must exist, this is validated via an assert\r\n *\r\n *\r\n */ function writeTreeRefCalcEventCacheAfterServerOverwrite(writeTreeRef, path, existingEventSnap, existingServerSnap) {\n    return writeTreeCalcEventCacheAfterServerOverwrite(writeTreeRef.writeTree, writeTreeRef.treePath, path, existingEventSnap, existingServerSnap);\n}\n/**\r\n * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at\r\n * a higher path, this will return the child of that write relative to the write and this path.\r\n * Returns null if there is no write at this path.\r\n *\r\n */ function writeTreeRefShadowingWrite(writeTreeRef, path) {\n    return writeTreeShadowingWrite(writeTreeRef.writeTree, pathChild(writeTreeRef.treePath, path));\n}\n/**\r\n * This method is used when processing child remove events on a query. If we can, we pull in children that were outside\r\n * the window, but may now be in the window\r\n */ function writeTreeRefCalcIndexedSlice(writeTreeRef, completeServerData, startPost, count, reverse, index) {\n    return writeTreeCalcIndexedSlice(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerData, startPost, count, reverse, index);\n}\n/**\r\n * Returns a complete child for a given server snap after applying all user writes or null if there is no\r\n * complete child for this ChildKey.\r\n */ function writeTreeRefCalcCompleteChild(writeTreeRef, childKey, existingServerCache) {\n    return writeTreeCalcCompleteChild(writeTreeRef.writeTree, writeTreeRef.treePath, childKey, existingServerCache);\n}\n/**\r\n * Return a WriteTreeRef for a child.\r\n */ function writeTreeRefChild(writeTreeRef, childName) {\n    return newWriteTreeRef(pathChild(writeTreeRef.treePath, childName), writeTreeRef.writeTree);\n}\nfunction newWriteTreeRef(path, writeTree) {\n    return {\n        treePath: path,\n        writeTree\n    };\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class ChildChangeAccumulator {\n    constructor(){\n        this.changeMap = new Map();\n    }\n    trackChildChange(change) {\n        const type = change.type;\n        const childKey = change.childName;\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(type === \"child_added\" /* ChangeType.CHILD_ADDED */  || type === \"child_changed\" /* ChangeType.CHILD_CHANGED */  || type === \"child_removed\" /* ChangeType.CHILD_REMOVED */ , \"Only child changes supported for tracking\");\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(childKey !== \".priority\", \"Only non-priority child changes can be tracked.\");\n        const oldChange = this.changeMap.get(childKey);\n        if (oldChange) {\n            const oldType = oldChange.type;\n            if (type === \"child_added\" /* ChangeType.CHILD_ADDED */  && oldType === \"child_removed\" /* ChangeType.CHILD_REMOVED */ ) {\n                this.changeMap.set(childKey, changeChildChanged(childKey, change.snapshotNode, oldChange.snapshotNode));\n            } else if (type === \"child_removed\" /* ChangeType.CHILD_REMOVED */  && oldType === \"child_added\" /* ChangeType.CHILD_ADDED */ ) {\n                this.changeMap.delete(childKey);\n            } else if (type === \"child_removed\" /* ChangeType.CHILD_REMOVED */  && oldType === \"child_changed\" /* ChangeType.CHILD_CHANGED */ ) {\n                this.changeMap.set(childKey, changeChildRemoved(childKey, oldChange.oldSnap));\n            } else if (type === \"child_changed\" /* ChangeType.CHILD_CHANGED */  && oldType === \"child_added\" /* ChangeType.CHILD_ADDED */ ) {\n                this.changeMap.set(childKey, changeChildAdded(childKey, change.snapshotNode));\n            } else if (type === \"child_changed\" /* ChangeType.CHILD_CHANGED */  && oldType === \"child_changed\" /* ChangeType.CHILD_CHANGED */ ) {\n                this.changeMap.set(childKey, changeChildChanged(childKey, change.snapshotNode, oldChange.oldSnap));\n            } else {\n                throw (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assertionError)(\"Illegal combination of changes: \" + change + \" occurred after \" + oldChange);\n            }\n        } else {\n            this.changeMap.set(childKey, change);\n        }\n    }\n    getChanges() {\n        return Array.from(this.changeMap.values());\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * An implementation of CompleteChildSource that never returns any additional children\r\n */ // eslint-disable-next-line @typescript-eslint/naming-convention\nclass NoCompleteChildSource_ {\n    getCompleteChild(childKey) {\n        return null;\n    }\n    getChildAfterChild(index, child, reverse) {\n        return null;\n    }\n}\n/**\r\n * Singleton instance.\r\n */ const NO_COMPLETE_CHILD_SOURCE = new NoCompleteChildSource_();\n/**\r\n * An implementation of CompleteChildSource that uses a WriteTree in addition to any other server data or\r\n * old event caches available to calculate complete children.\r\n */ class WriteTreeCompleteChildSource {\n    constructor(writes_, viewCache_, optCompleteServerCache_ = null){\n        this.writes_ = writes_;\n        this.viewCache_ = viewCache_;\n        this.optCompleteServerCache_ = optCompleteServerCache_;\n    }\n    getCompleteChild(childKey) {\n        const node = this.viewCache_.eventCache;\n        if (node.isCompleteForChild(childKey)) {\n            return node.getNode().getImmediateChild(childKey);\n        } else {\n            const serverNode = this.optCompleteServerCache_ != null ? new CacheNode(this.optCompleteServerCache_, true, false) : this.viewCache_.serverCache;\n            return writeTreeRefCalcCompleteChild(this.writes_, childKey, serverNode);\n        }\n    }\n    getChildAfterChild(index, child, reverse) {\n        const completeServerData = this.optCompleteServerCache_ != null ? this.optCompleteServerCache_ : viewCacheGetCompleteServerSnap(this.viewCache_);\n        const nodes = writeTreeRefCalcIndexedSlice(this.writes_, completeServerData, child, 1, reverse, index);\n        if (nodes.length === 0) {\n            return null;\n        } else {\n            return nodes[0];\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function newViewProcessor(filter) {\n    return {\n        filter\n    };\n}\nfunction viewProcessorAssertIndexed(viewProcessor, viewCache) {\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(viewCache.eventCache.getNode().isIndexed(viewProcessor.filter.getIndex()), \"Event snap not indexed\");\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(viewCache.serverCache.getNode().isIndexed(viewProcessor.filter.getIndex()), \"Server snap not indexed\");\n}\nfunction viewProcessorApplyOperation(viewProcessor, oldViewCache, operation, writesCache, completeCache) {\n    const accumulator = new ChildChangeAccumulator();\n    let newViewCache, filterServerNode;\n    if (operation.type === OperationType.OVERWRITE) {\n        const overwrite = operation;\n        if (overwrite.source.fromUser) {\n            newViewCache = viewProcessorApplyUserOverwrite(viewProcessor, oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, accumulator);\n        } else {\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(overwrite.source.fromServer, \"Unknown source.\");\n            // We filter the node if it's a tagged update or the node has been previously filtered  and the\n            // update is not at the root in which case it is ok (and necessary) to mark the node unfiltered\n            // again\n            filterServerNode = overwrite.source.tagged || oldViewCache.serverCache.isFiltered() && !pathIsEmpty(overwrite.path);\n            newViewCache = viewProcessorApplyServerOverwrite(viewProcessor, oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, filterServerNode, accumulator);\n        }\n    } else if (operation.type === OperationType.MERGE) {\n        const merge = operation;\n        if (merge.source.fromUser) {\n            newViewCache = viewProcessorApplyUserMerge(viewProcessor, oldViewCache, merge.path, merge.children, writesCache, completeCache, accumulator);\n        } else {\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(merge.source.fromServer, \"Unknown source.\");\n            // We filter the node if it's a tagged update or the node has been previously filtered\n            filterServerNode = merge.source.tagged || oldViewCache.serverCache.isFiltered();\n            newViewCache = viewProcessorApplyServerMerge(viewProcessor, oldViewCache, merge.path, merge.children, writesCache, completeCache, filterServerNode, accumulator);\n        }\n    } else if (operation.type === OperationType.ACK_USER_WRITE) {\n        const ackUserWrite = operation;\n        if (!ackUserWrite.revert) {\n            newViewCache = viewProcessorAckUserWrite(viewProcessor, oldViewCache, ackUserWrite.path, ackUserWrite.affectedTree, writesCache, completeCache, accumulator);\n        } else {\n            newViewCache = viewProcessorRevertUserWrite(viewProcessor, oldViewCache, ackUserWrite.path, writesCache, completeCache, accumulator);\n        }\n    } else if (operation.type === OperationType.LISTEN_COMPLETE) {\n        newViewCache = viewProcessorListenComplete(viewProcessor, oldViewCache, operation.path, writesCache, accumulator);\n    } else {\n        throw (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assertionError)(\"Unknown operation type: \" + operation.type);\n    }\n    const changes = accumulator.getChanges();\n    viewProcessorMaybeAddValueEvent(oldViewCache, newViewCache, changes);\n    return {\n        viewCache: newViewCache,\n        changes\n    };\n}\nfunction viewProcessorMaybeAddValueEvent(oldViewCache, newViewCache, accumulator) {\n    const eventSnap = newViewCache.eventCache;\n    if (eventSnap.isFullyInitialized()) {\n        const isLeafOrEmpty = eventSnap.getNode().isLeafNode() || eventSnap.getNode().isEmpty();\n        const oldCompleteSnap = viewCacheGetCompleteEventSnap(oldViewCache);\n        if (accumulator.length > 0 || !oldViewCache.eventCache.isFullyInitialized() || isLeafOrEmpty && !eventSnap.getNode().equals(oldCompleteSnap) || !eventSnap.getNode().getPriority().equals(oldCompleteSnap.getPriority())) {\n            accumulator.push(changeValue(viewCacheGetCompleteEventSnap(newViewCache)));\n        }\n    }\n}\nfunction viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, viewCache, changePath, writesCache, source, accumulator) {\n    const oldEventSnap = viewCache.eventCache;\n    if (writeTreeRefShadowingWrite(writesCache, changePath) != null) {\n        // we have a shadowing write, ignore changes\n        return viewCache;\n    } else {\n        let newEventCache, serverNode;\n        if (pathIsEmpty(changePath)) {\n            // TODO: figure out how this plays with \"sliding ack windows\"\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(viewCache.serverCache.isFullyInitialized(), \"If change path is empty, we must have complete server data\");\n            if (viewCache.serverCache.isFiltered()) {\n                // We need to special case this, because we need to only apply writes to complete children, or\n                // we might end up raising events for incomplete children. If the server data is filtered deep\n                // writes cannot be guaranteed to be complete\n                const serverCache = viewCacheGetCompleteServerSnap(viewCache);\n                const completeChildren = serverCache instanceof ChildrenNode ? serverCache : ChildrenNode.EMPTY_NODE;\n                const completeEventChildren = writeTreeRefCalcCompleteEventChildren(writesCache, completeChildren);\n                newEventCache = viewProcessor.filter.updateFullNode(viewCache.eventCache.getNode(), completeEventChildren, accumulator);\n            } else {\n                const completeNode = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));\n                newEventCache = viewProcessor.filter.updateFullNode(viewCache.eventCache.getNode(), completeNode, accumulator);\n            }\n        } else {\n            const childKey = pathGetFront(changePath);\n            if (childKey === \".priority\") {\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(pathGetLength(changePath) === 1, \"Can't have a priority with additional path components\");\n                const oldEventNode = oldEventSnap.getNode();\n                serverNode = viewCache.serverCache.getNode();\n                // we might have overwrites for this priority\n                const updatedPriority = writeTreeRefCalcEventCacheAfterServerOverwrite(writesCache, changePath, oldEventNode, serverNode);\n                if (updatedPriority != null) {\n                    newEventCache = viewProcessor.filter.updatePriority(oldEventNode, updatedPriority);\n                } else {\n                    // priority didn't change, keep old node\n                    newEventCache = oldEventSnap.getNode();\n                }\n            } else {\n                const childChangePath = pathPopFront(changePath);\n                // update child\n                let newEventChild;\n                if (oldEventSnap.isCompleteForChild(childKey)) {\n                    serverNode = viewCache.serverCache.getNode();\n                    const eventChildUpdate = writeTreeRefCalcEventCacheAfterServerOverwrite(writesCache, changePath, oldEventSnap.getNode(), serverNode);\n                    if (eventChildUpdate != null) {\n                        newEventChild = oldEventSnap.getNode().getImmediateChild(childKey).updateChild(childChangePath, eventChildUpdate);\n                    } else {\n                        // Nothing changed, just keep the old child\n                        newEventChild = oldEventSnap.getNode().getImmediateChild(childKey);\n                    }\n                } else {\n                    newEventChild = writeTreeRefCalcCompleteChild(writesCache, childKey, viewCache.serverCache);\n                }\n                if (newEventChild != null) {\n                    newEventCache = viewProcessor.filter.updateChild(oldEventSnap.getNode(), childKey, newEventChild, childChangePath, source, accumulator);\n                } else {\n                    // no complete child available or no change\n                    newEventCache = oldEventSnap.getNode();\n                }\n            }\n        }\n        return viewCacheUpdateEventSnap(viewCache, newEventCache, oldEventSnap.isFullyInitialized() || pathIsEmpty(changePath), viewProcessor.filter.filtersNodes());\n    }\n}\nfunction viewProcessorApplyServerOverwrite(viewProcessor, oldViewCache, changePath, changedSnap, writesCache, completeCache, filterServerNode, accumulator) {\n    const oldServerSnap = oldViewCache.serverCache;\n    let newServerCache;\n    const serverFilter = filterServerNode ? viewProcessor.filter : viewProcessor.filter.getIndexedFilter();\n    if (pathIsEmpty(changePath)) {\n        newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), changedSnap, null);\n    } else if (serverFilter.filtersNodes() && !oldServerSnap.isFiltered()) {\n        // we want to filter the server node, but we didn't filter the server node yet, so simulate a full update\n        const newServerNode = oldServerSnap.getNode().updateChild(changePath, changedSnap);\n        newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), newServerNode, null);\n    } else {\n        const childKey = pathGetFront(changePath);\n        if (!oldServerSnap.isCompleteForPath(changePath) && pathGetLength(changePath) > 1) {\n            // We don't update incomplete nodes with updates intended for other listeners\n            return oldViewCache;\n        }\n        const childChangePath = pathPopFront(changePath);\n        const childNode = oldServerSnap.getNode().getImmediateChild(childKey);\n        const newChildNode = childNode.updateChild(childChangePath, changedSnap);\n        if (childKey === \".priority\") {\n            newServerCache = serverFilter.updatePriority(oldServerSnap.getNode(), newChildNode);\n        } else {\n            newServerCache = serverFilter.updateChild(oldServerSnap.getNode(), childKey, newChildNode, childChangePath, NO_COMPLETE_CHILD_SOURCE, null);\n        }\n    }\n    const newViewCache = viewCacheUpdateServerSnap(oldViewCache, newServerCache, oldServerSnap.isFullyInitialized() || pathIsEmpty(changePath), serverFilter.filtersNodes());\n    const source = new WriteTreeCompleteChildSource(writesCache, newViewCache, completeCache);\n    return viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, newViewCache, changePath, writesCache, source, accumulator);\n}\nfunction viewProcessorApplyUserOverwrite(viewProcessor, oldViewCache, changePath, changedSnap, writesCache, completeCache, accumulator) {\n    const oldEventSnap = oldViewCache.eventCache;\n    let newViewCache, newEventCache;\n    const source = new WriteTreeCompleteChildSource(writesCache, oldViewCache, completeCache);\n    if (pathIsEmpty(changePath)) {\n        newEventCache = viewProcessor.filter.updateFullNode(oldViewCache.eventCache.getNode(), changedSnap, accumulator);\n        newViewCache = viewCacheUpdateEventSnap(oldViewCache, newEventCache, true, viewProcessor.filter.filtersNodes());\n    } else {\n        const childKey = pathGetFront(changePath);\n        if (childKey === \".priority\") {\n            newEventCache = viewProcessor.filter.updatePriority(oldViewCache.eventCache.getNode(), changedSnap);\n            newViewCache = viewCacheUpdateEventSnap(oldViewCache, newEventCache, oldEventSnap.isFullyInitialized(), oldEventSnap.isFiltered());\n        } else {\n            const childChangePath = pathPopFront(changePath);\n            const oldChild = oldEventSnap.getNode().getImmediateChild(childKey);\n            let newChild;\n            if (pathIsEmpty(childChangePath)) {\n                // Child overwrite, we can replace the child\n                newChild = changedSnap;\n            } else {\n                const childNode = source.getCompleteChild(childKey);\n                if (childNode != null) {\n                    if (pathGetBack(childChangePath) === \".priority\" && childNode.getChild(pathParent(childChangePath)).isEmpty()) {\n                        // This is a priority update on an empty node. If this node exists on the server, the\n                        // server will send down the priority in the update, so ignore for now\n                        newChild = childNode;\n                    } else {\n                        newChild = childNode.updateChild(childChangePath, changedSnap);\n                    }\n                } else {\n                    // There is no complete child node available\n                    newChild = ChildrenNode.EMPTY_NODE;\n                }\n            }\n            if (!oldChild.equals(newChild)) {\n                const newEventSnap = viewProcessor.filter.updateChild(oldEventSnap.getNode(), childKey, newChild, childChangePath, source, accumulator);\n                newViewCache = viewCacheUpdateEventSnap(oldViewCache, newEventSnap, oldEventSnap.isFullyInitialized(), viewProcessor.filter.filtersNodes());\n            } else {\n                newViewCache = oldViewCache;\n            }\n        }\n    }\n    return newViewCache;\n}\nfunction viewProcessorCacheHasChild(viewCache, childKey) {\n    return viewCache.eventCache.isCompleteForChild(childKey);\n}\nfunction viewProcessorApplyUserMerge(viewProcessor, viewCache, path, changedChildren, writesCache, serverCache, accumulator) {\n    // HACK: In the case of a limit query, there may be some changes that bump things out of the\n    // window leaving room for new items.  It's important we process these changes first, so we\n    // iterate the changes twice, first processing any that affect items currently in view.\n    // TODO: I consider an item \"in view\" if cacheHasChild is true, which checks both the server\n    // and event snap.  I'm not sure if this will result in edge cases when a child is in one but\n    // not the other.\n    let curViewCache = viewCache;\n    changedChildren.foreach((relativePath, childNode)=>{\n        const writePath = pathChild(path, relativePath);\n        if (viewProcessorCacheHasChild(viewCache, pathGetFront(writePath))) {\n            curViewCache = viewProcessorApplyUserOverwrite(viewProcessor, curViewCache, writePath, childNode, writesCache, serverCache, accumulator);\n        }\n    });\n    changedChildren.foreach((relativePath, childNode)=>{\n        const writePath = pathChild(path, relativePath);\n        if (!viewProcessorCacheHasChild(viewCache, pathGetFront(writePath))) {\n            curViewCache = viewProcessorApplyUserOverwrite(viewProcessor, curViewCache, writePath, childNode, writesCache, serverCache, accumulator);\n        }\n    });\n    return curViewCache;\n}\nfunction viewProcessorApplyMerge(viewProcessor, node, merge) {\n    merge.foreach((relativePath, childNode)=>{\n        node = node.updateChild(relativePath, childNode);\n    });\n    return node;\n}\nfunction viewProcessorApplyServerMerge(viewProcessor, viewCache, path, changedChildren, writesCache, serverCache, filterServerNode, accumulator) {\n    // If we don't have a cache yet, this merge was intended for a previously listen in the same location. Ignore it and\n    // wait for the complete data update coming soon.\n    if (viewCache.serverCache.getNode().isEmpty() && !viewCache.serverCache.isFullyInitialized()) {\n        return viewCache;\n    }\n    // HACK: In the case of a limit query, there may be some changes that bump things out of the\n    // window leaving room for new items.  It's important we process these changes first, so we\n    // iterate the changes twice, first processing any that affect items currently in view.\n    // TODO: I consider an item \"in view\" if cacheHasChild is true, which checks both the server\n    // and event snap.  I'm not sure if this will result in edge cases when a child is in one but\n    // not the other.\n    let curViewCache = viewCache;\n    let viewMergeTree;\n    if (pathIsEmpty(path)) {\n        viewMergeTree = changedChildren;\n    } else {\n        viewMergeTree = new ImmutableTree(null).setTree(path, changedChildren);\n    }\n    const serverNode = viewCache.serverCache.getNode();\n    viewMergeTree.children.inorderTraversal((childKey, childTree)=>{\n        if (serverNode.hasChild(childKey)) {\n            const serverChild = viewCache.serverCache.getNode().getImmediateChild(childKey);\n            const newChild = viewProcessorApplyMerge(viewProcessor, serverChild, childTree);\n            curViewCache = viewProcessorApplyServerOverwrite(viewProcessor, curViewCache, new Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);\n        }\n    });\n    viewMergeTree.children.inorderTraversal((childKey, childMergeTree)=>{\n        const isUnknownDeepMerge = !viewCache.serverCache.isCompleteForChild(childKey) && childMergeTree.value === null;\n        if (!serverNode.hasChild(childKey) && !isUnknownDeepMerge) {\n            const serverChild = viewCache.serverCache.getNode().getImmediateChild(childKey);\n            const newChild = viewProcessorApplyMerge(viewProcessor, serverChild, childMergeTree);\n            curViewCache = viewProcessorApplyServerOverwrite(viewProcessor, curViewCache, new Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);\n        }\n    });\n    return curViewCache;\n}\nfunction viewProcessorAckUserWrite(viewProcessor, viewCache, ackPath, affectedTree, writesCache, completeCache, accumulator) {\n    if (writeTreeRefShadowingWrite(writesCache, ackPath) != null) {\n        return viewCache;\n    }\n    // Only filter server node if it is currently filtered\n    const filterServerNode = viewCache.serverCache.isFiltered();\n    // Essentially we'll just get our existing server cache for the affected paths and re-apply it as a server update\n    // now that it won't be shadowed.\n    const serverCache = viewCache.serverCache;\n    if (affectedTree.value != null) {\n        // This is an overwrite.\n        if (pathIsEmpty(ackPath) && serverCache.isFullyInitialized() || serverCache.isCompleteForPath(ackPath)) {\n            return viewProcessorApplyServerOverwrite(viewProcessor, viewCache, ackPath, serverCache.getNode().getChild(ackPath), writesCache, completeCache, filterServerNode, accumulator);\n        } else if (pathIsEmpty(ackPath)) {\n            // This is a goofy edge case where we are acking data at this location but don't have full data.  We\n            // should just re-apply whatever we have in our cache as a merge.\n            let changedChildren = new ImmutableTree(null);\n            serverCache.getNode().forEachChild(KEY_INDEX, (name, node)=>{\n                changedChildren = changedChildren.set(new Path(name), node);\n            });\n            return viewProcessorApplyServerMerge(viewProcessor, viewCache, ackPath, changedChildren, writesCache, completeCache, filterServerNode, accumulator);\n        } else {\n            return viewCache;\n        }\n    } else {\n        // This is a merge.\n        let changedChildren = new ImmutableTree(null);\n        affectedTree.foreach((mergePath, value)=>{\n            const serverCachePath = pathChild(ackPath, mergePath);\n            if (serverCache.isCompleteForPath(serverCachePath)) {\n                changedChildren = changedChildren.set(mergePath, serverCache.getNode().getChild(serverCachePath));\n            }\n        });\n        return viewProcessorApplyServerMerge(viewProcessor, viewCache, ackPath, changedChildren, writesCache, completeCache, filterServerNode, accumulator);\n    }\n}\nfunction viewProcessorListenComplete(viewProcessor, viewCache, path, writesCache, accumulator) {\n    const oldServerNode = viewCache.serverCache;\n    const newViewCache = viewCacheUpdateServerSnap(viewCache, oldServerNode.getNode(), oldServerNode.isFullyInitialized() || pathIsEmpty(path), oldServerNode.isFiltered());\n    return viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, newViewCache, path, writesCache, NO_COMPLETE_CHILD_SOURCE, accumulator);\n}\nfunction viewProcessorRevertUserWrite(viewProcessor, viewCache, path, writesCache, completeServerCache, accumulator) {\n    let complete;\n    if (writeTreeRefShadowingWrite(writesCache, path) != null) {\n        return viewCache;\n    } else {\n        const source = new WriteTreeCompleteChildSource(writesCache, viewCache, completeServerCache);\n        const oldEventCache = viewCache.eventCache.getNode();\n        let newEventCache;\n        if (pathIsEmpty(path) || pathGetFront(path) === \".priority\") {\n            let newNode;\n            if (viewCache.serverCache.isFullyInitialized()) {\n                newNode = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));\n            } else {\n                const serverChildren = viewCache.serverCache.getNode();\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(serverChildren instanceof ChildrenNode, \"serverChildren would be complete if leaf node\");\n                newNode = writeTreeRefCalcCompleteEventChildren(writesCache, serverChildren);\n            }\n            newNode = newNode;\n            newEventCache = viewProcessor.filter.updateFullNode(oldEventCache, newNode, accumulator);\n        } else {\n            const childKey = pathGetFront(path);\n            let newChild = writeTreeRefCalcCompleteChild(writesCache, childKey, viewCache.serverCache);\n            if (newChild == null && viewCache.serverCache.isCompleteForChild(childKey)) {\n                newChild = oldEventCache.getImmediateChild(childKey);\n            }\n            if (newChild != null) {\n                newEventCache = viewProcessor.filter.updateChild(oldEventCache, childKey, newChild, pathPopFront(path), source, accumulator);\n            } else if (viewCache.eventCache.getNode().hasChild(childKey)) {\n                // No complete child available, delete the existing one, if any\n                newEventCache = viewProcessor.filter.updateChild(oldEventCache, childKey, ChildrenNode.EMPTY_NODE, pathPopFront(path), source, accumulator);\n            } else {\n                newEventCache = oldEventCache;\n            }\n            if (newEventCache.isEmpty() && viewCache.serverCache.isFullyInitialized()) {\n                // We might have reverted all child writes. Maybe the old event was a leaf node\n                complete = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));\n                if (complete.isLeafNode()) {\n                    newEventCache = viewProcessor.filter.updateFullNode(newEventCache, complete, accumulator);\n                }\n            }\n        }\n        complete = viewCache.serverCache.isFullyInitialized() || writeTreeRefShadowingWrite(writesCache, newEmptyPath()) != null;\n        return viewCacheUpdateEventSnap(viewCache, newEventCache, complete, viewProcessor.filter.filtersNodes());\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * A view represents a specific location and query that has 1 or more event registrations.\r\n *\r\n * It does several things:\r\n *  - Maintains the list of event registrations for this location/query.\r\n *  - Maintains a cache of the data visible for this location/query.\r\n *  - Applies new operations (via applyOperation), updates the cache, and based on the event\r\n *    registrations returns the set of events to be raised.\r\n */ class View {\n    constructor(query_, initialViewCache){\n        this.query_ = query_;\n        this.eventRegistrations_ = [];\n        const params = this.query_._queryParams;\n        const indexFilter = new IndexedFilter(params.getIndex());\n        const filter = queryParamsGetNodeFilter(params);\n        this.processor_ = newViewProcessor(filter);\n        const initialServerCache = initialViewCache.serverCache;\n        const initialEventCache = initialViewCache.eventCache;\n        // Don't filter server node with other filter than index, wait for tagged listen\n        const serverSnap = indexFilter.updateFullNode(ChildrenNode.EMPTY_NODE, initialServerCache.getNode(), null);\n        const eventSnap = filter.updateFullNode(ChildrenNode.EMPTY_NODE, initialEventCache.getNode(), null);\n        const newServerCache = new CacheNode(serverSnap, initialServerCache.isFullyInitialized(), indexFilter.filtersNodes());\n        const newEventCache = new CacheNode(eventSnap, initialEventCache.isFullyInitialized(), filter.filtersNodes());\n        this.viewCache_ = newViewCache(newEventCache, newServerCache);\n        this.eventGenerator_ = new EventGenerator(this.query_);\n    }\n    get query() {\n        return this.query_;\n    }\n}\nfunction viewGetServerCache(view) {\n    return view.viewCache_.serverCache.getNode();\n}\nfunction viewGetCompleteNode(view) {\n    return viewCacheGetCompleteEventSnap(view.viewCache_);\n}\nfunction viewGetCompleteServerCache(view, path) {\n    const cache = viewCacheGetCompleteServerSnap(view.viewCache_);\n    if (cache) {\n        // If this isn't a \"loadsAllData\" view, then cache isn't actually a complete cache and\n        // we need to see if it contains the child we're interested in.\n        if (view.query._queryParams.loadsAllData() || !pathIsEmpty(path) && !cache.getImmediateChild(pathGetFront(path)).isEmpty()) {\n            return cache.getChild(path);\n        }\n    }\n    return null;\n}\nfunction viewIsEmpty(view) {\n    return view.eventRegistrations_.length === 0;\n}\nfunction viewAddEventRegistration(view, eventRegistration) {\n    view.eventRegistrations_.push(eventRegistration);\n}\n/**\r\n * @param eventRegistration - If null, remove all callbacks.\r\n * @param cancelError - If a cancelError is provided, appropriate cancel events will be returned.\r\n * @returns Cancel events, if cancelError was provided.\r\n */ function viewRemoveEventRegistration(view, eventRegistration, cancelError) {\n    const cancelEvents = [];\n    if (cancelError) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(eventRegistration == null, \"A cancel should cancel all event registrations.\");\n        const path = view.query._path;\n        view.eventRegistrations_.forEach((registration)=>{\n            const maybeEvent = registration.createCancelEvent(cancelError, path);\n            if (maybeEvent) {\n                cancelEvents.push(maybeEvent);\n            }\n        });\n    }\n    if (eventRegistration) {\n        let remaining = [];\n        for(let i = 0; i < view.eventRegistrations_.length; ++i){\n            const existing = view.eventRegistrations_[i];\n            if (!existing.matches(eventRegistration)) {\n                remaining.push(existing);\n            } else if (eventRegistration.hasAnyCallback()) {\n                // We're removing just this one\n                remaining = remaining.concat(view.eventRegistrations_.slice(i + 1));\n                break;\n            }\n        }\n        view.eventRegistrations_ = remaining;\n    } else {\n        view.eventRegistrations_ = [];\n    }\n    return cancelEvents;\n}\n/**\r\n * Applies the given Operation, updates our cache, and returns the appropriate events.\r\n */ function viewApplyOperation(view, operation, writesCache, completeServerCache) {\n    if (operation.type === OperationType.MERGE && operation.source.queryId !== null) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(viewCacheGetCompleteServerSnap(view.viewCache_), \"We should always have a full cache before handling merges\");\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(viewCacheGetCompleteEventSnap(view.viewCache_), \"Missing event cache, even though we have a server cache\");\n    }\n    const oldViewCache = view.viewCache_;\n    const result = viewProcessorApplyOperation(view.processor_, oldViewCache, operation, writesCache, completeServerCache);\n    viewProcessorAssertIndexed(view.processor_, result.viewCache);\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(result.viewCache.serverCache.isFullyInitialized() || !oldViewCache.serverCache.isFullyInitialized(), \"Once a server snap is complete, it should never go back\");\n    view.viewCache_ = result.viewCache;\n    return viewGenerateEventsForChanges_(view, result.changes, result.viewCache.eventCache.getNode(), null);\n}\nfunction viewGetInitialEvents(view, registration) {\n    const eventSnap = view.viewCache_.eventCache;\n    const initialChanges = [];\n    if (!eventSnap.getNode().isLeafNode()) {\n        const eventNode = eventSnap.getNode();\n        eventNode.forEachChild(PRIORITY_INDEX, (key, childNode)=>{\n            initialChanges.push(changeChildAdded(key, childNode));\n        });\n    }\n    if (eventSnap.isFullyInitialized()) {\n        initialChanges.push(changeValue(eventSnap.getNode()));\n    }\n    return viewGenerateEventsForChanges_(view, initialChanges, eventSnap.getNode(), registration);\n}\nfunction viewGenerateEventsForChanges_(view, changes, eventCache, eventRegistration) {\n    const registrations = eventRegistration ? [\n        eventRegistration\n    ] : view.eventRegistrations_;\n    return eventGeneratorGenerateEventsForChanges(view.eventGenerator_, changes, eventCache, registrations);\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ let referenceConstructor$1;\n/**\r\n * SyncPoint represents a single location in a SyncTree with 1 or more event registrations, meaning we need to\r\n * maintain 1 or more Views at this location to cache server data and raise appropriate events for server changes\r\n * and user writes (set, transaction, update).\r\n *\r\n * It's responsible for:\r\n *  - Maintaining the set of 1 or more views necessary at this location (a SyncPoint with 0 views should be removed).\r\n *  - Proxying user / server operations to the views as appropriate (i.e. applyServerOverwrite,\r\n *    applyUserOverwrite, etc.)\r\n */ class SyncPoint {\n    constructor(){\n        /**\r\n         * The Views being tracked at this location in the tree, stored as a map where the key is a\r\n         * queryId and the value is the View for that query.\r\n         *\r\n         * NOTE: This list will be quite small (usually 1, but perhaps 2 or 3; any more is an odd use case).\r\n         */ this.views = new Map();\n    }\n}\nfunction syncPointSetReferenceConstructor(val) {\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(!referenceConstructor$1, \"__referenceConstructor has already been defined\");\n    referenceConstructor$1 = val;\n}\nfunction syncPointGetReferenceConstructor() {\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(referenceConstructor$1, \"Reference.ts has not been loaded\");\n    return referenceConstructor$1;\n}\nfunction syncPointIsEmpty(syncPoint) {\n    return syncPoint.views.size === 0;\n}\nfunction syncPointApplyOperation(syncPoint, operation, writesCache, optCompleteServerCache) {\n    const queryId = operation.source.queryId;\n    if (queryId !== null) {\n        const view = syncPoint.views.get(queryId);\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(view != null, \"SyncTree gave us an op for an invalid query.\");\n        return viewApplyOperation(view, operation, writesCache, optCompleteServerCache);\n    } else {\n        let events = [];\n        for (const view of syncPoint.views.values()){\n            events = events.concat(viewApplyOperation(view, operation, writesCache, optCompleteServerCache));\n        }\n        return events;\n    }\n}\n/**\r\n * Get a view for the specified query.\r\n *\r\n * @param query - The query to return a view for\r\n * @param writesCache\r\n * @param serverCache\r\n * @param serverCacheComplete\r\n * @returns Events to raise.\r\n */ function syncPointGetView(syncPoint, query, writesCache, serverCache, serverCacheComplete) {\n    const queryId = query._queryIdentifier;\n    const view = syncPoint.views.get(queryId);\n    if (!view) {\n        // TODO: make writesCache take flag for complete server node\n        let eventCache = writeTreeRefCalcCompleteEventCache(writesCache, serverCacheComplete ? serverCache : null);\n        let eventCacheComplete = false;\n        if (eventCache) {\n            eventCacheComplete = true;\n        } else if (serverCache instanceof ChildrenNode) {\n            eventCache = writeTreeRefCalcCompleteEventChildren(writesCache, serverCache);\n            eventCacheComplete = false;\n        } else {\n            eventCache = ChildrenNode.EMPTY_NODE;\n            eventCacheComplete = false;\n        }\n        const viewCache = newViewCache(new CacheNode(eventCache, eventCacheComplete, false), new CacheNode(serverCache, serverCacheComplete, false));\n        return new View(query, viewCache);\n    }\n    return view;\n}\n/**\r\n * Add an event callback for the specified query.\r\n *\r\n * @param query\r\n * @param eventRegistration\r\n * @param writesCache\r\n * @param serverCache - Complete server cache, if we have it.\r\n * @param serverCacheComplete\r\n * @returns Events to raise.\r\n */ function syncPointAddEventRegistration(syncPoint, query, eventRegistration, writesCache, serverCache, serverCacheComplete) {\n    const view = syncPointGetView(syncPoint, query, writesCache, serverCache, serverCacheComplete);\n    if (!syncPoint.views.has(query._queryIdentifier)) {\n        syncPoint.views.set(query._queryIdentifier, view);\n    }\n    // This is guaranteed to exist now, we just created anything that was missing\n    viewAddEventRegistration(view, eventRegistration);\n    return viewGetInitialEvents(view, eventRegistration);\n}\n/**\r\n * Remove event callback(s).  Return cancelEvents if a cancelError is specified.\r\n *\r\n * If query is the default query, we'll check all views for the specified eventRegistration.\r\n * If eventRegistration is null, we'll remove all callbacks for the specified view(s).\r\n *\r\n * @param eventRegistration - If null, remove all callbacks.\r\n * @param cancelError - If a cancelError is provided, appropriate cancel events will be returned.\r\n * @returns removed queries and any cancel events\r\n */ function syncPointRemoveEventRegistration(syncPoint, query, eventRegistration, cancelError) {\n    const queryId = query._queryIdentifier;\n    const removed = [];\n    let cancelEvents = [];\n    const hadCompleteView = syncPointHasCompleteView(syncPoint);\n    if (queryId === \"default\") {\n        // When you do ref.off(...), we search all views for the registration to remove.\n        for (const [viewQueryId, view] of syncPoint.views.entries()){\n            cancelEvents = cancelEvents.concat(viewRemoveEventRegistration(view, eventRegistration, cancelError));\n            if (viewIsEmpty(view)) {\n                syncPoint.views.delete(viewQueryId);\n                // We'll deal with complete views later.\n                if (!view.query._queryParams.loadsAllData()) {\n                    removed.push(view.query);\n                }\n            }\n        }\n    } else {\n        // remove the callback from the specific view.\n        const view = syncPoint.views.get(queryId);\n        if (view) {\n            cancelEvents = cancelEvents.concat(viewRemoveEventRegistration(view, eventRegistration, cancelError));\n            if (viewIsEmpty(view)) {\n                syncPoint.views.delete(queryId);\n                // We'll deal with complete views later.\n                if (!view.query._queryParams.loadsAllData()) {\n                    removed.push(view.query);\n                }\n            }\n        }\n    }\n    if (hadCompleteView && !syncPointHasCompleteView(syncPoint)) {\n        // We removed our last complete view.\n        removed.push(new (syncPointGetReferenceConstructor())(query._repo, query._path));\n    }\n    return {\n        removed,\n        events: cancelEvents\n    };\n}\nfunction syncPointGetQueryViews(syncPoint) {\n    const result = [];\n    for (const view of syncPoint.views.values()){\n        if (!view.query._queryParams.loadsAllData()) {\n            result.push(view);\n        }\n    }\n    return result;\n}\n/**\r\n * @param path - The path to the desired complete snapshot\r\n * @returns A complete cache, if it exists\r\n */ function syncPointGetCompleteServerCache(syncPoint, path) {\n    let serverCache = null;\n    for (const view of syncPoint.views.values()){\n        serverCache = serverCache || viewGetCompleteServerCache(view, path);\n    }\n    return serverCache;\n}\nfunction syncPointViewForQuery(syncPoint, query) {\n    const params = query._queryParams;\n    if (params.loadsAllData()) {\n        return syncPointGetCompleteView(syncPoint);\n    } else {\n        const queryId = query._queryIdentifier;\n        return syncPoint.views.get(queryId);\n    }\n}\nfunction syncPointViewExistsForQuery(syncPoint, query) {\n    return syncPointViewForQuery(syncPoint, query) != null;\n}\nfunction syncPointHasCompleteView(syncPoint) {\n    return syncPointGetCompleteView(syncPoint) != null;\n}\nfunction syncPointGetCompleteView(syncPoint) {\n    for (const view of syncPoint.views.values()){\n        if (view.query._queryParams.loadsAllData()) {\n            return view;\n        }\n    }\n    return null;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ let referenceConstructor;\nfunction syncTreeSetReferenceConstructor(val) {\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(!referenceConstructor, \"__referenceConstructor has already been defined\");\n    referenceConstructor = val;\n}\nfunction syncTreeGetReferenceConstructor() {\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(referenceConstructor, \"Reference.ts has not been loaded\");\n    return referenceConstructor;\n}\n/**\r\n * Static tracker for next query tag.\r\n */ let syncTreeNextQueryTag_ = 1;\n/**\r\n * SyncTree is the central class for managing event callback registration, data caching, views\r\n * (query processing), and event generation.  There are typically two SyncTree instances for\r\n * each Repo, one for the normal Firebase data, and one for the .info data.\r\n *\r\n * It has a number of responsibilities, including:\r\n *  - Tracking all user event callbacks (registered via addEventRegistration() and removeEventRegistration()).\r\n *  - Applying and caching data changes for user set(), transaction(), and update() calls\r\n *    (applyUserOverwrite(), applyUserMerge()).\r\n *  - Applying and caching data changes for server data changes (applyServerOverwrite(),\r\n *    applyServerMerge()).\r\n *  - Generating user-facing events for server and user changes (all of the apply* methods\r\n *    return the set of events that need to be raised as a result).\r\n *  - Maintaining the appropriate set of server listens to ensure we are always subscribed\r\n *    to the correct set of paths and queries to satisfy the current set of user event\r\n *    callbacks (listens are started/stopped using the provided listenProvider).\r\n *\r\n * NOTE: Although SyncTree tracks event callbacks and calculates events to raise, the actual\r\n * events are returned to the caller rather than raised synchronously.\r\n *\r\n */ class SyncTree {\n    /**\r\n     * @param listenProvider_ - Used by SyncTree to start / stop listening\r\n     *   to server data.\r\n     */ constructor(listenProvider_){\n        this.listenProvider_ = listenProvider_;\n        /**\r\n         * Tree of SyncPoints.  There's a SyncPoint at any location that has 1 or more views.\r\n         */ this.syncPointTree_ = new ImmutableTree(null);\n        /**\r\n         * A tree of all pending user writes (user-initiated set()'s, transaction()'s, update()'s, etc.).\r\n         */ this.pendingWriteTree_ = newWriteTree();\n        this.tagToQueryMap = new Map();\n        this.queryToTagMap = new Map();\n    }\n}\n/**\r\n * Apply the data changes for a user-generated set() or transaction() call.\r\n *\r\n * @returns Events to raise.\r\n */ function syncTreeApplyUserOverwrite(syncTree, path, newData, writeId, visible) {\n    // Record pending write.\n    writeTreeAddOverwrite(syncTree.pendingWriteTree_, path, newData, writeId, visible);\n    if (!visible) {\n        return [];\n    } else {\n        return syncTreeApplyOperationToSyncPoints_(syncTree, new Overwrite(newOperationSourceUser(), path, newData));\n    }\n}\n/**\r\n * Apply the data from a user-generated update() call\r\n *\r\n * @returns Events to raise.\r\n */ function syncTreeApplyUserMerge(syncTree, path, changedChildren, writeId) {\n    // Record pending merge.\n    writeTreeAddMerge(syncTree.pendingWriteTree_, path, changedChildren, writeId);\n    const changeTree = ImmutableTree.fromObject(changedChildren);\n    return syncTreeApplyOperationToSyncPoints_(syncTree, new Merge(newOperationSourceUser(), path, changeTree));\n}\n/**\r\n * Acknowledge a pending user write that was previously registered with applyUserOverwrite() or applyUserMerge().\r\n *\r\n * @param revert - True if the given write failed and needs to be reverted\r\n * @returns Events to raise.\r\n */ function syncTreeAckUserWrite(syncTree, writeId, revert = false) {\n    const write = writeTreeGetWrite(syncTree.pendingWriteTree_, writeId);\n    const needToReevaluate = writeTreeRemoveWrite(syncTree.pendingWriteTree_, writeId);\n    if (!needToReevaluate) {\n        return [];\n    } else {\n        let affectedTree = new ImmutableTree(null);\n        if (write.snap != null) {\n            // overwrite\n            affectedTree = affectedTree.set(newEmptyPath(), true);\n        } else {\n            each(write.children, (pathString)=>{\n                affectedTree = affectedTree.set(new Path(pathString), true);\n            });\n        }\n        return syncTreeApplyOperationToSyncPoints_(syncTree, new AckUserWrite(write.path, affectedTree, revert));\n    }\n}\n/**\r\n * Apply new server data for the specified path..\r\n *\r\n * @returns Events to raise.\r\n */ function syncTreeApplyServerOverwrite(syncTree, path, newData) {\n    return syncTreeApplyOperationToSyncPoints_(syncTree, new Overwrite(newOperationSourceServer(), path, newData));\n}\n/**\r\n * Apply new server data to be merged in at the specified path.\r\n *\r\n * @returns Events to raise.\r\n */ function syncTreeApplyServerMerge(syncTree, path, changedChildren) {\n    const changeTree = ImmutableTree.fromObject(changedChildren);\n    return syncTreeApplyOperationToSyncPoints_(syncTree, new Merge(newOperationSourceServer(), path, changeTree));\n}\n/**\r\n * Apply a listen complete for a query\r\n *\r\n * @returns Events to raise.\r\n */ function syncTreeApplyListenComplete(syncTree, path) {\n    return syncTreeApplyOperationToSyncPoints_(syncTree, new ListenComplete(newOperationSourceServer(), path));\n}\n/**\r\n * Apply a listen complete for a tagged query\r\n *\r\n * @returns Events to raise.\r\n */ function syncTreeApplyTaggedListenComplete(syncTree, path, tag) {\n    const queryKey = syncTreeQueryKeyForTag_(syncTree, tag);\n    if (queryKey) {\n        const r = syncTreeParseQueryKey_(queryKey);\n        const queryPath = r.path, queryId = r.queryId;\n        const relativePath = newRelativePath(queryPath, path);\n        const op = new ListenComplete(newOperationSourceServerTaggedQuery(queryId), relativePath);\n        return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);\n    } else {\n        // We've already removed the query. No big deal, ignore the update\n        return [];\n    }\n}\n/**\r\n * Remove event callback(s).\r\n *\r\n * If query is the default query, we'll check all queries for the specified eventRegistration.\r\n * If eventRegistration is null, we'll remove all callbacks for the specified query/queries.\r\n *\r\n * @param eventRegistration - If null, all callbacks are removed.\r\n * @param cancelError - If a cancelError is provided, appropriate cancel events will be returned.\r\n * @param skipListenerDedup - When performing a `get()`, we don't add any new listeners, so no\r\n *  deduping needs to take place. This flag allows toggling of that behavior\r\n * @returns Cancel events, if cancelError was provided.\r\n */ function syncTreeRemoveEventRegistration(syncTree, query, eventRegistration, cancelError, skipListenerDedup = false) {\n    // Find the syncPoint first. Then deal with whether or not it has matching listeners\n    const path = query._path;\n    const maybeSyncPoint = syncTree.syncPointTree_.get(path);\n    let cancelEvents = [];\n    // A removal on a default query affects all queries at that location. A removal on an indexed query, even one without\n    // other query constraints, does *not* affect all queries at that location. So this check must be for 'default', and\n    // not loadsAllData().\n    if (maybeSyncPoint && (query._queryIdentifier === \"default\" || syncPointViewExistsForQuery(maybeSyncPoint, query))) {\n        const removedAndEvents = syncPointRemoveEventRegistration(maybeSyncPoint, query, eventRegistration, cancelError);\n        if (syncPointIsEmpty(maybeSyncPoint)) {\n            syncTree.syncPointTree_ = syncTree.syncPointTree_.remove(path);\n        }\n        const removed = removedAndEvents.removed;\n        cancelEvents = removedAndEvents.events;\n        if (!skipListenerDedup) {\n            /**\r\n             * We may have just removed one of many listeners and can short-circuit this whole process\r\n             * We may also not have removed a default listener, in which case all of the descendant listeners should already be\r\n             * properly set up.\r\n             */ // Since indexed queries can shadow if they don't have other query constraints, check for loadsAllData(), instead of\n            // queryId === 'default'\n            const removingDefault = -1 !== removed.findIndex((query)=>{\n                return query._queryParams.loadsAllData();\n            });\n            const covered = syncTree.syncPointTree_.findOnPath(path, (relativePath, parentSyncPoint)=>syncPointHasCompleteView(parentSyncPoint));\n            if (removingDefault && !covered) {\n                const subtree = syncTree.syncPointTree_.subtree(path);\n                // There are potentially child listeners. Determine what if any listens we need to send before executing the\n                // removal\n                if (!subtree.isEmpty()) {\n                    // We need to fold over our subtree and collect the listeners to send\n                    const newViews = syncTreeCollectDistinctViewsForSubTree_(subtree);\n                    // Ok, we've collected all the listens we need. Set them up.\n                    for(let i = 0; i < newViews.length; ++i){\n                        const view = newViews[i], newQuery = view.query;\n                        const listener = syncTreeCreateListenerForView_(syncTree, view);\n                        syncTree.listenProvider_.startListening(syncTreeQueryForListening_(newQuery), syncTreeTagForQuery(syncTree, newQuery), listener.hashFn, listener.onComplete);\n                    }\n                }\n            // Otherwise there's nothing below us, so nothing we need to start listening on\n            }\n            // If we removed anything and we're not covered by a higher up listen, we need to stop listening on this query\n            // The above block has us covered in terms of making sure we're set up on listens lower in the tree.\n            // Also, note that if we have a cancelError, it's already been removed at the provider level.\n            if (!covered && removed.length > 0 && !cancelError) {\n                // If we removed a default, then we weren't listening on any of the other queries here. Just cancel the one\n                // default. Otherwise, we need to iterate through and cancel each individual query\n                if (removingDefault) {\n                    // We don't tag default listeners\n                    const defaultTag = null;\n                    syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(query), defaultTag);\n                } else {\n                    removed.forEach((queryToRemove)=>{\n                        const tagToRemove = syncTree.queryToTagMap.get(syncTreeMakeQueryKey_(queryToRemove));\n                        syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(queryToRemove), tagToRemove);\n                    });\n                }\n            }\n        }\n        // Now, clear all of the tags we're tracking for the removed listens\n        syncTreeRemoveTags_(syncTree, removed);\n    }\n    return cancelEvents;\n}\n/**\r\n * Apply new server data for the specified tagged query.\r\n *\r\n * @returns Events to raise.\r\n */ function syncTreeApplyTaggedQueryOverwrite(syncTree, path, snap, tag) {\n    const queryKey = syncTreeQueryKeyForTag_(syncTree, tag);\n    if (queryKey != null) {\n        const r = syncTreeParseQueryKey_(queryKey);\n        const queryPath = r.path, queryId = r.queryId;\n        const relativePath = newRelativePath(queryPath, path);\n        const op = new Overwrite(newOperationSourceServerTaggedQuery(queryId), relativePath, snap);\n        return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);\n    } else {\n        // Query must have been removed already\n        return [];\n    }\n}\n/**\r\n * Apply server data to be merged in for the specified tagged query.\r\n *\r\n * @returns Events to raise.\r\n */ function syncTreeApplyTaggedQueryMerge(syncTree, path, changedChildren, tag) {\n    const queryKey = syncTreeQueryKeyForTag_(syncTree, tag);\n    if (queryKey) {\n        const r = syncTreeParseQueryKey_(queryKey);\n        const queryPath = r.path, queryId = r.queryId;\n        const relativePath = newRelativePath(queryPath, path);\n        const changeTree = ImmutableTree.fromObject(changedChildren);\n        const op = new Merge(newOperationSourceServerTaggedQuery(queryId), relativePath, changeTree);\n        return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);\n    } else {\n        // We've already removed the query. No big deal, ignore the update\n        return [];\n    }\n}\n/**\r\n * Add an event callback for the specified query.\r\n *\r\n * @returns Events to raise.\r\n */ function syncTreeAddEventRegistration(syncTree, query, eventRegistration, skipSetupListener = false) {\n    const path = query._path;\n    let serverCache = null;\n    let foundAncestorDefaultView = false;\n    // Any covering writes will necessarily be at the root, so really all we need to find is the server cache.\n    // Consider optimizing this once there's a better understanding of what actual behavior will be.\n    syncTree.syncPointTree_.foreachOnPath(path, (pathToSyncPoint, sp)=>{\n        const relativePath = newRelativePath(pathToSyncPoint, path);\n        serverCache = serverCache || syncPointGetCompleteServerCache(sp, relativePath);\n        foundAncestorDefaultView = foundAncestorDefaultView || syncPointHasCompleteView(sp);\n    });\n    let syncPoint = syncTree.syncPointTree_.get(path);\n    if (!syncPoint) {\n        syncPoint = new SyncPoint();\n        syncTree.syncPointTree_ = syncTree.syncPointTree_.set(path, syncPoint);\n    } else {\n        foundAncestorDefaultView = foundAncestorDefaultView || syncPointHasCompleteView(syncPoint);\n        serverCache = serverCache || syncPointGetCompleteServerCache(syncPoint, newEmptyPath());\n    }\n    let serverCacheComplete;\n    if (serverCache != null) {\n        serverCacheComplete = true;\n    } else {\n        serverCacheComplete = false;\n        serverCache = ChildrenNode.EMPTY_NODE;\n        const subtree = syncTree.syncPointTree_.subtree(path);\n        subtree.foreachChild((childName, childSyncPoint)=>{\n            const completeCache = syncPointGetCompleteServerCache(childSyncPoint, newEmptyPath());\n            if (completeCache) {\n                serverCache = serverCache.updateImmediateChild(childName, completeCache);\n            }\n        });\n    }\n    const viewAlreadyExists = syncPointViewExistsForQuery(syncPoint, query);\n    if (!viewAlreadyExists && !query._queryParams.loadsAllData()) {\n        // We need to track a tag for this query\n        const queryKey = syncTreeMakeQueryKey_(query);\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(!syncTree.queryToTagMap.has(queryKey), \"View does not exist, but we have a tag\");\n        const tag = syncTreeGetNextQueryTag_();\n        syncTree.queryToTagMap.set(queryKey, tag);\n        syncTree.tagToQueryMap.set(tag, queryKey);\n    }\n    const writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, path);\n    let events = syncPointAddEventRegistration(syncPoint, query, eventRegistration, writesCache, serverCache, serverCacheComplete);\n    if (!viewAlreadyExists && !foundAncestorDefaultView && !skipSetupListener) {\n        const view = syncPointViewForQuery(syncPoint, query);\n        events = events.concat(syncTreeSetupListener_(syncTree, query, view));\n    }\n    return events;\n}\n/**\r\n * Returns a complete cache, if we have one, of the data at a particular path. If the location does not have a\r\n * listener above it, we will get a false \"null\". This shouldn't be a problem because transactions will always\r\n * have a listener above, and atomic operations would correctly show a jitter of <increment value> ->\r\n *     <incremented total> as the write is applied locally and then acknowledged at the server.\r\n *\r\n * Note: this method will *include* hidden writes from transaction with applyLocally set to false.\r\n *\r\n * @param path - The path to the data we want\r\n * @param writeIdsToExclude - A specific set to be excluded\r\n */ function syncTreeCalcCompleteEventCache(syncTree, path, writeIdsToExclude) {\n    const includeHiddenSets = true;\n    const writeTree = syncTree.pendingWriteTree_;\n    const serverCache = syncTree.syncPointTree_.findOnPath(path, (pathSoFar, syncPoint)=>{\n        const relativePath = newRelativePath(pathSoFar, path);\n        const serverCache = syncPointGetCompleteServerCache(syncPoint, relativePath);\n        if (serverCache) {\n            return serverCache;\n        }\n    });\n    return writeTreeCalcCompleteEventCache(writeTree, path, serverCache, writeIdsToExclude, includeHiddenSets);\n}\nfunction syncTreeGetServerValue(syncTree, query) {\n    const path = query._path;\n    let serverCache = null;\n    // Any covering writes will necessarily be at the root, so really all we need to find is the server cache.\n    // Consider optimizing this once there's a better understanding of what actual behavior will be.\n    syncTree.syncPointTree_.foreachOnPath(path, (pathToSyncPoint, sp)=>{\n        const relativePath = newRelativePath(pathToSyncPoint, path);\n        serverCache = serverCache || syncPointGetCompleteServerCache(sp, relativePath);\n    });\n    let syncPoint = syncTree.syncPointTree_.get(path);\n    if (!syncPoint) {\n        syncPoint = new SyncPoint();\n        syncTree.syncPointTree_ = syncTree.syncPointTree_.set(path, syncPoint);\n    } else {\n        serverCache = serverCache || syncPointGetCompleteServerCache(syncPoint, newEmptyPath());\n    }\n    const serverCacheComplete = serverCache != null;\n    const serverCacheNode = serverCacheComplete ? new CacheNode(serverCache, true, false) : null;\n    const writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, query._path);\n    const view = syncPointGetView(syncPoint, query, writesCache, serverCacheComplete ? serverCacheNode.getNode() : ChildrenNode.EMPTY_NODE, serverCacheComplete);\n    return viewGetCompleteNode(view);\n}\n/**\r\n * A helper method that visits all descendant and ancestor SyncPoints, applying the operation.\r\n *\r\n * NOTES:\r\n * - Descendant SyncPoints will be visited first (since we raise events depth-first).\r\n *\r\n * - We call applyOperation() on each SyncPoint passing three things:\r\n *   1. A version of the Operation that has been made relative to the SyncPoint location.\r\n *   2. A WriteTreeRef of any writes we have cached at the SyncPoint location.\r\n *   3. A snapshot Node with cached server data, if we have it.\r\n *\r\n * - We concatenate all of the events returned by each SyncPoint and return the result.\r\n */ function syncTreeApplyOperationToSyncPoints_(syncTree, operation) {\n    return syncTreeApplyOperationHelper_(operation, syncTree.syncPointTree_, /*serverCache=*/ null, writeTreeChildWrites(syncTree.pendingWriteTree_, newEmptyPath()));\n}\n/**\r\n * Recursive helper for applyOperationToSyncPoints_\r\n */ function syncTreeApplyOperationHelper_(operation, syncPointTree, serverCache, writesCache) {\n    if (pathIsEmpty(operation.path)) {\n        return syncTreeApplyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache);\n    } else {\n        const syncPoint = syncPointTree.get(newEmptyPath());\n        // If we don't have cached server data, see if we can get it from this SyncPoint.\n        if (serverCache == null && syncPoint != null) {\n            serverCache = syncPointGetCompleteServerCache(syncPoint, newEmptyPath());\n        }\n        let events = [];\n        const childName = pathGetFront(operation.path);\n        const childOperation = operation.operationForChild(childName);\n        const childTree = syncPointTree.children.get(childName);\n        if (childTree && childOperation) {\n            const childServerCache = serverCache ? serverCache.getImmediateChild(childName) : null;\n            const childWritesCache = writeTreeRefChild(writesCache, childName);\n            events = events.concat(syncTreeApplyOperationHelper_(childOperation, childTree, childServerCache, childWritesCache));\n        }\n        if (syncPoint) {\n            events = events.concat(syncPointApplyOperation(syncPoint, operation, writesCache, serverCache));\n        }\n        return events;\n    }\n}\n/**\r\n * Recursive helper for applyOperationToSyncPoints_\r\n */ function syncTreeApplyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache) {\n    const syncPoint = syncPointTree.get(newEmptyPath());\n    // If we don't have cached server data, see if we can get it from this SyncPoint.\n    if (serverCache == null && syncPoint != null) {\n        serverCache = syncPointGetCompleteServerCache(syncPoint, newEmptyPath());\n    }\n    let events = [];\n    syncPointTree.children.inorderTraversal((childName, childTree)=>{\n        const childServerCache = serverCache ? serverCache.getImmediateChild(childName) : null;\n        const childWritesCache = writeTreeRefChild(writesCache, childName);\n        const childOperation = operation.operationForChild(childName);\n        if (childOperation) {\n            events = events.concat(syncTreeApplyOperationDescendantsHelper_(childOperation, childTree, childServerCache, childWritesCache));\n        }\n    });\n    if (syncPoint) {\n        events = events.concat(syncPointApplyOperation(syncPoint, operation, writesCache, serverCache));\n    }\n    return events;\n}\nfunction syncTreeCreateListenerForView_(syncTree, view) {\n    const query = view.query;\n    const tag = syncTreeTagForQuery(syncTree, query);\n    return {\n        hashFn: ()=>{\n            const cache = viewGetServerCache(view) || ChildrenNode.EMPTY_NODE;\n            return cache.hash();\n        },\n        onComplete: (status)=>{\n            if (status === \"ok\") {\n                if (tag) {\n                    return syncTreeApplyTaggedListenComplete(syncTree, query._path, tag);\n                } else {\n                    return syncTreeApplyListenComplete(syncTree, query._path);\n                }\n            } else {\n                // If a listen failed, kill all of the listeners here, not just the one that triggered the error.\n                // Note that this may need to be scoped to just this listener if we change permissions on filtered children\n                const error = errorForServerCode(status, query);\n                return syncTreeRemoveEventRegistration(syncTree, query, /*eventRegistration*/ null, error);\n            }\n        }\n    };\n}\n/**\r\n * Return the tag associated with the given query.\r\n */ function syncTreeTagForQuery(syncTree, query) {\n    const queryKey = syncTreeMakeQueryKey_(query);\n    return syncTree.queryToTagMap.get(queryKey);\n}\n/**\r\n * Given a query, computes a \"queryKey\" suitable for use in our queryToTagMap_.\r\n */ function syncTreeMakeQueryKey_(query) {\n    return query._path.toString() + \"$\" + query._queryIdentifier;\n}\n/**\r\n * Return the query associated with the given tag, if we have one\r\n */ function syncTreeQueryKeyForTag_(syncTree, tag) {\n    return syncTree.tagToQueryMap.get(tag);\n}\n/**\r\n * Given a queryKey (created by makeQueryKey), parse it back into a path and queryId.\r\n */ function syncTreeParseQueryKey_(queryKey) {\n    const splitIndex = queryKey.indexOf(\"$\");\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(splitIndex !== -1 && splitIndex < queryKey.length - 1, \"Bad queryKey.\");\n    return {\n        queryId: queryKey.substr(splitIndex + 1),\n        path: new Path(queryKey.substr(0, splitIndex))\n    };\n}\n/**\r\n * A helper method to apply tagged operations\r\n */ function syncTreeApplyTaggedOperation_(syncTree, queryPath, operation) {\n    const syncPoint = syncTree.syncPointTree_.get(queryPath);\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(syncPoint, \"Missing sync point for query tag that we're tracking\");\n    const writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, queryPath);\n    return syncPointApplyOperation(syncPoint, operation, writesCache, null);\n}\n/**\r\n * This collapses multiple unfiltered views into a single view, since we only need a single\r\n * listener for them.\r\n */ function syncTreeCollectDistinctViewsForSubTree_(subtree) {\n    return subtree.fold((relativePath, maybeChildSyncPoint, childMap)=>{\n        if (maybeChildSyncPoint && syncPointHasCompleteView(maybeChildSyncPoint)) {\n            const completeView = syncPointGetCompleteView(maybeChildSyncPoint);\n            return [\n                completeView\n            ];\n        } else {\n            // No complete view here, flatten any deeper listens into an array\n            let views = [];\n            if (maybeChildSyncPoint) {\n                views = syncPointGetQueryViews(maybeChildSyncPoint);\n            }\n            each(childMap, (_key, childViews)=>{\n                views = views.concat(childViews);\n            });\n            return views;\n        }\n    });\n}\n/**\r\n * Normalizes a query to a query we send the server for listening\r\n *\r\n * @returns The normalized query\r\n */ function syncTreeQueryForListening_(query) {\n    if (query._queryParams.loadsAllData() && !query._queryParams.isDefault()) {\n        // We treat queries that load all data as default queries\n        // Cast is necessary because ref() technically returns Firebase which is actually fb.api.Firebase which inherits\n        // from Query\n        return new (syncTreeGetReferenceConstructor())(query._repo, query._path);\n    } else {\n        return query;\n    }\n}\nfunction syncTreeRemoveTags_(syncTree, queries) {\n    for(let j = 0; j < queries.length; ++j){\n        const removedQuery = queries[j];\n        if (!removedQuery._queryParams.loadsAllData()) {\n            // We should have a tag for this\n            const removedQueryKey = syncTreeMakeQueryKey_(removedQuery);\n            const removedQueryTag = syncTree.queryToTagMap.get(removedQueryKey);\n            syncTree.queryToTagMap.delete(removedQueryKey);\n            syncTree.tagToQueryMap.delete(removedQueryTag);\n        }\n    }\n}\n/**\r\n * Static accessor for query tags.\r\n */ function syncTreeGetNextQueryTag_() {\n    return syncTreeNextQueryTag_++;\n}\n/**\r\n * For a given new listen, manage the de-duplication of outstanding subscriptions.\r\n *\r\n * @returns This method can return events to support synchronous data sources\r\n */ function syncTreeSetupListener_(syncTree, query, view) {\n    const path = query._path;\n    const tag = syncTreeTagForQuery(syncTree, query);\n    const listener = syncTreeCreateListenerForView_(syncTree, view);\n    const events = syncTree.listenProvider_.startListening(syncTreeQueryForListening_(query), tag, listener.hashFn, listener.onComplete);\n    const subtree = syncTree.syncPointTree_.subtree(path);\n    // The root of this subtree has our query. We're here because we definitely need to send a listen for that, but we\n    // may need to shadow other listens as well.\n    if (tag) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(!syncPointHasCompleteView(subtree.value), \"If we're adding a query, it shouldn't be shadowed\");\n    } else {\n        // Shadow everything at or below this location, this is a default listener.\n        const queriesToStop = subtree.fold((relativePath, maybeChildSyncPoint, childMap)=>{\n            if (!pathIsEmpty(relativePath) && maybeChildSyncPoint && syncPointHasCompleteView(maybeChildSyncPoint)) {\n                return [\n                    syncPointGetCompleteView(maybeChildSyncPoint).query\n                ];\n            } else {\n                // No default listener here, flatten any deeper queries into an array\n                let queries = [];\n                if (maybeChildSyncPoint) {\n                    queries = queries.concat(syncPointGetQueryViews(maybeChildSyncPoint).map((view)=>view.query));\n                }\n                each(childMap, (_key, childQueries)=>{\n                    queries = queries.concat(childQueries);\n                });\n                return queries;\n            }\n        });\n        for(let i = 0; i < queriesToStop.length; ++i){\n            const queryToStop = queriesToStop[i];\n            syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(queryToStop), syncTreeTagForQuery(syncTree, queryToStop));\n        }\n    }\n    return events;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class ExistingValueProvider {\n    constructor(node_){\n        this.node_ = node_;\n    }\n    getImmediateChild(childName) {\n        const child = this.node_.getImmediateChild(childName);\n        return new ExistingValueProvider(child);\n    }\n    node() {\n        return this.node_;\n    }\n}\nclass DeferredValueProvider {\n    constructor(syncTree, path){\n        this.syncTree_ = syncTree;\n        this.path_ = path;\n    }\n    getImmediateChild(childName) {\n        const childPath = pathChild(this.path_, childName);\n        return new DeferredValueProvider(this.syncTree_, childPath);\n    }\n    node() {\n        return syncTreeCalcCompleteEventCache(this.syncTree_, this.path_);\n    }\n}\n/**\r\n * Generate placeholders for deferred values.\r\n */ const generateWithValues = function(values) {\n    values = values || {};\n    values[\"timestamp\"] = values[\"timestamp\"] || new Date().getTime();\n    return values;\n};\n/**\r\n * Value to use when firing local events. When writing server values, fire\r\n * local events with an approximate value, otherwise return value as-is.\r\n */ const resolveDeferredLeafValue = function(value, existingVal, serverValues) {\n    if (!value || typeof value !== \"object\") {\n        return value;\n    }\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(\".sv\" in value, \"Unexpected leaf node or priority contents\");\n    if (typeof value[\".sv\"] === \"string\") {\n        return resolveScalarDeferredValue(value[\".sv\"], existingVal, serverValues);\n    } else if (typeof value[\".sv\"] === \"object\") {\n        return resolveComplexDeferredValue(value[\".sv\"], existingVal);\n    } else {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"Unexpected server value: \" + JSON.stringify(value, null, 2));\n    }\n};\nconst resolveScalarDeferredValue = function(op, existing, serverValues) {\n    switch(op){\n        case \"timestamp\":\n            return serverValues[\"timestamp\"];\n        default:\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"Unexpected server value: \" + op);\n    }\n};\nconst resolveComplexDeferredValue = function(op, existing, unused) {\n    if (!op.hasOwnProperty(\"increment\")) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"Unexpected server value: \" + JSON.stringify(op, null, 2));\n    }\n    const delta = op[\"increment\"];\n    if (typeof delta !== \"number\") {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"Unexpected increment value: \" + delta);\n    }\n    const existingNode = existing.node();\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(existingNode !== null && typeof existingNode !== \"undefined\", \"Expected ChildrenNode.EMPTY_NODE for nulls\");\n    // Incrementing a non-number sets the value to the incremented amount\n    if (!existingNode.isLeafNode()) {\n        return delta;\n    }\n    const leaf = existingNode;\n    const existingVal = leaf.getValue();\n    if (typeof existingVal !== \"number\") {\n        return delta;\n    }\n    // No need to do over/underflow arithmetic here because JS only handles floats under the covers\n    return existingVal + delta;\n};\n/**\r\n * Recursively replace all deferred values and priorities in the tree with the\r\n * specified generated replacement values.\r\n * @param path - path to which write is relative\r\n * @param node - new data written at path\r\n * @param syncTree - current data\r\n */ const resolveDeferredValueTree = function(path, node, syncTree, serverValues) {\n    return resolveDeferredValue(node, new DeferredValueProvider(syncTree, path), serverValues);\n};\n/**\r\n * Recursively replace all deferred values and priorities in the node with the\r\n * specified generated replacement values.  If there are no server values in the node,\r\n * it'll be returned as-is.\r\n */ const resolveDeferredValueSnapshot = function(node, existing, serverValues) {\n    return resolveDeferredValue(node, new ExistingValueProvider(existing), serverValues);\n};\nfunction resolveDeferredValue(node, existingVal, serverValues) {\n    const rawPri = node.getPriority().val();\n    const priority = resolveDeferredLeafValue(rawPri, existingVal.getImmediateChild(\".priority\"), serverValues);\n    let newNode;\n    if (node.isLeafNode()) {\n        const leafNode = node;\n        const value = resolveDeferredLeafValue(leafNode.getValue(), existingVal, serverValues);\n        if (value !== leafNode.getValue() || priority !== leafNode.getPriority().val()) {\n            return new LeafNode(value, nodeFromJSON(priority));\n        } else {\n            return node;\n        }\n    } else {\n        const childrenNode = node;\n        newNode = childrenNode;\n        if (priority !== childrenNode.getPriority().val()) {\n            newNode = newNode.updatePriority(new LeafNode(priority));\n        }\n        childrenNode.forEachChild(PRIORITY_INDEX, (childName, childNode)=>{\n            const newChildNode = resolveDeferredValue(childNode, existingVal.getImmediateChild(childName), serverValues);\n            if (newChildNode !== childNode) {\n                newNode = newNode.updateImmediateChild(childName, newChildNode);\n            }\n        });\n        return newNode;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * A light-weight tree, traversable by path.  Nodes can have both values and children.\r\n * Nodes are not enumerated (by forEachChild) unless they have a value or non-empty\r\n * children.\r\n */ class Tree {\n    /**\r\n     * @param name - Optional name of the node.\r\n     * @param parent - Optional parent node.\r\n     * @param node - Optional node to wrap.\r\n     */ constructor(name = \"\", parent = null, node = {\n        children: {},\n        childCount: 0\n    }){\n        this.name = name;\n        this.parent = parent;\n        this.node = node;\n    }\n}\n/**\r\n * Returns a sub-Tree for the given path.\r\n *\r\n * @param pathObj - Path to look up.\r\n * @returns Tree for path.\r\n */ function treeSubTree(tree, pathObj) {\n    // TODO: Require pathObj to be Path?\n    let path = pathObj instanceof Path ? pathObj : new Path(pathObj);\n    let child = tree, next = pathGetFront(path);\n    while(next !== null){\n        const childNode = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.safeGet)(child.node.children, next) || {\n            children: {},\n            childCount: 0\n        };\n        child = new Tree(next, child, childNode);\n        path = pathPopFront(path);\n        next = pathGetFront(path);\n    }\n    return child;\n}\n/**\r\n * Returns the data associated with this tree node.\r\n *\r\n * @returns The data or null if no data exists.\r\n */ function treeGetValue(tree) {\n    return tree.node.value;\n}\n/**\r\n * Sets data to this tree node.\r\n *\r\n * @param value - Value to set.\r\n */ function treeSetValue(tree, value) {\n    tree.node.value = value;\n    treeUpdateParents(tree);\n}\n/**\r\n * @returns Whether the tree has any children.\r\n */ function treeHasChildren(tree) {\n    return tree.node.childCount > 0;\n}\n/**\r\n * @returns Whethe rthe tree is empty (no value or children).\r\n */ function treeIsEmpty(tree) {\n    return treeGetValue(tree) === undefined && !treeHasChildren(tree);\n}\n/**\r\n * Calls action for each child of this tree node.\r\n *\r\n * @param action - Action to be called for each child.\r\n */ function treeForEachChild(tree, action) {\n    each(tree.node.children, (child, childTree)=>{\n        action(new Tree(child, tree, childTree));\n    });\n}\n/**\r\n * Does a depth-first traversal of this node's descendants, calling action for each one.\r\n *\r\n * @param action - Action to be called for each child.\r\n * @param includeSelf - Whether to call action on this node as well. Defaults to\r\n *   false.\r\n * @param childrenFirst - Whether to call action on children before calling it on\r\n *   parent.\r\n */ function treeForEachDescendant(tree, action, includeSelf, childrenFirst) {\n    if (includeSelf && !childrenFirst) {\n        action(tree);\n    }\n    treeForEachChild(tree, (child)=>{\n        treeForEachDescendant(child, action, true, childrenFirst);\n    });\n    if (includeSelf && childrenFirst) {\n        action(tree);\n    }\n}\n/**\r\n * Calls action on each ancestor node.\r\n *\r\n * @param action - Action to be called on each parent; return\r\n *   true to abort.\r\n * @param includeSelf - Whether to call action on this node as well.\r\n * @returns true if the action callback returned true.\r\n */ function treeForEachAncestor(tree, action, includeSelf) {\n    let node = includeSelf ? tree : tree.parent;\n    while(node !== null){\n        if (action(node)) {\n            return true;\n        }\n        node = node.parent;\n    }\n    return false;\n}\n/**\r\n * @returns The path of this tree node, as a Path.\r\n */ function treeGetPath(tree) {\n    return new Path(tree.parent === null ? tree.name : treeGetPath(tree.parent) + \"/\" + tree.name);\n}\n/**\r\n * Adds or removes this child from its parent based on whether it's empty or not.\r\n */ function treeUpdateParents(tree) {\n    if (tree.parent !== null) {\n        treeUpdateChild(tree.parent, tree.name, tree);\n    }\n}\n/**\r\n * Adds or removes the passed child to this tree node, depending on whether it's empty.\r\n *\r\n * @param childName - The name of the child to update.\r\n * @param child - The child to update.\r\n */ function treeUpdateChild(tree, childName, child) {\n    const childEmpty = treeIsEmpty(child);\n    const childExists = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.contains)(tree.node.children, childName);\n    if (childEmpty && childExists) {\n        delete tree.node.children[childName];\n        tree.node.childCount--;\n        treeUpdateParents(tree);\n    } else if (!childEmpty && !childExists) {\n        tree.node.children[childName] = child.node;\n        tree.node.childCount++;\n        treeUpdateParents(tree);\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * True for invalid Firebase keys\r\n */ const INVALID_KEY_REGEX_ = /[\\[\\].#$\\/\\u0000-\\u001F\\u007F]/;\n/**\r\n * True for invalid Firebase paths.\r\n * Allows '/' in paths.\r\n */ const INVALID_PATH_REGEX_ = /[\\[\\].#$\\u0000-\\u001F\\u007F]/;\n/**\r\n * Maximum number of characters to allow in leaf value\r\n */ const MAX_LEAF_SIZE_ = 10 * 1024 * 1024;\nconst isValidKey = function(key) {\n    return typeof key === \"string\" && key.length !== 0 && !INVALID_KEY_REGEX_.test(key);\n};\nconst isValidPathString = function(pathString) {\n    return typeof pathString === \"string\" && pathString.length !== 0 && !INVALID_PATH_REGEX_.test(pathString);\n};\nconst isValidRootPathString = function(pathString) {\n    if (pathString) {\n        // Allow '/.info/' at the beginning.\n        pathString = pathString.replace(/^\\/*\\.info(\\/|$)/, \"/\");\n    }\n    return isValidPathString(pathString);\n};\nconst isValidPriority = function(priority) {\n    return priority === null || typeof priority === \"string\" || typeof priority === \"number\" && !isInvalidJSONNumber(priority) || priority && typeof priority === \"object\" && // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.contains)(priority, \".sv\");\n};\n/**\r\n * Pre-validate a datum passed as an argument to Firebase function.\r\n */ const validateFirebaseDataArg = function(fnName, value, path, optional) {\n    if (optional && value === undefined) {\n        return;\n    }\n    validateFirebaseData((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.errorPrefix)(fnName, \"value\"), value, path);\n};\n/**\r\n * Validate a data object client-side before sending to server.\r\n */ const validateFirebaseData = function(errorPrefix, data, path_) {\n    const path = path_ instanceof Path ? new ValidationPath(path_, errorPrefix) : path_;\n    if (data === undefined) {\n        throw new Error(errorPrefix + \"contains undefined \" + validationPathToErrorString(path));\n    }\n    if (typeof data === \"function\") {\n        throw new Error(errorPrefix + \"contains a function \" + validationPathToErrorString(path) + \" with contents = \" + data.toString());\n    }\n    if (isInvalidJSONNumber(data)) {\n        throw new Error(errorPrefix + \"contains \" + data.toString() + \" \" + validationPathToErrorString(path));\n    }\n    // Check max leaf size, but try to avoid the utf8 conversion if we can.\n    if (typeof data === \"string\" && data.length > MAX_LEAF_SIZE_ / 3 && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringLength)(data) > MAX_LEAF_SIZE_) {\n        throw new Error(errorPrefix + \"contains a string greater than \" + MAX_LEAF_SIZE_ + \" utf8 bytes \" + validationPathToErrorString(path) + \" ('\" + data.substring(0, 50) + \"...')\");\n    }\n    // TODO = Perf = Consider combining the recursive validation of keys into NodeFromJSON\n    // to save extra walking of large objects.\n    if (data && typeof data === \"object\") {\n        let hasDotValue = false;\n        let hasActualChild = false;\n        each(data, (key, value)=>{\n            if (key === \".value\") {\n                hasDotValue = true;\n            } else if (key !== \".priority\" && key !== \".sv\") {\n                hasActualChild = true;\n                if (!isValidKey(key)) {\n                    throw new Error(errorPrefix + \" contains an invalid key (\" + key + \") \" + validationPathToErrorString(path) + \".  Keys must be non-empty strings \" + 'and can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\"');\n                }\n            }\n            validationPathPush(path, key);\n            validateFirebaseData(errorPrefix, value, path);\n            validationPathPop(path);\n        });\n        if (hasDotValue && hasActualChild) {\n            throw new Error(errorPrefix + ' contains \".value\" child ' + validationPathToErrorString(path) + \" in addition to actual children.\");\n        }\n    }\n};\n/**\r\n * Pre-validate paths passed in the firebase function.\r\n */ const validateFirebaseMergePaths = function(errorPrefix, mergePaths) {\n    let i, curPath;\n    for(i = 0; i < mergePaths.length; i++){\n        curPath = mergePaths[i];\n        const keys = pathSlice(curPath);\n        for(let j = 0; j < keys.length; j++){\n            if (keys[j] === \".priority\" && j === keys.length - 1) ;\n            else if (!isValidKey(keys[j])) {\n                throw new Error(errorPrefix + \"contains an invalid key (\" + keys[j] + \") in path \" + curPath.toString() + \". Keys must be non-empty strings \" + 'and can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\"');\n            }\n        }\n    }\n    // Check that update keys are not descendants of each other.\n    // We rely on the property that sorting guarantees that ancestors come\n    // right before descendants.\n    mergePaths.sort(pathCompare);\n    let prevPath = null;\n    for(i = 0; i < mergePaths.length; i++){\n        curPath = mergePaths[i];\n        if (prevPath !== null && pathContains(prevPath, curPath)) {\n            throw new Error(errorPrefix + \"contains a path \" + prevPath.toString() + \" that is ancestor of another path \" + curPath.toString());\n        }\n        prevPath = curPath;\n    }\n};\n/**\r\n * pre-validate an object passed as an argument to firebase function (\r\n * must be an object - e.g. for firebase.update()).\r\n */ const validateFirebaseMergeDataArg = function(fnName, data, path, optional) {\n    if (optional && data === undefined) {\n        return;\n    }\n    const errorPrefix$1 = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.errorPrefix)(fnName, \"values\");\n    if (!(data && typeof data === \"object\") || Array.isArray(data)) {\n        throw new Error(errorPrefix$1 + \" must be an object containing the children to replace.\");\n    }\n    const mergePaths = [];\n    each(data, (key, value)=>{\n        const curPath = new Path(key);\n        validateFirebaseData(errorPrefix$1, value, pathChild(path, curPath));\n        if (pathGetBack(curPath) === \".priority\") {\n            if (!isValidPriority(value)) {\n                throw new Error(errorPrefix$1 + \"contains an invalid value for '\" + curPath.toString() + \"', which must be a valid \" + \"Firebase priority (a string, finite number, server value, or null).\");\n            }\n        }\n        mergePaths.push(curPath);\n    });\n    validateFirebaseMergePaths(errorPrefix$1, mergePaths);\n};\nconst validatePriority = function(fnName, priority, optional) {\n    if (optional && priority === undefined) {\n        return;\n    }\n    if (isInvalidJSONNumber(priority)) {\n        throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.errorPrefix)(fnName, \"priority\") + \"is \" + priority.toString() + \", but must be a valid Firebase priority (a string, finite number, \" + \"server value, or null).\");\n    }\n    // Special case to allow importing data with a .sv.\n    if (!isValidPriority(priority)) {\n        throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.errorPrefix)(fnName, \"priority\") + \"must be a valid Firebase priority \" + \"(a string, finite number, server value, or null).\");\n    }\n};\nconst validateKey = function(fnName, argumentName, key, optional) {\n    if (optional && key === undefined) {\n        return;\n    }\n    if (!isValidKey(key)) {\n        throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.errorPrefix)(fnName, argumentName) + 'was an invalid key = \"' + key + '\".  Firebase keys must be non-empty strings and ' + 'can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\").');\n    }\n};\n/**\r\n * @internal\r\n */ const validatePathString = function(fnName, argumentName, pathString, optional) {\n    if (optional && pathString === undefined) {\n        return;\n    }\n    if (!isValidPathString(pathString)) {\n        throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.errorPrefix)(fnName, argumentName) + 'was an invalid path = \"' + pathString + '\". Paths must be non-empty strings and ' + 'can\\'t contain \".\", \"#\", \"$\", \"[\", or \"]\"');\n    }\n};\nconst validateRootPathString = function(fnName, argumentName, pathString, optional) {\n    if (pathString) {\n        // Allow '/.info/' at the beginning.\n        pathString = pathString.replace(/^\\/*\\.info(\\/|$)/, \"/\");\n    }\n    validatePathString(fnName, argumentName, pathString, optional);\n};\n/**\r\n * @internal\r\n */ const validateWritablePath = function(fnName, path) {\n    if (pathGetFront(path) === \".info\") {\n        throw new Error(fnName + \" failed = Can't modify data under /.info/\");\n    }\n};\nconst validateUrl = function(fnName, parsedUrl) {\n    // TODO = Validate server better.\n    const pathString = parsedUrl.path.toString();\n    if (!(typeof parsedUrl.repoInfo.host === \"string\") || parsedUrl.repoInfo.host.length === 0 || !isValidKey(parsedUrl.repoInfo.namespace) && parsedUrl.repoInfo.host.split(\":\")[0] !== \"localhost\" || pathString.length !== 0 && !isValidRootPathString(pathString)) {\n        throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.errorPrefix)(fnName, \"url\") + \"must be a valid firebase URL and \" + 'the path can\\'t contain \".\", \"#\", \"$\", \"[\", or \"]\".');\n    }\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * The event queue serves a few purposes:\r\n * 1. It ensures we maintain event order in the face of event callbacks doing operations that result in more\r\n *    events being queued.\r\n * 2. raiseQueuedEvents() handles being called reentrantly nicely.  That is, if in the course of raising events,\r\n *    raiseQueuedEvents() is called again, the \"inner\" call will pick up raising events where the \"outer\" call\r\n *    left off, ensuring that the events are still raised synchronously and in order.\r\n * 3. You can use raiseEventsAtPath and raiseEventsForChangedPath to ensure only relevant previously-queued\r\n *    events are raised synchronously.\r\n *\r\n * NOTE: This can all go away if/when we move to async events.\r\n *\r\n */ class EventQueue {\n    constructor(){\n        this.eventLists_ = [];\n        /**\r\n         * Tracks recursion depth of raiseQueuedEvents_, for debugging purposes.\r\n         */ this.recursionDepth_ = 0;\n    }\n}\n/**\r\n * @param eventDataList - The new events to queue.\r\n */ function eventQueueQueueEvents(eventQueue, eventDataList) {\n    // We group events by path, storing them in a single EventList, to make it easier to skip over them quickly.\n    let currList = null;\n    for(let i = 0; i < eventDataList.length; i++){\n        const data = eventDataList[i];\n        const path = data.getPath();\n        if (currList !== null && !pathEquals(path, currList.path)) {\n            eventQueue.eventLists_.push(currList);\n            currList = null;\n        }\n        if (currList === null) {\n            currList = {\n                events: [],\n                path\n            };\n        }\n        currList.events.push(data);\n    }\n    if (currList) {\n        eventQueue.eventLists_.push(currList);\n    }\n}\n/**\r\n * Queues the specified events and synchronously raises all events (including previously queued ones)\r\n * for the specified path.\r\n *\r\n * It is assumed that the new events are all for the specified path.\r\n *\r\n * @param path - The path to raise events for.\r\n * @param eventDataList - The new events to raise.\r\n */ function eventQueueRaiseEventsAtPath(eventQueue, path, eventDataList) {\n    eventQueueQueueEvents(eventQueue, eventDataList);\n    eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, (eventPath)=>pathEquals(eventPath, path));\n}\n/**\r\n * Queues the specified events and synchronously raises all events (including previously queued ones) for\r\n * locations related to the specified change path (i.e. all ancestors and descendants).\r\n *\r\n * It is assumed that the new events are all related (ancestor or descendant) to the specified path.\r\n *\r\n * @param changedPath - The path to raise events for.\r\n * @param eventDataList - The events to raise\r\n */ function eventQueueRaiseEventsForChangedPath(eventQueue, changedPath, eventDataList) {\n    eventQueueQueueEvents(eventQueue, eventDataList);\n    eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, (eventPath)=>pathContains(eventPath, changedPath) || pathContains(changedPath, eventPath));\n}\nfunction eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, predicate) {\n    eventQueue.recursionDepth_++;\n    let sentAll = true;\n    for(let i = 0; i < eventQueue.eventLists_.length; i++){\n        const eventList = eventQueue.eventLists_[i];\n        if (eventList) {\n            const eventPath = eventList.path;\n            if (predicate(eventPath)) {\n                eventListRaise(eventQueue.eventLists_[i]);\n                eventQueue.eventLists_[i] = null;\n            } else {\n                sentAll = false;\n            }\n        }\n    }\n    if (sentAll) {\n        eventQueue.eventLists_ = [];\n    }\n    eventQueue.recursionDepth_--;\n}\n/**\r\n * Iterates through the list and raises each event\r\n */ function eventListRaise(eventList) {\n    for(let i = 0; i < eventList.events.length; i++){\n        const eventData = eventList.events[i];\n        if (eventData !== null) {\n            eventList.events[i] = null;\n            const eventFn = eventData.getEventRunner();\n            if (logger) {\n                log(\"event: \" + eventData.toString());\n            }\n            exceptionGuard(eventFn);\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const INTERRUPT_REASON = \"repo_interrupt\";\n/**\r\n * If a transaction does not succeed after 25 retries, we abort it. Among other\r\n * things this ensure that if there's ever a bug causing a mismatch between\r\n * client / server hashes for some data, we won't retry indefinitely.\r\n */ const MAX_TRANSACTION_RETRIES = 25;\n/**\r\n * A connection to a single data repository.\r\n */ class Repo {\n    constructor(repoInfo_, forceRestClient_, authTokenProvider_, appCheckProvider_){\n        this.repoInfo_ = repoInfo_;\n        this.forceRestClient_ = forceRestClient_;\n        this.authTokenProvider_ = authTokenProvider_;\n        this.appCheckProvider_ = appCheckProvider_;\n        this.dataUpdateCount = 0;\n        this.statsListener_ = null;\n        this.eventQueue_ = new EventQueue();\n        this.nextWriteId_ = 1;\n        this.interceptServerDataCallback_ = null;\n        /** A list of data pieces and paths to be set when this client disconnects. */ this.onDisconnect_ = newSparseSnapshotTree();\n        /** Stores queues of outstanding transactions for Firebase locations. */ this.transactionQueueTree_ = new Tree();\n        // TODO: This should be @private but it's used by test_access.js and internal.js\n        this.persistentConnection_ = null;\n        // This key is intentionally not updated if RepoInfo is later changed or replaced\n        this.key = this.repoInfo_.toURLString();\n    }\n    /**\r\n     * @returns The URL corresponding to the root of this Firebase.\r\n     */ toString() {\n        return (this.repoInfo_.secure ? \"https://\" : \"http://\") + this.repoInfo_.host;\n    }\n}\nfunction repoStart(repo, appId, authOverride) {\n    repo.stats_ = statsManagerGetCollection(repo.repoInfo_);\n    if (repo.forceRestClient_ || beingCrawled()) {\n        repo.server_ = new ReadonlyRestClient(repo.repoInfo_, (pathString, data, isMerge, tag)=>{\n            repoOnDataUpdate(repo, pathString, data, isMerge, tag);\n        }, repo.authTokenProvider_, repo.appCheckProvider_);\n        // Minor hack: Fire onConnect immediately, since there's no actual connection.\n        setTimeout(()=>repoOnConnectStatus(repo, /* connectStatus= */ true), 0);\n    } else {\n        // Validate authOverride\n        if (typeof authOverride !== \"undefined\" && authOverride !== null) {\n            if (typeof authOverride !== \"object\") {\n                throw new Error(\"Only objects are supported for option databaseAuthVariableOverride\");\n            }\n            try {\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(authOverride);\n            } catch (e) {\n                throw new Error(\"Invalid authOverride provided: \" + e);\n            }\n        }\n        repo.persistentConnection_ = new PersistentConnection(repo.repoInfo_, appId, (pathString, data, isMerge, tag)=>{\n            repoOnDataUpdate(repo, pathString, data, isMerge, tag);\n        }, (connectStatus)=>{\n            repoOnConnectStatus(repo, connectStatus);\n        }, (updates)=>{\n            repoOnServerInfoUpdate(repo, updates);\n        }, repo.authTokenProvider_, repo.appCheckProvider_, authOverride);\n        repo.server_ = repo.persistentConnection_;\n    }\n    repo.authTokenProvider_.addTokenChangeListener((token)=>{\n        repo.server_.refreshAuthToken(token);\n    });\n    repo.appCheckProvider_.addTokenChangeListener((result)=>{\n        repo.server_.refreshAppCheckToken(result.token);\n    });\n    // In the case of multiple Repos for the same repoInfo (i.e. there are multiple Firebase.Contexts being used),\n    // we only want to create one StatsReporter.  As such, we'll report stats over the first Repo created.\n    repo.statsReporter_ = statsManagerGetOrCreateReporter(repo.repoInfo_, ()=>new StatsReporter(repo.stats_, repo.server_));\n    // Used for .info.\n    repo.infoData_ = new SnapshotHolder();\n    repo.infoSyncTree_ = new SyncTree({\n        startListening: (query, tag, currentHashFn, onComplete)=>{\n            let infoEvents = [];\n            const node = repo.infoData_.getNode(query._path);\n            // This is possibly a hack, but we have different semantics for .info endpoints. We don't raise null events\n            // on initial data...\n            if (!node.isEmpty()) {\n                infoEvents = syncTreeApplyServerOverwrite(repo.infoSyncTree_, query._path, node);\n                setTimeout(()=>{\n                    onComplete(\"ok\");\n                }, 0);\n            }\n            return infoEvents;\n        },\n        stopListening: ()=>{}\n    });\n    repoUpdateInfo(repo, \"connected\", false);\n    repo.serverSyncTree_ = new SyncTree({\n        startListening: (query, tag, currentHashFn, onComplete)=>{\n            repo.server_.listen(query, currentHashFn, tag, (status, data)=>{\n                const events = onComplete(status, data);\n                eventQueueRaiseEventsForChangedPath(repo.eventQueue_, query._path, events);\n            });\n            // No synchronous events for network-backed sync trees\n            return [];\n        },\n        stopListening: (query, tag)=>{\n            repo.server_.unlisten(query, tag);\n        }\n    });\n}\n/**\r\n * @returns The time in milliseconds, taking the server offset into account if we have one.\r\n */ function repoServerTime(repo) {\n    const offsetNode = repo.infoData_.getNode(new Path(\".info/serverTimeOffset\"));\n    const offset = offsetNode.val() || 0;\n    return new Date().getTime() + offset;\n}\n/**\r\n * Generate ServerValues using some variables from the repo object.\r\n */ function repoGenerateServerValues(repo) {\n    return generateWithValues({\n        timestamp: repoServerTime(repo)\n    });\n}\n/**\r\n * Called by realtime when we get new messages from the server.\r\n */ function repoOnDataUpdate(repo, pathString, data, isMerge, tag) {\n    // For testing.\n    repo.dataUpdateCount++;\n    const path = new Path(pathString);\n    data = repo.interceptServerDataCallback_ ? repo.interceptServerDataCallback_(pathString, data) : data;\n    let events = [];\n    if (tag) {\n        if (isMerge) {\n            const taggedChildren = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.map)(data, (raw)=>nodeFromJSON(raw));\n            events = syncTreeApplyTaggedQueryMerge(repo.serverSyncTree_, path, taggedChildren, tag);\n        } else {\n            const taggedSnap = nodeFromJSON(data);\n            events = syncTreeApplyTaggedQueryOverwrite(repo.serverSyncTree_, path, taggedSnap, tag);\n        }\n    } else if (isMerge) {\n        const changedChildren = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.map)(data, (raw)=>nodeFromJSON(raw));\n        events = syncTreeApplyServerMerge(repo.serverSyncTree_, path, changedChildren);\n    } else {\n        const snap = nodeFromJSON(data);\n        events = syncTreeApplyServerOverwrite(repo.serverSyncTree_, path, snap);\n    }\n    let affectedPath = path;\n    if (events.length > 0) {\n        // Since we have a listener outstanding for each transaction, receiving any events\n        // is a proxy for some change having occurred.\n        affectedPath = repoRerunTransactions(repo, path);\n    }\n    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, events);\n}\nfunction repoOnConnectStatus(repo, connectStatus) {\n    repoUpdateInfo(repo, \"connected\", connectStatus);\n    if (connectStatus === false) {\n        repoRunOnDisconnectEvents(repo);\n    }\n}\nfunction repoOnServerInfoUpdate(repo, updates) {\n    each(updates, (key, value)=>{\n        repoUpdateInfo(repo, key, value);\n    });\n}\nfunction repoUpdateInfo(repo, pathString, value) {\n    const path = new Path(\"/.info/\" + pathString);\n    const newNode = nodeFromJSON(value);\n    repo.infoData_.updateSnapshot(path, newNode);\n    const events = syncTreeApplyServerOverwrite(repo.infoSyncTree_, path, newNode);\n    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);\n}\nfunction repoGetNextWriteId(repo) {\n    return repo.nextWriteId_++;\n}\n/**\r\n * The purpose of `getValue` is to return the latest known value\r\n * satisfying `query`.\r\n *\r\n * This method will first check for in-memory cached values\r\n * belonging to active listeners. If they are found, such values\r\n * are considered to be the most up-to-date.\r\n *\r\n * If the client is not connected, this method will wait until the\r\n *  repo has established a connection and then request the value for `query`.\r\n * If the client is not able to retrieve the query result for another reason,\r\n * it reports an error.\r\n *\r\n * @param query - The query to surface a value for.\r\n */ function repoGetValue(repo, query, eventRegistration) {\n    // Only active queries are cached. There is no persisted cache.\n    const cached = syncTreeGetServerValue(repo.serverSyncTree_, query);\n    if (cached != null) {\n        return Promise.resolve(cached);\n    }\n    return repo.server_.get(query).then((payload)=>{\n        const node = nodeFromJSON(payload).withIndex(query._queryParams.getIndex());\n        /**\r\n         * Below we simulate the actions of an `onlyOnce` `onValue()` event where:\r\n         * Add an event registration,\r\n         * Update data at the path,\r\n         * Raise any events,\r\n         * Cleanup the SyncTree\r\n         */ syncTreeAddEventRegistration(repo.serverSyncTree_, query, eventRegistration, true);\n        let events;\n        if (query._queryParams.loadsAllData()) {\n            events = syncTreeApplyServerOverwrite(repo.serverSyncTree_, query._path, node);\n        } else {\n            const tag = syncTreeTagForQuery(repo.serverSyncTree_, query);\n            events = syncTreeApplyTaggedQueryOverwrite(repo.serverSyncTree_, query._path, node, tag);\n        }\n        /*\r\n         * We need to raise events in the scenario where `get()` is called at a parent path, and\r\n         * while the `get()` is pending, `onValue` is called at a child location. While get() is waiting\r\n         * for the data, `onValue` will register a new event. Then, get() will come back, and update the syncTree\r\n         * and its corresponding serverCache, including the child location where `onValue` is called. Then,\r\n         * `onValue` will receive the event from the server, but look at the syncTree and see that the data received\r\n         * from the server is already at the SyncPoint, and so the `onValue` callback will never get fired.\r\n         * Calling `eventQueueRaiseEventsForChangedPath()` is the correct way to propagate the events and\r\n         * ensure the corresponding child events will get fired.\r\n         */ eventQueueRaiseEventsForChangedPath(repo.eventQueue_, query._path, events);\n        syncTreeRemoveEventRegistration(repo.serverSyncTree_, query, eventRegistration, null, true);\n        return node;\n    }, (err)=>{\n        repoLog(repo, \"get for query \" + (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(query) + \" failed: \" + err);\n        return Promise.reject(new Error(err));\n    });\n}\nfunction repoSetWithPriority(repo, path, newVal, newPriority, onComplete) {\n    repoLog(repo, \"set\", {\n        path: path.toString(),\n        value: newVal,\n        priority: newPriority\n    });\n    // TODO: Optimize this behavior to either (a) store flag to skip resolving where possible and / or\n    // (b) store unresolved paths on JSON parse\n    const serverValues = repoGenerateServerValues(repo);\n    const newNodeUnresolved = nodeFromJSON(newVal, newPriority);\n    const existing = syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path);\n    const newNode = resolveDeferredValueSnapshot(newNodeUnresolved, existing, serverValues);\n    const writeId = repoGetNextWriteId(repo);\n    const events = syncTreeApplyUserOverwrite(repo.serverSyncTree_, path, newNode, writeId, true);\n    eventQueueQueueEvents(repo.eventQueue_, events);\n    repo.server_.put(path.toString(), newNodeUnresolved.val(/*export=*/ true), (status, errorReason)=>{\n        const success = status === \"ok\";\n        if (!success) {\n            warn(\"set at \" + path + \" failed: \" + status);\n        }\n        const clearEvents = syncTreeAckUserWrite(repo.serverSyncTree_, writeId, !success);\n        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, clearEvents);\n        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);\n    });\n    const affectedPath = repoAbortTransactions(repo, path);\n    repoRerunTransactions(repo, affectedPath);\n    // We queued the events above, so just flush the queue here\n    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, []);\n}\nfunction repoUpdate(repo, path, childrenToMerge, onComplete) {\n    repoLog(repo, \"update\", {\n        path: path.toString(),\n        value: childrenToMerge\n    });\n    // Start with our existing data and merge each child into it.\n    let empty = true;\n    const serverValues = repoGenerateServerValues(repo);\n    const changedChildren = {};\n    each(childrenToMerge, (changedKey, changedValue)=>{\n        empty = false;\n        changedChildren[changedKey] = resolveDeferredValueTree(pathChild(path, changedKey), nodeFromJSON(changedValue), repo.serverSyncTree_, serverValues);\n    });\n    if (!empty) {\n        const writeId = repoGetNextWriteId(repo);\n        const events = syncTreeApplyUserMerge(repo.serverSyncTree_, path, changedChildren, writeId);\n        eventQueueQueueEvents(repo.eventQueue_, events);\n        repo.server_.merge(path.toString(), childrenToMerge, (status, errorReason)=>{\n            const success = status === \"ok\";\n            if (!success) {\n                warn(\"update at \" + path + \" failed: \" + status);\n            }\n            const clearEvents = syncTreeAckUserWrite(repo.serverSyncTree_, writeId, !success);\n            const affectedPath = clearEvents.length > 0 ? repoRerunTransactions(repo, path) : path;\n            eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, clearEvents);\n            repoCallOnCompleteCallback(repo, onComplete, status, errorReason);\n        });\n        each(childrenToMerge, (changedPath)=>{\n            const affectedPath = repoAbortTransactions(repo, pathChild(path, changedPath));\n            repoRerunTransactions(repo, affectedPath);\n        });\n        // We queued the events above, so just flush the queue here\n        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, []);\n    } else {\n        log(\"update() called with empty data.  Don't do anything.\");\n        repoCallOnCompleteCallback(repo, onComplete, \"ok\", undefined);\n    }\n}\n/**\r\n * Applies all of the changes stored up in the onDisconnect_ tree.\r\n */ function repoRunOnDisconnectEvents(repo) {\n    repoLog(repo, \"onDisconnectEvents\");\n    const serverValues = repoGenerateServerValues(repo);\n    const resolvedOnDisconnectTree = newSparseSnapshotTree();\n    sparseSnapshotTreeForEachTree(repo.onDisconnect_, newEmptyPath(), (path, node)=>{\n        const resolved = resolveDeferredValueTree(path, node, repo.serverSyncTree_, serverValues);\n        sparseSnapshotTreeRemember(resolvedOnDisconnectTree, path, resolved);\n    });\n    let events = [];\n    sparseSnapshotTreeForEachTree(resolvedOnDisconnectTree, newEmptyPath(), (path, snap)=>{\n        events = events.concat(syncTreeApplyServerOverwrite(repo.serverSyncTree_, path, snap));\n        const affectedPath = repoAbortTransactions(repo, path);\n        repoRerunTransactions(repo, affectedPath);\n    });\n    repo.onDisconnect_ = newSparseSnapshotTree();\n    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, newEmptyPath(), events);\n}\nfunction repoOnDisconnectCancel(repo, path, onComplete) {\n    repo.server_.onDisconnectCancel(path.toString(), (status, errorReason)=>{\n        if (status === \"ok\") {\n            sparseSnapshotTreeForget(repo.onDisconnect_, path);\n        }\n        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);\n    });\n}\nfunction repoOnDisconnectSet(repo, path, value, onComplete) {\n    const newNode = nodeFromJSON(value);\n    repo.server_.onDisconnectPut(path.toString(), newNode.val(/*export=*/ true), (status, errorReason)=>{\n        if (status === \"ok\") {\n            sparseSnapshotTreeRemember(repo.onDisconnect_, path, newNode);\n        }\n        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);\n    });\n}\nfunction repoOnDisconnectSetWithPriority(repo, path, value, priority, onComplete) {\n    const newNode = nodeFromJSON(value, priority);\n    repo.server_.onDisconnectPut(path.toString(), newNode.val(/*export=*/ true), (status, errorReason)=>{\n        if (status === \"ok\") {\n            sparseSnapshotTreeRemember(repo.onDisconnect_, path, newNode);\n        }\n        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);\n    });\n}\nfunction repoOnDisconnectUpdate(repo, path, childrenToMerge, onComplete) {\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(childrenToMerge)) {\n        log(\"onDisconnect().update() called with empty data.  Don't do anything.\");\n        repoCallOnCompleteCallback(repo, onComplete, \"ok\", undefined);\n        return;\n    }\n    repo.server_.onDisconnectMerge(path.toString(), childrenToMerge, (status, errorReason)=>{\n        if (status === \"ok\") {\n            each(childrenToMerge, (childName, childNode)=>{\n                const newChildNode = nodeFromJSON(childNode);\n                sparseSnapshotTreeRemember(repo.onDisconnect_, pathChild(path, childName), newChildNode);\n            });\n        }\n        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);\n    });\n}\nfunction repoAddEventCallbackForQuery(repo, query, eventRegistration) {\n    let events;\n    if (pathGetFront(query._path) === \".info\") {\n        events = syncTreeAddEventRegistration(repo.infoSyncTree_, query, eventRegistration);\n    } else {\n        events = syncTreeAddEventRegistration(repo.serverSyncTree_, query, eventRegistration);\n    }\n    eventQueueRaiseEventsAtPath(repo.eventQueue_, query._path, events);\n}\nfunction repoRemoveEventCallbackForQuery(repo, query, eventRegistration) {\n    // These are guaranteed not to raise events, since we're not passing in a cancelError. However, we can future-proof\n    // a little bit by handling the return values anyways.\n    let events;\n    if (pathGetFront(query._path) === \".info\") {\n        events = syncTreeRemoveEventRegistration(repo.infoSyncTree_, query, eventRegistration);\n    } else {\n        events = syncTreeRemoveEventRegistration(repo.serverSyncTree_, query, eventRegistration);\n    }\n    eventQueueRaiseEventsAtPath(repo.eventQueue_, query._path, events);\n}\nfunction repoInterrupt(repo) {\n    if (repo.persistentConnection_) {\n        repo.persistentConnection_.interrupt(INTERRUPT_REASON);\n    }\n}\nfunction repoResume(repo) {\n    if (repo.persistentConnection_) {\n        repo.persistentConnection_.resume(INTERRUPT_REASON);\n    }\n}\nfunction repoLog(repo, ...varArgs) {\n    let prefix = \"\";\n    if (repo.persistentConnection_) {\n        prefix = repo.persistentConnection_.id + \":\";\n    }\n    log(prefix, ...varArgs);\n}\nfunction repoCallOnCompleteCallback(repo, callback, status, errorReason) {\n    if (callback) {\n        exceptionGuard(()=>{\n            if (status === \"ok\") {\n                callback(null);\n            } else {\n                const code = (status || \"error\").toUpperCase();\n                let message = code;\n                if (errorReason) {\n                    message += \": \" + errorReason;\n                }\n                const error = new Error(message);\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                error.code = code;\n                callback(error);\n            }\n        });\n    }\n}\n/**\r\n * Creates a new transaction, adds it to the transactions we're tracking, and\r\n * sends it to the server if possible.\r\n *\r\n * @param path - Path at which to do transaction.\r\n * @param transactionUpdate - Update callback.\r\n * @param onComplete - Completion callback.\r\n * @param unwatcher - Function that will be called when the transaction no longer\r\n * need data updates for `path`.\r\n * @param applyLocally - Whether or not to make intermediate results visible\r\n */ function repoStartTransaction(repo, path, transactionUpdate, onComplete, unwatcher, applyLocally) {\n    repoLog(repo, \"transaction on \" + path);\n    // Initialize transaction.\n    const transaction = {\n        path,\n        update: transactionUpdate,\n        onComplete,\n        // One of TransactionStatus enums.\n        status: null,\n        // Used when combining transactions at different locations to figure out\n        // which one goes first.\n        order: LUIDGenerator(),\n        // Whether to raise local events for this transaction.\n        applyLocally,\n        // Count of how many times we've retried the transaction.\n        retryCount: 0,\n        // Function to call to clean up our .on() listener.\n        unwatcher,\n        // Stores why a transaction was aborted.\n        abortReason: null,\n        currentWriteId: null,\n        currentInputSnapshot: null,\n        currentOutputSnapshotRaw: null,\n        currentOutputSnapshotResolved: null\n    };\n    // Run transaction initially.\n    const currentState = repoGetLatestState(repo, path, undefined);\n    transaction.currentInputSnapshot = currentState;\n    const newVal = transaction.update(currentState.val());\n    if (newVal === undefined) {\n        // Abort transaction.\n        transaction.unwatcher();\n        transaction.currentOutputSnapshotRaw = null;\n        transaction.currentOutputSnapshotResolved = null;\n        if (transaction.onComplete) {\n            transaction.onComplete(null, false, transaction.currentInputSnapshot);\n        }\n    } else {\n        validateFirebaseData(\"transaction failed: Data returned \", newVal, transaction.path);\n        // Mark as run and add to our queue.\n        transaction.status = 0 /* TransactionStatus.RUN */ ;\n        const queueNode = treeSubTree(repo.transactionQueueTree_, path);\n        const nodeQueue = treeGetValue(queueNode) || [];\n        nodeQueue.push(transaction);\n        treeSetValue(queueNode, nodeQueue);\n        // Update visibleData and raise events\n        // Note: We intentionally raise events after updating all of our\n        // transaction state, since the user could start new transactions from the\n        // event callbacks.\n        let priorityForNode;\n        if (typeof newVal === \"object\" && newVal !== null && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.contains)(newVal, \".priority\")) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            priorityForNode = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.safeGet)(newVal, \".priority\");\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(isValidPriority(priorityForNode), \"Invalid priority returned by transaction. \" + \"Priority must be a valid string, finite number, server value, or null.\");\n        } else {\n            const currentNode = syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path) || ChildrenNode.EMPTY_NODE;\n            priorityForNode = currentNode.getPriority().val();\n        }\n        const serverValues = repoGenerateServerValues(repo);\n        const newNodeUnresolved = nodeFromJSON(newVal, priorityForNode);\n        const newNode = resolveDeferredValueSnapshot(newNodeUnresolved, currentState, serverValues);\n        transaction.currentOutputSnapshotRaw = newNodeUnresolved;\n        transaction.currentOutputSnapshotResolved = newNode;\n        transaction.currentWriteId = repoGetNextWriteId(repo);\n        const events = syncTreeApplyUserOverwrite(repo.serverSyncTree_, path, newNode, transaction.currentWriteId, transaction.applyLocally);\n        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);\n        repoSendReadyTransactions(repo, repo.transactionQueueTree_);\n    }\n}\n/**\r\n * @param excludeSets - A specific set to exclude\r\n */ function repoGetLatestState(repo, path, excludeSets) {\n    return syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path, excludeSets) || ChildrenNode.EMPTY_NODE;\n}\n/**\r\n * Sends any already-run transactions that aren't waiting for outstanding\r\n * transactions to complete.\r\n *\r\n * Externally it's called with no arguments, but it calls itself recursively\r\n * with a particular transactionQueueTree node to recurse through the tree.\r\n *\r\n * @param node - transactionQueueTree node to start at.\r\n */ function repoSendReadyTransactions(repo, node = repo.transactionQueueTree_) {\n    // Before recursing, make sure any completed transactions are removed.\n    if (!node) {\n        repoPruneCompletedTransactionsBelowNode(repo, node);\n    }\n    if (treeGetValue(node)) {\n        const queue = repoBuildTransactionQueue(repo, node);\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(queue.length > 0, \"Sending zero length transaction queue\");\n        const allRun = queue.every((transaction)=>transaction.status === 0 /* TransactionStatus.RUN */ );\n        // If they're all run (and not sent), we can send them.  Else, we must wait.\n        if (allRun) {\n            repoSendTransactionQueue(repo, treeGetPath(node), queue);\n        }\n    } else if (treeHasChildren(node)) {\n        treeForEachChild(node, (childNode)=>{\n            repoSendReadyTransactions(repo, childNode);\n        });\n    }\n}\n/**\r\n * Given a list of run transactions, send them to the server and then handle\r\n * the result (success or failure).\r\n *\r\n * @param path - The location of the queue.\r\n * @param queue - Queue of transactions under the specified location.\r\n */ function repoSendTransactionQueue(repo, path, queue) {\n    // Mark transactions as sent and increment retry count!\n    const setsToIgnore = queue.map((txn)=>{\n        return txn.currentWriteId;\n    });\n    const latestState = repoGetLatestState(repo, path, setsToIgnore);\n    let snapToSend = latestState;\n    const latestHash = latestState.hash();\n    for(let i = 0; i < queue.length; i++){\n        const txn = queue[i];\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(txn.status === 0 /* TransactionStatus.RUN */ , \"tryToSendTransactionQueue_: items in queue should all be run.\");\n        txn.status = 1 /* TransactionStatus.SENT */ ;\n        txn.retryCount++;\n        const relativePath = newRelativePath(path, txn.path);\n        // If we've gotten to this point, the output snapshot must be defined.\n        snapToSend = snapToSend.updateChild(relativePath /** @type {!Node} */ , txn.currentOutputSnapshotRaw);\n    }\n    const dataToSend = snapToSend.val(true);\n    const pathToSend = path;\n    // Send the put.\n    repo.server_.put(pathToSend.toString(), dataToSend, (status)=>{\n        repoLog(repo, \"transaction put response\", {\n            path: pathToSend.toString(),\n            status\n        });\n        let events = [];\n        if (status === \"ok\") {\n            // Queue up the callbacks and fire them after cleaning up all of our\n            // transaction state, since the callback could trigger more\n            // transactions or sets.\n            const callbacks = [];\n            for(let i = 0; i < queue.length; i++){\n                queue[i].status = 2 /* TransactionStatus.COMPLETED */ ;\n                events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, queue[i].currentWriteId));\n                if (queue[i].onComplete) {\n                    // We never unset the output snapshot, and given that this\n                    // transaction is complete, it should be set\n                    callbacks.push(()=>queue[i].onComplete(null, true, queue[i].currentOutputSnapshotResolved));\n                }\n                queue[i].unwatcher();\n            }\n            // Now remove the completed transactions.\n            repoPruneCompletedTransactionsBelowNode(repo, treeSubTree(repo.transactionQueueTree_, path));\n            // There may be pending transactions that we can now send.\n            repoSendReadyTransactions(repo, repo.transactionQueueTree_);\n            eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);\n            // Finally, trigger onComplete callbacks.\n            for(let i = 0; i < callbacks.length; i++){\n                exceptionGuard(callbacks[i]);\n            }\n        } else {\n            // transactions are no longer sent.  Update their status appropriately.\n            if (status === \"datastale\") {\n                for(let i = 0; i < queue.length; i++){\n                    if (queue[i].status === 3 /* TransactionStatus.SENT_NEEDS_ABORT */ ) {\n                        queue[i].status = 4 /* TransactionStatus.NEEDS_ABORT */ ;\n                    } else {\n                        queue[i].status = 0 /* TransactionStatus.RUN */ ;\n                    }\n                }\n            } else {\n                warn(\"transaction at \" + pathToSend.toString() + \" failed: \" + status);\n                for(let i = 0; i < queue.length; i++){\n                    queue[i].status = 4 /* TransactionStatus.NEEDS_ABORT */ ;\n                    queue[i].abortReason = status;\n                }\n            }\n            repoRerunTransactions(repo, path);\n        }\n    }, latestHash);\n}\n/**\r\n * Finds all transactions dependent on the data at changedPath and reruns them.\r\n *\r\n * Should be called any time cached data changes.\r\n *\r\n * Return the highest path that was affected by rerunning transactions. This\r\n * is the path at which events need to be raised for.\r\n *\r\n * @param changedPath - The path in mergedData that changed.\r\n * @returns The rootmost path that was affected by rerunning transactions.\r\n */ function repoRerunTransactions(repo, changedPath) {\n    const rootMostTransactionNode = repoGetAncestorTransactionNode(repo, changedPath);\n    const path = treeGetPath(rootMostTransactionNode);\n    const queue = repoBuildTransactionQueue(repo, rootMostTransactionNode);\n    repoRerunTransactionQueue(repo, queue, path);\n    return path;\n}\n/**\r\n * Does all the work of rerunning transactions (as well as cleans up aborted\r\n * transactions and whatnot).\r\n *\r\n * @param queue - The queue of transactions to run.\r\n * @param path - The path the queue is for.\r\n */ function repoRerunTransactionQueue(repo, queue, path) {\n    if (queue.length === 0) {\n        return; // Nothing to do!\n    }\n    // Queue up the callbacks and fire them after cleaning up all of our\n    // transaction state, since the callback could trigger more transactions or\n    // sets.\n    const callbacks = [];\n    let events = [];\n    // Ignore all of the sets we're going to re-run.\n    const txnsToRerun = queue.filter((q)=>{\n        return q.status === 0 /* TransactionStatus.RUN */ ;\n    });\n    const setsToIgnore = txnsToRerun.map((q)=>{\n        return q.currentWriteId;\n    });\n    for(let i = 0; i < queue.length; i++){\n        const transaction = queue[i];\n        const relativePath = newRelativePath(path, transaction.path);\n        let abortTransaction = false, abortReason;\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(relativePath !== null, \"rerunTransactionsUnderNode_: relativePath should not be null.\");\n        if (transaction.status === 4 /* TransactionStatus.NEEDS_ABORT */ ) {\n            abortTransaction = true;\n            abortReason = transaction.abortReason;\n            events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));\n        } else if (transaction.status === 0 /* TransactionStatus.RUN */ ) {\n            if (transaction.retryCount >= MAX_TRANSACTION_RETRIES) {\n                abortTransaction = true;\n                abortReason = \"maxretry\";\n                events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));\n            } else {\n                // This code reruns a transaction\n                const currentNode = repoGetLatestState(repo, transaction.path, setsToIgnore);\n                transaction.currentInputSnapshot = currentNode;\n                const newData = queue[i].update(currentNode.val());\n                if (newData !== undefined) {\n                    validateFirebaseData(\"transaction failed: Data returned \", newData, transaction.path);\n                    let newDataNode = nodeFromJSON(newData);\n                    const hasExplicitPriority = typeof newData === \"object\" && newData != null && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.contains)(newData, \".priority\");\n                    if (!hasExplicitPriority) {\n                        // Keep the old priority if there wasn't a priority explicitly specified.\n                        newDataNode = newDataNode.updatePriority(currentNode.getPriority());\n                    }\n                    const oldWriteId = transaction.currentWriteId;\n                    const serverValues = repoGenerateServerValues(repo);\n                    const newNodeResolved = resolveDeferredValueSnapshot(newDataNode, currentNode, serverValues);\n                    transaction.currentOutputSnapshotRaw = newDataNode;\n                    transaction.currentOutputSnapshotResolved = newNodeResolved;\n                    transaction.currentWriteId = repoGetNextWriteId(repo);\n                    // Mutates setsToIgnore in place\n                    setsToIgnore.splice(setsToIgnore.indexOf(oldWriteId), 1);\n                    events = events.concat(syncTreeApplyUserOverwrite(repo.serverSyncTree_, transaction.path, newNodeResolved, transaction.currentWriteId, transaction.applyLocally));\n                    events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, oldWriteId, true));\n                } else {\n                    abortTransaction = true;\n                    abortReason = \"nodata\";\n                    events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));\n                }\n            }\n        }\n        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);\n        events = [];\n        if (abortTransaction) {\n            // Abort.\n            queue[i].status = 2 /* TransactionStatus.COMPLETED */ ;\n            // Removing a listener can trigger pruning which can muck with\n            // mergedData/visibleData (as it prunes data). So defer the unwatcher\n            // until we're done.\n            (function(unwatcher) {\n                setTimeout(unwatcher, Math.floor(0));\n            })(queue[i].unwatcher);\n            if (queue[i].onComplete) {\n                if (abortReason === \"nodata\") {\n                    callbacks.push(()=>queue[i].onComplete(null, false, queue[i].currentInputSnapshot));\n                } else {\n                    callbacks.push(()=>queue[i].onComplete(new Error(abortReason), false, null));\n                }\n            }\n        }\n    }\n    // Clean up completed transactions.\n    repoPruneCompletedTransactionsBelowNode(repo, repo.transactionQueueTree_);\n    // Now fire callbacks, now that we're in a good, known state.\n    for(let i = 0; i < callbacks.length; i++){\n        exceptionGuard(callbacks[i]);\n    }\n    // Try to send the transaction result to the server.\n    repoSendReadyTransactions(repo, repo.transactionQueueTree_);\n}\n/**\r\n * Returns the rootmost ancestor node of the specified path that has a pending\r\n * transaction on it, or just returns the node for the given path if there are\r\n * no pending transactions on any ancestor.\r\n *\r\n * @param path - The location to start at.\r\n * @returns The rootmost node with a transaction.\r\n */ function repoGetAncestorTransactionNode(repo, path) {\n    let front;\n    // Start at the root and walk deeper into the tree towards path until we\n    // find a node with pending transactions.\n    let transactionNode = repo.transactionQueueTree_;\n    front = pathGetFront(path);\n    while(front !== null && treeGetValue(transactionNode) === undefined){\n        transactionNode = treeSubTree(transactionNode, front);\n        path = pathPopFront(path);\n        front = pathGetFront(path);\n    }\n    return transactionNode;\n}\n/**\r\n * Builds the queue of all transactions at or below the specified\r\n * transactionNode.\r\n *\r\n * @param transactionNode\r\n * @returns The generated queue.\r\n */ function repoBuildTransactionQueue(repo, transactionNode) {\n    // Walk any child transaction queues and aggregate them into a single queue.\n    const transactionQueue = [];\n    repoAggregateTransactionQueuesForNode(repo, transactionNode, transactionQueue);\n    // Sort them by the order the transactions were created.\n    transactionQueue.sort((a, b)=>a.order - b.order);\n    return transactionQueue;\n}\nfunction repoAggregateTransactionQueuesForNode(repo, node, queue) {\n    const nodeQueue = treeGetValue(node);\n    if (nodeQueue) {\n        for(let i = 0; i < nodeQueue.length; i++){\n            queue.push(nodeQueue[i]);\n        }\n    }\n    treeForEachChild(node, (child)=>{\n        repoAggregateTransactionQueuesForNode(repo, child, queue);\n    });\n}\n/**\r\n * Remove COMPLETED transactions at or below this node in the transactionQueueTree_.\r\n */ function repoPruneCompletedTransactionsBelowNode(repo, node) {\n    const queue = treeGetValue(node);\n    if (queue) {\n        let to = 0;\n        for(let from = 0; from < queue.length; from++){\n            if (queue[from].status !== 2 /* TransactionStatus.COMPLETED */ ) {\n                queue[to] = queue[from];\n                to++;\n            }\n        }\n        queue.length = to;\n        treeSetValue(node, queue.length > 0 ? queue : undefined);\n    }\n    treeForEachChild(node, (childNode)=>{\n        repoPruneCompletedTransactionsBelowNode(repo, childNode);\n    });\n}\n/**\r\n * Aborts all transactions on ancestors or descendants of the specified path.\r\n * Called when doing a set() or update() since we consider them incompatible\r\n * with transactions.\r\n *\r\n * @param path - Path for which we want to abort related transactions.\r\n */ function repoAbortTransactions(repo, path) {\n    const affectedPath = treeGetPath(repoGetAncestorTransactionNode(repo, path));\n    const transactionNode = treeSubTree(repo.transactionQueueTree_, path);\n    treeForEachAncestor(transactionNode, (node)=>{\n        repoAbortTransactionsOnNode(repo, node);\n    });\n    repoAbortTransactionsOnNode(repo, transactionNode);\n    treeForEachDescendant(transactionNode, (node)=>{\n        repoAbortTransactionsOnNode(repo, node);\n    });\n    return affectedPath;\n}\n/**\r\n * Abort transactions stored in this transaction queue node.\r\n *\r\n * @param node - Node to abort transactions for.\r\n */ function repoAbortTransactionsOnNode(repo, node) {\n    const queue = treeGetValue(node);\n    if (queue) {\n        // Queue up the callbacks and fire them after cleaning up all of our\n        // transaction state, since the callback could trigger more transactions\n        // or sets.\n        const callbacks = [];\n        // Go through queue.  Any already-sent transactions must be marked for\n        // abort, while the unsent ones can be immediately aborted and removed.\n        let events = [];\n        let lastSent = -1;\n        for(let i = 0; i < queue.length; i++){\n            if (queue[i].status === 3 /* TransactionStatus.SENT_NEEDS_ABORT */ ) ;\n            else if (queue[i].status === 1 /* TransactionStatus.SENT */ ) {\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(lastSent === i - 1, \"All SENT items should be at beginning of queue.\");\n                lastSent = i;\n                // Mark transaction for abort when it comes back.\n                queue[i].status = 3 /* TransactionStatus.SENT_NEEDS_ABORT */ ;\n                queue[i].abortReason = \"set\";\n            } else {\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(queue[i].status === 0 /* TransactionStatus.RUN */ , \"Unexpected transaction status in abort\");\n                // We can abort it immediately.\n                queue[i].unwatcher();\n                events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, queue[i].currentWriteId, true));\n                if (queue[i].onComplete) {\n                    callbacks.push(queue[i].onComplete.bind(null, new Error(\"set\"), false, null));\n                }\n            }\n        }\n        if (lastSent === -1) {\n            // We're not waiting for any sent transactions.  We can clear the queue.\n            treeSetValue(node, undefined);\n        } else {\n            // Remove the transactions we aborted.\n            queue.length = lastSent + 1;\n        }\n        // Now fire the callbacks.\n        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, treeGetPath(node), events);\n        for(let i = 0; i < callbacks.length; i++){\n            exceptionGuard(callbacks[i]);\n        }\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function decodePath(pathString) {\n    let pathStringDecoded = \"\";\n    const pieces = pathString.split(\"/\");\n    for(let i = 0; i < pieces.length; i++){\n        if (pieces[i].length > 0) {\n            let piece = pieces[i];\n            try {\n                piece = decodeURIComponent(piece.replace(/\\+/g, \" \"));\n            } catch (e) {}\n            pathStringDecoded += \"/\" + piece;\n        }\n    }\n    return pathStringDecoded;\n}\n/**\r\n * @returns key value hash\r\n */ function decodeQuery(queryString) {\n    const results = {};\n    if (queryString.charAt(0) === \"?\") {\n        queryString = queryString.substring(1);\n    }\n    for (const segment of queryString.split(\"&\")){\n        if (segment.length === 0) {\n            continue;\n        }\n        const kv = segment.split(\"=\");\n        if (kv.length === 2) {\n            results[decodeURIComponent(kv[0])] = decodeURIComponent(kv[1]);\n        } else {\n            warn(`Invalid query segment '${segment}' in query '${queryString}'`);\n        }\n    }\n    return results;\n}\nconst parseRepoInfo = function(dataURL, nodeAdmin) {\n    const parsedUrl = parseDatabaseURL(dataURL), namespace = parsedUrl.namespace;\n    if (parsedUrl.domain === \"firebase.com\") {\n        fatal(parsedUrl.host + \" is no longer supported. \" + \"Please use <YOUR FIREBASE>.firebaseio.com instead\");\n    }\n    // Catch common error of uninitialized namespace value.\n    if ((!namespace || namespace === \"undefined\") && parsedUrl.domain !== \"localhost\") {\n        fatal(\"Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com\");\n    }\n    if (!parsedUrl.secure) {\n        warnIfPageIsSecure();\n    }\n    const webSocketOnly = parsedUrl.scheme === \"ws\" || parsedUrl.scheme === \"wss\";\n    return {\n        repoInfo: new RepoInfo(parsedUrl.host, parsedUrl.secure, namespace, webSocketOnly, nodeAdmin, /*persistenceKey=*/ \"\", /*includeNamespaceInQueryParams=*/ namespace !== parsedUrl.subdomain),\n        path: new Path(parsedUrl.pathString)\n    };\n};\nconst parseDatabaseURL = function(dataURL) {\n    // Default to empty strings in the event of a malformed string.\n    let host = \"\", domain = \"\", subdomain = \"\", pathString = \"\", namespace = \"\";\n    // Always default to SSL, unless otherwise specified.\n    let secure = true, scheme = \"https\", port = 443;\n    // Don't do any validation here. The caller is responsible for validating the result of parsing.\n    if (typeof dataURL === \"string\") {\n        // Parse scheme.\n        let colonInd = dataURL.indexOf(\"//\");\n        if (colonInd >= 0) {\n            scheme = dataURL.substring(0, colonInd - 1);\n            dataURL = dataURL.substring(colonInd + 2);\n        }\n        // Parse host, path, and query string.\n        let slashInd = dataURL.indexOf(\"/\");\n        if (slashInd === -1) {\n            slashInd = dataURL.length;\n        }\n        let questionMarkInd = dataURL.indexOf(\"?\");\n        if (questionMarkInd === -1) {\n            questionMarkInd = dataURL.length;\n        }\n        host = dataURL.substring(0, Math.min(slashInd, questionMarkInd));\n        if (slashInd < questionMarkInd) {\n            // For pathString, questionMarkInd will always come after slashInd\n            pathString = decodePath(dataURL.substring(slashInd, questionMarkInd));\n        }\n        const queryParams = decodeQuery(dataURL.substring(Math.min(dataURL.length, questionMarkInd)));\n        // If we have a port, use scheme for determining if it's secure.\n        colonInd = host.indexOf(\":\");\n        if (colonInd >= 0) {\n            secure = scheme === \"https\" || scheme === \"wss\";\n            port = parseInt(host.substring(colonInd + 1), 10);\n        } else {\n            colonInd = host.length;\n        }\n        const hostWithoutPort = host.slice(0, colonInd);\n        if (hostWithoutPort.toLowerCase() === \"localhost\") {\n            domain = \"localhost\";\n        } else if (hostWithoutPort.split(\".\").length <= 2) {\n            domain = hostWithoutPort;\n        } else {\n            // Interpret the subdomain of a 3 or more component URL as the namespace name.\n            const dotInd = host.indexOf(\".\");\n            subdomain = host.substring(0, dotInd).toLowerCase();\n            domain = host.substring(dotInd + 1);\n            // Normalize namespaces to lowercase to share storage / connection.\n            namespace = subdomain;\n        }\n        // Always treat the value of the `ns` as the namespace name if it is present.\n        if (\"ns\" in queryParams) {\n            namespace = queryParams[\"ns\"];\n        }\n    }\n    return {\n        host,\n        port,\n        domain,\n        subdomain,\n        secure,\n        scheme,\n        pathString,\n        namespace\n    };\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // Modeled after base64 web-safe chars, but ordered by ASCII.\nconst PUSH_CHARS = \"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\";\n/**\r\n * Fancy ID generator that creates 20-character string identifiers with the\r\n * following properties:\r\n *\r\n * 1. They're based on timestamp so that they sort *after* any existing ids.\r\n * 2. They contain 72-bits of random data after the timestamp so that IDs won't\r\n *    collide with other clients' IDs.\r\n * 3. They sort *lexicographically* (so the timestamp is converted to characters\r\n *    that will sort properly).\r\n * 4. They're monotonically increasing. Even if you generate more than one in\r\n *    the same timestamp, the latter ones will sort after the former ones. We do\r\n *    this by using the previous random bits but \"incrementing\" them by 1 (only\r\n *    in the case of a timestamp collision).\r\n */ const nextPushId = function() {\n    // Timestamp of last push, used to prevent local collisions if you push twice\n    // in one ms.\n    let lastPushTime = 0;\n    // We generate 72-bits of randomness which get turned into 12 characters and\n    // appended to the timestamp to prevent collisions with other clients. We\n    // store the last characters we generated because in the event of a collision,\n    // we'll use those same characters except \"incremented\" by one.\n    const lastRandChars = [];\n    return function(now) {\n        const duplicateTime = now === lastPushTime;\n        lastPushTime = now;\n        let i;\n        const timeStampChars = new Array(8);\n        for(i = 7; i >= 0; i--){\n            timeStampChars[i] = PUSH_CHARS.charAt(now % 64);\n            // NOTE: Can't use << here because javascript will convert to int and lose\n            // the upper bits.\n            now = Math.floor(now / 64);\n        }\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(now === 0, \"Cannot push at time == 0\");\n        let id = timeStampChars.join(\"\");\n        if (!duplicateTime) {\n            for(i = 0; i < 12; i++){\n                lastRandChars[i] = Math.floor(Math.random() * 64);\n            }\n        } else {\n            // If the timestamp hasn't changed since last push, use the same random\n            // number, except incremented by 1.\n            for(i = 11; i >= 0 && lastRandChars[i] === 63; i--){\n                lastRandChars[i] = 0;\n            }\n            lastRandChars[i]++;\n        }\n        for(i = 0; i < 12; i++){\n            id += PUSH_CHARS.charAt(lastRandChars[i]);\n        }\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(id.length === 20, \"nextPushId: Length should be 20.\");\n        return id;\n    };\n}();\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Encapsulates the data needed to raise an event\r\n */ class DataEvent {\n    /**\r\n     * @param eventType - One of: value, child_added, child_changed, child_moved, child_removed\r\n     * @param eventRegistration - The function to call to with the event data. User provided\r\n     * @param snapshot - The data backing the event\r\n     * @param prevName - Optional, the name of the previous child for child_* events.\r\n     */ constructor(eventType, eventRegistration, snapshot, prevName){\n        this.eventType = eventType;\n        this.eventRegistration = eventRegistration;\n        this.snapshot = snapshot;\n        this.prevName = prevName;\n    }\n    getPath() {\n        const ref = this.snapshot.ref;\n        if (this.eventType === \"value\") {\n            return ref._path;\n        } else {\n            return ref.parent._path;\n        }\n    }\n    getEventType() {\n        return this.eventType;\n    }\n    getEventRunner() {\n        return this.eventRegistration.getEventRunner(this);\n    }\n    toString() {\n        return this.getPath().toString() + \":\" + this.eventType + \":\" + (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.stringify)(this.snapshot.exportVal());\n    }\n}\nclass CancelEvent {\n    constructor(eventRegistration, error, path){\n        this.eventRegistration = eventRegistration;\n        this.error = error;\n        this.path = path;\n    }\n    getPath() {\n        return this.path;\n    }\n    getEventType() {\n        return \"cancel\";\n    }\n    getEventRunner() {\n        return this.eventRegistration.getEventRunner(this);\n    }\n    toString() {\n        return this.path.toString() + \":cancel\";\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * A wrapper class that converts events from the database@exp SDK to the legacy\r\n * Database SDK. Events are not converted directly as event registration relies\r\n * on reference comparison of the original user callback (see `matches()`) and\r\n * relies on equality of the legacy SDK's `context` object.\r\n */ class CallbackContext {\n    constructor(snapshotCallback, cancelCallback){\n        this.snapshotCallback = snapshotCallback;\n        this.cancelCallback = cancelCallback;\n    }\n    onValue(expDataSnapshot, previousChildName) {\n        this.snapshotCallback.call(null, expDataSnapshot, previousChildName);\n    }\n    onCancel(error) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(this.hasCancelCallback, \"Raising a cancel event on a listener with no cancel callback\");\n        return this.cancelCallback.call(null, error);\n    }\n    get hasCancelCallback() {\n        return !!this.cancelCallback;\n    }\n    matches(other) {\n        return this.snapshotCallback === other.snapshotCallback || this.snapshotCallback.userCallback !== undefined && this.snapshotCallback.userCallback === other.snapshotCallback.userCallback && this.snapshotCallback.context === other.snapshotCallback.context;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * The `onDisconnect` class allows you to write or clear data when your client\r\n * disconnects from the Database server. These updates occur whether your\r\n * client disconnects cleanly or not, so you can rely on them to clean up data\r\n * even if a connection is dropped or a client crashes.\r\n *\r\n * The `onDisconnect` class is most commonly used to manage presence in\r\n * applications where it is useful to detect how many clients are connected and\r\n * when other clients disconnect. See\r\n * {@link https://firebase.google.com/docs/database/web/offline-capabilities | Enabling Offline Capabilities in JavaScript}\r\n * for more information.\r\n *\r\n * To avoid problems when a connection is dropped before the requests can be\r\n * transferred to the Database server, these functions should be called before\r\n * writing any data.\r\n *\r\n * Note that `onDisconnect` operations are only triggered once. If you want an\r\n * operation to occur each time a disconnect occurs, you'll need to re-establish\r\n * the `onDisconnect` operations each time you reconnect.\r\n */ class OnDisconnect {\n    /** @hideconstructor */ constructor(_repo, _path){\n        this._repo = _repo;\n        this._path = _path;\n    }\n    /**\r\n     * Cancels all previously queued `onDisconnect()` set or update events for this\r\n     * location and all children.\r\n     *\r\n     * If a write has been queued for this location via a `set()` or `update()` at a\r\n     * parent location, the write at this location will be canceled, though writes\r\n     * to sibling locations will still occur.\r\n     *\r\n     * @returns Resolves when synchronization to the server is complete.\r\n     */ cancel() {\n        const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n        repoOnDisconnectCancel(this._repo, this._path, deferred.wrapCallback(()=>{}));\n        return deferred.promise;\n    }\n    /**\r\n     * Ensures the data at this location is deleted when the client is disconnected\r\n     * (due to closing the browser, navigating to a new page, or network issues).\r\n     *\r\n     * @returns Resolves when synchronization to the server is complete.\r\n     */ remove() {\n        validateWritablePath(\"OnDisconnect.remove\", this._path);\n        const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n        repoOnDisconnectSet(this._repo, this._path, null, deferred.wrapCallback(()=>{}));\n        return deferred.promise;\n    }\n    /**\r\n     * Ensures the data at this location is set to the specified value when the\r\n     * client is disconnected (due to closing the browser, navigating to a new page,\r\n     * or network issues).\r\n     *\r\n     * `set()` is especially useful for implementing \"presence\" systems, where a\r\n     * value should be changed or cleared when a user disconnects so that they\r\n     * appear \"offline\" to other users. See\r\n     * {@link https://firebase.google.com/docs/database/web/offline-capabilities | Enabling Offline Capabilities in JavaScript}\r\n     * for more information.\r\n     *\r\n     * Note that `onDisconnect` operations are only triggered once. If you want an\r\n     * operation to occur each time a disconnect occurs, you'll need to re-establish\r\n     * the `onDisconnect` operations each time.\r\n     *\r\n     * @param value - The value to be written to this location on disconnect (can\r\n     * be an object, array, string, number, boolean, or null).\r\n     * @returns Resolves when synchronization to the Database is complete.\r\n     */ set(value) {\n        validateWritablePath(\"OnDisconnect.set\", this._path);\n        validateFirebaseDataArg(\"OnDisconnect.set\", value, this._path, false);\n        const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n        repoOnDisconnectSet(this._repo, this._path, value, deferred.wrapCallback(()=>{}));\n        return deferred.promise;\n    }\n    /**\r\n     * Ensures the data at this location is set to the specified value and priority\r\n     * when the client is disconnected (due to closing the browser, navigating to a\r\n     * new page, or network issues).\r\n     *\r\n     * @param value - The value to be written to this location on disconnect (can\r\n     * be an object, array, string, number, boolean, or null).\r\n     * @param priority - The priority to be written (string, number, or null).\r\n     * @returns Resolves when synchronization to the Database is complete.\r\n     */ setWithPriority(value, priority) {\n        validateWritablePath(\"OnDisconnect.setWithPriority\", this._path);\n        validateFirebaseDataArg(\"OnDisconnect.setWithPriority\", value, this._path, false);\n        validatePriority(\"OnDisconnect.setWithPriority\", priority, false);\n        const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n        repoOnDisconnectSetWithPriority(this._repo, this._path, value, priority, deferred.wrapCallback(()=>{}));\n        return deferred.promise;\n    }\n    /**\r\n     * Writes multiple values at this location when the client is disconnected (due\r\n     * to closing the browser, navigating to a new page, or network issues).\r\n     *\r\n     * The `values` argument contains multiple property-value pairs that will be\r\n     * written to the Database together. Each child property can either be a simple\r\n     * property (for example, \"name\") or a relative path (for example, \"name/first\")\r\n     * from the current location to the data to update.\r\n     *\r\n     * As opposed to the `set()` method, `update()` can be use to selectively update\r\n     * only the referenced properties at the current location (instead of replacing\r\n     * all the child properties at the current location).\r\n     *\r\n     * @param values - Object containing multiple values.\r\n     * @returns Resolves when synchronization to the Database is complete.\r\n     */ update(values) {\n        validateWritablePath(\"OnDisconnect.update\", this._path);\n        validateFirebaseMergeDataArg(\"OnDisconnect.update\", values, this._path, false);\n        const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n        repoOnDisconnectUpdate(this._repo, this._path, values, deferred.wrapCallback(()=>{}));\n        return deferred.promise;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * @internal\r\n */ class QueryImpl {\n    /**\r\n     * @hideconstructor\r\n     */ constructor(_repo, _path, _queryParams, _orderByCalled){\n        this._repo = _repo;\n        this._path = _path;\n        this._queryParams = _queryParams;\n        this._orderByCalled = _orderByCalled;\n    }\n    get key() {\n        if (pathIsEmpty(this._path)) {\n            return null;\n        } else {\n            return pathGetBack(this._path);\n        }\n    }\n    get ref() {\n        return new ReferenceImpl(this._repo, this._path);\n    }\n    get _queryIdentifier() {\n        const obj = queryParamsGetQueryObject(this._queryParams);\n        const id = ObjectToUniqueKey(obj);\n        return id === \"{}\" ? \"default\" : id;\n    }\n    /**\r\n     * An object representation of the query parameters used by this Query.\r\n     */ get _queryObject() {\n        return queryParamsGetQueryObject(this._queryParams);\n    }\n    isEqual(other) {\n        other = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(other);\n        if (!(other instanceof QueryImpl)) {\n            return false;\n        }\n        const sameRepo = this._repo === other._repo;\n        const samePath = pathEquals(this._path, other._path);\n        const sameQueryIdentifier = this._queryIdentifier === other._queryIdentifier;\n        return sameRepo && samePath && sameQueryIdentifier;\n    }\n    toJSON() {\n        return this.toString();\n    }\n    toString() {\n        return this._repo.toString() + pathToUrlEncodedString(this._path);\n    }\n}\n/**\r\n * Validates that no other order by call has been made\r\n */ function validateNoPreviousOrderByCall(query, fnName) {\n    if (query._orderByCalled === true) {\n        throw new Error(fnName + \": You can't combine multiple orderBy calls.\");\n    }\n}\n/**\r\n * Validates start/end values for queries.\r\n */ function validateQueryEndpoints(params) {\n    let startNode = null;\n    let endNode = null;\n    if (params.hasStart()) {\n        startNode = params.getIndexStartValue();\n    }\n    if (params.hasEnd()) {\n        endNode = params.getIndexEndValue();\n    }\n    if (params.getIndex() === KEY_INDEX) {\n        const tooManyArgsError = \"Query: When ordering by key, you may only pass one argument to \" + \"startAt(), endAt(), or equalTo().\";\n        const wrongArgTypeError = \"Query: When ordering by key, the argument passed to startAt(), startAfter(), \" + \"endAt(), endBefore(), or equalTo() must be a string.\";\n        if (params.hasStart()) {\n            const startName = params.getIndexStartName();\n            if (startName !== MIN_NAME) {\n                throw new Error(tooManyArgsError);\n            } else if (typeof startNode !== \"string\") {\n                throw new Error(wrongArgTypeError);\n            }\n        }\n        if (params.hasEnd()) {\n            const endName = params.getIndexEndName();\n            if (endName !== MAX_NAME) {\n                throw new Error(tooManyArgsError);\n            } else if (typeof endNode !== \"string\") {\n                throw new Error(wrongArgTypeError);\n            }\n        }\n    } else if (params.getIndex() === PRIORITY_INDEX) {\n        if (startNode != null && !isValidPriority(startNode) || endNode != null && !isValidPriority(endNode)) {\n            throw new Error(\"Query: When ordering by priority, the first argument passed to startAt(), \" + \"startAfter() endAt(), endBefore(), or equalTo() must be a valid priority value \" + \"(null, a number, or a string).\");\n        }\n    } else {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(params.getIndex() instanceof PathIndex || params.getIndex() === VALUE_INDEX, \"unknown index type.\");\n        if (startNode != null && typeof startNode === \"object\" || endNode != null && typeof endNode === \"object\") {\n            throw new Error(\"Query: First argument passed to startAt(), startAfter(), endAt(), endBefore(), or \" + \"equalTo() cannot be an object.\");\n        }\n    }\n}\n/**\r\n * Validates that limit* has been called with the correct combination of parameters\r\n */ function validateLimit(params) {\n    if (params.hasStart() && params.hasEnd() && params.hasLimit() && !params.hasAnchoredLimit()) {\n        throw new Error(\"Query: Can't combine startAt(), startAfter(), endAt(), endBefore(), and limit(). Use \" + \"limitToFirst() or limitToLast() instead.\");\n    }\n}\n/**\r\n * @internal\r\n */ class ReferenceImpl extends QueryImpl {\n    /** @hideconstructor */ constructor(repo, path){\n        super(repo, path, new QueryParams(), false);\n    }\n    get parent() {\n        const parentPath = pathParent(this._path);\n        return parentPath === null ? null : new ReferenceImpl(this._repo, parentPath);\n    }\n    get root() {\n        let ref = this;\n        while(ref.parent !== null){\n            ref = ref.parent;\n        }\n        return ref;\n    }\n}\n/**\r\n * A `DataSnapshot` contains data from a Database location.\r\n *\r\n * Any time you read data from the Database, you receive the data as a\r\n * `DataSnapshot`. A `DataSnapshot` is passed to the event callbacks you attach\r\n * with `on()` or `once()`. You can extract the contents of the snapshot as a\r\n * JavaScript object by calling the `val()` method. Alternatively, you can\r\n * traverse into the snapshot by calling `child()` to return child snapshots\r\n * (which you could then call `val()` on).\r\n *\r\n * A `DataSnapshot` is an efficiently generated, immutable copy of the data at\r\n * a Database location. It cannot be modified and will never change (to modify\r\n * data, you always call the `set()` method on a `Reference` directly).\r\n */ class DataSnapshot {\n    /**\r\n     * @param _node - A SnapshotNode to wrap.\r\n     * @param ref - The location this snapshot came from.\r\n     * @param _index - The iteration order for this snapshot\r\n     * @hideconstructor\r\n     */ constructor(_node, /**\r\n     * The location of this DataSnapshot.\r\n     */ ref, _index){\n        this._node = _node;\n        this.ref = ref;\n        this._index = _index;\n    }\n    /**\r\n     * Gets the priority value of the data in this `DataSnapshot`.\r\n     *\r\n     * Applications need not use priority but can order collections by\r\n     * ordinary properties (see\r\n     * {@link https://firebase.google.com/docs/database/web/lists-of-data#sorting_and_filtering_data |Sorting and filtering data}\r\n     * ).\r\n     */ get priority() {\n        // typecast here because we never return deferred values or internal priorities (MAX_PRIORITY)\n        return this._node.getPriority().val();\n    }\n    /**\r\n     * The key (last part of the path) of the location of this `DataSnapshot`.\r\n     *\r\n     * The last token in a Database location is considered its key. For example,\r\n     * \"ada\" is the key for the /users/ada/ node. Accessing the key on any\r\n     * `DataSnapshot` will return the key for the location that generated it.\r\n     * However, accessing the key on the root URL of a Database will return\r\n     * `null`.\r\n     */ get key() {\n        return this.ref.key;\n    }\n    /** Returns the number of child properties of this `DataSnapshot`. */ get size() {\n        return this._node.numChildren();\n    }\n    /**\r\n     * Gets another `DataSnapshot` for the location at the specified relative path.\r\n     *\r\n     * Passing a relative path to the `child()` method of a DataSnapshot returns\r\n     * another `DataSnapshot` for the location at the specified relative path. The\r\n     * relative path can either be a simple child name (for example, \"ada\") or a\r\n     * deeper, slash-separated path (for example, \"ada/name/first\"). If the child\r\n     * location has no data, an empty `DataSnapshot` (that is, a `DataSnapshot`\r\n     * whose value is `null`) is returned.\r\n     *\r\n     * @param path - A relative path to the location of child data.\r\n     */ child(path) {\n        const childPath = new Path(path);\n        const childRef = child(this.ref, path);\n        return new DataSnapshot(this._node.getChild(childPath), childRef, PRIORITY_INDEX);\n    }\n    /**\r\n     * Returns true if this `DataSnapshot` contains any data. It is slightly more\r\n     * efficient than using `snapshot.val() !== null`.\r\n     */ exists() {\n        return !this._node.isEmpty();\n    }\n    /**\r\n     * Exports the entire contents of the DataSnapshot as a JavaScript object.\r\n     *\r\n     * The `exportVal()` method is similar to `val()`, except priority information\r\n     * is included (if available), making it suitable for backing up your data.\r\n     *\r\n     * @returns The DataSnapshot's contents as a JavaScript value (Object,\r\n     *   Array, string, number, boolean, or `null`).\r\n     */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    exportVal() {\n        return this._node.val(true);\n    }\n    /**\r\n     * Enumerates the top-level children in the `IteratedDataSnapshot`.\r\n     *\r\n     * Because of the way JavaScript objects work, the ordering of data in the\r\n     * JavaScript object returned by `val()` is not guaranteed to match the\r\n     * ordering on the server nor the ordering of `onChildAdded()` events. That is\r\n     * where `forEach()` comes in handy. It guarantees the children of a\r\n     * `DataSnapshot` will be iterated in their query order.\r\n     *\r\n     * If no explicit `orderBy*()` method is used, results are returned\r\n     * ordered by key (unless priorities are used, in which case, results are\r\n     * returned by priority).\r\n     *\r\n     * @param action - A function that will be called for each child DataSnapshot.\r\n     * The callback can return true to cancel further enumeration.\r\n     * @returns true if enumeration was canceled due to your callback returning\r\n     * true.\r\n     */ forEach(action) {\n        if (this._node.isLeafNode()) {\n            return false;\n        }\n        const childrenNode = this._node;\n        // Sanitize the return value to a boolean. ChildrenNode.forEachChild has a weird return type...\n        return !!childrenNode.forEachChild(this._index, (key, node)=>{\n            return action(new DataSnapshot(node, child(this.ref, key), PRIORITY_INDEX));\n        });\n    }\n    /**\r\n     * Returns true if the specified child path has (non-null) data.\r\n     *\r\n     * @param path - A relative path to the location of a potential child.\r\n     * @returns `true` if data exists at the specified child path; else\r\n     *  `false`.\r\n     */ hasChild(path) {\n        const childPath = new Path(path);\n        return !this._node.getChild(childPath).isEmpty();\n    }\n    /**\r\n     * Returns whether or not the `DataSnapshot` has any non-`null` child\r\n     * properties.\r\n     *\r\n     * You can use `hasChildren()` to determine if a `DataSnapshot` has any\r\n     * children. If it does, you can enumerate them using `forEach()`. If it\r\n     * doesn't, then either this snapshot contains a primitive value (which can be\r\n     * retrieved with `val()`) or it is empty (in which case, `val()` will return\r\n     * `null`).\r\n     *\r\n     * @returns true if this snapshot has any children; else false.\r\n     */ hasChildren() {\n        if (this._node.isLeafNode()) {\n            return false;\n        } else {\n            return !this._node.isEmpty();\n        }\n    }\n    /**\r\n     * Returns a JSON-serializable representation of this object.\r\n     */ toJSON() {\n        return this.exportVal();\n    }\n    /**\r\n     * Extracts a JavaScript value from a `DataSnapshot`.\r\n     *\r\n     * Depending on the data in a `DataSnapshot`, the `val()` method may return a\r\n     * scalar type (string, number, or boolean), an array, or an object. It may\r\n     * also return null, indicating that the `DataSnapshot` is empty (contains no\r\n     * data).\r\n     *\r\n     * @returns The DataSnapshot's contents as a JavaScript value (Object,\r\n     *   Array, string, number, boolean, or `null`).\r\n     */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    val() {\n        return this._node.val();\n    }\n}\n/**\r\n *\r\n * Returns a `Reference` representing the location in the Database\r\n * corresponding to the provided path. If no path is provided, the `Reference`\r\n * will point to the root of the Database.\r\n *\r\n * @param db - The database instance to obtain a reference for.\r\n * @param path - Optional path representing the location the returned\r\n *   `Reference` will point. If not provided, the returned `Reference` will\r\n *   point to the root of the Database.\r\n * @returns If a path is provided, a `Reference`\r\n *   pointing to the provided path. Otherwise, a `Reference` pointing to the\r\n *   root of the Database.\r\n */ function ref(db, path) {\n    db = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(db);\n    db._checkNotDeleted(\"ref\");\n    return path !== undefined ? child(db._root, path) : db._root;\n}\n/**\r\n * Returns a `Reference` representing the location in the Database\r\n * corresponding to the provided Firebase URL.\r\n *\r\n * An exception is thrown if the URL is not a valid Firebase Database URL or it\r\n * has a different domain than the current `Database` instance.\r\n *\r\n * Note that all query parameters (`orderBy`, `limitToLast`, etc.) are ignored\r\n * and are not applied to the returned `Reference`.\r\n *\r\n * @param db - The database instance to obtain a reference for.\r\n * @param url - The Firebase URL at which the returned `Reference` will\r\n *   point.\r\n * @returns A `Reference` pointing to the provided\r\n *   Firebase URL.\r\n */ function refFromURL(db, url) {\n    db = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(db);\n    db._checkNotDeleted(\"refFromURL\");\n    const parsedURL = parseRepoInfo(url, db._repo.repoInfo_.nodeAdmin);\n    validateUrl(\"refFromURL\", parsedURL);\n    const repoInfo = parsedURL.repoInfo;\n    if (!db._repo.repoInfo_.isCustomHost() && repoInfo.host !== db._repo.repoInfo_.host) {\n        fatal(\"refFromURL\" + \": Host name does not match the current database: \" + \"(found \" + repoInfo.host + \" but expected \" + db._repo.repoInfo_.host + \")\");\n    }\n    return ref(db, parsedURL.path.toString());\n}\n/**\r\n * Gets a `Reference` for the location at the specified relative path.\r\n *\r\n * The relative path can either be a simple child name (for example, \"ada\") or\r\n * a deeper slash-separated path (for example, \"ada/name/first\").\r\n *\r\n * @param parent - The parent location.\r\n * @param path - A relative path from this location to the desired child\r\n *   location.\r\n * @returns The specified child location.\r\n */ function child(parent, path) {\n    parent = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(parent);\n    if (pathGetFront(parent._path) === null) {\n        validateRootPathString(\"child\", \"path\", path, false);\n    } else {\n        validatePathString(\"child\", \"path\", path, false);\n    }\n    return new ReferenceImpl(parent._repo, pathChild(parent._path, path));\n}\n/**\r\n * Returns an `OnDisconnect` object - see\r\n * {@link https://firebase.google.com/docs/database/web/offline-capabilities | Enabling Offline Capabilities in JavaScript}\r\n * for more information on how to use it.\r\n *\r\n * @param ref - The reference to add OnDisconnect triggers for.\r\n */ function onDisconnect(ref) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return new OnDisconnect(ref._repo, ref._path);\n}\n/**\r\n * Generates a new child location using a unique key and returns its\r\n * `Reference`.\r\n *\r\n * This is the most common pattern for adding data to a collection of items.\r\n *\r\n * If you provide a value to `push()`, the value is written to the\r\n * generated location. If you don't pass a value, nothing is written to the\r\n * database and the child remains empty (but you can use the `Reference`\r\n * elsewhere).\r\n *\r\n * The unique keys generated by `push()` are ordered by the current time, so the\r\n * resulting list of items is chronologically sorted. The keys are also\r\n * designed to be unguessable (they contain 72 random bits of entropy).\r\n *\r\n * See {@link https://firebase.google.com/docs/database/web/lists-of-data#append_to_a_list_of_data | Append to a list of data}.\r\n * See {@link https://firebase.googleblog.com/2015/02/the-2120-ways-to-ensure-unique_68.html | The 2^120 Ways to Ensure Unique Identifiers}.\r\n *\r\n * @param parent - The parent location.\r\n * @param value - Optional value to be written at the generated location.\r\n * @returns Combined `Promise` and `Reference`; resolves when write is complete,\r\n * but can be used immediately as the `Reference` to the child location.\r\n */ function push(parent, value) {\n    parent = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(parent);\n    validateWritablePath(\"push\", parent._path);\n    validateFirebaseDataArg(\"push\", value, parent._path, true);\n    const now = repoServerTime(parent._repo);\n    const name = nextPushId(now);\n    // push() returns a ThennableReference whose promise is fulfilled with a\n    // regular Reference. We use child() to create handles to two different\n    // references. The first is turned into a ThennableReference below by adding\n    // then() and catch() methods and is used as the return value of push(). The\n    // second remains a regular Reference and is used as the fulfilled value of\n    // the first ThennableReference.\n    const thennablePushRef = child(parent, name);\n    const pushRef = child(parent, name);\n    let promise;\n    if (value != null) {\n        promise = set(pushRef, value).then(()=>pushRef);\n    } else {\n        promise = Promise.resolve(pushRef);\n    }\n    thennablePushRef.then = promise.then.bind(promise);\n    thennablePushRef.catch = promise.then.bind(promise, undefined);\n    return thennablePushRef;\n}\n/**\r\n * Removes the data at this Database location.\r\n *\r\n * Any data at child locations will also be deleted.\r\n *\r\n * The effect of the remove will be visible immediately and the corresponding\r\n * event 'value' will be triggered. Synchronization of the remove to the\r\n * Firebase servers will also be started, and the returned Promise will resolve\r\n * when complete. If provided, the onComplete callback will be called\r\n * asynchronously after synchronization has finished.\r\n *\r\n * @param ref - The location to remove.\r\n * @returns Resolves when remove on server is complete.\r\n */ function remove(ref) {\n    validateWritablePath(\"remove\", ref._path);\n    return set(ref, null);\n}\n/**\r\n * Writes data to this Database location.\r\n *\r\n * This will overwrite any data at this location and all child locations.\r\n *\r\n * The effect of the write will be visible immediately, and the corresponding\r\n * events (\"value\", \"child_added\", etc.) will be triggered. Synchronization of\r\n * the data to the Firebase servers will also be started, and the returned\r\n * Promise will resolve when complete. If provided, the `onComplete` callback\r\n * will be called asynchronously after synchronization has finished.\r\n *\r\n * Passing `null` for the new value is equivalent to calling `remove()`; namely,\r\n * all data at this location and all child locations will be deleted.\r\n *\r\n * `set()` will remove any priority stored at this location, so if priority is\r\n * meant to be preserved, you need to use `setWithPriority()` instead.\r\n *\r\n * Note that modifying data with `set()` will cancel any pending transactions\r\n * at that location, so extreme care should be taken if mixing `set()` and\r\n * `transaction()` to modify the same data.\r\n *\r\n * A single `set()` will generate a single \"value\" event at the location where\r\n * the `set()` was performed.\r\n *\r\n * @param ref - The location to write to.\r\n * @param value - The value to be written (string, number, boolean, object,\r\n *   array, or null).\r\n * @returns Resolves when write to server is complete.\r\n */ function set(ref, value) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    validateWritablePath(\"set\", ref._path);\n    validateFirebaseDataArg(\"set\", value, ref._path, false);\n    const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n    repoSetWithPriority(ref._repo, ref._path, value, /*priority=*/ null, deferred.wrapCallback(()=>{}));\n    return deferred.promise;\n}\n/**\r\n * Sets a priority for the data at this Database location.\r\n *\r\n * Applications need not use priority but can order collections by\r\n * ordinary properties (see\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#sorting_and_filtering_data | Sorting and filtering data}\r\n * ).\r\n *\r\n * @param ref - The location to write to.\r\n * @param priority - The priority to be written (string, number, or null).\r\n * @returns Resolves when write to server is complete.\r\n */ function setPriority(ref, priority) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    validateWritablePath(\"setPriority\", ref._path);\n    validatePriority(\"setPriority\", priority, false);\n    const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n    repoSetWithPriority(ref._repo, pathChild(ref._path, \".priority\"), priority, null, deferred.wrapCallback(()=>{}));\n    return deferred.promise;\n}\n/**\r\n * Writes data the Database location. Like `set()` but also specifies the\r\n * priority for that data.\r\n *\r\n * Applications need not use priority but can order collections by\r\n * ordinary properties (see\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#sorting_and_filtering_data | Sorting and filtering data}\r\n * ).\r\n *\r\n * @param ref - The location to write to.\r\n * @param value - The value to be written (string, number, boolean, object,\r\n *   array, or null).\r\n * @param priority - The priority to be written (string, number, or null).\r\n * @returns Resolves when write to server is complete.\r\n */ function setWithPriority(ref, value, priority) {\n    validateWritablePath(\"setWithPriority\", ref._path);\n    validateFirebaseDataArg(\"setWithPriority\", value, ref._path, false);\n    validatePriority(\"setWithPriority\", priority, false);\n    if (ref.key === \".length\" || ref.key === \".keys\") {\n        throw \"setWithPriority failed: \" + ref.key + \" is a read-only object.\";\n    }\n    const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n    repoSetWithPriority(ref._repo, ref._path, value, priority, deferred.wrapCallback(()=>{}));\n    return deferred.promise;\n}\n/**\r\n * Writes multiple values to the Database at once.\r\n *\r\n * The `values` argument contains multiple property-value pairs that will be\r\n * written to the Database together. Each child property can either be a simple\r\n * property (for example, \"name\") or a relative path (for example,\r\n * \"name/first\") from the current location to the data to update.\r\n *\r\n * As opposed to the `set()` method, `update()` can be use to selectively update\r\n * only the referenced properties at the current location (instead of replacing\r\n * all the child properties at the current location).\r\n *\r\n * The effect of the write will be visible immediately, and the corresponding\r\n * events ('value', 'child_added', etc.) will be triggered. Synchronization of\r\n * the data to the Firebase servers will also be started, and the returned\r\n * Promise will resolve when complete. If provided, the `onComplete` callback\r\n * will be called asynchronously after synchronization has finished.\r\n *\r\n * A single `update()` will generate a single \"value\" event at the location\r\n * where the `update()` was performed, regardless of how many children were\r\n * modified.\r\n *\r\n * Note that modifying data with `update()` will cancel any pending\r\n * transactions at that location, so extreme care should be taken if mixing\r\n * `update()` and `transaction()` to modify the same data.\r\n *\r\n * Passing `null` to `update()` will remove the data at this location.\r\n *\r\n * See\r\n * {@link https://firebase.googleblog.com/2015/09/introducing-multi-location-updates-and_86.html | Introducing multi-location updates and more}.\r\n *\r\n * @param ref - The location to write to.\r\n * @param values - Object containing multiple values.\r\n * @returns Resolves when update on server is complete.\r\n */ function update(ref, values) {\n    validateFirebaseMergeDataArg(\"update\", values, ref._path, false);\n    const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n    repoUpdate(ref._repo, ref._path, values, deferred.wrapCallback(()=>{}));\n    return deferred.promise;\n}\n/**\r\n * Gets the most up-to-date result for this query.\r\n *\r\n * @param query - The query to run.\r\n * @returns A `Promise` which resolves to the resulting DataSnapshot if a value is\r\n * available, or rejects if the client is unable to return a value (e.g., if the\r\n * server is unreachable and there is nothing cached).\r\n */ function get(query) {\n    query = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(query);\n    const callbackContext = new CallbackContext(()=>{});\n    const container = new ValueEventRegistration(callbackContext);\n    return repoGetValue(query._repo, query, container).then((node)=>{\n        return new DataSnapshot(node, new ReferenceImpl(query._repo, query._path), query._queryParams.getIndex());\n    });\n}\n/**\r\n * Represents registration for 'value' events.\r\n */ class ValueEventRegistration {\n    constructor(callbackContext){\n        this.callbackContext = callbackContext;\n    }\n    respondsTo(eventType) {\n        return eventType === \"value\";\n    }\n    createEvent(change, query) {\n        const index = query._queryParams.getIndex();\n        return new DataEvent(\"value\", this, new DataSnapshot(change.snapshotNode, new ReferenceImpl(query._repo, query._path), index));\n    }\n    getEventRunner(eventData) {\n        if (eventData.getEventType() === \"cancel\") {\n            return ()=>this.callbackContext.onCancel(eventData.error);\n        } else {\n            return ()=>this.callbackContext.onValue(eventData.snapshot, null);\n        }\n    }\n    createCancelEvent(error, path) {\n        if (this.callbackContext.hasCancelCallback) {\n            return new CancelEvent(this, error, path);\n        } else {\n            return null;\n        }\n    }\n    matches(other) {\n        if (!(other instanceof ValueEventRegistration)) {\n            return false;\n        } else if (!other.callbackContext || !this.callbackContext) {\n            // If no callback specified, we consider it to match any callback.\n            return true;\n        } else {\n            return other.callbackContext.matches(this.callbackContext);\n        }\n    }\n    hasAnyCallback() {\n        return this.callbackContext !== null;\n    }\n}\n/**\r\n * Represents the registration of a child_x event.\r\n */ class ChildEventRegistration {\n    constructor(eventType, callbackContext){\n        this.eventType = eventType;\n        this.callbackContext = callbackContext;\n    }\n    respondsTo(eventType) {\n        let eventToCheck = eventType === \"children_added\" ? \"child_added\" : eventType;\n        eventToCheck = eventToCheck === \"children_removed\" ? \"child_removed\" : eventToCheck;\n        return this.eventType === eventToCheck;\n    }\n    createCancelEvent(error, path) {\n        if (this.callbackContext.hasCancelCallback) {\n            return new CancelEvent(this, error, path);\n        } else {\n            return null;\n        }\n    }\n    createEvent(change, query) {\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.assert)(change.childName != null, \"Child events should have a childName.\");\n        const childRef = child(new ReferenceImpl(query._repo, query._path), change.childName);\n        const index = query._queryParams.getIndex();\n        return new DataEvent(change.type, this, new DataSnapshot(change.snapshotNode, childRef, index), change.prevName);\n    }\n    getEventRunner(eventData) {\n        if (eventData.getEventType() === \"cancel\") {\n            return ()=>this.callbackContext.onCancel(eventData.error);\n        } else {\n            return ()=>this.callbackContext.onValue(eventData.snapshot, eventData.prevName);\n        }\n    }\n    matches(other) {\n        if (other instanceof ChildEventRegistration) {\n            return this.eventType === other.eventType && (!this.callbackContext || !other.callbackContext || this.callbackContext.matches(other.callbackContext));\n        }\n        return false;\n    }\n    hasAnyCallback() {\n        return !!this.callbackContext;\n    }\n}\nfunction addEventListener(query, eventType, callback, cancelCallbackOrListenOptions, options) {\n    let cancelCallback;\n    if (typeof cancelCallbackOrListenOptions === \"object\") {\n        cancelCallback = undefined;\n        options = cancelCallbackOrListenOptions;\n    }\n    if (typeof cancelCallbackOrListenOptions === \"function\") {\n        cancelCallback = cancelCallbackOrListenOptions;\n    }\n    if (options && options.onlyOnce) {\n        const userCallback = callback;\n        const onceCallback = (dataSnapshot, previousChildName)=>{\n            repoRemoveEventCallbackForQuery(query._repo, query, container);\n            userCallback(dataSnapshot, previousChildName);\n        };\n        onceCallback.userCallback = callback.userCallback;\n        onceCallback.context = callback.context;\n        callback = onceCallback;\n    }\n    const callbackContext = new CallbackContext(callback, cancelCallback || undefined);\n    const container = eventType === \"value\" ? new ValueEventRegistration(callbackContext) : new ChildEventRegistration(eventType, callbackContext);\n    repoAddEventCallbackForQuery(query._repo, query, container);\n    return ()=>repoRemoveEventCallbackForQuery(query._repo, query, container);\n}\nfunction onValue(query, callback, cancelCallbackOrListenOptions, options) {\n    return addEventListener(query, \"value\", callback, cancelCallbackOrListenOptions, options);\n}\nfunction onChildAdded(query, callback, cancelCallbackOrListenOptions, options) {\n    return addEventListener(query, \"child_added\", callback, cancelCallbackOrListenOptions, options);\n}\nfunction onChildChanged(query, callback, cancelCallbackOrListenOptions, options) {\n    return addEventListener(query, \"child_changed\", callback, cancelCallbackOrListenOptions, options);\n}\nfunction onChildMoved(query, callback, cancelCallbackOrListenOptions, options) {\n    return addEventListener(query, \"child_moved\", callback, cancelCallbackOrListenOptions, options);\n}\nfunction onChildRemoved(query, callback, cancelCallbackOrListenOptions, options) {\n    return addEventListener(query, \"child_removed\", callback, cancelCallbackOrListenOptions, options);\n}\n/**\r\n * Detaches a callback previously attached with the corresponding `on*()` (`onValue`, `onChildAdded`) listener.\r\n * Note: This is not the recommended way to remove a listener. Instead, please use the returned callback function from\r\n * the respective `on*` callbacks.\r\n *\r\n * Detach a callback previously attached with `on*()`. Calling `off()` on a parent listener\r\n * will not automatically remove listeners registered on child nodes, `off()`\r\n * must also be called on any child listeners to remove the callback.\r\n *\r\n * If a callback is not specified, all callbacks for the specified eventType\r\n * will be removed. Similarly, if no eventType is specified, all callbacks\r\n * for the `Reference` will be removed.\r\n *\r\n * Individual listeners can also be removed by invoking their unsubscribe\r\n * callbacks.\r\n *\r\n * @param query - The query that the listener was registered with.\r\n * @param eventType - One of the following strings: \"value\", \"child_added\",\r\n * \"child_changed\", \"child_removed\", or \"child_moved.\" If omitted, all callbacks\r\n * for the `Reference` will be removed.\r\n * @param callback - The callback function that was passed to `on()` or\r\n * `undefined` to remove all callbacks.\r\n */ function off(query, eventType, callback) {\n    let container = null;\n    const expCallback = callback ? new CallbackContext(callback) : null;\n    if (eventType === \"value\") {\n        container = new ValueEventRegistration(expCallback);\n    } else if (eventType) {\n        container = new ChildEventRegistration(eventType, expCallback);\n    }\n    repoRemoveEventCallbackForQuery(query._repo, query, container);\n}\n/**\r\n * A `QueryConstraint` is used to narrow the set of documents returned by a\r\n * Database query. `QueryConstraint`s are created by invoking {@link endAt},\r\n * {@link endBefore}, {@link startAt}, {@link startAfter}, {@link\r\n * limitToFirst}, {@link limitToLast}, {@link orderByChild},\r\n * {@link orderByChild}, {@link orderByKey} , {@link orderByPriority} ,\r\n * {@link orderByValue}  or {@link equalTo} and\r\n * can then be passed to {@link query} to create a new query instance that\r\n * also contains this `QueryConstraint`.\r\n */ class QueryConstraint {\n}\nclass QueryEndAtConstraint extends QueryConstraint {\n    constructor(_value, _key){\n        super();\n        this._value = _value;\n        this._key = _key;\n        this.type = \"endAt\";\n    }\n    _apply(query) {\n        validateFirebaseDataArg(\"endAt\", this._value, query._path, true);\n        const newParams = queryParamsEndAt(query._queryParams, this._value, this._key);\n        validateLimit(newParams);\n        validateQueryEndpoints(newParams);\n        if (query._queryParams.hasEnd()) {\n            throw new Error(\"endAt: Starting point was already set (by another call to endAt, \" + \"endBefore or equalTo).\");\n        }\n        return new QueryImpl(query._repo, query._path, newParams, query._orderByCalled);\n    }\n}\n/**\r\n * Creates a `QueryConstraint` with the specified ending point.\r\n *\r\n * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`\r\n * allows you to choose arbitrary starting and ending points for your queries.\r\n *\r\n * The ending point is inclusive, so children with exactly the specified value\r\n * will be included in the query. The optional key argument can be used to\r\n * further limit the range of the query. If it is specified, then children that\r\n * have exactly the specified value must also have a key name less than or equal\r\n * to the specified key.\r\n *\r\n * You can read more about `endAt()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.\r\n *\r\n * @param value - The value to end at. The argument type depends on which\r\n * `orderBy*()` function was used in this query. Specify a value that matches\r\n * the `orderBy*()` type. When used in combination with `orderByKey()`, the\r\n * value must be a string.\r\n * @param key - The child key to end at, among the children with the previously\r\n * specified priority. This argument is only allowed if ordering by child,\r\n * value, or priority.\r\n */ function endAt(value, key) {\n    validateKey(\"endAt\", \"key\", key, true);\n    return new QueryEndAtConstraint(value, key);\n}\nclass QueryEndBeforeConstraint extends QueryConstraint {\n    constructor(_value, _key){\n        super();\n        this._value = _value;\n        this._key = _key;\n        this.type = \"endBefore\";\n    }\n    _apply(query) {\n        validateFirebaseDataArg(\"endBefore\", this._value, query._path, false);\n        const newParams = queryParamsEndBefore(query._queryParams, this._value, this._key);\n        validateLimit(newParams);\n        validateQueryEndpoints(newParams);\n        if (query._queryParams.hasEnd()) {\n            throw new Error(\"endBefore: Starting point was already set (by another call to endAt, \" + \"endBefore or equalTo).\");\n        }\n        return new QueryImpl(query._repo, query._path, newParams, query._orderByCalled);\n    }\n}\n/**\r\n * Creates a `QueryConstraint` with the specified ending point (exclusive).\r\n *\r\n * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`\r\n * allows you to choose arbitrary starting and ending points for your queries.\r\n *\r\n * The ending point is exclusive. If only a value is provided, children\r\n * with a value less than the specified value will be included in the query.\r\n * If a key is specified, then children must have a value less than or equal\r\n * to the specified value and a key name less than the specified key.\r\n *\r\n * @param value - The value to end before. The argument type depends on which\r\n * `orderBy*()` function was used in this query. Specify a value that matches\r\n * the `orderBy*()` type. When used in combination with `orderByKey()`, the\r\n * value must be a string.\r\n * @param key - The child key to end before, among the children with the\r\n * previously specified priority. This argument is only allowed if ordering by\r\n * child, value, or priority.\r\n */ function endBefore(value, key) {\n    validateKey(\"endBefore\", \"key\", key, true);\n    return new QueryEndBeforeConstraint(value, key);\n}\nclass QueryStartAtConstraint extends QueryConstraint {\n    constructor(_value, _key){\n        super();\n        this._value = _value;\n        this._key = _key;\n        this.type = \"startAt\";\n    }\n    _apply(query) {\n        validateFirebaseDataArg(\"startAt\", this._value, query._path, true);\n        const newParams = queryParamsStartAt(query._queryParams, this._value, this._key);\n        validateLimit(newParams);\n        validateQueryEndpoints(newParams);\n        if (query._queryParams.hasStart()) {\n            throw new Error(\"startAt: Starting point was already set (by another call to startAt, \" + \"startBefore or equalTo).\");\n        }\n        return new QueryImpl(query._repo, query._path, newParams, query._orderByCalled);\n    }\n}\n/**\r\n * Creates a `QueryConstraint` with the specified starting point.\r\n *\r\n * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`\r\n * allows you to choose arbitrary starting and ending points for your queries.\r\n *\r\n * The starting point is inclusive, so children with exactly the specified value\r\n * will be included in the query. The optional key argument can be used to\r\n * further limit the range of the query. If it is specified, then children that\r\n * have exactly the specified value must also have a key name greater than or\r\n * equal to the specified key.\r\n *\r\n * You can read more about `startAt()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.\r\n *\r\n * @param value - The value to start at. The argument type depends on which\r\n * `orderBy*()` function was used in this query. Specify a value that matches\r\n * the `orderBy*()` type. When used in combination with `orderByKey()`, the\r\n * value must be a string.\r\n * @param key - The child key to start at. This argument is only allowed if\r\n * ordering by child, value, or priority.\r\n */ function startAt(value = null, key) {\n    validateKey(\"startAt\", \"key\", key, true);\n    return new QueryStartAtConstraint(value, key);\n}\nclass QueryStartAfterConstraint extends QueryConstraint {\n    constructor(_value, _key){\n        super();\n        this._value = _value;\n        this._key = _key;\n        this.type = \"startAfter\";\n    }\n    _apply(query) {\n        validateFirebaseDataArg(\"startAfter\", this._value, query._path, false);\n        const newParams = queryParamsStartAfter(query._queryParams, this._value, this._key);\n        validateLimit(newParams);\n        validateQueryEndpoints(newParams);\n        if (query._queryParams.hasStart()) {\n            throw new Error(\"startAfter: Starting point was already set (by another call to startAt, \" + \"startAfter, or equalTo).\");\n        }\n        return new QueryImpl(query._repo, query._path, newParams, query._orderByCalled);\n    }\n}\n/**\r\n * Creates a `QueryConstraint` with the specified starting point (exclusive).\r\n *\r\n * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`\r\n * allows you to choose arbitrary starting and ending points for your queries.\r\n *\r\n * The starting point is exclusive. If only a value is provided, children\r\n * with a value greater than the specified value will be included in the query.\r\n * If a key is specified, then children must have a value greater than or equal\r\n * to the specified value and a a key name greater than the specified key.\r\n *\r\n * @param value - The value to start after. The argument type depends on which\r\n * `orderBy*()` function was used in this query. Specify a value that matches\r\n * the `orderBy*()` type. When used in combination with `orderByKey()`, the\r\n * value must be a string.\r\n * @param key - The child key to start after. This argument is only allowed if\r\n * ordering by child, value, or priority.\r\n */ function startAfter(value, key) {\n    validateKey(\"startAfter\", \"key\", key, true);\n    return new QueryStartAfterConstraint(value, key);\n}\nclass QueryLimitToFirstConstraint extends QueryConstraint {\n    constructor(_limit){\n        super();\n        this._limit = _limit;\n        this.type = \"limitToFirst\";\n    }\n    _apply(query) {\n        if (query._queryParams.hasLimit()) {\n            throw new Error(\"limitToFirst: Limit was already set (by another call to limitToFirst \" + \"or limitToLast).\");\n        }\n        return new QueryImpl(query._repo, query._path, queryParamsLimitToFirst(query._queryParams, this._limit), query._orderByCalled);\n    }\n}\n/**\r\n * Creates a new `QueryConstraint` that if limited to the first specific number\r\n * of children.\r\n *\r\n * The `limitToFirst()` method is used to set a maximum number of children to be\r\n * synced for a given callback. If we set a limit of 100, we will initially only\r\n * receive up to 100 `child_added` events. If we have fewer than 100 messages\r\n * stored in our Database, a `child_added` event will fire for each message.\r\n * However, if we have over 100 messages, we will only receive a `child_added`\r\n * event for the first 100 ordered messages. As items change, we will receive\r\n * `child_removed` events for each item that drops out of the active list so\r\n * that the total number stays at 100.\r\n *\r\n * You can read more about `limitToFirst()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.\r\n *\r\n * @param limit - The maximum number of nodes to include in this query.\r\n */ function limitToFirst(limit) {\n    if (typeof limit !== \"number\" || Math.floor(limit) !== limit || limit <= 0) {\n        throw new Error(\"limitToFirst: First argument must be a positive integer.\");\n    }\n    return new QueryLimitToFirstConstraint(limit);\n}\nclass QueryLimitToLastConstraint extends QueryConstraint {\n    constructor(_limit){\n        super();\n        this._limit = _limit;\n        this.type = \"limitToLast\";\n    }\n    _apply(query) {\n        if (query._queryParams.hasLimit()) {\n            throw new Error(\"limitToLast: Limit was already set (by another call to limitToFirst \" + \"or limitToLast).\");\n        }\n        return new QueryImpl(query._repo, query._path, queryParamsLimitToLast(query._queryParams, this._limit), query._orderByCalled);\n    }\n}\n/**\r\n * Creates a new `QueryConstraint` that is limited to return only the last\r\n * specified number of children.\r\n *\r\n * The `limitToLast()` method is used to set a maximum number of children to be\r\n * synced for a given callback. If we set a limit of 100, we will initially only\r\n * receive up to 100 `child_added` events. If we have fewer than 100 messages\r\n * stored in our Database, a `child_added` event will fire for each message.\r\n * However, if we have over 100 messages, we will only receive a `child_added`\r\n * event for the last 100 ordered messages. As items change, we will receive\r\n * `child_removed` events for each item that drops out of the active list so\r\n * that the total number stays at 100.\r\n *\r\n * You can read more about `limitToLast()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.\r\n *\r\n * @param limit - The maximum number of nodes to include in this query.\r\n */ function limitToLast(limit) {\n    if (typeof limit !== \"number\" || Math.floor(limit) !== limit || limit <= 0) {\n        throw new Error(\"limitToLast: First argument must be a positive integer.\");\n    }\n    return new QueryLimitToLastConstraint(limit);\n}\nclass QueryOrderByChildConstraint extends QueryConstraint {\n    constructor(_path){\n        super();\n        this._path = _path;\n        this.type = \"orderByChild\";\n    }\n    _apply(query) {\n        validateNoPreviousOrderByCall(query, \"orderByChild\");\n        const parsedPath = new Path(this._path);\n        if (pathIsEmpty(parsedPath)) {\n            throw new Error(\"orderByChild: cannot pass in empty path. Use orderByValue() instead.\");\n        }\n        const index = new PathIndex(parsedPath);\n        const newParams = queryParamsOrderBy(query._queryParams, index);\n        validateQueryEndpoints(newParams);\n        return new QueryImpl(query._repo, query._path, newParams, /*orderByCalled=*/ true);\n    }\n}\n/**\r\n * Creates a new `QueryConstraint` that orders by the specified child key.\r\n *\r\n * Queries can only order by one key at a time. Calling `orderByChild()`\r\n * multiple times on the same query is an error.\r\n *\r\n * Firebase queries allow you to order your data by any child key on the fly.\r\n * However, if you know in advance what your indexes will be, you can define\r\n * them via the .indexOn rule in your Security Rules for better performance. See\r\n * the{@link https://firebase.google.com/docs/database/security/indexing-data}\r\n * rule for more information.\r\n *\r\n * You can read more about `orderByChild()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}.\r\n *\r\n * @param path - The path to order by.\r\n */ function orderByChild(path) {\n    if (path === \"$key\") {\n        throw new Error('orderByChild: \"$key\" is invalid.  Use orderByKey() instead.');\n    } else if (path === \"$priority\") {\n        throw new Error('orderByChild: \"$priority\" is invalid.  Use orderByPriority() instead.');\n    } else if (path === \"$value\") {\n        throw new Error('orderByChild: \"$value\" is invalid.  Use orderByValue() instead.');\n    }\n    validatePathString(\"orderByChild\", \"path\", path, false);\n    return new QueryOrderByChildConstraint(path);\n}\nclass QueryOrderByKeyConstraint extends QueryConstraint {\n    constructor(){\n        super(...arguments);\n        this.type = \"orderByKey\";\n    }\n    _apply(query) {\n        validateNoPreviousOrderByCall(query, \"orderByKey\");\n        const newParams = queryParamsOrderBy(query._queryParams, KEY_INDEX);\n        validateQueryEndpoints(newParams);\n        return new QueryImpl(query._repo, query._path, newParams, /*orderByCalled=*/ true);\n    }\n}\n/**\r\n * Creates a new `QueryConstraint` that orders by the key.\r\n *\r\n * Sorts the results of a query by their (ascending) key values.\r\n *\r\n * You can read more about `orderByKey()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}.\r\n */ function orderByKey() {\n    return new QueryOrderByKeyConstraint();\n}\nclass QueryOrderByPriorityConstraint extends QueryConstraint {\n    constructor(){\n        super(...arguments);\n        this.type = \"orderByPriority\";\n    }\n    _apply(query) {\n        validateNoPreviousOrderByCall(query, \"orderByPriority\");\n        const newParams = queryParamsOrderBy(query._queryParams, PRIORITY_INDEX);\n        validateQueryEndpoints(newParams);\n        return new QueryImpl(query._repo, query._path, newParams, /*orderByCalled=*/ true);\n    }\n}\n/**\r\n * Creates a new `QueryConstraint` that orders by priority.\r\n *\r\n * Applications need not use priority but can order collections by\r\n * ordinary properties (see\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}\r\n * for alternatives to priority.\r\n */ function orderByPriority() {\n    return new QueryOrderByPriorityConstraint();\n}\nclass QueryOrderByValueConstraint extends QueryConstraint {\n    constructor(){\n        super(...arguments);\n        this.type = \"orderByValue\";\n    }\n    _apply(query) {\n        validateNoPreviousOrderByCall(query, \"orderByValue\");\n        const newParams = queryParamsOrderBy(query._queryParams, VALUE_INDEX);\n        validateQueryEndpoints(newParams);\n        return new QueryImpl(query._repo, query._path, newParams, /*orderByCalled=*/ true);\n    }\n}\n/**\r\n * Creates a new `QueryConstraint` that orders by value.\r\n *\r\n * If the children of a query are all scalar values (string, number, or\r\n * boolean), you can order the results by their (ascending) values.\r\n *\r\n * You can read more about `orderByValue()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}.\r\n */ function orderByValue() {\n    return new QueryOrderByValueConstraint();\n}\nclass QueryEqualToValueConstraint extends QueryConstraint {\n    constructor(_value, _key){\n        super();\n        this._value = _value;\n        this._key = _key;\n        this.type = \"equalTo\";\n    }\n    _apply(query) {\n        validateFirebaseDataArg(\"equalTo\", this._value, query._path, false);\n        if (query._queryParams.hasStart()) {\n            throw new Error(\"equalTo: Starting point was already set (by another call to startAt/startAfter or \" + \"equalTo).\");\n        }\n        if (query._queryParams.hasEnd()) {\n            throw new Error(\"equalTo: Ending point was already set (by another call to endAt/endBefore or \" + \"equalTo).\");\n        }\n        return new QueryEndAtConstraint(this._value, this._key)._apply(new QueryStartAtConstraint(this._value, this._key)._apply(query));\n    }\n}\n/**\r\n * Creates a `QueryConstraint` that includes children that match the specified\r\n * value.\r\n *\r\n * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`\r\n * allows you to choose arbitrary starting and ending points for your queries.\r\n *\r\n * The optional key argument can be used to further limit the range of the\r\n * query. If it is specified, then children that have exactly the specified\r\n * value must also have exactly the specified key as their key name. This can be\r\n * used to filter result sets with many matches for the same value.\r\n *\r\n * You can read more about `equalTo()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.\r\n *\r\n * @param value - The value to match for. The argument type depends on which\r\n * `orderBy*()` function was used in this query. Specify a value that matches\r\n * the `orderBy*()` type. When used in combination with `orderByKey()`, the\r\n * value must be a string.\r\n * @param key - The child key to start at, among the children with the\r\n * previously specified priority. This argument is only allowed if ordering by\r\n * child, value, or priority.\r\n */ function equalTo(value, key) {\n    validateKey(\"equalTo\", \"key\", key, true);\n    return new QueryEqualToValueConstraint(value, key);\n}\n/**\r\n * Creates a new immutable instance of `Query` that is extended to also include\r\n * additional query constraints.\r\n *\r\n * @param query - The Query instance to use as a base for the new constraints.\r\n * @param queryConstraints - The list of `QueryConstraint`s to apply.\r\n * @throws if any of the provided query constraints cannot be combined with the\r\n * existing or new constraints.\r\n */ function query(query1, ...queryConstraints) {\n    let queryImpl = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(query1);\n    for (const constraint of queryConstraints){\n        queryImpl = constraint._apply(queryImpl);\n    }\n    return queryImpl;\n}\n/**\r\n * Define reference constructor in various modules\r\n *\r\n * We are doing this here to avoid several circular\r\n * dependency issues\r\n */ syncPointSetReferenceConstructor(ReferenceImpl);\nsyncTreeSetReferenceConstructor(ReferenceImpl);\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * This variable is also defined in the firebase Node.js Admin SDK. Before\r\n * modifying this definition, consult the definition in:\r\n *\r\n * https://github.com/firebase/firebase-admin-node\r\n *\r\n * and make sure the two are consistent.\r\n */ const FIREBASE_DATABASE_EMULATOR_HOST_VAR = \"FIREBASE_DATABASE_EMULATOR_HOST\";\n/**\r\n * Creates and caches `Repo` instances.\r\n */ const repos = {};\n/**\r\n * If true, any new `Repo` will be created to use `ReadonlyRestClient` (for testing purposes).\r\n */ let useRestClient = false;\n/**\r\n * Update an existing `Repo` in place to point to a new host/port.\r\n */ function repoManagerApplyEmulatorSettings(repo, host, port, tokenProvider) {\n    repo.repoInfo_ = new RepoInfo(`${host}:${port}`, /* secure= */ false, repo.repoInfo_.namespace, repo.repoInfo_.webSocketOnly, repo.repoInfo_.nodeAdmin, repo.repoInfo_.persistenceKey, repo.repoInfo_.includeNamespaceInQueryParams, /*isUsingEmulator=*/ true);\n    if (tokenProvider) {\n        repo.authTokenProvider_ = tokenProvider;\n    }\n}\n/**\r\n * This function should only ever be called to CREATE a new database instance.\r\n * @internal\r\n */ function repoManagerDatabaseFromApp(app, authProvider, appCheckProvider, url, nodeAdmin) {\n    let dbUrl = url || app.options.databaseURL;\n    if (dbUrl === undefined) {\n        if (!app.options.projectId) {\n            fatal(\"Can't determine Firebase Database URL. Be sure to include \" + \" a Project ID when calling firebase.initializeApp().\");\n        }\n        log(\"Using default host for project \", app.options.projectId);\n        dbUrl = `${app.options.projectId}-default-rtdb.firebaseio.com`;\n    }\n    let parsedUrl = parseRepoInfo(dbUrl, nodeAdmin);\n    let repoInfo = parsedUrl.repoInfo;\n    let isEmulator;\n    let dbEmulatorHost = undefined;\n    if (typeof process !== \"undefined\" && process.env) {\n        dbEmulatorHost = process.env[FIREBASE_DATABASE_EMULATOR_HOST_VAR];\n    }\n    if (dbEmulatorHost) {\n        isEmulator = true;\n        dbUrl = `http://${dbEmulatorHost}?ns=${repoInfo.namespace}`;\n        parsedUrl = parseRepoInfo(dbUrl, nodeAdmin);\n        repoInfo = parsedUrl.repoInfo;\n    } else {\n        isEmulator = !parsedUrl.repoInfo.secure;\n    }\n    const authTokenProvider = nodeAdmin && isEmulator ? new EmulatorTokenProvider(EmulatorTokenProvider.OWNER) : new FirebaseAuthTokenProvider(app.name, app.options, authProvider);\n    validateUrl(\"Invalid Firebase Database URL\", parsedUrl);\n    if (!pathIsEmpty(parsedUrl.path)) {\n        fatal(\"Database URL must point to the root of a Firebase Database \" + \"(not including a child path).\");\n    }\n    const repo = repoManagerCreateRepo(repoInfo, app, authTokenProvider, new AppCheckTokenProvider(app.name, appCheckProvider));\n    return new Database(repo, app);\n}\n/**\r\n * Remove the repo and make sure it is disconnected.\r\n *\r\n */ function repoManagerDeleteRepo(repo, appName) {\n    const appRepos = repos[appName];\n    // This should never happen...\n    if (!appRepos || appRepos[repo.key] !== repo) {\n        fatal(`Database ${appName}(${repo.repoInfo_}) has already been deleted.`);\n    }\n    repoInterrupt(repo);\n    delete appRepos[repo.key];\n}\n/**\r\n * Ensures a repo doesn't already exist and then creates one using the\r\n * provided app.\r\n *\r\n * @param repoInfo - The metadata about the Repo\r\n * @returns The Repo object for the specified server / repoName.\r\n */ function repoManagerCreateRepo(repoInfo, app, authTokenProvider, appCheckProvider) {\n    let appRepos = repos[app.name];\n    if (!appRepos) {\n        appRepos = {};\n        repos[app.name] = appRepos;\n    }\n    let repo = appRepos[repoInfo.toURLString()];\n    if (repo) {\n        fatal(\"Database initialized multiple times. Please make sure the format of the database URL matches with each database() call.\");\n    }\n    repo = new Repo(repoInfo, useRestClient, authTokenProvider, appCheckProvider);\n    appRepos[repoInfo.toURLString()] = repo;\n    return repo;\n}\n/**\r\n * Forces us to use ReadonlyRestClient instead of PersistentConnection for new Repos.\r\n */ function repoManagerForceRestClient(forceRestClient) {\n    useRestClient = forceRestClient;\n}\n/**\r\n * Class representing a Firebase Realtime Database.\r\n */ class Database {\n    /** @hideconstructor */ constructor(_repoInternal, /** The {@link @firebase/app#FirebaseApp} associated with this Realtime Database instance. */ app){\n        this._repoInternal = _repoInternal;\n        this.app = app;\n        /** Represents a `Database` instance. */ this[\"type\"] = \"database\";\n        /** Track if the instance has been used (root or repo accessed) */ this._instanceStarted = false;\n    }\n    get _repo() {\n        if (!this._instanceStarted) {\n            repoStart(this._repoInternal, this.app.options.appId, this.app.options[\"databaseAuthVariableOverride\"]);\n            this._instanceStarted = true;\n        }\n        return this._repoInternal;\n    }\n    get _root() {\n        if (!this._rootInternal) {\n            this._rootInternal = new ReferenceImpl(this._repo, newEmptyPath());\n        }\n        return this._rootInternal;\n    }\n    _delete() {\n        if (this._rootInternal !== null) {\n            repoManagerDeleteRepo(this._repo, this.app.name);\n            this._repoInternal = null;\n            this._rootInternal = null;\n        }\n        return Promise.resolve();\n    }\n    _checkNotDeleted(apiName) {\n        if (this._rootInternal === null) {\n            fatal(\"Cannot call \" + apiName + \" on a deleted database.\");\n        }\n    }\n}\nfunction checkTransportInit() {\n    if (TransportManager.IS_TRANSPORT_INITIALIZED) {\n        warn(\"Transport has already been initialized. Please call this function before calling ref or setting up a listener\");\n    }\n}\n/**\r\n * Force the use of websockets instead of longPolling.\r\n */ function forceWebSockets() {\n    checkTransportInit();\n    BrowserPollConnection.forceDisallow();\n}\n/**\r\n * Force the use of longPolling instead of websockets. This will be ignored if websocket protocol is used in databaseURL.\r\n */ function forceLongPolling() {\n    checkTransportInit();\n    WebSocketConnection.forceDisallow();\n    BrowserPollConnection.forceAllow();\n}\n/**\r\n * Returns the instance of the Realtime Database SDK that is associated\r\n * with the provided {@link @firebase/app#FirebaseApp}. Initializes a new instance with\r\n * with default settings if no instance exists or if the existing instance uses\r\n * a custom database URL.\r\n *\r\n * @param app - The {@link @firebase/app#FirebaseApp} instance that the returned Realtime\r\n * Database instance is associated with.\r\n * @param url - The URL of the Realtime Database instance to connect to. If not\r\n * provided, the SDK connects to the default instance of the Firebase App.\r\n * @returns The `Database` instance of the provided app.\r\n */ function getDatabase(app = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_3__.getApp)(), url) {\n    const db = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_3__._getProvider)(app, \"database\").getImmediate({\n        identifier: url\n    });\n    if (!db._instanceStarted) {\n        const emulator = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getDefaultEmulatorHostnameAndPort)(\"database\");\n        if (emulator) {\n            connectDatabaseEmulator(db, ...emulator);\n        }\n    }\n    return db;\n}\n/**\r\n * Modify the provided instance to communicate with the Realtime Database\r\n * emulator.\r\n *\r\n * <p>Note: This method must be called before performing any other operation.\r\n *\r\n * @param db - The instance to modify.\r\n * @param host - The emulator host (ex: localhost)\r\n * @param port - The emulator port (ex: 8080)\r\n * @param options.mockUserToken - the mock auth token to use for unit testing Security Rules\r\n */ function connectDatabaseEmulator(db, host, port, options = {}) {\n    db = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(db);\n    db._checkNotDeleted(\"useEmulator\");\n    if (db._instanceStarted) {\n        fatal(\"Cannot call useEmulator() after instance has already been initialized.\");\n    }\n    const repo = db._repoInternal;\n    let tokenProvider = undefined;\n    if (repo.repoInfo_.nodeAdmin) {\n        if (options.mockUserToken) {\n            fatal('mockUserToken is not supported by the Admin SDK. For client access with mock users, please use the \"firebase\" package instead of \"firebase-admin\".');\n        }\n        tokenProvider = new EmulatorTokenProvider(EmulatorTokenProvider.OWNER);\n    } else if (options.mockUserToken) {\n        const token = typeof options.mockUserToken === \"string\" ? options.mockUserToken : (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.createMockUserToken)(options.mockUserToken, db.app.options.projectId);\n        tokenProvider = new EmulatorTokenProvider(token);\n    }\n    // Modify the repo to apply emulator settings\n    repoManagerApplyEmulatorSettings(repo, host, port, tokenProvider);\n}\n/**\r\n * Disconnects from the server (all Database operations will be completed\r\n * offline).\r\n *\r\n * The client automatically maintains a persistent connection to the Database\r\n * server, which will remain active indefinitely and reconnect when\r\n * disconnected. However, the `goOffline()` and `goOnline()` methods may be used\r\n * to control the client connection in cases where a persistent connection is\r\n * undesirable.\r\n *\r\n * While offline, the client will no longer receive data updates from the\r\n * Database. However, all Database operations performed locally will continue to\r\n * immediately fire events, allowing your application to continue behaving\r\n * normally. Additionally, each operation performed locally will automatically\r\n * be queued and retried upon reconnection to the Database server.\r\n *\r\n * To reconnect to the Database and begin receiving remote events, see\r\n * `goOnline()`.\r\n *\r\n * @param db - The instance to disconnect.\r\n */ function goOffline(db) {\n    db = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(db);\n    db._checkNotDeleted(\"goOffline\");\n    repoInterrupt(db._repo);\n}\n/**\r\n * Reconnects to the server and synchronizes the offline Database state\r\n * with the server state.\r\n *\r\n * This method should be used after disabling the active connection with\r\n * `goOffline()`. Once reconnected, the client will transmit the proper data\r\n * and fire the appropriate events so that your client \"catches up\"\r\n * automatically.\r\n *\r\n * @param db - The instance to reconnect.\r\n */ function goOnline(db) {\n    db = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(db);\n    db._checkNotDeleted(\"goOnline\");\n    repoResume(db._repo);\n}\nfunction enableLogging(logger, persistent) {\n    enableLogging$1(logger, persistent);\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function registerDatabase(variant) {\n    setSDKVersion(_firebase_app__WEBPACK_IMPORTED_MODULE_3__.SDK_VERSION);\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_3__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_4__.Component(\"database\", (container, { instanceIdentifier: url })=>{\n        const app = container.getProvider(\"app\").getImmediate();\n        const authProvider = container.getProvider(\"auth-internal\");\n        const appCheckProvider = container.getProvider(\"app-check-internal\");\n        return repoManagerDatabaseFromApp(app, authProvider, appCheckProvider, url);\n    }, \"PUBLIC\" /* ComponentType.PUBLIC */ ).setMultipleInstances(true));\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_3__.registerVersion)(name, version, variant);\n    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_3__.registerVersion)(name, version, \"esm2017\");\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const SERVER_TIMESTAMP = {\n    \".sv\": \"timestamp\"\n};\n/**\r\n * Returns a placeholder value for auto-populating the current timestamp (time\r\n * since the Unix epoch, in milliseconds) as determined by the Firebase\r\n * servers.\r\n */ function serverTimestamp() {\n    return SERVER_TIMESTAMP;\n}\n/**\r\n * Returns a placeholder value that can be used to atomically increment the\r\n * current database value by the provided delta.\r\n *\r\n * @param delta - the amount to modify the current value atomically.\r\n * @returns A placeholder value for modifying data atomically server-side.\r\n */ function increment(delta) {\n    return {\n        \".sv\": {\n            \"increment\": delta\n        }\n    };\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * A type for the resolve value of {@link runTransaction}.\r\n */ class TransactionResult {\n    /** @hideconstructor */ constructor(/** Whether the transaction was successfully committed. */ committed, /** The resulting data snapshot. */ snapshot){\n        this.committed = committed;\n        this.snapshot = snapshot;\n    }\n    /** Returns a JSON-serializable representation of this object. */ toJSON() {\n        return {\n            committed: this.committed,\n            snapshot: this.snapshot.toJSON()\n        };\n    }\n}\n/**\r\n * Atomically modifies the data at this location.\r\n *\r\n * Atomically modify the data at this location. Unlike a normal `set()`, which\r\n * just overwrites the data regardless of its previous value, `runTransaction()` is\r\n * used to modify the existing value to a new value, ensuring there are no\r\n * conflicts with other clients writing to the same location at the same time.\r\n *\r\n * To accomplish this, you pass `runTransaction()` an update function which is\r\n * used to transform the current value into a new value. If another client\r\n * writes to the location before your new value is successfully written, your\r\n * update function will be called again with the new current value, and the\r\n * write will be retried. This will happen repeatedly until your write succeeds\r\n * without conflict or you abort the transaction by not returning a value from\r\n * your update function.\r\n *\r\n * Note: Modifying data with `set()` will cancel any pending transactions at\r\n * that location, so extreme care should be taken if mixing `set()` and\r\n * `runTransaction()` to update the same data.\r\n *\r\n * Note: When using transactions with Security and Firebase Rules in place, be\r\n * aware that a client needs `.read` access in addition to `.write` access in\r\n * order to perform a transaction. This is because the client-side nature of\r\n * transactions requires the client to read the data in order to transactionally\r\n * update it.\r\n *\r\n * @param ref - The location to atomically modify.\r\n * @param transactionUpdate - A developer-supplied function which will be passed\r\n * the current data stored at this location (as a JavaScript object). The\r\n * function should return the new value it would like written (as a JavaScript\r\n * object). If `undefined` is returned (i.e. you return with no arguments) the\r\n * transaction will be aborted and the data at this location will not be\r\n * modified.\r\n * @param options - An options object to configure transactions.\r\n * @returns A `Promise` that can optionally be used instead of the `onComplete`\r\n * callback to handle success and failure.\r\n */ function runTransaction(ref, // eslint-disable-next-line @typescript-eslint/no-explicit-any\ntransactionUpdate, options) {\n    var _a;\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    validateWritablePath(\"Reference.transaction\", ref._path);\n    if (ref.key === \".length\" || ref.key === \".keys\") {\n        throw \"Reference.transaction failed: \" + ref.key + \" is a read-only object.\";\n    }\n    const applyLocally = (_a = options === null || options === void 0 ? void 0 : options.applyLocally) !== null && _a !== void 0 ? _a : true;\n    const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n    const promiseComplete = (error, committed, node)=>{\n        let dataSnapshot = null;\n        if (error) {\n            deferred.reject(error);\n        } else {\n            dataSnapshot = new DataSnapshot(node, new ReferenceImpl(ref._repo, ref._path), PRIORITY_INDEX);\n            deferred.resolve(new TransactionResult(committed, dataSnapshot));\n        }\n    };\n    // Add a watch to make sure we get server updates.\n    const unwatcher = onValue(ref, ()=>{});\n    repoStartTransaction(ref._repo, ref._path, transactionUpdate, promiseComplete, unwatcher, applyLocally);\n    return deferred.promise;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ PersistentConnection;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nPersistentConnection.prototype.simpleListen = function(pathString, onComplete) {\n    this.sendRequest(\"q\", {\n        p: pathString\n    }, onComplete);\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nPersistentConnection.prototype.echo = function(data, onEcho) {\n    this.sendRequest(\"echo\", {\n        d: data\n    }, onEcho);\n};\n// RealTimeConnection properties that we use in tests.\nConnection;\n/**\r\n * @internal\r\n */ const hijackHash = function(newHash) {\n    const oldPut = PersistentConnection.prototype.put;\n    PersistentConnection.prototype.put = function(pathString, data, onComplete, hash) {\n        if (hash !== undefined) {\n            hash = newHash();\n        }\n        oldPut.call(this, pathString, data, onComplete, hash);\n    };\n    return function() {\n        PersistentConnection.prototype.put = oldPut;\n    };\n};\nRepoInfo;\n/**\r\n * Forces the RepoManager to create Repos that use ReadonlyRestClient instead of PersistentConnection.\r\n * @internal\r\n */ const forceRestClient = function(forceRestClient) {\n    repoManagerForceRestClient(forceRestClient);\n};\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Used by console to create a database based on the app,\r\n * passed database URL and a custom auth implementation.\r\n * @internal\r\n * @param app - A valid FirebaseApp-like object\r\n * @param url - A valid Firebase databaseURL\r\n * @param version - custom version e.g. firebase-admin version\r\n * @param customAppCheckImpl - custom app check implementation\r\n * @param customAuthImpl - custom auth implementation\r\n */ function _initStandalone({ app, url, version, customAuthImpl, customAppCheckImpl, nodeAdmin = false }) {\n    setSDKVersion(version);\n    /**\r\n     * ComponentContainer('database-standalone') is just a placeholder that doesn't perform\r\n     * any actual function.\r\n     */ const componentContainer = new _firebase_component__WEBPACK_IMPORTED_MODULE_4__.ComponentContainer(\"database-standalone\");\n    const authProvider = new _firebase_component__WEBPACK_IMPORTED_MODULE_4__.Provider(\"auth-internal\", componentContainer);\n    let appCheckProvider;\n    if (customAppCheckImpl) {\n        appCheckProvider = new _firebase_component__WEBPACK_IMPORTED_MODULE_4__.Provider(\"app-check-internal\", componentContainer);\n        appCheckProvider.setComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_4__.Component(\"app-check-internal\", ()=>customAppCheckImpl, \"PRIVATE\" /* ComponentType.PRIVATE */ ));\n    }\n    authProvider.setComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_4__.Component(\"auth-internal\", ()=>customAuthImpl, \"PRIVATE\" /* ComponentType.PRIVATE */ ));\n    return repoManagerDatabaseFromApp(app, authProvider, appCheckProvider, url, nodeAdmin);\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ setWebSocketImpl(faye_websocket__WEBPACK_IMPORTED_MODULE_0__.Client);\nregisterDatabase(\"node\");\n //# sourceMappingURL=index.node.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3Qvbm9kZS1lc20vaW5kZXgubm9kZS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUM7QUFDaVU7QUFDcFQ7QUFDb0U7QUFDMUM7QUFFOUU7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0QsTUFBTXFDLG1CQUFtQjtBQUN6QixNQUFNQyxnQkFBZ0I7QUFDdEIsTUFBTUMsMEJBQTBCO0FBQ2hDLE1BQU1DLGdCQUFnQjtBQUN0QixNQUFNQyxZQUFZO0FBQ2xCLDhFQUE4RTtBQUM5RSwyQkFBMkI7QUFDM0IsTUFBTUMsa0JBQWtCO0FBQ3hCLE1BQU1DLHFCQUFxQjtBQUMzQixNQUFNQyx1QkFBdUI7QUFDN0IsTUFBTUMsd0JBQXdCO0FBQzlCLE1BQU1DLFlBQVk7QUFDbEIsTUFBTUMsZUFBZTtBQUVyQjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRDs7Ozs7Ozs7Q0FRQyxHQUNELE1BQU1DO0lBQ0Y7O0tBRUMsR0FDREMsWUFBWUMsV0FBVyxDQUFFO1FBQ3JCLElBQUksQ0FBQ0EsV0FBVyxHQUFHQTtRQUNuQixzRUFBc0U7UUFDdEUsSUFBSSxDQUFDQyxPQUFPLEdBQUc7SUFDbkI7SUFDQTs7O0tBR0MsR0FDREMsSUFBSUMsR0FBRyxFQUFFQyxLQUFLLEVBQUU7UUFDWixJQUFJQSxTQUFTLE1BQU07WUFDZixJQUFJLENBQUNKLFdBQVcsQ0FBQ0ssVUFBVSxDQUFDLElBQUksQ0FBQ0MsYUFBYSxDQUFDSDtRQUNuRCxPQUNLO1lBQ0QsSUFBSSxDQUFDSCxXQUFXLENBQUNPLE9BQU8sQ0FBQyxJQUFJLENBQUNELGFBQWEsQ0FBQ0gsTUFBTXBELHlEQUFTQSxDQUFDcUQ7UUFDaEU7SUFDSjtJQUNBOztLQUVDLEdBQ0RJLElBQUlMLEdBQUcsRUFBRTtRQUNMLE1BQU1NLFlBQVksSUFBSSxDQUFDVCxX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a0JBQWtCLFNBQVVBLGVBQWU7SUFDN0NELDJCQUEyQkM7QUFDL0I7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRDs7Ozs7Ozs7O0NBU0MsR0FDRCxTQUFTb0MsZ0JBQWdCLEVBQUVsRCxHQUFHLEVBQUV6MkMsR0FBRyxFQUFFak4sT0FBTyxFQUFFNm1ELGNBQWMsRUFBRUMsa0JBQWtCLEVBQUUzb0QsWUFBWSxLQUFLLEVBQUU7SUFDakc0QixjQUFjQztJQUNkOzs7S0FHQyxHQUNELE1BQU0rbUQscUJBQXFCLElBQUl4ekQsbUVBQWtCQSxDQUFDO0lBQ2xELE1BQU1vd0QsZUFBZSxJQUFJbndELHlEQUFRQSxDQUFDLGlCQUFpQnV6RDtJQUNuRCxJQUFJL2hEO0lBQ0osSUFBSThoRCxvQkFBb0I7UUFDcEI5aEQsbUJBQW1CLElBQUl4Uix5REFBUUEsQ0FBQyxzQkFBc0J1ekQ7UUFDdEQvaEQsaUJBQWlCZ2lELFlBQVksQ0FBQyxJQUFJMXpELDBEQUFTQSxDQUFDLHNCQUFzQixJQUFNd3pELG9CQUFvQixVQUFVLHlCQUF5QjtJQUNuSTtJQUNBbkQsYUFBYXFELFlBQVksQ0FBQyxJQUFJMXpELDBEQUFTQSxDQUFDLGlCQUFpQixJQUFNdXpELGdCQUFnQixVQUFVLHlCQUF5QjtJQUNsSCxPQUFPcEQsMkJBQTJCQyxLQUFLQyxjQUFjMytDLGtCQUFrQmlJLEtBQUs5TztBQUNoRjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEbUMsaUJBQWlCbFAsa0RBQWdCO0FBQ2pDcTBELGlCQUFpQjtBQUUyNEIsQ0FDNTVCLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dvcmxkd2ViLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L25vZGUtZXNtL2luZGV4Lm5vZGUuZXNtLmpzPzE3ODciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFdlYnNvY2tldCBmcm9tICdmYXllLXdlYnNvY2tldCc7XG5pbXBvcnQgeyBzdHJpbmdpZnksIGpzb25FdmFsLCBjb250YWlucywgYXNzZXJ0LCBpc05vZGVTZGssIHN0cmluZ1RvQnl0ZUFycmF5LCBTaGExLCBiYXNlNjQsIGRlZXBDb3B5LCBiYXNlNjRFbmNvZGUsIGlzTW9iaWxlQ29yZG92YSwgc3RyaW5nTGVuZ3RoLCBEZWZlcnJlZCwgc2FmZUdldCwgaXNBZG1pbiwgaXNWYWxpZEZvcm1hdCwgaXNFbXB0eSwgaXNSZWFjdE5hdGl2ZSwgYXNzZXJ0aW9uRXJyb3IsIG1hcCwgcXVlcnlzdHJpbmcsIGVycm9yUHJlZml4LCBnZXRNb2R1bGFySW5zdGFuY2UsIGdldERlZmF1bHRFbXVsYXRvckhvc3RuYW1lQW5kUG9ydCwgY3JlYXRlTW9ja1VzZXJUb2tlbiB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IExvZ2dlciwgTG9nTGV2ZWwgfSBmcm9tICdAZmlyZWJhc2UvbG9nZ2VyJztcbmltcG9ydCB7IF9nZXRQcm92aWRlciwgZ2V0QXBwLCBTREtfVkVSU0lPTiBhcyBTREtfVkVSU0lPTiQxLCBfcmVnaXN0ZXJDb21wb25lbnQsIHJlZ2lzdGVyVmVyc2lvbiB9IGZyb20gJ0BmaXJlYmFzZS9hcHAnO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBDb21wb25lbnRDb250YWluZXIsIFByb3ZpZGVyIH0gZnJvbSAnQGZpcmViYXNlL2NvbXBvbmVudCc7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IFBST1RPQ09MX1ZFUlNJT04gPSAnNSc7XHJcbmNvbnN0IFZFUlNJT05fUEFSQU0gPSAndic7XHJcbmNvbnN0IFRSQU5TUE9SVF9TRVNTSU9OX1BBUkFNID0gJ3MnO1xyXG5jb25zdCBSRUZFUkVSX1BBUkFNID0gJ3InO1xyXG5jb25zdCBGT1JHRV9SRUYgPSAnZic7XHJcbi8vIE1hdGNoZXMgY29uc29sZS5maXJlYmFzZS5nb29nbGUuY29tLCBmaXJlYmFzZS1jb25zb2xlLSouY29ycC5nb29nbGUuY29tIGFuZFxyXG4vLyBmaXJlYmFzZS5jb3JwLmdvb2dsZS5jb21cclxuY29uc3QgRk9SR0VfRE9NQUlOX1JFID0gLyhjb25zb2xlXFwuZmlyZWJhc2V8ZmlyZWJhc2UtY29uc29sZS1cXHcrXFwuY29ycHxmaXJlYmFzZVxcLmNvcnApXFwuZ29vZ2xlXFwuY29tLztcclxuY29uc3QgTEFTVF9TRVNTSU9OX1BBUkFNID0gJ2xzJztcclxuY29uc3QgQVBQTElDQVRJT05fSURfUEFSQU0gPSAncCc7XHJcbmNvbnN0IEFQUF9DSEVDS19UT0tFTl9QQVJBTSA9ICdhYyc7XHJcbmNvbnN0IFdFQlNPQ0tFVCA9ICd3ZWJzb2NrZXQnO1xyXG5jb25zdCBMT05HX1BPTExJTkcgPSAnbG9uZ19wb2xsaW5nJztcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFdyYXBzIGEgRE9NIFN0b3JhZ2Ugb2JqZWN0IGFuZDpcclxuICogLSBhdXRvbWF0aWNhbGx5IGVuY29kZSBvYmplY3RzIGFzIEpTT04gc3RyaW5ncyBiZWZvcmUgc3RvcmluZyB0aGVtIHRvIGFsbG93IHVzIHRvIHN0b3JlIGFyYml0cmFyeSB0eXBlcy5cclxuICogLSBwcmVmaXhlcyBuYW1lcyB3aXRoIFwiZmlyZWJhc2U6XCIgdG8gYXZvaWQgY29sbGlzaW9ucyB3aXRoIGFwcCBkYXRhLlxyXG4gKlxyXG4gKiBXZSBhdXRvbWF0aWNhbGx5IChzZWUgc3RvcmFnZS5qcykgY3JlYXRlIHR3byBzdWNoIHdyYXBwZXJzLCBvbmUgZm9yIHNlc3Npb25TdG9yYWdlLFxyXG4gKiBhbmQgb25lIGZvciBsb2NhbFN0b3JhZ2UuXHJcbiAqXHJcbiAqL1xyXG5jbGFzcyBET01TdG9yYWdlV3JhcHBlciB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBkb21TdG9yYWdlXyAtIFRoZSB1bmRlcmx5aW5nIHN0b3JhZ2Ugb2JqZWN0IChlLmcuIGxvY2FsU3RvcmFnZSBvciBzZXNzaW9uU3RvcmFnZSlcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZG9tU3RvcmFnZV8pIHtcclxuICAgICAgICB0aGlzLmRvbVN0b3JhZ2VfID0gZG9tU3RvcmFnZV87XHJcbiAgICAgICAgLy8gVXNlIGEgcHJlZml4IHRvIGF2b2lkIGNvbGxpc2lvbnMgd2l0aCBvdGhlciBzdHVmZiBzYXZlZCBieSB0aGUgYXBwLlxyXG4gICAgICAgIHRoaXMucHJlZml4XyA9ICdmaXJlYmFzZTonO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSB0byBzYXZlIHRoZSB2YWx1ZSB1bmRlclxyXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIGJlaW5nIHN0b3JlZCwgb3IgbnVsbCB0byByZW1vdmUgdGhlIGtleS5cclxuICAgICAqL1xyXG4gICAgc2V0KGtleSwgdmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmRvbVN0b3JhZ2VfLnJlbW92ZUl0ZW0odGhpcy5wcmVmaXhlZE5hbWVfKGtleSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kb21TdG9yYWdlXy5zZXRJdGVtKHRoaXMucHJlZml4ZWROYW1lXyhrZXkpLCBzdHJpbmdpZnkodmFsdWUpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRoZSB2YWx1ZSB0aGF0IHdhcyBzdG9yZWQgdW5kZXIgdGhpcyBrZXksIG9yIG51bGxcclxuICAgICAqL1xyXG4gICAgZ2V0KGtleSkge1xyXG4gICAgICAgIGNvbnN0IHN0b3JlZFZhbCA9IHRoaXMuZG9tU3RvcmFnZV8uZ2V0SXRlbSh0aGlzLnByZWZpeGVkTmFtZV8oa2V5KSk7XHJcbiAgICAgICAgaWYgKHN0b3JlZFZhbCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGpzb25FdmFsKHN0b3JlZFZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVtb3ZlKGtleSkge1xyXG4gICAgICAgIHRoaXMuZG9tU3RvcmFnZV8ucmVtb3ZlSXRlbSh0aGlzLnByZWZpeGVkTmFtZV8oa2V5KSk7XHJcbiAgICB9XHJcbiAgICBwcmVmaXhlZE5hbWVfKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wcmVmaXhfICsgbmFtZTtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRvbVN0b3JhZ2VfLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEFuIGluLW1lbW9yeSBzdG9yYWdlIGltcGxlbWVudGF0aW9uIHRoYXQgbWF0Y2hlcyB0aGUgQVBJIG9mIERPTVN0b3JhZ2VXcmFwcGVyXHJcbiAqIChUT0RPOiBjcmVhdGUgaW50ZXJmYWNlIGZvciBib3RoIHRvIGltcGxlbWVudCkuXHJcbiAqL1xyXG5jbGFzcyBNZW1vcnlTdG9yYWdlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuY2FjaGVfID0ge307XHJcbiAgICAgICAgdGhpcy5pc0luTWVtb3J5U3RvcmFnZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNhY2hlX1trZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5jYWNoZV9ba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldChrZXkpIHtcclxuICAgICAgICBpZiAoY29udGFpbnModGhpcy5jYWNoZV8sIGtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVfW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlKGtleSkge1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLmNhY2hlX1trZXldO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBIZWxwZXIgdG8gY3JlYXRlIGEgRE9NU3RvcmFnZVdyYXBwZXIgb3IgZWxzZSBmYWxsIGJhY2sgdG8gTWVtb3J5U3RvcmFnZS5cclxuICogVE9ETzogT25jZSBNZW1vcnlTdG9yYWdlIGFuZCBET01TdG9yYWdlV3JhcHBlciBoYXZlIGEgc2hhcmVkIGludGVyZmFjZSB0aGlzIG1ldGhvZCBhbm5vdGF0aW9uIHNob3VsZCBjaGFuZ2VcclxuICogdG8gcmVmbGVjdCB0aGlzIHR5cGVcclxuICpcclxuICogQHBhcmFtIGRvbVN0b3JhZ2VOYW1lIC0gTmFtZSBvZiB0aGUgdW5kZXJseWluZyBzdG9yYWdlIG9iamVjdFxyXG4gKiAgIChlLmcuICdsb2NhbFN0b3JhZ2UnIG9yICdzZXNzaW9uU3RvcmFnZScpLlxyXG4gKiBAcmV0dXJucyBUdXJuaW5nIG9mZiB0eXBlIGluZm9ybWF0aW9uIHVudGlsIGEgY29tbW9uIGludGVyZmFjZSBpcyBkZWZpbmVkLlxyXG4gKi9cclxuY29uc3QgY3JlYXRlU3RvcmFnZWZvciA9IGZ1bmN0aW9uIChkb21TdG9yYWdlTmFtZSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICAvLyBOT1RFOiBqdXN0IGFjY2Vzc2luZyBcImxvY2FsU3RvcmFnZVwiIG9yIFwid2luZG93Wydsb2NhbFN0b3JhZ2UnXVwiIG1heSB0aHJvdyBhIHNlY3VyaXR5IGV4Y2VwdGlvbixcclxuICAgICAgICAvLyBzbyBpdCBtdXN0IGJlIGluc2lkZSB0aGUgdHJ5L2NhdGNoLlxyXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgICAgICB0eXBlb2Ygd2luZG93W2RvbVN0b3JhZ2VOYW1lXSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgLy8gTmVlZCB0byB0ZXN0IGNhY2hlLiBKdXN0IGJlY2F1c2UgaXQncyBoZXJlIGRvZXNuJ3QgbWVhbiBpdCB3b3Jrc1xyXG4gICAgICAgICAgICBjb25zdCBkb21TdG9yYWdlID0gd2luZG93W2RvbVN0b3JhZ2VOYW1lXTtcclxuICAgICAgICAgICAgZG9tU3RvcmFnZS5zZXRJdGVtKCdmaXJlYmFzZTpzZW50aW5lbCcsICdjYWNoZScpO1xyXG4gICAgICAgICAgICBkb21TdG9yYWdlLnJlbW92ZUl0ZW0oJ2ZpcmViYXNlOnNlbnRpbmVsJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRE9NU3RvcmFnZVdyYXBwZXIoZG9tU3RvcmFnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHsgfVxyXG4gICAgLy8gRmFpbGVkIHRvIGNyZWF0ZSB3cmFwcGVyLiAgSnVzdCByZXR1cm4gaW4tbWVtb3J5IHN0b3JhZ2UuXHJcbiAgICAvLyBUT0RPOiBsb2c/XHJcbiAgICByZXR1cm4gbmV3IE1lbW9yeVN0b3JhZ2UoKTtcclxufTtcclxuLyoqIEEgc3RvcmFnZSBvYmplY3QgdGhhdCBsYXN0cyBhY3Jvc3Mgc2Vzc2lvbnMgKi9cclxuY29uc3QgUGVyc2lzdGVudFN0b3JhZ2UgPSBjcmVhdGVTdG9yYWdlZm9yKCdsb2NhbFN0b3JhZ2UnKTtcclxuLyoqIEEgc3RvcmFnZSBvYmplY3QgdGhhdCBvbmx5IGxhc3RzIG9uZSBzZXNzaW9uICovXHJcbmNvbnN0IFNlc3Npb25TdG9yYWdlID0gY3JlYXRlU3RvcmFnZWZvcignc2Vzc2lvblN0b3JhZ2UnKTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgbG9nQ2xpZW50ID0gbmV3IExvZ2dlcignQGZpcmViYXNlL2RhdGFiYXNlJyk7XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgbG9jYWxseS11bmlxdWUgSUQgKGdlbmVyYXRlZCBieSBqdXN0IGluY3JlbWVudGluZyB1cCBmcm9tIDAgZWFjaCB0aW1lIGl0cyBjYWxsZWQpLlxyXG4gKi9cclxuY29uc3QgTFVJREdlbmVyYXRvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBsZXQgaWQgPSAxO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gaWQrKztcclxuICAgIH07XHJcbn0pKCk7XHJcbi8qKlxyXG4gKiBTaGExIGhhc2ggb2YgdGhlIGlucHV0IHN0cmluZ1xyXG4gKiBAcGFyYW0gc3RyIC0gVGhlIHN0cmluZyB0byBoYXNoXHJcbiAqIEByZXR1cm5zIHshc3RyaW5nfSBUaGUgcmVzdWx0aW5nIGhhc2hcclxuICovXHJcbmNvbnN0IHNoYTEgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICBjb25zdCB1dGY4Qnl0ZXMgPSBzdHJpbmdUb0J5dGVBcnJheShzdHIpO1xyXG4gICAgY29uc3Qgc2hhMSA9IG5ldyBTaGExKCk7XHJcbiAgICBzaGExLnVwZGF0ZSh1dGY4Qnl0ZXMpO1xyXG4gICAgY29uc3Qgc2hhMUJ5dGVzID0gc2hhMS5kaWdlc3QoKTtcclxuICAgIHJldHVybiBiYXNlNjQuZW5jb2RlQnl0ZUFycmF5KHNoYTFCeXRlcyk7XHJcbn07XHJcbmNvbnN0IGJ1aWxkTG9nTWVzc2FnZV8gPSBmdW5jdGlvbiAoLi4udmFyQXJncykge1xyXG4gICAgbGV0IG1lc3NhZ2UgPSAnJztcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFyQXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGFyZyA9IHZhckFyZ3NbaV07XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSB8fFxyXG4gICAgICAgICAgICAoYXJnICYmXHJcbiAgICAgICAgICAgICAgICB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJlxyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgICAgIHR5cGVvZiBhcmcubGVuZ3RoID09PSAnbnVtYmVyJykpIHtcclxuICAgICAgICAgICAgbWVzc2FnZSArPSBidWlsZExvZ01lc3NhZ2VfLmFwcGx5KG51bGwsIGFyZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gc3RyaW5naWZ5KGFyZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBtZXNzYWdlICs9IGFyZztcclxuICAgICAgICB9XHJcbiAgICAgICAgbWVzc2FnZSArPSAnICc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWVzc2FnZTtcclxufTtcclxuLyoqXHJcbiAqIFVzZSB0aGlzIGZvciBhbGwgZGVidWcgbWVzc2FnZXMgaW4gRmlyZWJhc2UuXHJcbiAqL1xyXG5sZXQgbG9nZ2VyID0gbnVsbDtcclxuLyoqXHJcbiAqIEZsYWcgdG8gY2hlY2sgZm9yIGxvZyBhdmFpbGFiaWxpdHkgb24gZmlyc3QgbG9nIG1lc3NhZ2VcclxuICovXHJcbmxldCBmaXJzdExvZ18gPSB0cnVlO1xyXG4vKipcclxuICogVGhlIGltcGxlbWVudGF0aW9uIG9mIEZpcmViYXNlLmVuYWJsZUxvZ2dpbmcgKGRlZmluZWQgaGVyZSB0byBicmVhayBkZXBlbmRlbmNpZXMpXHJcbiAqIEBwYXJhbSBsb2dnZXJfIC0gQSBmbGFnIHRvIHR1cm4gb24gbG9nZ2luZywgb3IgYSBjdXN0b20gbG9nZ2VyXHJcbiAqIEBwYXJhbSBwZXJzaXN0ZW50IC0gV2hldGhlciBvciBub3QgdG8gcGVyc2lzdCBsb2dnaW5nIHNldHRpbmdzIGFjcm9zcyByZWZyZXNoZXNcclxuICovXHJcbmNvbnN0IGVuYWJsZUxvZ2dpbmckMSA9IGZ1bmN0aW9uIChsb2dnZXJfLCBwZXJzaXN0ZW50KSB7XHJcbiAgICBhc3NlcnQoIXBlcnNpc3RlbnQgfHwgbG9nZ2VyXyA9PT0gdHJ1ZSB8fCBsb2dnZXJfID09PSBmYWxzZSwgXCJDYW4ndCB0dXJuIG9uIGN1c3RvbSBsb2dnZXJzIHBlcnNpc3RlbnRseS5cIik7XHJcbiAgICBpZiAobG9nZ2VyXyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIGxvZ0NsaWVudC5sb2dMZXZlbCA9IExvZ0xldmVsLlZFUkJPU0U7XHJcbiAgICAgICAgbG9nZ2VyID0gbG9nQ2xpZW50LmxvZy5iaW5kKGxvZ0NsaWVudCk7XHJcbiAgICAgICAgaWYgKHBlcnNpc3RlbnQpIHtcclxuICAgICAgICAgICAgU2Vzc2lvblN0b3JhZ2Uuc2V0KCdsb2dnaW5nX2VuYWJsZWQnLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgbG9nZ2VyXyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGxvZ2dlciA9IGxvZ2dlcl87XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsb2dnZXIgPSBudWxsO1xyXG4gICAgICAgIFNlc3Npb25TdG9yYWdlLnJlbW92ZSgnbG9nZ2luZ19lbmFibGVkJyk7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IGxvZyA9IGZ1bmN0aW9uICguLi52YXJBcmdzKSB7XHJcbiAgICBpZiAoZmlyc3RMb2dfID09PSB0cnVlKSB7XHJcbiAgICAgICAgZmlyc3RMb2dfID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKGxvZ2dlciA9PT0gbnVsbCAmJiBTZXNzaW9uU3RvcmFnZS5nZXQoJ2xvZ2dpbmdfZW5hYmxlZCcpID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIGVuYWJsZUxvZ2dpbmckMSh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobG9nZ2VyKSB7XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGJ1aWxkTG9nTWVzc2FnZV8uYXBwbHkobnVsbCwgdmFyQXJncyk7XHJcbiAgICAgICAgbG9nZ2VyKG1lc3NhZ2UpO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBsb2dXcmFwcGVyID0gZnVuY3Rpb24gKHByZWZpeCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi52YXJBcmdzKSB7XHJcbiAgICAgICAgbG9nKHByZWZpeCwgLi4udmFyQXJncyk7XHJcbiAgICB9O1xyXG59O1xyXG5jb25zdCBlcnJvciA9IGZ1bmN0aW9uICguLi52YXJBcmdzKSB7XHJcbiAgICBjb25zdCBtZXNzYWdlID0gJ0ZJUkVCQVNFIElOVEVSTkFMIEVSUk9SOiAnICsgYnVpbGRMb2dNZXNzYWdlXyguLi52YXJBcmdzKTtcclxuICAgIGxvZ0NsaWVudC5lcnJvcihtZXNzYWdlKTtcclxufTtcclxuY29uc3QgZmF0YWwgPSBmdW5jdGlvbiAoLi4udmFyQXJncykge1xyXG4gICAgY29uc3QgbWVzc2FnZSA9IGBGSVJFQkFTRSBGQVRBTCBFUlJPUjogJHtidWlsZExvZ01lc3NhZ2VfKC4uLnZhckFyZ3MpfWA7XHJcbiAgICBsb2dDbGllbnQuZXJyb3IobWVzc2FnZSk7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbn07XHJcbmNvbnN0IHdhcm4gPSBmdW5jdGlvbiAoLi4udmFyQXJncykge1xyXG4gICAgY29uc3QgbWVzc2FnZSA9ICdGSVJFQkFTRSBXQVJOSU5HOiAnICsgYnVpbGRMb2dNZXNzYWdlXyguLi52YXJBcmdzKTtcclxuICAgIGxvZ0NsaWVudC53YXJuKG1lc3NhZ2UpO1xyXG59O1xyXG4vKipcclxuICogTG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbnRhaW5pbmcgcGFnZSB1c2VzIGh0dHBzLiBDYWxsZWQgd2hlbiBhIGNhbGwgdG8gbmV3IEZpcmViYXNlXHJcbiAqIGRvZXMgbm90IHVzZSBodHRwcy5cclxuICovXHJcbmNvbnN0IHdhcm5JZlBhZ2VJc1NlY3VyZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIEJlIHZlcnkgY2FyZWZ1bCBhY2Nlc3NpbmcgYnJvd3NlciBnbG9iYWxzLiBXaG8ga25vd3Mgd2hhdCBtYXkgb3IgbWF5IG5vdCBleGlzdC5cclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbiAmJlxyXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCAmJlxyXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbC5pbmRleE9mKCdodHRwczonKSAhPT0gLTEpIHtcclxuICAgICAgICB3YXJuKCdJbnNlY3VyZSBGaXJlYmFzZSBhY2Nlc3MgZnJvbSBhIHNlY3VyZSBwYWdlLiAnICtcclxuICAgICAgICAgICAgJ1BsZWFzZSB1c2UgaHR0cHMgaW4gY2FsbHMgdG8gbmV3IEZpcmViYXNlKCkuJyk7XHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgZGF0YSBpcyBOYU4sIG9yICsvLSBJbmZpbml0eS5cclxuICovXHJcbmNvbnN0IGlzSW52YWxpZEpTT05OdW1iZXIgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgcmV0dXJuICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicgJiZcclxuICAgICAgICAoZGF0YSAhPT0gZGF0YSB8fCAvLyBOYU5cclxuICAgICAgICAgICAgZGF0YSA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIHx8XHJcbiAgICAgICAgICAgIGRhdGEgPT09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSkpO1xyXG59O1xyXG5jb25zdCBleGVjdXRlV2hlbkRPTVJlYWR5ID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICBpZiAoaXNOb2RlU2RrKCkgfHwgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xyXG4gICAgICAgIGZuKCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBNb2RlbGVkIGFmdGVyIGpRdWVyeS4gVHJ5IERPTUNvbnRlbnRMb2FkZWQgYW5kIG9ucmVhZHlzdGF0ZWNoYW5nZSAod2hpY2hcclxuICAgICAgICAvLyBmaXJlIGJlZm9yZSBvbmxvYWQpLCBidXQgZmFsbCBiYWNrIHRvIG9ubG9hZC5cclxuICAgICAgICBsZXQgY2FsbGVkID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3Qgd3JhcHBlZEZuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIWRvY3VtZW50LmJvZHkpIHtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQod3JhcHBlZEZuLCBNYXRoLmZsb29yKDEwKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFjYWxsZWQpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBmbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgd3JhcHBlZEZuLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIC8vIGZhbGxiYWNrIHRvIG9ubG9hZC5cclxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB3cmFwcGVkRm4sIGZhbHNlKTtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZG9jdW1lbnQuYXR0YWNoRXZlbnQpIHtcclxuICAgICAgICAgICAgLy8gSUUuXHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmF0dGFjaEV2ZW50KCdvbnJlYWR5c3RhdGVjaGFuZ2UnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZWRGbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gZmFsbGJhY2sgdG8gb25sb2FkLlxyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICB3aW5kb3cuYXR0YWNoRXZlbnQoJ29ubG9hZCcsIHdyYXBwZWRGbik7XHJcbiAgICAgICAgICAgIC8vIGpRdWVyeSBoYXMgYW4gZXh0cmEgaGFjayBmb3IgSUUgdGhhdCB3ZSBjb3VsZCBlbXBsb3kgKGJhc2VkIG9uXHJcbiAgICAgICAgICAgIC8vIGh0dHA6Ly9qYXZhc2NyaXB0Lm53Ym94LmNvbS9JRUNvbnRlbnRMb2FkZWQvKSBCdXQgaXQgbG9va3MgcmVhbGx5IG9sZC5cclxuICAgICAgICAgICAgLy8gSSdtIGhvcGluZyB3ZSBkb24ndCBuZWVkIGl0LlxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIE1pbmltdW0ga2V5IG5hbWUuIEludmFsaWQgZm9yIGFjdHVhbCBkYXRhLCB1c2VkIGFzIGEgbWFya2VyIHRvIHNvcnQgYmVmb3JlIGFueSB2YWxpZCBuYW1lc1xyXG4gKi9cclxuY29uc3QgTUlOX05BTUUgPSAnW01JTl9OQU1FXSc7XHJcbi8qKlxyXG4gKiBNYXhpbXVtIGtleSBuYW1lLiBJbnZhbGlkIGZvciBhY3R1YWwgZGF0YSwgdXNlZCBhcyBhIG1hcmtlciB0byBzb3J0IGFib3ZlIGFueSB2YWxpZCBuYW1lc1xyXG4gKi9cclxuY29uc3QgTUFYX05BTUUgPSAnW01BWF9OQU1FXSc7XHJcbi8qKlxyXG4gKiBDb21wYXJlcyB2YWxpZCBGaXJlYmFzZSBrZXkgbmFtZXMsIHBsdXMgbWluIGFuZCBtYXggbmFtZVxyXG4gKi9cclxuY29uc3QgbmFtZUNvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgaWYgKGEgPT09IGIpIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGEgPT09IE1JTl9OQU1FIHx8IGIgPT09IE1BWF9OQU1FKSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYiA9PT0gTUlOX05BTUUgfHwgYSA9PT0gTUFYX05BTUUpIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGFBc0ludCA9IHRyeVBhcnNlSW50KGEpLCBiQXNJbnQgPSB0cnlQYXJzZUludChiKTtcclxuICAgICAgICBpZiAoYUFzSW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChiQXNJbnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhQXNJbnQgLSBiQXNJbnQgPT09IDAgPyBhLmxlbmd0aCAtIGIubGVuZ3RoIDogYUFzSW50IC0gYkFzSW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGJBc0ludCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBAcmV0dXJucyB7IW51bWJlcn0gY29tcGFyaXNvbiByZXN1bHQuXHJcbiAqL1xyXG5jb25zdCBzdHJpbmdDb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgIGlmIChhID09PSBiKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChhIDwgYikge1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCByZXF1aXJlS2V5ID0gZnVuY3Rpb24gKGtleSwgb2JqKSB7XHJcbiAgICBpZiAob2JqICYmIGtleSBpbiBvYmopIHtcclxuICAgICAgICByZXR1cm4gb2JqW2tleV07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQga2V5ICgnICsga2V5ICsgJykgaW4gb2JqZWN0OiAnICsgc3RyaW5naWZ5KG9iaikpO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBPYmplY3RUb1VuaXF1ZUtleSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5naWZ5KG9iaik7XHJcbiAgICB9XHJcbiAgICBjb25zdCBrZXlzID0gW107XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ3VhcmQtZm9yLWluXHJcbiAgICBmb3IgKGNvbnN0IGsgaW4gb2JqKSB7XHJcbiAgICAgICAga2V5cy5wdXNoKGspO1xyXG4gICAgfVxyXG4gICAgLy8gRXhwb3J0IGFzIGpzb24sIGJ1dCB3aXRoIHRoZSBrZXlzIHNvcnRlZC5cclxuICAgIGtleXMuc29ydCgpO1xyXG4gICAgbGV0IGtleSA9ICd7JztcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChpICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGtleSArPSAnLCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGtleSArPSBzdHJpbmdpZnkoa2V5c1tpXSk7XHJcbiAgICAgICAga2V5ICs9ICc6JztcclxuICAgICAgICBrZXkgKz0gT2JqZWN0VG9VbmlxdWVLZXkob2JqW2tleXNbaV1dKTtcclxuICAgIH1cclxuICAgIGtleSArPSAnfSc7XHJcbiAgICByZXR1cm4ga2V5O1xyXG59O1xyXG4vKipcclxuICogU3BsaXRzIGEgc3RyaW5nIGludG8gYSBudW1iZXIgb2Ygc21hbGxlciBzZWdtZW50cyBvZiBtYXhpbXVtIHNpemVcclxuICogQHBhcmFtIHN0ciAtIFRoZSBzdHJpbmdcclxuICogQHBhcmFtIHNlZ3NpemUgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgY2hhcnMgaW4gdGhlIHN0cmluZy5cclxuICogQHJldHVybnMgVGhlIHN0cmluZywgc3BsaXQgaW50byBhcHByb3ByaWF0ZWx5LXNpemVkIGNodW5rc1xyXG4gKi9cclxuY29uc3Qgc3BsaXRTdHJpbmdCeVNpemUgPSBmdW5jdGlvbiAoc3RyLCBzZWdzaXplKSB7XHJcbiAgICBjb25zdCBsZW4gPSBzdHIubGVuZ3RoO1xyXG4gICAgaWYgKGxlbiA8PSBzZWdzaXplKSB7XHJcbiAgICAgICAgcmV0dXJuIFtzdHJdO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGF0YVNlZ3MgPSBbXTtcclxuICAgIGZvciAobGV0IGMgPSAwOyBjIDwgbGVuOyBjICs9IHNlZ3NpemUpIHtcclxuICAgICAgICBpZiAoYyArIHNlZ3NpemUgPiBsZW4pIHtcclxuICAgICAgICAgICAgZGF0YVNlZ3MucHVzaChzdHIuc3Vic3RyaW5nKGMsIGxlbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZGF0YVNlZ3MucHVzaChzdHIuc3Vic3RyaW5nKGMsIGMgKyBzZWdzaXplKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRhdGFTZWdzO1xyXG59O1xyXG4vKipcclxuICogQXBwbHkgYSBmdW5jdGlvbiB0byBlYWNoIChrZXksIHZhbHVlKSBwYWlyIGluIGFuIG9iamVjdCBvclxyXG4gKiBhcHBseSBhIGZ1bmN0aW9uIHRvIGVhY2ggKGluZGV4LCB2YWx1ZSkgcGFpciBpbiBhbiBhcnJheVxyXG4gKiBAcGFyYW0gb2JqIC0gVGhlIG9iamVjdCBvciBhcnJheSB0byBpdGVyYXRlIG92ZXJcclxuICogQHBhcmFtIGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGFwcGx5XHJcbiAqL1xyXG5mdW5jdGlvbiBlYWNoKG9iaiwgZm4pIHtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xyXG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICBmbihrZXksIG9ialtrZXldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEJvcnJvd2VkIGZyb20gaHR0cDovL2hnLnNlY29uZGxpZmUuY29tL2xsc2Qvc3JjL3RpcC9qcy90eXBlZGFycmF5LmpzIChNSVQgTGljZW5zZSlcclxuICogSSBtYWRlIG9uZSBtb2RpZmljYXRpb24gYXQgdGhlIGVuZCBhbmQgcmVtb3ZlZCB0aGUgTmFOIC8gSW5maW5pdHlcclxuICogaGFuZGxpbmcgKHNpbmNlIGl0IHNlZW1lZCBicm9rZW4gW2NhdXNlZCBhbiBvdmVyZmxvd10gYW5kIHdlIGRvbid0IG5lZWQgaXQpLiAgU2VlIE1KTCBjb21tZW50cy5cclxuICogQHBhcmFtIHYgLSBBIGRvdWJsZVxyXG4gKlxyXG4gKi9cclxuY29uc3QgZG91YmxlVG9JRUVFNzU0U3RyaW5nID0gZnVuY3Rpb24gKHYpIHtcclxuICAgIGFzc2VydCghaXNJbnZhbGlkSlNPTk51bWJlcih2KSwgJ0ludmFsaWQgSlNPTiBudW1iZXInKTsgLy8gTUpMXHJcbiAgICBjb25zdCBlYml0cyA9IDExLCBmYml0cyA9IDUyO1xyXG4gICAgY29uc3QgYmlhcyA9ICgxIDw8IChlYml0cyAtIDEpKSAtIDE7XHJcbiAgICBsZXQgcywgZSwgZiwgbG4sIGk7XHJcbiAgICAvLyBDb21wdXRlIHNpZ24sIGV4cG9uZW50LCBmcmFjdGlvblxyXG4gICAgLy8gU2tpcCBOYU4gLyBJbmZpbml0eSBoYW5kbGluZyAtLU1KTC5cclxuICAgIGlmICh2ID09PSAwKSB7XHJcbiAgICAgICAgZSA9IDA7XHJcbiAgICAgICAgZiA9IDA7XHJcbiAgICAgICAgcyA9IDEgLyB2ID09PSAtSW5maW5pdHkgPyAxIDogMDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHMgPSB2IDwgMDtcclxuICAgICAgICB2ID0gTWF0aC5hYnModik7XHJcbiAgICAgICAgaWYgKHYgPj0gTWF0aC5wb3coMiwgMSAtIGJpYXMpKSB7XHJcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZWRcclxuICAgICAgICAgICAgbG4gPSBNYXRoLm1pbihNYXRoLmZsb29yKE1hdGgubG9nKHYpIC8gTWF0aC5MTjIpLCBiaWFzKTtcclxuICAgICAgICAgICAgZSA9IGxuICsgYmlhcztcclxuICAgICAgICAgICAgZiA9IE1hdGgucm91bmQodiAqIE1hdGgucG93KDIsIGZiaXRzIC0gbG4pIC0gTWF0aC5wb3coMiwgZmJpdHMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIERlbm9ybWFsaXplZFxyXG4gICAgICAgICAgICBlID0gMDtcclxuICAgICAgICAgICAgZiA9IE1hdGgucm91bmQodiAvIE1hdGgucG93KDIsIDEgLSBiaWFzIC0gZmJpdHMpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBQYWNrIHNpZ24sIGV4cG9uZW50LCBmcmFjdGlvblxyXG4gICAgY29uc3QgYml0cyA9IFtdO1xyXG4gICAgZm9yIChpID0gZmJpdHM7IGk7IGkgLT0gMSkge1xyXG4gICAgICAgIGJpdHMucHVzaChmICUgMiA/IDEgOiAwKTtcclxuICAgICAgICBmID0gTWF0aC5mbG9vcihmIC8gMik7XHJcbiAgICB9XHJcbiAgICBmb3IgKGkgPSBlYml0czsgaTsgaSAtPSAxKSB7XHJcbiAgICAgICAgYml0cy5wdXNoKGUgJSAyID8gMSA6IDApO1xyXG4gICAgICAgIGUgPSBNYXRoLmZsb29yKGUgLyAyKTtcclxuICAgIH1cclxuICAgIGJpdHMucHVzaChzID8gMSA6IDApO1xyXG4gICAgYml0cy5yZXZlcnNlKCk7XHJcbiAgICBjb25zdCBzdHIgPSBiaXRzLmpvaW4oJycpO1xyXG4gICAgLy8gUmV0dXJuIHRoZSBkYXRhIGFzIGEgaGV4IHN0cmluZy4gLS1NSkxcclxuICAgIGxldCBoZXhCeXRlU3RyaW5nID0gJyc7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkgKz0gOCkge1xyXG4gICAgICAgIGxldCBoZXhCeXRlID0gcGFyc2VJbnQoc3RyLnN1YnN0cihpLCA4KSwgMikudG9TdHJpbmcoMTYpO1xyXG4gICAgICAgIGlmIChoZXhCeXRlLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICBoZXhCeXRlID0gJzAnICsgaGV4Qnl0ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaGV4Qnl0ZVN0cmluZyA9IGhleEJ5dGVTdHJpbmcgKyBoZXhCeXRlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhleEJ5dGVTdHJpbmcudG9Mb3dlckNhc2UoKTtcclxufTtcclxuLyoqXHJcbiAqIFVzZWQgdG8gZGV0ZWN0IGlmIHdlJ3JlIGluIGEgQ2hyb21lIGNvbnRlbnQgc2NyaXB0ICh3aGljaCBleGVjdXRlcyBpbiBhblxyXG4gKiBpc29sYXRlZCBlbnZpcm9ubWVudCB3aGVyZSBsb25nLXBvbGxpbmcgZG9lc24ndCB3b3JrKS5cclxuICovXHJcbmNvbnN0IGlzQ2hyb21lRXh0ZW5zaW9uQ29udGVudFNjcmlwdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiAhISh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJlxyXG4gICAgICAgIHdpbmRvd1snY2hyb21lJ10gJiZcclxuICAgICAgICB3aW5kb3dbJ2Nocm9tZSddWydleHRlbnNpb24nXSAmJlxyXG4gICAgICAgICEvXmNocm9tZS8udGVzdCh3aW5kb3cubG9jYXRpb24uaHJlZikpO1xyXG59O1xyXG4vKipcclxuICogVXNlZCB0byBkZXRlY3QgaWYgd2UncmUgaW4gYSBXaW5kb3dzIDggU3RvcmUgYXBwLlxyXG4gKi9cclxuY29uc3QgaXNXaW5kb3dzU3RvcmVBcHAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBDaGVjayBmb3IgdGhlIHByZXNlbmNlIG9mIGEgY291cGxlIFdpblJUIGdsb2JhbHNcclxuICAgIHJldHVybiB0eXBlb2YgV2luZG93cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIFdpbmRvd3MuVUkgPT09ICdvYmplY3QnO1xyXG59O1xyXG4vKipcclxuICogQ29udmVydHMgYSBzZXJ2ZXIgZXJyb3IgY29kZSB0byBhIEphdmFzY3JpcHQgRXJyb3JcclxuICovXHJcbmZ1bmN0aW9uIGVycm9yRm9yU2VydmVyQ29kZShjb2RlLCBxdWVyeSkge1xyXG4gICAgbGV0IHJlYXNvbiA9ICdVbmtub3duIEVycm9yJztcclxuICAgIGlmIChjb2RlID09PSAndG9vX2JpZycpIHtcclxuICAgICAgICByZWFzb24gPVxyXG4gICAgICAgICAgICAnVGhlIGRhdGEgcmVxdWVzdGVkIGV4Y2VlZHMgdGhlIG1heGltdW0gc2l6ZSAnICtcclxuICAgICAgICAgICAgICAgICd0aGF0IGNhbiBiZSBhY2Nlc3NlZCB3aXRoIGEgc2luZ2xlIHJlcXVlc3QuJztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNvZGUgPT09ICdwZXJtaXNzaW9uX2RlbmllZCcpIHtcclxuICAgICAgICByZWFzb24gPSBcIkNsaWVudCBkb2Vzbid0IGhhdmUgcGVybWlzc2lvbiB0byBhY2Nlc3MgdGhlIGRlc2lyZWQgZGF0YS5cIjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNvZGUgPT09ICd1bmF2YWlsYWJsZScpIHtcclxuICAgICAgICByZWFzb24gPSAnVGhlIHNlcnZpY2UgaXMgdW5hdmFpbGFibGUnO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoY29kZSArICcgYXQgJyArIHF1ZXJ5Ll9wYXRoLnRvU3RyaW5nKCkgKyAnOiAnICsgcmVhc29uKTtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICBlcnJvci5jb2RlID0gY29kZS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgcmV0dXJuIGVycm9yO1xyXG59XHJcbi8qKlxyXG4gKiBVc2VkIHRvIHRlc3QgZm9yIGludGVnZXItbG9va2luZyBzdHJpbmdzXHJcbiAqL1xyXG5jb25zdCBJTlRFR0VSX1JFR0VYUF8gPSBuZXcgUmVnRXhwKCdeLT8oMCopXFxcXGR7MSwxMH0kJyk7XHJcbi8qKlxyXG4gKiBGb3IgdXNlIGluIGtleXMsIHRoZSBtaW5pbXVtIHBvc3NpYmxlIDMyLWJpdCBpbnRlZ2VyLlxyXG4gKi9cclxuY29uc3QgSU5URUdFUl8zMl9NSU4gPSAtMjE0NzQ4MzY0ODtcclxuLyoqXHJcbiAqIEZvciB1c2UgaW4ga3llcywgdGhlIG1heGltdW0gcG9zc2libGUgMzItYml0IGludGVnZXIuXHJcbiAqL1xyXG5jb25zdCBJTlRFR0VSXzMyX01BWCA9IDIxNDc0ODM2NDc7XHJcbi8qKlxyXG4gKiBJZiB0aGUgc3RyaW5nIGNvbnRhaW5zIGEgMzItYml0IGludGVnZXIsIHJldHVybiBpdC4gIEVsc2UgcmV0dXJuIG51bGwuXHJcbiAqL1xyXG5jb25zdCB0cnlQYXJzZUludCA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgIGlmIChJTlRFR0VSX1JFR0VYUF8udGVzdChzdHIpKSB7XHJcbiAgICAgICAgY29uc3QgaW50VmFsID0gTnVtYmVyKHN0cik7XHJcbiAgICAgICAgaWYgKGludFZhbCA+PSBJTlRFR0VSXzMyX01JTiAmJiBpbnRWYWwgPD0gSU5URUdFUl8zMl9NQVgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGludFZhbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufTtcclxuLyoqXHJcbiAqIEhlbHBlciB0byBydW4gc29tZSBjb2RlIGJ1dCBjYXRjaCBhbnkgZXhjZXB0aW9ucyBhbmQgcmUtdGhyb3cgdGhlbSBsYXRlci5cclxuICogVXNlZnVsIGZvciBwcmV2ZW50aW5nIHVzZXIgY2FsbGJhY2tzIGZyb20gYnJlYWtpbmcgaW50ZXJuYWwgY29kZS5cclxuICpcclxuICogUmUtdGhyb3dpbmcgdGhlIGV4Y2VwdGlvbiBmcm9tIGEgc2V0VGltZW91dCBpcyBhIGxpdHRsZSBldmlsLCBidXQgaXQncyB2ZXJ5XHJcbiAqIGNvbnZlbmllbnQgKHdlIGRvbid0IGhhdmUgdG8gdHJ5IHRvIGZpZ3VyZSBvdXQgd2hlbiBpcyBhIHNhZmUgcG9pbnQgdG9cclxuICogcmUtdGhyb3cgaXQpLCBhbmQgdGhlIGJlaGF2aW9yIHNlZW1zIHJlYXNvbmFibGU6XHJcbiAqXHJcbiAqICogSWYgeW91IGFyZW4ndCBwYXVzaW5nIG9uIGV4Y2VwdGlvbnMsIHlvdSBnZXQgYW4gZXJyb3IgaW4gdGhlIGNvbnNvbGUgd2l0aFxyXG4gKiAgIHRoZSBjb3JyZWN0IHN0YWNrIHRyYWNlLlxyXG4gKiAqIElmIHlvdSdyZSBwYXVzaW5nIG9uIGFsbCBleGNlcHRpb25zLCB0aGUgZGVidWdnZXIgd2lsbCBwYXVzZSBvbiB5b3VyXHJcbiAqICAgZXhjZXB0aW9uIGFuZCB0aGVuIGFnYWluIHdoZW4gd2UgcmV0aHJvdyBpdC5cclxuICogKiBJZiB5b3UncmUgb25seSBwYXVzaW5nIG9uIHVuY2F1Z2h0IGV4Y2VwdGlvbnMsIHRoZSBkZWJ1Z2dlciB3aWxsIG9ubHkgcGF1c2VcclxuICogICBvbiB1cyByZS10aHJvd2luZyBpdC5cclxuICpcclxuICogQHBhcmFtIGZuIC0gVGhlIGNvZGUgdG8gZ3VhcmQuXHJcbiAqL1xyXG5jb25zdCBleGNlcHRpb25HdWFyZCA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBmbigpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAvLyBSZS10aHJvdyBleGNlcHRpb24gd2hlbiBpdCdzIHNhZmUuXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIEl0IHVzZWQgdG8gYmUgdGhhdCBcInRocm93IGVcIiB3b3VsZCByZXN1bHQgaW4gYSBnb29kIGNvbnNvbGUgZXJyb3Igd2l0aFxyXG4gICAgICAgICAgICAvLyByZWxldmFudCBjb250ZXh0LCBidXQgYXMgb2YgQ2hyb21lIDM5LCB5b3UganVzdCBnZXQgdGhlIGZpcmViYXNlLmpzXHJcbiAgICAgICAgICAgIC8vIGZpbGUvbGluZSBudW1iZXIgd2hlcmUgd2UgcmUtdGhyb3cgaXQsIHdoaWNoIGlzIHVzZWxlc3MuIFNvIHdlIGxvZ1xyXG4gICAgICAgICAgICAvLyBlLnN0YWNrIGV4cGxpY2l0bHkuXHJcbiAgICAgICAgICAgIGNvbnN0IHN0YWNrID0gZS5zdGFjayB8fCAnJztcclxuICAgICAgICAgICAgd2FybignRXhjZXB0aW9uIHdhcyB0aHJvd24gYnkgdXNlciBjYWxsYmFjay4nLCBzdGFjayk7XHJcbiAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgfSwgTWF0aC5mbG9vcigwKSk7XHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB3ZSB0aGluayB3ZSdyZSBjdXJyZW50bHkgYmVpbmcgY3Jhd2xlZC5cclxuICovXHJcbmNvbnN0IGJlaW5nQ3Jhd2xlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGNvbnN0IHVzZXJBZ2VudCA9ICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJlxyXG4gICAgICAgIHdpbmRvd1snbmF2aWdhdG9yJ10gJiZcclxuICAgICAgICB3aW5kb3dbJ25hdmlnYXRvciddWyd1c2VyQWdlbnQnXSkgfHxcclxuICAgICAgICAnJztcclxuICAgIC8vIEZvciBub3cgd2Ugd2hpdGVsaXN0IHRoZSBtb3N0IHBvcHVsYXIgY3Jhd2xlcnMuICBXZSBzaG91bGQgcmVmaW5lIHRoaXMgdG8gYmUgdGhlIHNldCBvZiBjcmF3bGVycyB3ZVxyXG4gICAgLy8gYmVsaWV2ZSB0byBzdXBwb3J0IEphdmFTY3JpcHQvQUpBWCByZW5kZXJpbmcuXHJcbiAgICAvLyBOT1RFOiBHb29nbGUgV2VibWFzdGVyIFRvb2xzIGRvZXNuJ3QgcmVhbGx5IGJlbG9uZywgYnV0IHRoZWlyIFwiVGhpcyBpcyBob3cgYSB2aXNpdG9yIHRvIHlvdXIgd2Vic2l0ZVxyXG4gICAgLy8gd291bGQgaGF2ZSBzZWVuIHRoZSBwYWdlXCIgaXMgZmxha3kgaWYgd2UgZG9uJ3QgdHJlYXQgaXQgYXMgYSBjcmF3bGVyLlxyXG4gICAgcmV0dXJuICh1c2VyQWdlbnQuc2VhcmNoKC9nb29nbGVib3R8Z29vZ2xlIHdlYm1hc3RlciB0b29sc3xiaW5nYm90fHlhaG9vISBzbHVycHxiYWlkdXNwaWRlcnx5YW5kZXhib3R8ZHVja2R1Y2tib3QvaSkgPj0gMCk7XHJcbn07XHJcbi8qKlxyXG4gKiBTYW1lIGFzIHNldFRpbWVvdXQoKSBleGNlcHQgb24gTm9kZS5KUyBpdCB3aWxsIC9ub3QvIHByZXZlbnQgdGhlIHByb2Nlc3MgZnJvbSBleGl0aW5nLlxyXG4gKlxyXG4gKiBJdCBpcyByZW1vdmVkIHdpdGggY2xlYXJUaW1lb3V0KCkgYXMgbm9ybWFsLlxyXG4gKlxyXG4gKiBAcGFyYW0gZm4gLSBGdW5jdGlvbiB0byBydW4uXHJcbiAqIEBwYXJhbSB0aW1lIC0gTWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIHJ1bm5pbmcuXHJcbiAqIEByZXR1cm5zIFRoZSBzZXRUaW1lb3V0KCkgcmV0dXJuIHZhbHVlLlxyXG4gKi9cclxuY29uc3Qgc2V0VGltZW91dE5vbkJsb2NraW5nID0gZnVuY3Rpb24gKGZuLCB0aW1lKSB7XHJcbiAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dChmbiwgdGltZSk7XHJcbiAgICAvLyBOb3RlOiBhdCB0aGUgdGltZSBvZiB0aGlzIGNvbW1lbnQsIHVucmVmVGltZXIgaXMgdW5kZXIgdGhlIHVuc3RhYmxlIHNldCBvZiBBUElzLiBSdW4gd2l0aCAtLXVuc3RhYmxlIHRvIGVuYWJsZSB0aGUgQVBJLlxyXG4gICAgaWYgKHR5cGVvZiB0aW1lb3V0ID09PSAnbnVtYmVyJyAmJlxyXG4gICAgICAgIC8vIEB0cy1pZ25vcmUgSXMgb25seSBkZWZpbmVkIGluIERlbm8gZW52aXJvbm1lbnRzLlxyXG4gICAgICAgIHR5cGVvZiBEZW5vICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgIC8vIEB0cy1pZ25vcmUgRGVubyBhbmQgdW5yZWZUaW1lciBhcmUgb25seSBkZWZpbmVkIGluIERlbm8gZW52aXJvbm1lbnRzLlxyXG4gICAgICAgIERlbm9bJ3VucmVmVGltZXInXSkge1xyXG4gICAgICAgIC8vIEB0cy1pZ25vcmUgRGVubyBhbmQgdW5yZWZUaW1lciBhcmUgb25seSBkZWZpbmVkIGluIERlbm8gZW52aXJvbm1lbnRzLlxyXG4gICAgICAgIERlbm8udW5yZWZUaW1lcih0aW1lb3V0KTtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIHRpbWVvdXQgPT09ICdvYmplY3QnICYmIHRpbWVvdXRbJ3VucmVmJ10pIHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgIHRpbWVvdXRbJ3VucmVmJ10oKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aW1lb3V0O1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQSBjbGFzcyB0aGF0IGhvbGRzIG1ldGFkYXRhIGFib3V0IGEgUmVwbyBvYmplY3RcclxuICovXHJcbmNsYXNzIFJlcG9JbmZvIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGhvc3QgLSBIb3N0bmFtZSBwb3J0aW9uIG9mIHRoZSB1cmwgZm9yIHRoZSByZXBvXHJcbiAgICAgKiBAcGFyYW0gc2VjdXJlIC0gV2hldGhlciBvciBub3QgdGhpcyByZXBvIGlzIGFjY2Vzc2VkIG92ZXIgc3NsXHJcbiAgICAgKiBAcGFyYW0gbmFtZXNwYWNlIC0gVGhlIG5hbWVzcGFjZSByZXByZXNlbnRlZCBieSB0aGUgcmVwb1xyXG4gICAgICogQHBhcmFtIHdlYlNvY2tldE9ubHkgLSBXaGV0aGVyIHRvIHByZWZlciB3ZWJzb2NrZXRzIG92ZXIgYWxsIG90aGVyIHRyYW5zcG9ydHMgKHVzZWQgYnkgTmVzdCkuXHJcbiAgICAgKiBAcGFyYW0gbm9kZUFkbWluIC0gV2hldGhlciB0aGlzIGluc3RhbmNlIHVzZXMgQWRtaW4gU0RLIGNyZWRlbnRpYWxzXHJcbiAgICAgKiBAcGFyYW0gcGVyc2lzdGVuY2VLZXkgLSBPdmVycmlkZSB0aGUgZGVmYXVsdCBzZXNzaW9uIHBlcnNpc3RlbmNlIHN0b3JhZ2Uga2V5XHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGhvc3QsIHNlY3VyZSwgbmFtZXNwYWNlLCB3ZWJTb2NrZXRPbmx5LCBub2RlQWRtaW4gPSBmYWxzZSwgcGVyc2lzdGVuY2VLZXkgPSAnJywgaW5jbHVkZU5hbWVzcGFjZUluUXVlcnlQYXJhbXMgPSBmYWxzZSwgaXNVc2luZ0VtdWxhdG9yID0gZmFsc2UpIHtcclxuICAgICAgICB0aGlzLnNlY3VyZSA9IHNlY3VyZTtcclxuICAgICAgICB0aGlzLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcclxuICAgICAgICB0aGlzLndlYlNvY2tldE9ubHkgPSB3ZWJTb2NrZXRPbmx5O1xyXG4gICAgICAgIHRoaXMubm9kZUFkbWluID0gbm9kZUFkbWluO1xyXG4gICAgICAgIHRoaXMucGVyc2lzdGVuY2VLZXkgPSBwZXJzaXN0ZW5jZUtleTtcclxuICAgICAgICB0aGlzLmluY2x1ZGVOYW1lc3BhY2VJblF1ZXJ5UGFyYW1zID0gaW5jbHVkZU5hbWVzcGFjZUluUXVlcnlQYXJhbXM7XHJcbiAgICAgICAgdGhpcy5pc1VzaW5nRW11bGF0b3IgPSBpc1VzaW5nRW11bGF0b3I7XHJcbiAgICAgICAgdGhpcy5faG9zdCA9IGhvc3QudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICB0aGlzLl9kb21haW4gPSB0aGlzLl9ob3N0LnN1YnN0cih0aGlzLl9ob3N0LmluZGV4T2YoJy4nKSArIDEpO1xyXG4gICAgICAgIHRoaXMuaW50ZXJuYWxIb3N0ID1cclxuICAgICAgICAgICAgUGVyc2lzdGVudFN0b3JhZ2UuZ2V0KCdob3N0OicgKyBob3N0KSB8fCB0aGlzLl9ob3N0O1xyXG4gICAgfVxyXG4gICAgaXNDYWNoZWFibGVIb3N0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsSG9zdC5zdWJzdHIoMCwgMikgPT09ICdzLSc7XHJcbiAgICB9XHJcbiAgICBpc0N1c3RvbUhvc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLl9kb21haW4gIT09ICdmaXJlYmFzZWlvLmNvbScgJiZcclxuICAgICAgICAgICAgdGhpcy5fZG9tYWluICE9PSAnZmlyZWJhc2Vpby1kZW1vLmNvbScpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGhvc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hvc3Q7XHJcbiAgICB9XHJcbiAgICBzZXQgaG9zdChuZXdIb3N0KSB7XHJcbiAgICAgICAgaWYgKG5ld0hvc3QgIT09IHRoaXMuaW50ZXJuYWxIb3N0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxIb3N0ID0gbmV3SG9zdDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNDYWNoZWFibGVIb3N0KCkpIHtcclxuICAgICAgICAgICAgICAgIFBlcnNpc3RlbnRTdG9yYWdlLnNldCgnaG9zdDonICsgdGhpcy5faG9zdCwgdGhpcy5pbnRlcm5hbEhvc3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgbGV0IHN0ciA9IHRoaXMudG9VUkxTdHJpbmcoKTtcclxuICAgICAgICBpZiAodGhpcy5wZXJzaXN0ZW5jZUtleSkge1xyXG4gICAgICAgICAgICBzdHIgKz0gJzwnICsgdGhpcy5wZXJzaXN0ZW5jZUtleSArICc+JztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH1cclxuICAgIHRvVVJMU3RyaW5nKCkge1xyXG4gICAgICAgIGNvbnN0IHByb3RvY29sID0gdGhpcy5zZWN1cmUgPyAnaHR0cHM6Ly8nIDogJ2h0dHA6Ly8nO1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5pbmNsdWRlTmFtZXNwYWNlSW5RdWVyeVBhcmFtc1xyXG4gICAgICAgICAgICA/IGA/bnM9JHt0aGlzLm5hbWVzcGFjZX1gXHJcbiAgICAgICAgICAgIDogJyc7XHJcbiAgICAgICAgcmV0dXJuIGAke3Byb3RvY29sfSR7dGhpcy5ob3N0fS8ke3F1ZXJ5fWA7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVwb0luZm9OZWVkc1F1ZXJ5UGFyYW0ocmVwb0luZm8pIHtcclxuICAgIHJldHVybiAocmVwb0luZm8uaG9zdCAhPT0gcmVwb0luZm8uaW50ZXJuYWxIb3N0IHx8XHJcbiAgICAgICAgcmVwb0luZm8uaXNDdXN0b21Ib3N0KCkgfHxcclxuICAgICAgICByZXBvSW5mby5pbmNsdWRlTmFtZXNwYWNlSW5RdWVyeVBhcmFtcyk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHdlYnNvY2tldCBVUkwgZm9yIHRoaXMgcmVwb1xyXG4gKiBAcGFyYW0gcmVwb0luZm8gLSBSZXBvSW5mbyBvYmplY3RcclxuICogQHBhcmFtIHR5cGUgLSBvZiBjb25uZWN0aW9uXHJcbiAqIEBwYXJhbSBwYXJhbXMgLSBsaXN0XHJcbiAqIEByZXR1cm5zIFRoZSBVUkwgZm9yIHRoaXMgcmVwb1xyXG4gKi9cclxuZnVuY3Rpb24gcmVwb0luZm9Db25uZWN0aW9uVVJMKHJlcG9JbmZvLCB0eXBlLCBwYXJhbXMpIHtcclxuICAgIGFzc2VydCh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycsICd0eXBlb2YgdHlwZSBtdXN0ID09IHN0cmluZycpO1xyXG4gICAgYXNzZXJ0KHR5cGVvZiBwYXJhbXMgPT09ICdvYmplY3QnLCAndHlwZW9mIHBhcmFtcyBtdXN0ID09IG9iamVjdCcpO1xyXG4gICAgbGV0IGNvbm5VUkw7XHJcbiAgICBpZiAodHlwZSA9PT0gV0VCU09DS0VUKSB7XHJcbiAgICAgICAgY29ublVSTCA9XHJcbiAgICAgICAgICAgIChyZXBvSW5mby5zZWN1cmUgPyAnd3NzOi8vJyA6ICd3czovLycpICsgcmVwb0luZm8uaW50ZXJuYWxIb3N0ICsgJy8ud3M/JztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGUgPT09IExPTkdfUE9MTElORykge1xyXG4gICAgICAgIGNvbm5VUkwgPVxyXG4gICAgICAgICAgICAocmVwb0luZm8uc2VjdXJlID8gJ2h0dHBzOi8vJyA6ICdodHRwOi8vJykgK1xyXG4gICAgICAgICAgICAgICAgcmVwb0luZm8uaW50ZXJuYWxIb3N0ICtcclxuICAgICAgICAgICAgICAgICcvLmxwPyc7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY29ubmVjdGlvbiB0eXBlOiAnICsgdHlwZSk7XHJcbiAgICB9XHJcbiAgICBpZiAocmVwb0luZm9OZWVkc1F1ZXJ5UGFyYW0ocmVwb0luZm8pKSB7XHJcbiAgICAgICAgcGFyYW1zWyducyddID0gcmVwb0luZm8ubmFtZXNwYWNlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcGFpcnMgPSBbXTtcclxuICAgIGVhY2gocGFyYW1zLCAoa2V5LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgIHBhaXJzLnB1c2goa2V5ICsgJz0nICsgdmFsdWUpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gY29ublVSTCArIHBhaXJzLmpvaW4oJyYnKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVHJhY2tzIGEgY29sbGVjdGlvbiBvZiBzdGF0cy5cclxuICovXHJcbmNsYXNzIFN0YXRzQ29sbGVjdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmNvdW50ZXJzXyA9IHt9O1xyXG4gICAgfVxyXG4gICAgaW5jcmVtZW50Q291bnRlcihuYW1lLCBhbW91bnQgPSAxKSB7XHJcbiAgICAgICAgaWYgKCFjb250YWlucyh0aGlzLmNvdW50ZXJzXywgbmFtZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5jb3VudGVyc19bbmFtZV0gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvdW50ZXJzX1tuYW1lXSArPSBhbW91bnQ7XHJcbiAgICB9XHJcbiAgICBnZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZXBDb3B5KHRoaXMuY291bnRlcnNfKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBjb2xsZWN0aW9ucyA9IHt9O1xyXG5jb25zdCByZXBvcnRlcnMgPSB7fTtcclxuZnVuY3Rpb24gc3RhdHNNYW5hZ2VyR2V0Q29sbGVjdGlvbihyZXBvSW5mbykge1xyXG4gICAgY29uc3QgaGFzaFN0cmluZyA9IHJlcG9JbmZvLnRvU3RyaW5nKCk7XHJcbiAgICBpZiAoIWNvbGxlY3Rpb25zW2hhc2hTdHJpbmddKSB7XHJcbiAgICAgICAgY29sbGVjdGlvbnNbaGFzaFN0cmluZ10gPSBuZXcgU3RhdHNDb2xsZWN0aW9uKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29sbGVjdGlvbnNbaGFzaFN0cmluZ107XHJcbn1cclxuZnVuY3Rpb24gc3RhdHNNYW5hZ2VyR2V0T3JDcmVhdGVSZXBvcnRlcihyZXBvSW5mbywgY3JlYXRvckZ1bmN0aW9uKSB7XHJcbiAgICBjb25zdCBoYXNoU3RyaW5nID0gcmVwb0luZm8udG9TdHJpbmcoKTtcclxuICAgIGlmICghcmVwb3J0ZXJzW2hhc2hTdHJpbmddKSB7XHJcbiAgICAgICAgcmVwb3J0ZXJzW2hhc2hTdHJpbmddID0gY3JlYXRvckZ1bmN0aW9uKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVwb3J0ZXJzW2hhc2hTdHJpbmddO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKiBUaGUgc2VtdmVyICh3d3cuc2VtdmVyLm9yZykgdmVyc2lvbiBvZiB0aGUgU0RLLiAqL1xyXG5sZXQgU0RLX1ZFUlNJT04gPSAnJztcclxuLyoqXHJcbiAqIFNES19WRVJTSU9OIHNob3VsZCBiZSBzZXQgYmVmb3JlIGFueSBkYXRhYmFzZSBpbnN0YW5jZSBpcyBjcmVhdGVkXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gc2V0U0RLVmVyc2lvbih2ZXJzaW9uKSB7XHJcbiAgICBTREtfVkVSU0lPTiA9IHZlcnNpb247XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgV0VCU09DS0VUX01BWF9GUkFNRV9TSVpFID0gMTYzODQ7XHJcbmNvbnN0IFdFQlNPQ0tFVF9LRUVQQUxJVkVfSU5URVJWQUwgPSA0NTAwMDtcclxubGV0IFdlYlNvY2tldEltcGwgPSBudWxsO1xyXG5pZiAodHlwZW9mIE1veldlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIFdlYlNvY2tldEltcGwgPSBNb3pXZWJTb2NrZXQ7XHJcbn1cclxuZWxzZSBpZiAodHlwZW9mIFdlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIFdlYlNvY2tldEltcGwgPSBXZWJTb2NrZXQ7XHJcbn1cclxuZnVuY3Rpb24gc2V0V2ViU29ja2V0SW1wbChpbXBsKSB7XHJcbiAgICBXZWJTb2NrZXRJbXBsID0gaW1wbDtcclxufVxyXG4vKipcclxuICogQ3JlYXRlIGEgbmV3IHdlYnNvY2tldCBjb25uZWN0aW9uIHdpdGggdGhlIGdpdmVuIGNhbGxiYWNrcy5cclxuICovXHJcbmNsYXNzIFdlYlNvY2tldENvbm5lY3Rpb24ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gY29ubklkIGlkZW50aWZpZXIgZm9yIHRoaXMgdHJhbnNwb3J0XHJcbiAgICAgKiBAcGFyYW0gcmVwb0luZm8gVGhlIGluZm8gZm9yIHRoZSB3ZWJzb2NrZXQgZW5kcG9pbnQuXHJcbiAgICAgKiBAcGFyYW0gYXBwbGljYXRpb25JZCBUaGUgRmlyZWJhc2UgQXBwIElEIGZvciB0aGlzIHByb2plY3QuXHJcbiAgICAgKiBAcGFyYW0gYXBwQ2hlY2tUb2tlbiBUaGUgQXBwIENoZWNrIFRva2VuIGZvciB0aGlzIGNsaWVudC5cclxuICAgICAqIEBwYXJhbSBhdXRoVG9rZW4gVGhlIEF1dGggVG9rZW4gZm9yIHRoaXMgY2xpZW50LlxyXG4gICAgICogQHBhcmFtIHRyYW5zcG9ydFNlc3Npb25JZCBPcHRpb25hbCB0cmFuc3BvcnRTZXNzaW9uSWQgaWYgdGhpcyBpcyBjb25uZWN0aW5nXHJcbiAgICAgKiB0byBhbiBleGlzdGluZyB0cmFuc3BvcnQgc2Vzc2lvblxyXG4gICAgICogQHBhcmFtIGxhc3RTZXNzaW9uSWQgT3B0aW9uYWwgbGFzdFNlc3Npb25JZCBpZiB0aGVyZSB3YXMgYSBwcmV2aW91c1xyXG4gICAgICogY29ubmVjdGlvblxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb25uSWQsIHJlcG9JbmZvLCBhcHBsaWNhdGlvbklkLCBhcHBDaGVja1Rva2VuLCBhdXRoVG9rZW4sIHRyYW5zcG9ydFNlc3Npb25JZCwgbGFzdFNlc3Npb25JZCkge1xyXG4gICAgICAgIHRoaXMuY29ubklkID0gY29ubklkO1xyXG4gICAgICAgIHRoaXMuYXBwbGljYXRpb25JZCA9IGFwcGxpY2F0aW9uSWQ7XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja1Rva2VuID0gYXBwQ2hlY2tUb2tlbjtcclxuICAgICAgICB0aGlzLmF1dGhUb2tlbiA9IGF1dGhUb2tlbjtcclxuICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLmZyYW1lcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy50b3RhbEZyYW1lcyA9IDA7XHJcbiAgICAgICAgdGhpcy5ieXRlc1NlbnQgPSAwO1xyXG4gICAgICAgIHRoaXMuYnl0ZXNSZWNlaXZlZCA9IDA7XHJcbiAgICAgICAgdGhpcy5sb2dfID0gbG9nV3JhcHBlcih0aGlzLmNvbm5JZCk7XHJcbiAgICAgICAgdGhpcy5zdGF0c18gPSBzdGF0c01hbmFnZXJHZXRDb2xsZWN0aW9uKHJlcG9JbmZvKTtcclxuICAgICAgICB0aGlzLmNvbm5VUkwgPSBXZWJTb2NrZXRDb25uZWN0aW9uLmNvbm5lY3Rpb25VUkxfKHJlcG9JbmZvLCB0cmFuc3BvcnRTZXNzaW9uSWQsIGxhc3RTZXNzaW9uSWQsIGFwcENoZWNrVG9rZW4sIGFwcGxpY2F0aW9uSWQpO1xyXG4gICAgICAgIHRoaXMubm9kZUFkbWluID0gcmVwb0luZm8ubm9kZUFkbWluO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gcmVwb0luZm8gLSBUaGUgaW5mbyBmb3IgdGhlIHdlYnNvY2tldCBlbmRwb2ludC5cclxuICAgICAqIEBwYXJhbSB0cmFuc3BvcnRTZXNzaW9uSWQgLSBPcHRpb25hbCB0cmFuc3BvcnRTZXNzaW9uSWQgaWYgdGhpcyBpcyBjb25uZWN0aW5nIHRvIGFuIGV4aXN0aW5nIHRyYW5zcG9ydFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25cclxuICAgICAqIEBwYXJhbSBsYXN0U2Vzc2lvbklkIC0gT3B0aW9uYWwgbGFzdFNlc3Npb25JZCBpZiB0aGVyZSB3YXMgYSBwcmV2aW91cyBjb25uZWN0aW9uXHJcbiAgICAgKiBAcmV0dXJucyBjb25uZWN0aW9uIHVybFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY29ubmVjdGlvblVSTF8ocmVwb0luZm8sIHRyYW5zcG9ydFNlc3Npb25JZCwgbGFzdFNlc3Npb25JZCwgYXBwQ2hlY2tUb2tlbiwgYXBwbGljYXRpb25JZCkge1xyXG4gICAgICAgIGNvbnN0IHVybFBhcmFtcyA9IHt9O1xyXG4gICAgICAgIHVybFBhcmFtc1tWRVJTSU9OX1BBUkFNXSA9IFBST1RPQ09MX1ZFUlNJT047XHJcbiAgICAgICAgaWYgKCFpc05vZGVTZGsoKSAmJlxyXG4gICAgICAgICAgICB0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgICAgIGxvY2F0aW9uLmhvc3RuYW1lICYmXHJcbiAgICAgICAgICAgIEZPUkdFX0RPTUFJTl9SRS50ZXN0KGxvY2F0aW9uLmhvc3RuYW1lKSkge1xyXG4gICAgICAgICAgICB1cmxQYXJhbXNbUkVGRVJFUl9QQVJBTV0gPSBGT1JHRV9SRUY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0cmFuc3BvcnRTZXNzaW9uSWQpIHtcclxuICAgICAgICAgICAgdXJsUGFyYW1zW1RSQU5TUE9SVF9TRVNTSU9OX1BBUkFNXSA9IHRyYW5zcG9ydFNlc3Npb25JZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhc3RTZXNzaW9uSWQpIHtcclxuICAgICAgICAgICAgdXJsUGFyYW1zW0xBU1RfU0VTU0lPTl9QQVJBTV0gPSBsYXN0U2Vzc2lvbklkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYXBwQ2hlY2tUb2tlbikge1xyXG4gICAgICAgICAgICB1cmxQYXJhbXNbQVBQX0NIRUNLX1RPS0VOX1BBUkFNXSA9IGFwcENoZWNrVG9rZW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhcHBsaWNhdGlvbklkKSB7XHJcbiAgICAgICAgICAgIHVybFBhcmFtc1tBUFBMSUNBVElPTl9JRF9QQVJBTV0gPSBhcHBsaWNhdGlvbklkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVwb0luZm9Db25uZWN0aW9uVVJMKHJlcG9JbmZvLCBXRUJTT0NLRVQsIHVybFBhcmFtcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBvbk1lc3NhZ2UgLSBDYWxsYmFjayB3aGVuIG1lc3NhZ2VzIGFycml2ZVxyXG4gICAgICogQHBhcmFtIG9uRGlzY29ubmVjdCAtIENhbGxiYWNrIHdpdGggY29ubmVjdGlvbiBsb3N0LlxyXG4gICAgICovXHJcbiAgICBvcGVuKG9uTWVzc2FnZSwgb25EaXNjb25uZWN0KSB7XHJcbiAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3QgPSBvbkRpc2Nvbm5lY3Q7XHJcbiAgICAgICAgdGhpcy5vbk1lc3NhZ2UgPSBvbk1lc3NhZ2U7XHJcbiAgICAgICAgdGhpcy5sb2dfKCdXZWJzb2NrZXQgY29ubmVjdGluZyB0byAnICsgdGhpcy5jb25uVVJMKTtcclxuICAgICAgICB0aGlzLmV2ZXJDb25uZWN0ZWRfID0gZmFsc2U7XHJcbiAgICAgICAgLy8gQXNzdW1lIGZhaWx1cmUgdW50aWwgcHJvdmVuIG90aGVyd2lzZS5cclxuICAgICAgICBQZXJzaXN0ZW50U3RvcmFnZS5zZXQoJ3ByZXZpb3VzX3dlYnNvY2tldF9mYWlsdXJlJywgdHJ1ZSk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbGV0IG9wdGlvbnM7XHJcbiAgICAgICAgICAgIGlmIChpc05vZGVTZGsoKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGV2aWNlID0gdGhpcy5ub2RlQWRtaW4gPyAnQWRtaW5Ob2RlJyA6ICdOb2RlJztcclxuICAgICAgICAgICAgICAgIC8vIFVBIEZvcm1hdDogRmlyZWJhc2UvPHdpcmVfcHJvdG9jb2w+LzxzZGtfdmVyc2lvbj4vPHBsYXRmb3JtPi88ZGV2aWNlPlxyXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdVc2VyLUFnZW50JzogYEZpcmViYXNlLyR7UFJPVE9DT0xfVkVSU0lPTn0vJHtTREtfVkVSU0lPTn0vJHtwcm9jZXNzLnBsYXRmb3JtfS8ke2RldmljZX1gLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnWC1GaXJlYmFzZS1HTVBJRCc6IHRoaXMuYXBwbGljYXRpb25JZCB8fCAnJ1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB1c2luZyBOb2RlIHdpdGggYWRtaW4gY3JlZHMsIEFwcENoZWNrLXJlbGF0ZWQgY2hlY2tzIGFyZSB1bm5lY2Vzc2FyeS5cclxuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB3ZSBzZW5kIHRoZSBjcmVkZW50aWFscyBoZXJlIGV2ZW4gaWYgdGhleSBhcmVuJ3QgYWRtaW4gY3JlZGVudGlhbHMsIHdoaWNoIGlzXHJcbiAgICAgICAgICAgICAgICAvLyBub3QgYSBwcm9ibGVtLlxyXG4gICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgaGVhZGVyIGlzIGp1c3QgdXNlZCB0byBieXBhc3MgYXBwY2hlY2ssIGFuZCB0aGUgdG9rZW4gc2hvdWxkIHN0aWxsIGJlIHNlbnRcclxuICAgICAgICAgICAgICAgIC8vIHRocm91Z2ggdGhlIHdlYnNvY2tldCBjb25uZWN0aW9uIG9uY2UgaXQgaXMgZXN0YWJsaXNoZWQuXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdXRoVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9IGBCZWFyZXIgJHt0aGlzLmF1dGhUb2tlbn1gO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXBwQ2hlY2tUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVyc1snWC1GaXJlYmFzZS1BcHBDaGVjayddID0gdGhpcy5hcHBDaGVja1Rva2VuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gUGx1bWIgYXBwcm9wcmlhdGUgaHR0cF9wcm94eSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpbnRvIGZheWUtd2Vic29ja2V0IGlmIGl0IGV4aXN0cy5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGVudiA9IHByb2Nlc3NbJ2VudiddO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJveHkgPSB0aGlzLmNvbm5VUkwuaW5kZXhPZignd3NzOi8vJykgPT09IDBcclxuICAgICAgICAgICAgICAgICAgICA/IGVudlsnSFRUUFNfUFJPWFknXSB8fCBlbnZbJ2h0dHBzX3Byb3h5J11cclxuICAgICAgICAgICAgICAgICAgICA6IGVudlsnSFRUUF9QUk9YWSddIHx8IGVudlsnaHR0cF9wcm94eSddO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb3h5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1sncHJveHknXSA9IHsgb3JpZ2luOiBwcm94eSB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubXlTb2NrID0gbmV3IFdlYlNvY2tldEltcGwodGhpcy5jb25uVVJMLCBbXSwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnRXJyb3IgaW5zdGFudGlhdGluZyBXZWJTb2NrZXQuJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gZS5tZXNzYWdlIHx8IGUuZGF0YTtcclxuICAgICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ18oZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMub25DbG9zZWRfKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5teVNvY2sub25vcGVuID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ1dlYnNvY2tldCBjb25uZWN0ZWQuJyk7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlckNvbm5lY3RlZF8gPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5teVNvY2sub25jbG9zZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdXZWJzb2NrZXQgY29ubmVjdGlvbiB3YXMgZGlzY29ubmVjdGVkLicpO1xyXG4gICAgICAgICAgICB0aGlzLm15U29jayA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMub25DbG9zZWRfKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLm15U29jay5vbm1lc3NhZ2UgPSBtID0+IHtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVJbmNvbWluZ0ZyYW1lKG0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5teVNvY2sub25lcnJvciA9IGUgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ1dlYlNvY2tldCBlcnJvci4gIENsb3NpbmcgY29ubmVjdGlvbi4nKTtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBlLm1lc3NhZ2UgfHwgZS5kYXRhO1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nXyhlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5vbkNsb3NlZF8oKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBOby1vcCBmb3Igd2Vic29ja2V0cywgd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZyBvbmNlIHRoZSBjb25uZWN0aW9uIGlzIGNvbmZpcm1lZCBhcyBvcGVuXHJcbiAgICAgKi9cclxuICAgIHN0YXJ0KCkgeyB9XHJcbiAgICBzdGF0aWMgZm9yY2VEaXNhbGxvdygpIHtcclxuICAgICAgICBXZWJTb2NrZXRDb25uZWN0aW9uLmZvcmNlRGlzYWxsb3dfID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBpc0F2YWlsYWJsZSgpIHtcclxuICAgICAgICBsZXQgaXNPbGRBbmRyb2lkID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQpIHtcclxuICAgICAgICAgICAgY29uc3Qgb2xkQW5kcm9pZFJlZ2V4ID0gL0FuZHJvaWQgKFswLTldezAsfVxcLlswLTldezAsfSkvO1xyXG4gICAgICAgICAgICBjb25zdCBvbGRBbmRyb2lkTWF0Y2ggPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKG9sZEFuZHJvaWRSZWdleCk7XHJcbiAgICAgICAgICAgIGlmIChvbGRBbmRyb2lkTWF0Y2ggJiYgb2xkQW5kcm9pZE1hdGNoLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJzZUZsb2F0KG9sZEFuZHJvaWRNYXRjaFsxXSkgPCA0LjQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpc09sZEFuZHJvaWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoIWlzT2xkQW5kcm9pZCAmJlxyXG4gICAgICAgICAgICBXZWJTb2NrZXRJbXBsICE9PSBudWxsICYmXHJcbiAgICAgICAgICAgICFXZWJTb2NrZXRDb25uZWN0aW9uLmZvcmNlRGlzYWxsb3dfKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHdlIHByZXZpb3VzbHkgZmFpbGVkIHRvIGNvbm5lY3Qgd2l0aCB0aGlzIHRyYW5zcG9ydC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHByZXZpb3VzbHlGYWlsZWQoKSB7XHJcbiAgICAgICAgLy8gSWYgb3VyIHBlcnNpc3RlbnQgc3RvcmFnZSBpcyBhY3R1YWxseSBvbmx5IGluLW1lbW9yeSBzdG9yYWdlLFxyXG4gICAgICAgIC8vIHdlIGRlZmF1bHQgdG8gYXNzdW1pbmcgdGhhdCBpdCBwcmV2aW91c2x5IGZhaWxlZCB0byBiZSBzYWZlLlxyXG4gICAgICAgIHJldHVybiAoUGVyc2lzdGVudFN0b3JhZ2UuaXNJbk1lbW9yeVN0b3JhZ2UgfHxcclxuICAgICAgICAgICAgUGVyc2lzdGVudFN0b3JhZ2UuZ2V0KCdwcmV2aW91c193ZWJzb2NrZXRfZmFpbHVyZScpID09PSB0cnVlKTtcclxuICAgIH1cclxuICAgIG1hcmtDb25uZWN0aW9uSGVhbHRoeSgpIHtcclxuICAgICAgICBQZXJzaXN0ZW50U3RvcmFnZS5yZW1vdmUoJ3ByZXZpb3VzX3dlYnNvY2tldF9mYWlsdXJlJyk7XHJcbiAgICB9XHJcbiAgICBhcHBlbmRGcmFtZV8oZGF0YSkge1xyXG4gICAgICAgIHRoaXMuZnJhbWVzLnB1c2goZGF0YSk7XHJcbiAgICAgICAgaWYgKHRoaXMuZnJhbWVzLmxlbmd0aCA9PT0gdGhpcy50b3RhbEZyYW1lcykge1xyXG4gICAgICAgICAgICBjb25zdCBmdWxsTWVzcyA9IHRoaXMuZnJhbWVzLmpvaW4oJycpO1xyXG4gICAgICAgICAgICB0aGlzLmZyYW1lcyA9IG51bGw7XHJcbiAgICAgICAgICAgIGNvbnN0IGpzb25NZXNzID0ganNvbkV2YWwoZnVsbE1lc3MpO1xyXG4gICAgICAgICAgICAvL2hhbmRsZSB0aGUgbWVzc2FnZVxyXG4gICAgICAgICAgICB0aGlzLm9uTWVzc2FnZShqc29uTWVzcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gZnJhbWVDb3VudCAtIFRoZSBudW1iZXIgb2YgZnJhbWVzIHdlIGFyZSBleHBlY3RpbmcgZnJvbSB0aGUgc2VydmVyXHJcbiAgICAgKi9cclxuICAgIGhhbmRsZU5ld0ZyYW1lQ291bnRfKGZyYW1lQ291bnQpIHtcclxuICAgICAgICB0aGlzLnRvdGFsRnJhbWVzID0gZnJhbWVDb3VudDtcclxuICAgICAgICB0aGlzLmZyYW1lcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBdHRlbXB0cyB0byBwYXJzZSBhIGZyYW1lIGNvdW50IG91dCBvZiBzb21lIHRleHQuIElmIGl0IGNhbid0LCBhc3N1bWVzIGEgdmFsdWUgb2YgMVxyXG4gICAgICogQHJldHVybnMgQW55IHJlbWFpbmluZyBkYXRhIHRvIGJlIHByb2Nlc3MsIG9yIG51bGwgaWYgdGhlcmUgaXMgbm9uZVxyXG4gICAgICovXHJcbiAgICBleHRyYWN0RnJhbWVDb3VudF8oZGF0YSkge1xyXG4gICAgICAgIGFzc2VydCh0aGlzLmZyYW1lcyA9PT0gbnVsbCwgJ1dlIGFscmVhZHkgaGF2ZSBhIGZyYW1lIGJ1ZmZlcicpO1xyXG4gICAgICAgIC8vIFRPRE86IFRoZSBzZXJ2ZXIgaXMgb25seSBzdXBwb3NlZCB0byBzZW5kIHVwIHRvIDk5OTkgZnJhbWVzIChpLmUuIGxlbmd0aCA8PSA0KSwgYnV0IHRoYXQgaXNuJ3QgYmVpbmcgZW5mb3JjZWRcclxuICAgICAgICAvLyBjdXJyZW50bHkuICBTbyBhbGxvd2luZyBsYXJnZXIgZnJhbWUgY291bnRzIChsZW5ndGggPD0gNikuICBTZWUgaHR0cHM6Ly9hcHAuYXNhbmEuY29tLzAvc2VhcmNoLzg2ODg1OTg5OTgzODAvODIzNzYwODA0MjUwOFxyXG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8PSA2KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZyYW1lQ291bnQgPSBOdW1iZXIoZGF0YSk7XHJcbiAgICAgICAgICAgIGlmICghaXNOYU4oZnJhbWVDb3VudCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlTmV3RnJhbWVDb3VudF8oZnJhbWVDb3VudCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmhhbmRsZU5ld0ZyYW1lQ291bnRfKDEpO1xyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9jZXNzIGEgd2Vic29ja2V0IGZyYW1lIHRoYXQgaGFzIGFycml2ZWQgZnJvbSB0aGUgc2VydmVyLlxyXG4gICAgICogQHBhcmFtIG1lc3MgLSBUaGUgZnJhbWUgZGF0YVxyXG4gICAgICovXHJcbiAgICBoYW5kbGVJbmNvbWluZ0ZyYW1lKG1lc3MpIHtcclxuICAgICAgICBpZiAodGhpcy5teVNvY2sgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuOyAvLyBDaHJvbWUgYXBwYXJlbnRseSBkZWxpdmVycyBpbmNvbWluZyBwYWNrZXRzIGV2ZW4gYWZ0ZXIgd2UgLmNsb3NlKCkgdGhlIGNvbm5lY3Rpb24gc29tZXRpbWVzLlxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkYXRhID0gbWVzc1snZGF0YSddO1xyXG4gICAgICAgIHRoaXMuYnl0ZXNSZWNlaXZlZCArPSBkYXRhLmxlbmd0aDtcclxuICAgICAgICB0aGlzLnN0YXRzXy5pbmNyZW1lbnRDb3VudGVyKCdieXRlc19yZWNlaXZlZCcsIGRhdGEubGVuZ3RoKTtcclxuICAgICAgICB0aGlzLnJlc2V0S2VlcEFsaXZlKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuZnJhbWVzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIHdlJ3JlIGJ1ZmZlcmluZ1xyXG4gICAgICAgICAgICB0aGlzLmFwcGVuZEZyYW1lXyhkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHRyeSB0byBwYXJzZSBvdXQgYSBmcmFtZSBjb3VudCwgb3RoZXJ3aXNlLCBhc3N1bWUgMSBhbmQgcHJvY2VzcyBpdFxyXG4gICAgICAgICAgICBjb25zdCByZW1haW5pbmdEYXRhID0gdGhpcy5leHRyYWN0RnJhbWVDb3VudF8oZGF0YSk7XHJcbiAgICAgICAgICAgIGlmIChyZW1haW5pbmdEYXRhICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZEZyYW1lXyhyZW1haW5pbmdEYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2VuZCBhIG1lc3NhZ2UgdG8gdGhlIHNlcnZlclxyXG4gICAgICogQHBhcmFtIGRhdGEgLSBUaGUgSlNPTiBvYmplY3QgdG8gdHJhbnNtaXRcclxuICAgICAqL1xyXG4gICAgc2VuZChkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5yZXNldEtlZXBBbGl2ZSgpO1xyXG4gICAgICAgIGNvbnN0IGRhdGFTdHIgPSBzdHJpbmdpZnkoZGF0YSk7XHJcbiAgICAgICAgdGhpcy5ieXRlc1NlbnQgKz0gZGF0YVN0ci5sZW5ndGg7XHJcbiAgICAgICAgdGhpcy5zdGF0c18uaW5jcmVtZW50Q291bnRlcignYnl0ZXNfc2VudCcsIGRhdGFTdHIubGVuZ3RoKTtcclxuICAgICAgICAvL1dlIGNhbiBvbmx5IGZpdCBhIGNlcnRhaW4gYW1vdW50IGluIGVhY2ggd2Vic29ja2V0IGZyYW1lLCBzbyB3ZSBuZWVkIHRvIHNwbGl0IHRoaXMgcmVxdWVzdFxyXG4gICAgICAgIC8vdXAgaW50byBtdWx0aXBsZSBwaWVjZXMgaWYgaXQgZG9lc24ndCBmaXQgaW4gb25lIHJlcXVlc3QuXHJcbiAgICAgICAgY29uc3QgZGF0YVNlZ3MgPSBzcGxpdFN0cmluZ0J5U2l6ZShkYXRhU3RyLCBXRUJTT0NLRVRfTUFYX0ZSQU1FX1NJWkUpO1xyXG4gICAgICAgIC8vU2VuZCB0aGUgbGVuZ3RoIGhlYWRlclxyXG4gICAgICAgIGlmIChkYXRhU2Vncy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZFN0cmluZ18oU3RyaW5nKGRhdGFTZWdzLmxlbmd0aCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL1NlbmQgdGhlIGFjdHVhbCBkYXRhIGluIHNlZ21lbnRzLlxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YVNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kU3RyaW5nXyhkYXRhU2Vnc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2h1dGRvd25fKCkge1xyXG4gICAgICAgIHRoaXMuaXNDbG9zZWRfID0gdHJ1ZTtcclxuICAgICAgICBpZiAodGhpcy5rZWVwYWxpdmVUaW1lcikge1xyXG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMua2VlcGFsaXZlVGltZXIpO1xyXG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVyID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubXlTb2NrKSB7XHJcbiAgICAgICAgICAgIHRoaXMubXlTb2NrLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIHRoaXMubXlTb2NrID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvbkNsb3NlZF8oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzQ2xvc2VkXykge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ1dlYlNvY2tldCBpcyBjbG9zaW5nIGl0c2VsZicpO1xyXG4gICAgICAgICAgICB0aGlzLnNodXRkb3duXygpO1xyXG4gICAgICAgICAgICAvLyBzaW5jZSB0aGlzIGlzIGFuIGludGVybmFsIGNsb3NlLCB0cmlnZ2VyIHRoZSBjbG9zZSBsaXN0ZW5lclxyXG4gICAgICAgICAgICBpZiAodGhpcy5vbkRpc2Nvbm5lY3QpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub25EaXNjb25uZWN0KHRoaXMuZXZlckNvbm5lY3RlZF8pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3QgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHRlcm5hbC1mYWNpbmcgY2xvc2UgaGFuZGxlci5cclxuICAgICAqIENsb3NlIHRoZSB3ZWJzb2NrZXQgYW5kIGtpbGwgdGhlIGNvbm5lY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGNsb3NlKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc0Nsb3NlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdXZWJTb2NrZXQgaXMgYmVpbmcgY2xvc2VkJyk7XHJcbiAgICAgICAgICAgIHRoaXMuc2h1dGRvd25fKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBLaWxsIHRoZSBjdXJyZW50IGtlZXBhbGl2ZSB0aW1lciBhbmQgc3RhcnQgYSBuZXcgb25lLCB0byBlbnN1cmUgdGhhdCBpdCBhbHdheXMgZmlyZXMgTiBzZWNvbmRzIGFmdGVyXHJcbiAgICAgKiB0aGUgbGFzdCBhY3Rpdml0eS5cclxuICAgICAqL1xyXG4gICAgcmVzZXRLZWVwQWxpdmUoKSB7XHJcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmtlZXBhbGl2ZVRpbWVyKTtcclxuICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xyXG4gICAgICAgICAgICAvL0lmIHRoZXJlIGhhcyBiZWVuIG5vIHdlYnNvY2tldCBhY3Rpdml0eSBmb3IgYSB3aGlsZSwgc2VuZCBhIG5vLW9wXHJcbiAgICAgICAgICAgIGlmICh0aGlzLm15U29jaykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kU3RyaW5nXygnMCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucmVzZXRLZWVwQWxpdmUoKTtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICB9LCBNYXRoLmZsb29yKFdFQlNPQ0tFVF9LRUVQQUxJVkVfSU5URVJWQUwpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2VuZCBhIHN0cmluZyBvdmVyIHRoZSB3ZWJzb2NrZXQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN0ciAtIFN0cmluZyB0byBzZW5kLlxyXG4gICAgICovXHJcbiAgICBzZW5kU3RyaW5nXyhzdHIpIHtcclxuICAgICAgICAvLyBGaXJlZm94IHNlZW1zIHRvIHNvbWV0aW1lcyB0aHJvdyBleGNlcHRpb25zIChOU19FUlJPUl9VTkVYUEVDVEVEKSBmcm9tIHdlYnNvY2tldCAuc2VuZCgpXHJcbiAgICAgICAgLy8gY2FsbHMgZm9yIHNvbWUgdW5rbm93biByZWFzb24uICBXZSB0cmVhdCB0aGVzZSBhcyBhbiBlcnJvciBhbmQgZGlzY29ubmVjdC5cclxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9hcHAuYXNhbmEuY29tLzAvNTg5MjYxMTE0MDIyOTIvNjgwMjEzNDAyNTA0MTBcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB0aGlzLm15U29jay5zZW5kKHN0cik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnRXhjZXB0aW9uIHRocm93biBmcm9tIFdlYlNvY2tldC5zZW5kKCk6JywgZS5tZXNzYWdlIHx8IGUuZGF0YSwgJ0Nsb3NpbmcgY29ubmVjdGlvbi4nKTtcclxuICAgICAgICAgICAgc2V0VGltZW91dCh0aGlzLm9uQ2xvc2VkXy5iaW5kKHRoaXMpLCAwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIE51bWJlciBvZiByZXNwb25zZSBiZWZvcmUgd2UgY29uc2lkZXIgdGhlIGNvbm5lY3Rpb24gXCJoZWFsdGh5LlwiXHJcbiAqL1xyXG5XZWJTb2NrZXRDb25uZWN0aW9uLnJlc3BvbnNlc1JlcXVpcmVkVG9CZUhlYWx0aHkgPSAyO1xyXG4vKipcclxuICogVGltZSB0byB3YWl0IGZvciB0aGUgY29ubmVjdGlvbiB0ZSBiZWNvbWUgaGVhbHRoeSBiZWZvcmUgZ2l2aW5nIHVwLlxyXG4gKi9cclxuV2ViU29ja2V0Q29ubmVjdGlvbi5oZWFsdGh5VGltZW91dCA9IDMwMDAwO1xuXG5jb25zdCBuYW1lID0gXCJAZmlyZWJhc2UvZGF0YWJhc2VcIjtcbmNvbnN0IHZlcnNpb24gPSBcIjEuMC4zXCI7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBYnN0cmFjdGlvbiBhcm91bmQgQXBwQ2hlY2sncyB0b2tlbiBmZXRjaGluZyBjYXBhYmlsaXRpZXMuXHJcbiAqL1xyXG5jbGFzcyBBcHBDaGVja1Rva2VuUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IoYXBwTmFtZV8sIGFwcENoZWNrUHJvdmlkZXIpIHtcclxuICAgICAgICB0aGlzLmFwcE5hbWVfID0gYXBwTmFtZV87XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja1Byb3ZpZGVyID0gYXBwQ2hlY2tQcm92aWRlcjtcclxuICAgICAgICB0aGlzLmFwcENoZWNrID0gYXBwQ2hlY2tQcm92aWRlciA9PT0gbnVsbCB8fCBhcHBDaGVja1Byb3ZpZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcHBDaGVja1Byb3ZpZGVyLmdldEltbWVkaWF0ZSh7IG9wdGlvbmFsOiB0cnVlIH0pO1xyXG4gICAgICAgIGlmICghdGhpcy5hcHBDaGVjaykge1xyXG4gICAgICAgICAgICBhcHBDaGVja1Byb3ZpZGVyID09PSBudWxsIHx8IGFwcENoZWNrUHJvdmlkZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFwcENoZWNrUHJvdmlkZXIuZ2V0KCkudGhlbihhcHBDaGVjayA9PiAodGhpcy5hcHBDaGVjayA9IGFwcENoZWNrKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0VG9rZW4oZm9yY2VSZWZyZXNoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmFwcENoZWNrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0IGRlbGF5ZWQgaW5pdGlhbGl6YXRpb24gb2YgRmlyZWJhc2VBcHBDaGVjay4gVGhpcyBhbGxvd3Mgb3VyXHJcbiAgICAgICAgICAgICAgICAvLyBjdXN0b21lcnMgdG8gaW5pdGlhbGl6ZSB0aGUgUlREQiBTREsgYmVmb3JlIGluaXRpYWxpemluZyBGaXJlYmFzZVxyXG4gICAgICAgICAgICAgICAgLy8gQXBwQ2hlY2sgYW5kIGVuc3VyZXMgdGhhdCBhbGwgcmVxdWVzdHMgYXJlIGF1dGhlbnRpY2F0ZWQgaWYgYSB0b2tlblxyXG4gICAgICAgICAgICAgICAgLy8gYmVjb21lcyBhdmFpbGFibGUgYmVmb3JlIHRoZSB0aW1vZW91dCBiZWxvdyBleHBpcmVzLlxyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXBwQ2hlY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRUb2tlbihmb3JjZVJlZnJlc2gpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5hcHBDaGVjay5nZXRUb2tlbihmb3JjZVJlZnJlc2gpO1xyXG4gICAgfVxyXG4gICAgYWRkVG9rZW5DaGFuZ2VMaXN0ZW5lcihsaXN0ZW5lcikge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICAoX2EgPSB0aGlzLmFwcENoZWNrUHJvdmlkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoKS50aGVuKGFwcENoZWNrID0+IGFwcENoZWNrLmFkZFRva2VuTGlzdGVuZXIobGlzdGVuZXIpKTtcclxuICAgIH1cclxuICAgIG5vdGlmeUZvckludmFsaWRUb2tlbigpIHtcclxuICAgICAgICB3YXJuKGBQcm92aWRlZCBBcHBDaGVjayBjcmVkZW50aWFscyBmb3IgdGhlIGFwcCBuYW1lZCBcIiR7dGhpcy5hcHBOYW1lX31cIiBgICtcclxuICAgICAgICAgICAgJ2FyZSBpbnZhbGlkLiBUaGlzIHVzdWFsbHkgaW5kaWNhdGVzIHlvdXIgYXBwIHdhcyBub3QgaW5pdGlhbGl6ZWQgY29ycmVjdGx5LicpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBYnN0cmFjdGlvbiBhcm91bmQgRmlyZWJhc2VBcHAncyB0b2tlbiBmZXRjaGluZyBjYXBhYmlsaXRpZXMuXHJcbiAqL1xyXG5jbGFzcyBGaXJlYmFzZUF1dGhUb2tlblByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGFwcE5hbWVfLCBmaXJlYmFzZU9wdGlvbnNfLCBhdXRoUHJvdmlkZXJfKSB7XHJcbiAgICAgICAgdGhpcy5hcHBOYW1lXyA9IGFwcE5hbWVfO1xyXG4gICAgICAgIHRoaXMuZmlyZWJhc2VPcHRpb25zXyA9IGZpcmViYXNlT3B0aW9uc187XHJcbiAgICAgICAgdGhpcy5hdXRoUHJvdmlkZXJfID0gYXV0aFByb3ZpZGVyXztcclxuICAgICAgICB0aGlzLmF1dGhfID0gbnVsbDtcclxuICAgICAgICB0aGlzLmF1dGhfID0gYXV0aFByb3ZpZGVyXy5nZXRJbW1lZGlhdGUoeyBvcHRpb25hbDogdHJ1ZSB9KTtcclxuICAgICAgICBpZiAoIXRoaXMuYXV0aF8pIHtcclxuICAgICAgICAgICAgYXV0aFByb3ZpZGVyXy5vbkluaXQoYXV0aCA9PiAodGhpcy5hdXRoXyA9IGF1dGgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRUb2tlbihmb3JjZVJlZnJlc2gpIHtcclxuICAgICAgICBpZiAoIXRoaXMuYXV0aF8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQgZGVsYXllZCBpbml0aWFsaXphdGlvbiBvZiBGaXJlYmFzZUF1dGguIFRoaXMgYWxsb3dzIG91clxyXG4gICAgICAgICAgICAgICAgLy8gY3VzdG9tZXJzIHRvIGluaXRpYWxpemUgdGhlIFJUREIgU0RLIGJlZm9yZSBpbml0aWFsaXppbmcgRmlyZWJhc2VcclxuICAgICAgICAgICAgICAgIC8vIEF1dGggYW5kIGVuc3VyZXMgdGhhdCBhbGwgcmVxdWVzdHMgYXJlIGF1dGhlbnRpY2F0ZWQgaWYgYSB0b2tlblxyXG4gICAgICAgICAgICAgICAgLy8gYmVjb21lcyBhdmFpbGFibGUgYmVmb3JlIHRoZSB0aW1vZW91dCBiZWxvdyBleHBpcmVzLlxyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXV0aF8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRUb2tlbihmb3JjZVJlZnJlc2gpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5hdXRoXy5nZXRUb2tlbihmb3JjZVJlZnJlc2gpLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgICAgLy8gVE9ETzogTmVlZCB0byBmaWd1cmUgb3V0IGFsbCB0aGUgY2FzZXMgdGhpcyBpcyByYWlzZWQgYW5kIHdoZXRoZXJcclxuICAgICAgICAgICAgLy8gdGhpcyBtYWtlcyBzZW5zZS5cclxuICAgICAgICAgICAgaWYgKGVycm9yICYmIGVycm9yLmNvZGUgPT09ICdhdXRoL3Rva2VuLW5vdC1pbml0aWFsaXplZCcpIHtcclxuICAgICAgICAgICAgICAgIGxvZygnR290IGF1dGgvdG9rZW4tbm90LWluaXRpYWxpemVkIGVycm9yLiAgVHJlYXRpbmcgYXMgbnVsbCB0b2tlbi4nKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgYWRkVG9rZW5DaGFuZ2VMaXN0ZW5lcihsaXN0ZW5lcikge1xyXG4gICAgICAgIC8vIFRPRE86IFdlIG1pZ2h0IHdhbnQgdG8gd3JhcCB0aGUgbGlzdGVuZXIgYW5kIGNhbGwgaXQgd2l0aCBubyBhcmdzIHRvXHJcbiAgICAgICAgLy8gYXZvaWQgYSBsZWFreSBhYnN0cmFjdGlvbiwgYnV0IHRoYXQgbWFrZXMgcmVtb3ZpbmcgdGhlIGxpc3RlbmVyIGhhcmRlci5cclxuICAgICAgICBpZiAodGhpcy5hdXRoXykge1xyXG4gICAgICAgICAgICB0aGlzLmF1dGhfLmFkZEF1dGhUb2tlbkxpc3RlbmVyKGxpc3RlbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXV0aFByb3ZpZGVyX1xyXG4gICAgICAgICAgICAgICAgLmdldCgpXHJcbiAgICAgICAgICAgICAgICAudGhlbihhdXRoID0+IGF1dGguYWRkQXV0aFRva2VuTGlzdGVuZXIobGlzdGVuZXIpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZW1vdmVUb2tlbkNoYW5nZUxpc3RlbmVyKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgdGhpcy5hdXRoUHJvdmlkZXJfXHJcbiAgICAgICAgICAgIC5nZXQoKVxyXG4gICAgICAgICAgICAudGhlbihhdXRoID0+IGF1dGgucmVtb3ZlQXV0aFRva2VuTGlzdGVuZXIobGlzdGVuZXIpKTtcclxuICAgIH1cclxuICAgIG5vdGlmeUZvckludmFsaWRUb2tlbigpIHtcclxuICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gJ1Byb3ZpZGVkIGF1dGhlbnRpY2F0aW9uIGNyZWRlbnRpYWxzIGZvciB0aGUgYXBwIG5hbWVkIFwiJyArXHJcbiAgICAgICAgICAgIHRoaXMuYXBwTmFtZV8gK1xyXG4gICAgICAgICAgICAnXCIgYXJlIGludmFsaWQuIFRoaXMgdXN1YWxseSBpbmRpY2F0ZXMgeW91ciBhcHAgd2FzIG5vdCAnICtcclxuICAgICAgICAgICAgJ2luaXRpYWxpemVkIGNvcnJlY3RseS4gJztcclxuICAgICAgICBpZiAoJ2NyZWRlbnRpYWwnIGluIHRoaXMuZmlyZWJhc2VPcHRpb25zXykge1xyXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz1cclxuICAgICAgICAgICAgICAgICdNYWtlIHN1cmUgdGhlIFwiY3JlZGVudGlhbFwiIHByb3BlcnR5IHByb3ZpZGVkIHRvIGluaXRpYWxpemVBcHAoKSAnICtcclxuICAgICAgICAgICAgICAgICAgICAnaXMgYXV0aG9yaXplZCB0byBhY2Nlc3MgdGhlIHNwZWNpZmllZCBcImRhdGFiYXNlVVJMXCIgYW5kIGlzIGZyb20gdGhlIGNvcnJlY3QgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ3Byb2plY3QuJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJ3NlcnZpY2VBY2NvdW50JyBpbiB0aGlzLmZpcmViYXNlT3B0aW9uc18pIHtcclxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9XHJcbiAgICAgICAgICAgICAgICAnTWFrZSBzdXJlIHRoZSBcInNlcnZpY2VBY2NvdW50XCIgcHJvcGVydHkgcHJvdmlkZWQgdG8gaW5pdGlhbGl6ZUFwcCgpICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdpcyBhdXRob3JpemVkIHRvIGFjY2VzcyB0aGUgc3BlY2lmaWVkIFwiZGF0YWJhc2VVUkxcIiBhbmQgaXMgZnJvbSB0aGUgY29ycmVjdCAnICtcclxuICAgICAgICAgICAgICAgICAgICAncHJvamVjdC4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9XHJcbiAgICAgICAgICAgICAgICAnTWFrZSBzdXJlIHRoZSBcImFwaUtleVwiIGFuZCBcImRhdGFiYXNlVVJMXCIgcHJvcGVydGllcyBwcm92aWRlZCB0byAnICtcclxuICAgICAgICAgICAgICAgICAgICAnaW5pdGlhbGl6ZUFwcCgpIG1hdGNoIHRoZSB2YWx1ZXMgcHJvdmlkZWQgZm9yIHlvdXIgYXBwIGF0ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2NvbnNvbGUuZmlyZWJhc2UuZ29vZ2xlLmNvbS8uJztcclxuICAgICAgICB9XHJcbiAgICAgICAgd2FybihlcnJvck1lc3NhZ2UpO1xyXG4gICAgfVxyXG59XHJcbi8qIEF1dGhUb2tlblByb3ZpZGVyIHRoYXQgc3VwcGxpZXMgYSBjb25zdGFudCB0b2tlbi4gVXNlZCBieSBBZG1pbiBTREsgb3IgbW9ja1VzZXJUb2tlbiB3aXRoIGVtdWxhdG9ycy4gKi9cclxuY2xhc3MgRW11bGF0b3JUb2tlblByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGFjY2Vzc1Rva2VuKSB7XHJcbiAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuO1xyXG4gICAgfVxyXG4gICAgZ2V0VG9rZW4oZm9yY2VSZWZyZXNoKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XHJcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuOiB0aGlzLmFjY2Vzc1Rva2VuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBhZGRUb2tlbkNoYW5nZUxpc3RlbmVyKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgLy8gSW52b2tlIHRoZSBsaXN0ZW5lciBpbW1lZGlhdGVseSB0byBtYXRjaCB0aGUgYmVoYXZpb3IgaW4gRmlyZWJhc2UgQXV0aFxyXG4gICAgICAgIC8vIChzZWUgcGFja2FnZXMvYXV0aC9zcmMvYXV0aC5qcyNMMTgwNylcclxuICAgICAgICBsaXN0ZW5lcih0aGlzLmFjY2Vzc1Rva2VuKTtcclxuICAgIH1cclxuICAgIHJlbW92ZVRva2VuQ2hhbmdlTGlzdGVuZXIobGlzdGVuZXIpIHsgfVxyXG4gICAgbm90aWZ5Rm9ySW52YWxpZFRva2VuKCkgeyB9XHJcbn1cclxuLyoqIEEgc3RyaW5nIHRoYXQgaXMgdHJlYXRlZCBhcyBhbiBhZG1pbiBhY2Nlc3MgdG9rZW4gYnkgdGhlIFJUREIgZW11bGF0b3IuIFVzZWQgYnkgQWRtaW4gU0RLLiAqL1xyXG5FbXVsYXRvclRva2VuUHJvdmlkZXIuT1dORVIgPSAnb3duZXInO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhpcyBjbGFzcyBlbnN1cmVzIHRoZSBwYWNrZXRzIGZyb20gdGhlIHNlcnZlciBhcnJpdmUgaW4gb3JkZXJcclxuICogVGhpcyBjbGFzcyB0YWtlcyBkYXRhIGZyb20gdGhlIHNlcnZlciBhbmQgZW5zdXJlcyBpdCBnZXRzIHBhc3NlZCBpbnRvIHRoZSBjYWxsYmFja3MgaW4gb3JkZXIuXHJcbiAqL1xyXG5jbGFzcyBQYWNrZXRSZWNlaXZlciB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBvbk1lc3NhZ2VfXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9uTWVzc2FnZV8pIHtcclxuICAgICAgICB0aGlzLm9uTWVzc2FnZV8gPSBvbk1lc3NhZ2VfO1xyXG4gICAgICAgIHRoaXMucGVuZGluZ1Jlc3BvbnNlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFJlc3BvbnNlTnVtID0gMDtcclxuICAgICAgICB0aGlzLmNsb3NlQWZ0ZXJSZXNwb25zZSA9IC0xO1xyXG4gICAgICAgIHRoaXMub25DbG9zZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBjbG9zZUFmdGVyKHJlc3BvbnNlTnVtLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMuY2xvc2VBZnRlclJlc3BvbnNlID0gcmVzcG9uc2VOdW07XHJcbiAgICAgICAgdGhpcy5vbkNsb3NlID0gY2FsbGJhY2s7XHJcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VBZnRlclJlc3BvbnNlIDwgdGhpcy5jdXJyZW50UmVzcG9uc2VOdW0pIHtcclxuICAgICAgICAgICAgdGhpcy5vbkNsb3NlKCk7XHJcbiAgICAgICAgICAgIHRoaXMub25DbG9zZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFYWNoIG1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyIGNvbWVzIHdpdGggYSByZXNwb25zZSBudW1iZXIsIGFuZCBhbiBhcnJheSBvZiBkYXRhLiBUaGUgcmVzcG9uc2VOdW1iZXJcclxuICAgICAqIGFsbG93cyB1cyB0byBlbnN1cmUgdGhhdCB3ZSBwcm9jZXNzIHRoZW0gaW4gdGhlIHJpZ2h0IG9yZGVyLCBzaW5jZSB3ZSBjYW4ndCBiZSBndWFyYW50ZWVkIHRoYXQgYWxsXHJcbiAgICAgKiBicm93c2VycyB3aWxsIHJlc3BvbmQgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIHJlcXVlc3RzIHdlIHNlbnRcclxuICAgICAqL1xyXG4gICAgaGFuZGxlUmVzcG9uc2UocmVxdWVzdE51bSwgZGF0YSkge1xyXG4gICAgICAgIHRoaXMucGVuZGluZ1Jlc3BvbnNlc1tyZXF1ZXN0TnVtXSA9IGRhdGE7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMucGVuZGluZ1Jlc3BvbnNlc1t0aGlzLmN1cnJlbnRSZXNwb25zZU51bV0pIHtcclxuICAgICAgICAgICAgY29uc3QgdG9Qcm9jZXNzID0gdGhpcy5wZW5kaW5nUmVzcG9uc2VzW3RoaXMuY3VycmVudFJlc3BvbnNlTnVtXTtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMucGVuZGluZ1Jlc3BvbnNlc1t0aGlzLmN1cnJlbnRSZXNwb25zZU51bV07XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9Qcm9jZXNzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9Qcm9jZXNzW2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhjZXB0aW9uR3VhcmQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTWVzc2FnZV8odG9Qcm9jZXNzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50UmVzcG9uc2VOdW0gPT09IHRoaXMuY2xvc2VBZnRlclJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbkNsb3NlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJlc3BvbnNlTnVtKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8vIFVSTCBxdWVyeSBwYXJhbWV0ZXJzIGFzc29jaWF0ZWQgd2l0aCBsb25ncG9sbGluZ1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9TVEFSVF9QQVJBTSA9ICdzdGFydCc7XHJcbmNvbnN0IEZJUkVCQVNFX0xPTkdQT0xMX0NMT1NFX0NPTU1BTkQgPSAnY2xvc2UnO1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9DT01NQU5EX0NCX05BTUUgPSAncExQQ29tbWFuZCc7XHJcbmNvbnN0IEZJUkVCQVNFX0xPTkdQT0xMX0RBVEFfQ0JfTkFNRSA9ICdwUlRMUENCJztcclxuY29uc3QgRklSRUJBU0VfTE9OR1BPTExfSURfUEFSQU0gPSAnaWQnO1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9QV19QQVJBTSA9ICdwdyc7XHJcbmNvbnN0IEZJUkVCQVNFX0xPTkdQT0xMX1NFUklBTF9QQVJBTSA9ICdzZXInO1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9DQUxMQkFDS19JRF9QQVJBTSA9ICdjYic7XHJcbmNvbnN0IEZJUkVCQVNFX0xPTkdQT0xMX1NFR01FTlRfTlVNX1BBUkFNID0gJ3NlZyc7XHJcbmNvbnN0IEZJUkVCQVNFX0xPTkdQT0xMX1NFR01FTlRTX0lOX1BBQ0tFVCA9ICd0cyc7XHJcbmNvbnN0IEZJUkVCQVNFX0xPTkdQT0xMX0RBVEFfUEFSQU0gPSAnZCc7XHJcbmNvbnN0IEZJUkVCQVNFX0xPTkdQT0xMX0RJU0NPTk5fRlJBTUVfUkVRVUVTVF9QQVJBTSA9ICdkZnJhbWUnO1xyXG4vL0RhdGEgc2l6ZSBjb25zdGFudHMuXHJcbi8vVE9ETzogUGVyZjogdGhlIG1heGltdW0gbGVuZ3RoIGFjdHVhbGx5IGRpZmZlcnMgZnJvbSBicm93c2VyIHRvIGJyb3dzZXIuXHJcbi8vIFdlIHNob3VsZCBjaGVjayB3aGF0IGJyb3dzZXIgd2UncmUgb24gYW5kIHNldCBhY2NvcmRpbmdseS5cclxuY29uc3QgTUFYX1VSTF9EQVRBX1NJWkUgPSAxODcwO1xyXG5jb25zdCBTRUdfSEVBREVSX1NJWkUgPSAzMDsgLy9pZTogJnNlZz04Mjk5MjM0JnRzPTk4MjM4OTEyMyZkPVxyXG5jb25zdCBNQVhfUEFZTE9BRF9TSVpFID0gTUFYX1VSTF9EQVRBX1NJWkUgLSBTRUdfSEVBREVSX1NJWkU7XHJcbi8qKlxyXG4gKiBLZWVwYWxpdmUgcGVyaW9kXHJcbiAqIHNlbmQgYSBmcmVzaCByZXF1ZXN0IGF0IG1pbmltdW0gZXZlcnkgMjUgc2Vjb25kcy4gT3BlcmEgaGFzIGEgbWF4aW11bSByZXF1ZXN0XHJcbiAqIGxlbmd0aCBvZiAzMCBzZWNvbmRzIHRoYXQgd2UgY2FuJ3QgZXhjZWVkLlxyXG4gKi9cclxuY29uc3QgS0VFUEFMSVZFX1JFUVVFU1RfSU5URVJWQUwgPSAyNTAwMDtcclxuLyoqXHJcbiAqIEhvdyBsb25nIHRvIHdhaXQgYmVmb3JlIGFib3J0aW5nIGEgbG9uZy1wb2xsaW5nIGNvbm5lY3Rpb24gYXR0ZW1wdC5cclxuICovXHJcbmNvbnN0IExQX0NPTk5FQ1RfVElNRU9VVCA9IDMwMDAwO1xyXG4vKipcclxuICogVGhpcyBjbGFzcyBtYW5hZ2VzIGEgc2luZ2xlIGxvbmctcG9sbGluZyBjb25uZWN0aW9uLlxyXG4gKi9cclxuY2xhc3MgQnJvd3NlclBvbGxDb25uZWN0aW9uIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGNvbm5JZCBBbiBpZGVudGlmaWVyIGZvciB0aGlzIGNvbm5lY3Rpb24sIHVzZWQgZm9yIGxvZ2dpbmdcclxuICAgICAqIEBwYXJhbSByZXBvSW5mbyBUaGUgaW5mbyBmb3IgdGhlIGVuZHBvaW50IHRvIHNlbmQgZGF0YSB0by5cclxuICAgICAqIEBwYXJhbSBhcHBsaWNhdGlvbklkIFRoZSBGaXJlYmFzZSBBcHAgSUQgZm9yIHRoaXMgcHJvamVjdC5cclxuICAgICAqIEBwYXJhbSBhcHBDaGVja1Rva2VuIFRoZSBBcHBDaGVjayB0b2tlbiBmb3IgdGhpcyBjbGllbnQuXHJcbiAgICAgKiBAcGFyYW0gYXV0aFRva2VuIFRoZSBBdXRoVG9rZW4gdG8gdXNlIGZvciB0aGlzIGNvbm5lY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNwb3J0U2Vzc2lvbklkIE9wdGlvbmFsIHRyYW5zcG9ydFNlc3Npb25pZCBpZiB3ZSBhcmVcclxuICAgICAqIHJlY29ubmVjdGluZyBmb3IgYW4gZXhpc3RpbmcgdHJhbnNwb3J0IHNlc3Npb25cclxuICAgICAqIEBwYXJhbSBsYXN0U2Vzc2lvbklkIE9wdGlvbmFsIGxhc3RTZXNzaW9uSWQgaWYgdGhlIFBlcnNpc3RlbnRDb25uZWN0aW9uIGhhc1xyXG4gICAgICogYWxyZWFkeSBjcmVhdGVkIGEgY29ubmVjdGlvbiBwcmV2aW91c2x5XHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvbm5JZCwgcmVwb0luZm8sIGFwcGxpY2F0aW9uSWQsIGFwcENoZWNrVG9rZW4sIGF1dGhUb2tlbiwgdHJhbnNwb3J0U2Vzc2lvbklkLCBsYXN0U2Vzc2lvbklkKSB7XHJcbiAgICAgICAgdGhpcy5jb25uSWQgPSBjb25uSWQ7XHJcbiAgICAgICAgdGhpcy5yZXBvSW5mbyA9IHJlcG9JbmZvO1xyXG4gICAgICAgIHRoaXMuYXBwbGljYXRpb25JZCA9IGFwcGxpY2F0aW9uSWQ7XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja1Rva2VuID0gYXBwQ2hlY2tUb2tlbjtcclxuICAgICAgICB0aGlzLmF1dGhUb2tlbiA9IGF1dGhUb2tlbjtcclxuICAgICAgICB0aGlzLnRyYW5zcG9ydFNlc3Npb25JZCA9IHRyYW5zcG9ydFNlc3Npb25JZDtcclxuICAgICAgICB0aGlzLmxhc3RTZXNzaW9uSWQgPSBsYXN0U2Vzc2lvbklkO1xyXG4gICAgICAgIHRoaXMuYnl0ZXNTZW50ID0gMDtcclxuICAgICAgICB0aGlzLmJ5dGVzUmVjZWl2ZWQgPSAwO1xyXG4gICAgICAgIHRoaXMuZXZlckNvbm5lY3RlZF8gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmxvZ18gPSBsb2dXcmFwcGVyKGNvbm5JZCk7XHJcbiAgICAgICAgdGhpcy5zdGF0c18gPSBzdGF0c01hbmFnZXJHZXRDb2xsZWN0aW9uKHJlcG9JbmZvKTtcclxuICAgICAgICB0aGlzLnVybEZuID0gKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAvLyBBbHdheXMgYWRkIHRoZSB0b2tlbiBpZiB3ZSBoYXZlIG9uZS5cclxuICAgICAgICAgICAgaWYgKHRoaXMuYXBwQ2hlY2tUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zW0FQUF9DSEVDS19UT0tFTl9QQVJBTV0gPSB0aGlzLmFwcENoZWNrVG9rZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlcG9JbmZvQ29ubmVjdGlvblVSTChyZXBvSW5mbywgTE9OR19QT0xMSU5HLCBwYXJhbXMpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBvbk1lc3NhZ2UgLSBDYWxsYmFjayB3aGVuIG1lc3NhZ2VzIGFycml2ZVxyXG4gICAgICogQHBhcmFtIG9uRGlzY29ubmVjdCAtIENhbGxiYWNrIHdpdGggY29ubmVjdGlvbiBsb3N0LlxyXG4gICAgICovXHJcbiAgICBvcGVuKG9uTWVzc2FnZSwgb25EaXNjb25uZWN0KSB7XHJcbiAgICAgICAgdGhpcy5jdXJTZWdtZW50TnVtID0gMDtcclxuICAgICAgICB0aGlzLm9uRGlzY29ubmVjdF8gPSBvbkRpc2Nvbm5lY3Q7XHJcbiAgICAgICAgdGhpcy5teVBhY2tldE9yZGVyZXIgPSBuZXcgUGFja2V0UmVjZWl2ZXIob25NZXNzYWdlKTtcclxuICAgICAgICB0aGlzLmlzQ2xvc2VkXyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXRUaW1lcl8gPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdUaW1lZCBvdXQgdHJ5aW5nIHRvIGNvbm5lY3QuJyk7XHJcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBjbGVhciB0aGUgaG9zdCBjYWNoZVxyXG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2VkXygpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RUaW1lb3V0VGltZXJfID0gbnVsbDtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICB9LCBNYXRoLmZsb29yKExQX0NPTk5FQ1RfVElNRU9VVCkpO1xyXG4gICAgICAgIC8vIEVuc3VyZSB3ZSBkZWxheSB0aGUgY3JlYXRpb24gb2YgdGhlIGlmcmFtZSB1bnRpbCB0aGUgRE9NIGlzIGxvYWRlZC5cclxuICAgICAgICBleGVjdXRlV2hlbkRPTVJlYWR5KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNDbG9zZWRfKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9TZXQgdXAgYSBjYWxsYmFjayB0aGF0IGdldHMgdHJpZ2dlcmVkIG9uY2UgYSBjb25uZWN0aW9uIGlzIHNldCB1cC5cclxuICAgICAgICAgICAgdGhpcy5zY3JpcHRUYWdIb2xkZXIgPSBuZXcgRmlyZWJhc2VJRnJhbWVTY3JpcHRIb2xkZXIoKC4uLmFyZ3MpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IFtjb21tYW5kLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0XSA9IGFyZ3M7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluY3JlbWVudEluY29taW5nQnl0ZXNfKGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNjcmlwdFRhZ0hvbGRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gd2UgY2xvc2VkIHRoZSBjb25uZWN0aW9uLlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdFRpbWVvdXRUaW1lcl8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0VGltZW91dFRpbWVyXyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0VGltZW91dFRpbWVyXyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZXJDb25uZWN0ZWRfID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChjb21tYW5kID09PSBGSVJFQkFTRV9MT05HUE9MTF9TVEFSVF9QQVJBTSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaWQgPSBhcmcxO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFzc3dvcmQgPSBhcmcyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29tbWFuZCA9PT0gRklSRUJBU0VfTE9OR1BPTExfQ0xPU0VfQ09NTUFORCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGNsZWFyIHRoZSBob3N0IGNhY2hlLiBXZSBnb3QgYSByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXIsIHNvIHdlIGtub3cgaXQncyByZWFjaGFibGVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJnMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBhcmVuJ3QgZXhwZWN0aW5nIGFueSBtb3JlIGRhdGEgKG90aGVyIHRoYW4gd2hhdCB0aGUgc2VydmVyJ3MgYWxyZWFkeSBpbiB0aGUgcHJvY2VzcyBvZiBzZW5kaW5nIHVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRocm91Z2ggb3VyIGFscmVhZHkgb3BlbiBwb2xscyksIHNvIGRvbid0IHNlbmQgYW55IG1vcmUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2NyaXB0VGFnSG9sZGVyLnNlbmROZXdQb2xscyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhcmcxIGluIHRoaXMgY2FzZSBpcyB0aGUgbGFzdCByZXNwb25zZSBudW1iZXIgc2VudCBieSB0aGUgc2VydmVyLiBXZSBzaG91bGQgdHJ5IHRvIHJlY2VpdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxsIG9mIHRoZSByZXNwb25zZXMgdXAgdG8gdGhpcyBvbmUgYmVmb3JlIGNsb3NpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5teVBhY2tldE9yZGVyZXIuY2xvc2VBZnRlcihhcmcxLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ2xvc2VkXygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25DbG9zZWRfKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnJlY29nbml6ZWQgY29tbWFuZCByZWNlaXZlZDogJyArIGNvbW1hbmQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCAoLi4uYXJncykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgW3BOLCBkYXRhXSA9IGFyZ3M7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluY3JlbWVudEluY29taW5nQnl0ZXNfKGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5teVBhY2tldE9yZGVyZXIuaGFuZGxlUmVzcG9uc2UocE4sIGRhdGEpO1xyXG4gICAgICAgICAgICB9LCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2xvc2VkXygpO1xyXG4gICAgICAgICAgICB9LCB0aGlzLnVybEZuKTtcclxuICAgICAgICAgICAgLy9TZW5kIHRoZSBpbml0aWFsIHJlcXVlc3QgdG8gY29ubmVjdC4gVGhlIHNlcmlhbCBudW1iZXIgaXMgc2ltcGx5IHRvIGtlZXAgdGhlIGJyb3dzZXIgZnJvbSBwdWxsaW5nIHByZXZpb3VzIHJlc3VsdHNcclxuICAgICAgICAgICAgLy9mcm9tIGNhY2hlLlxyXG4gICAgICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX1NUQVJUX1BBUkFNXSA9ICd0JztcclxuICAgICAgICAgICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX1NFUklBTF9QQVJBTV0gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMDApO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zY3JpcHRUYWdIb2xkZXIudW5pcXVlQ2FsbGJhY2tJZGVudGlmaWVyKSB7XHJcbiAgICAgICAgICAgICAgICB1cmxQYXJhbXNbRklSRUJBU0VfTE9OR1BPTExfQ0FMTEJBQ0tfSURfUEFSQU1dID1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcmlwdFRhZ0hvbGRlci51bmlxdWVDYWxsYmFja0lkZW50aWZpZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdXJsUGFyYW1zW1ZFUlNJT05fUEFSQU1dID0gUFJPVE9DT0xfVkVSU0lPTjtcclxuICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNwb3J0U2Vzc2lvbklkKSB7XHJcbiAgICAgICAgICAgICAgICB1cmxQYXJhbXNbVFJBTlNQT1JUX1NFU1NJT05fUEFSQU1dID0gdGhpcy50cmFuc3BvcnRTZXNzaW9uSWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMubGFzdFNlc3Npb25JZCkge1xyXG4gICAgICAgICAgICAgICAgdXJsUGFyYW1zW0xBU1RfU0VTU0lPTl9QQVJBTV0gPSB0aGlzLmxhc3RTZXNzaW9uSWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuYXBwbGljYXRpb25JZCkge1xyXG4gICAgICAgICAgICAgICAgdXJsUGFyYW1zW0FQUExJQ0FUSU9OX0lEX1BBUkFNXSA9IHRoaXMuYXBwbGljYXRpb25JZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5hcHBDaGVja1Rva2VuKSB7XHJcbiAgICAgICAgICAgICAgICB1cmxQYXJhbXNbQVBQX0NIRUNLX1RPS0VOX1BBUkFNXSA9IHRoaXMuYXBwQ2hlY2tUb2tlbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgICAgICAgICAgbG9jYXRpb24uaG9zdG5hbWUgJiZcclxuICAgICAgICAgICAgICAgIEZPUkdFX0RPTUFJTl9SRS50ZXN0KGxvY2F0aW9uLmhvc3RuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgdXJsUGFyYW1zW1JFRkVSRVJfUEFSQU1dID0gRk9SR0VfUkVGO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RVUkwgPSB0aGlzLnVybEZuKHVybFBhcmFtcyk7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnQ29ubmVjdGluZyB2aWEgbG9uZy1wb2xsIHRvICcgKyBjb25uZWN0VVJMKTtcclxuICAgICAgICAgICAgdGhpcy5zY3JpcHRUYWdIb2xkZXIuYWRkVGFnKGNvbm5lY3RVUkwsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8qIGRvIG5vdGhpbmcgKi9cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGwgdGhpcyB3aGVuIGEgaGFuZHNoYWtlIGhhcyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5IGFuZCB3ZSB3YW50IHRvIGNvbnNpZGVyIHRoZSBjb25uZWN0aW9uIGVzdGFibGlzaGVkXHJcbiAgICAgKi9cclxuICAgIHN0YXJ0KCkge1xyXG4gICAgICAgIHRoaXMuc2NyaXB0VGFnSG9sZGVyLnN0YXJ0TG9uZ1BvbGwodGhpcy5pZCwgdGhpcy5wYXNzd29yZCk7XHJcbiAgICAgICAgdGhpcy5hZGREaXNjb25uZWN0UGluZ0ZyYW1lKHRoaXMuaWQsIHRoaXMucGFzc3dvcmQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3JjZXMgbG9uZyBwb2xsaW5nIHRvIGJlIGNvbnNpZGVyZWQgYXMgYSBwb3RlbnRpYWwgdHJhbnNwb3J0XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmb3JjZUFsbG93KCkge1xyXG4gICAgICAgIEJyb3dzZXJQb2xsQ29ubmVjdGlvbi5mb3JjZUFsbG93XyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZvcmNlcyBsb25ncG9sbGluZyB0byBub3QgYmUgY29uc2lkZXJlZCBhcyBhIHBvdGVudGlhbCB0cmFuc3BvcnRcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZvcmNlRGlzYWxsb3coKSB7XHJcbiAgICAgICAgQnJvd3NlclBvbGxDb25uZWN0aW9uLmZvcmNlRGlzYWxsb3dfID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8vIFN0YXRpYyBtZXRob2QsIHVzZSBzdHJpbmcgbGl0ZXJhbCBzbyBpdCBjYW4gYmUgYWNjZXNzZWQgaW4gYSBnZW5lcmljIHdheVxyXG4gICAgc3RhdGljIGlzQXZhaWxhYmxlKCkge1xyXG4gICAgICAgIGlmIChpc05vZGVTZGsoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKEJyb3dzZXJQb2xsQ29ubmVjdGlvbi5mb3JjZUFsbG93Xykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE5PVEU6IEluIFJlYWN0LU5hdGl2ZSB0aGVyZSdzIG5vcm1hbGx5IG5vICdkb2N1bWVudCcsIGJ1dCBpZiB5b3UgZGVidWcgYSBSZWFjdC1OYXRpdmUgYXBwIGluXHJcbiAgICAgICAgICAgIC8vIHRoZSBDaHJvbWUgZGVidWdnZXIsICdkb2N1bWVudCcgaXMgZGVmaW5lZCwgYnV0IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgbnVsbCAoMjAxNS8wNi8wOCkuXHJcbiAgICAgICAgICAgIHJldHVybiAoIUJyb3dzZXJQb2xsQ29ubmVjdGlvbi5mb3JjZURpc2FsbG93XyAmJlxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPSBudWxsICYmXHJcbiAgICAgICAgICAgICAgICAhaXNDaHJvbWVFeHRlbnNpb25Db250ZW50U2NyaXB0KCkgJiZcclxuICAgICAgICAgICAgICAgICFpc1dpbmRvd3NTdG9yZUFwcCgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE5vLW9wIGZvciBwb2xsaW5nXHJcbiAgICAgKi9cclxuICAgIG1hcmtDb25uZWN0aW9uSGVhbHRoeSgpIHsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wcyBwb2xsaW5nIGFuZCBjbGVhbnMgdXAgdGhlIGlmcmFtZVxyXG4gICAgICovXHJcbiAgICBzaHV0ZG93bl8oKSB7XHJcbiAgICAgICAgdGhpcy5pc0Nsb3NlZF8gPSB0cnVlO1xyXG4gICAgICAgIGlmICh0aGlzLnNjcmlwdFRhZ0hvbGRlcikge1xyXG4gICAgICAgICAgICB0aGlzLnNjcmlwdFRhZ0hvbGRlci5jbG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnNjcmlwdFRhZ0hvbGRlciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vcmVtb3ZlIHRoZSBkaXNjb25uZWN0IGZyYW1lLCB3aGljaCB3aWxsIHRyaWdnZXIgYW4gWEhSIGNhbGwgdG8gdGhlIHNlcnZlciB0byB0ZWxsIGl0IHdlJ3JlIGxlYXZpbmcuXHJcbiAgICAgICAgaWYgKHRoaXMubXlEaXNjb25uRnJhbWUpIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLm15RGlzY29ubkZyYW1lKTtcclxuICAgICAgICAgICAgdGhpcy5teURpc2Nvbm5GcmFtZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RUaW1lb3V0VGltZXJfKSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3RUaW1lb3V0VGltZXJfKTtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0VGltZW91dFRpbWVyXyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiB0aGlzIHRyYW5zcG9ydCBpcyBjbG9zZWRcclxuICAgICAqL1xyXG4gICAgb25DbG9zZWRfKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc0Nsb3NlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdMb25ncG9sbCBpcyBjbG9zaW5nIGl0c2VsZicpO1xyXG4gICAgICAgICAgICB0aGlzLnNodXRkb3duXygpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vbkRpc2Nvbm5lY3RfKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdF8odGhpcy5ldmVyQ29ubmVjdGVkXyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdF8gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHRlcm5hbC1mYWNpbmcgY2xvc2UgaGFuZGxlci4gUmVhbFRpbWUgaGFzIHJlcXVlc3RlZCB3ZSBzaHV0IGRvd24uIEtpbGwgb3VyIGNvbm5lY3Rpb24gYW5kIHRlbGwgdGhlIHNlcnZlclxyXG4gICAgICogdGhhdCB3ZSd2ZSBsZWZ0LlxyXG4gICAgICovXHJcbiAgICBjbG9zZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNDbG9zZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnTG9uZ3BvbGwgaXMgYmVpbmcgY2xvc2VkLicpO1xyXG4gICAgICAgICAgICB0aGlzLnNodXRkb3duXygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2VuZCB0aGUgSlNPTiBvYmplY3QgZG93biB0byB0aGUgc2VydmVyLiBJdCB3aWxsIG5lZWQgdG8gYmUgc3RyaW5naWZpZWQsIGJhc2U2NCBlbmNvZGVkLCBhbmQgdGhlblxyXG4gICAgICogYnJva2VuIGludG8gY2h1bmtzIChzaW5jZSBVUkxzIGhhdmUgYSBzbWFsbCBtYXhpbXVtIGxlbmd0aCkuXHJcbiAgICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBKU09OIGRhdGEgdG8gdHJhbnNtaXQuXHJcbiAgICAgKi9cclxuICAgIHNlbmQoZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGRhdGFTdHIgPSBzdHJpbmdpZnkoZGF0YSk7XHJcbiAgICAgICAgdGhpcy5ieXRlc1NlbnQgKz0gZGF0YVN0ci5sZW5ndGg7XHJcbiAgICAgICAgdGhpcy5zdGF0c18uaW5jcmVtZW50Q291bnRlcignYnl0ZXNfc2VudCcsIGRhdGFTdHIubGVuZ3RoKTtcclxuICAgICAgICAvL2ZpcnN0LCBsZXRzIGdldCB0aGUgYmFzZTY0LWVuY29kZWQgZGF0YVxyXG4gICAgICAgIGNvbnN0IGJhc2U2NGRhdGEgPSBiYXNlNjRFbmNvZGUoZGF0YVN0cik7XHJcbiAgICAgICAgLy9XZSBjYW4gb25seSBmaXQgYSBjZXJ0YWluIGFtb3VudCBpbiBlYWNoIFVSTCwgc28gd2UgbmVlZCB0byBzcGxpdCB0aGlzIHJlcXVlc3RcclxuICAgICAgICAvL3VwIGludG8gbXVsdGlwbGUgcGllY2VzIGlmIGl0IGRvZXNuJ3QgZml0IGluIG9uZSByZXF1ZXN0LlxyXG4gICAgICAgIGNvbnN0IGRhdGFTZWdzID0gc3BsaXRTdHJpbmdCeVNpemUoYmFzZTY0ZGF0YSwgTUFYX1BBWUxPQURfU0laRSk7XHJcbiAgICAgICAgLy9FbnF1ZXVlIGVhY2ggc2VnbWVudCBmb3IgdHJhbnNtaXNzaW9uLiBXZSBhc3NpZ24gZWFjaCBjaHVuayBhIHNlcXVlbnRpYWwgSUQgYW5kIGEgdG90YWwgbnVtYmVyXHJcbiAgICAgICAgLy9vZiBzZWdtZW50cyBzbyB0aGF0IHdlIGNhbiByZWFzc2VtYmxlIHRoZSBwYWNrZXQgb24gdGhlIHNlcnZlci5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFTZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2NyaXB0VGFnSG9sZGVyLmVucXVldWVTZWdtZW50KHRoaXMuY3VyU2VnbWVudE51bSwgZGF0YVNlZ3MubGVuZ3RoLCBkYXRhU2Vnc1tpXSk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VyU2VnbWVudE51bSsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBpcyBob3cgd2Ugbm90aWZ5IHRoZSBzZXJ2ZXIgdGhhdCB3ZSdyZSBsZWF2aW5nLlxyXG4gICAgICogV2UgYXJlbid0IGFibGUgdG8gc2VuZCByZXF1ZXN0cyB3aXRoIERIVE1MIG9uIGEgd2luZG93IGNsb3NlIGV2ZW50LCBidXQgd2UgY2FuXHJcbiAgICAgKiB0cmlnZ2VyIFhIUiByZXF1ZXN0cyBpbiBzb21lIGJyb3dzZXJzIChldmVyeXRoaW5nIGJ1dCBPcGVyYSBiYXNpY2FsbHkpLlxyXG4gICAgICovXHJcbiAgICBhZGREaXNjb25uZWN0UGluZ0ZyYW1lKGlkLCBwdykge1xyXG4gICAgICAgIGlmIChpc05vZGVTZGsoKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubXlEaXNjb25uRnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcclxuICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSB7fTtcclxuICAgICAgICB1cmxQYXJhbXNbRklSRUJBU0VfTE9OR1BPTExfRElTQ09OTl9GUkFNRV9SRVFVRVNUX1BBUkFNXSA9ICd0JztcclxuICAgICAgICB1cmxQYXJhbXNbRklSRUJBU0VfTE9OR1BPTExfSURfUEFSQU1dID0gaWQ7XHJcbiAgICAgICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX1BXX1BBUkFNXSA9IHB3O1xyXG4gICAgICAgIHRoaXMubXlEaXNjb25uRnJhbWUuc3JjID0gdGhpcy51cmxGbih1cmxQYXJhbXMpO1xyXG4gICAgICAgIHRoaXMubXlEaXNjb25uRnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMubXlEaXNjb25uRnJhbWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIHRvIHRyYWNrIHRoZSBieXRlcyByZWNlaXZlZCBieSB0aGlzIGNsaWVudFxyXG4gICAgICovXHJcbiAgICBpbmNyZW1lbnRJbmNvbWluZ0J5dGVzXyhhcmdzKSB7XHJcbiAgICAgICAgLy8gVE9ETzogVGhpcyBpcyBhbiBhbm5veWluZyBwZXJmIGhpdCBqdXN0IHRvIHRyYWNrIHRoZSBudW1iZXIgb2YgaW5jb21pbmcgYnl0ZXMuICBNYXliZSBpdCBzaG91bGQgYmUgb3B0LWluLlxyXG4gICAgICAgIGNvbnN0IGJ5dGVzUmVjZWl2ZWQgPSBzdHJpbmdpZnkoYXJncykubGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuYnl0ZXNSZWNlaXZlZCArPSBieXRlc1JlY2VpdmVkO1xyXG4gICAgICAgIHRoaXMuc3RhdHNfLmluY3JlbWVudENvdW50ZXIoJ2J5dGVzX3JlY2VpdmVkJywgYnl0ZXNSZWNlaXZlZCk7XHJcbiAgICB9XHJcbn1cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKiBBIHdyYXBwZXIgYXJvdW5kIGFuIGlmcmFtZSB0aGF0IGlzIHVzZWQgYXMgYSBsb25nLXBvbGxpbmcgc2NyaXB0IGhvbGRlci5cclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuY2xhc3MgRmlyZWJhc2VJRnJhbWVTY3JpcHRIb2xkZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gY29tbWFuZENCIC0gVGhlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCB3aGVuIGNvbnRyb2wgY29tbWFuZHMgYXJlIHJlY2V2aWVkIGZyb20gdGhlIHNlcnZlci5cclxuICAgICAqIEBwYXJhbSBvbk1lc3NhZ2VDQiAtIFRoZSBjYWxsYmFjayB0byBiZSB0cmlnZ2VyZWQgd2hlbiByZXNwb25zZXMgYXJyaXZlIGZyb20gdGhlIHNlcnZlci5cclxuICAgICAqIEBwYXJhbSBvbkRpc2Nvbm5lY3QgLSBUaGUgY2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gdGhpcyB0YWcgaG9sZGVyIGlzIGNsb3NlZFxyXG4gICAgICogQHBhcmFtIHVybEZuIC0gQSBmdW5jdGlvbiB0aGF0IHByb3ZpZGVzIHRoZSBVUkwgb2YgdGhlIGVuZHBvaW50IHRvIHNlbmQgZGF0YSB0by5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoY29tbWFuZENCLCBvbk1lc3NhZ2VDQiwgb25EaXNjb25uZWN0LCB1cmxGbikge1xyXG4gICAgICAgIHRoaXMub25EaXNjb25uZWN0ID0gb25EaXNjb25uZWN0O1xyXG4gICAgICAgIHRoaXMudXJsRm4gPSB1cmxGbjtcclxuICAgICAgICAvL1dlIG1haW50YWluIGEgY291bnQgb2YgYWxsIG9mIHRoZSBvdXRzdGFuZGluZyByZXF1ZXN0cywgYmVjYXVzZSBpZiB3ZSBoYXZlIHRvbyBtYW55IGFjdGl2ZSBhdCBvbmNlIGl0IGNhbiBjYXVzZVxyXG4gICAgICAgIC8vcHJvYmxlbXMgaW4gc29tZSBicm93c2Vycy5cclxuICAgICAgICB0aGlzLm91dHN0YW5kaW5nUmVxdWVzdHMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgLy9BIHF1ZXVlIG9mIHRoZSBwZW5kaW5nIHNlZ21lbnRzIHdhaXRpbmcgZm9yIHRyYW5zbWlzc2lvbiB0byB0aGUgc2VydmVyLlxyXG4gICAgICAgIHRoaXMucGVuZGluZ1NlZ3MgPSBbXTtcclxuICAgICAgICAvL0Egc2VyaWFsIG51bWJlci4gV2UgdXNlIHRoaXMgZm9yIHR3byB0aGluZ3M6XHJcbiAgICAgICAgLy8gMSkgQSB3YXkgdG8gZW5zdXJlIHRoZSBicm93c2VyIGRvZXNuJ3QgY2FjaGUgcmVzcG9uc2VzIHRvIHBvbGxzXHJcbiAgICAgICAgLy8gMikgQSB3YXkgdG8gbWFrZSB0aGUgc2VydmVyIGF3YXJlIHdoZW4gbG9uZy1wb2xscyBhcnJpdmUgaW4gYSBkaWZmZXJlbnQgb3JkZXIgdGhhbiB3ZSBzdGFydGVkIHRoZW0uIFRoZVxyXG4gICAgICAgIC8vICAgIHNlcnZlciBuZWVkcyB0byByZWxlYXNlIGJvdGggcG9sbHMgaW4gdGhpcyBjYXNlIG9yIGl0IHdpbGwgY2F1c2UgcHJvYmxlbXMgaW4gT3BlcmEgc2luY2UgT3BlcmEgY2FuIG9ubHkgZXhlY3V0ZVxyXG4gICAgICAgIC8vICAgIEpTT05QIGNvZGUgaW4gdGhlIG9yZGVyIGl0IHdhcyBhZGRlZCB0byB0aGUgaWZyYW1lLlxyXG4gICAgICAgIHRoaXMuY3VycmVudFNlcmlhbCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwMCk7XHJcbiAgICAgICAgLy8gVGhpcyBnZXRzIHNldCB0byBmYWxzZSB3aGVuIHdlJ3JlIFwiY2xvc2luZyBkb3duXCIgdGhlIGNvbm5lY3Rpb24gKGUuZy4gd2UncmUgc3dpdGNoaW5nIHRyYW5zcG9ydHMgYnV0IHRoZXJlJ3Mgc3RpbGxcclxuICAgICAgICAvLyBpbmNvbWluZyBkYXRhIGZyb20gdGhlIHNlcnZlciB0aGF0IHdlJ3JlIHdhaXRpbmcgZm9yKS5cclxuICAgICAgICB0aGlzLnNlbmROZXdQb2xscyA9IHRydWU7XHJcbiAgICAgICAgaWYgKCFpc05vZGVTZGsoKSkge1xyXG4gICAgICAgICAgICAvL0VhY2ggc2NyaXB0IGhvbGRlciByZWdpc3RlcnMgYSBjb3VwbGUgb2YgdW5pcXVlbHkgbmFtZWQgY2FsbGJhY2tzIHdpdGggdGhlIHdpbmRvdy4gVGhlc2UgYXJlIGNhbGxlZCBmcm9tIHRoZVxyXG4gICAgICAgICAgICAvL2lmcmFtZXMgd2hlcmUgd2UgcHV0IHRoZSBsb25nLXBvbGxpbmcgc2NyaXB0IHRhZ3MuIFdlIGhhdmUgdHdvIGNhbGxiYWNrczpcclxuICAgICAgICAgICAgLy8gICAxKSBDb21tYW5kIENhbGxiYWNrIC0gVHJpZ2dlcmVkIGZvciBjb250cm9sIGlzc3VlcywgbGlrZSBzdGFydGluZyBhIGNvbm5lY3Rpb24uXHJcbiAgICAgICAgICAgIC8vICAgMikgTWVzc2FnZSBDYWxsYmFjayAtIFRyaWdnZXJlZCB3aGVuIG5ldyBkYXRhIGFycml2ZXMuXHJcbiAgICAgICAgICAgIHRoaXMudW5pcXVlQ2FsbGJhY2tJZGVudGlmaWVyID0gTFVJREdlbmVyYXRvcigpO1xyXG4gICAgICAgICAgICB3aW5kb3dbRklSRUJBU0VfTE9OR1BPTExfQ09NTUFORF9DQl9OQU1FICsgdGhpcy51bmlxdWVDYWxsYmFja0lkZW50aWZpZXJdID0gY29tbWFuZENCO1xyXG4gICAgICAgICAgICB3aW5kb3dbRklSRUJBU0VfTE9OR1BPTExfREFUQV9DQl9OQU1FICsgdGhpcy51bmlxdWVDYWxsYmFja0lkZW50aWZpZXJdID1cclxuICAgICAgICAgICAgICAgIG9uTWVzc2FnZUNCO1xyXG4gICAgICAgICAgICAvL0NyZWF0ZSBhbiBpZnJhbWUgZm9yIHVzIHRvIGFkZCBzY3JpcHQgdGFncyB0by5cclxuICAgICAgICAgICAgdGhpcy5teUlGcmFtZSA9IEZpcmViYXNlSUZyYW1lU2NyaXB0SG9sZGVyLmNyZWF0ZUlGcmFtZV8oKTtcclxuICAgICAgICAgICAgLy8gU2V0IHRoZSBpZnJhbWUncyBjb250ZW50cy5cclxuICAgICAgICAgICAgbGV0IHNjcmlwdCA9ICcnO1xyXG4gICAgICAgICAgICAvLyBpZiB3ZSBzZXQgYSBqYXZhc2NyaXB0IHVybCwgaXQncyBJRSBhbmQgd2UgbmVlZCB0byBzZXQgdGhlIGRvY3VtZW50IGRvbWFpbi4gVGhlIGphdmFzY3JpcHQgdXJsIGlzIHN1ZmZpY2llbnRcclxuICAgICAgICAgICAgLy8gZm9yIGllOSwgYnV0IGllOCBuZWVkcyB0byBkbyBpdCBhZ2FpbiBpbiB0aGUgZG9jdW1lbnQgaXRzZWxmLlxyXG4gICAgICAgICAgICBpZiAodGhpcy5teUlGcmFtZS5zcmMgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMubXlJRnJhbWUuc3JjLnN1YnN0cigwLCAnamF2YXNjcmlwdDonLmxlbmd0aCkgPT09ICdqYXZhc2NyaXB0OicpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnREb21haW4gPSBkb2N1bWVudC5kb21haW47XHJcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSAnPHNjcmlwdD5kb2N1bWVudC5kb21haW49XCInICsgY3VycmVudERvbWFpbiArICdcIjs8L3NjcmlwdD4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGlmcmFtZUNvbnRlbnRzID0gJzxodG1sPjxib2R5PicgKyBzY3JpcHQgKyAnPC9ib2R5PjwvaHRtbD4nO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5teUlGcmFtZS5kb2Mub3BlbigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5teUlGcmFtZS5kb2Mud3JpdGUoaWZyYW1lQ29udGVudHMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5teUlGcmFtZS5kb2MuY2xvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgbG9nKCdmcmFtZSB3cml0aW5nIGV4Y2VwdGlvbicpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGUuc3RhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2coZS5zdGFjayk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsb2coZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29tbWFuZENCID0gY29tbWFuZENCO1xyXG4gICAgICAgICAgICB0aGlzLm9uTWVzc2FnZUNCID0gb25NZXNzYWdlQ0I7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFYWNoIGJyb3dzZXIgaGFzIGl0cyBvd24gZnVubnkgd2F5IHRvIGhhbmRsZSBpZnJhbWVzLiBIZXJlIHdlIG11c2ggdGhlbSBhbGwgdG9nZXRoZXIgaW50byBvbmUgb2JqZWN0IHRoYXQgSSBjYW5cclxuICAgICAqIGFjdHVhbGx5IHVzZS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZUlGcmFtZV8oKSB7XHJcbiAgICAgICAgY29uc3QgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XHJcbiAgICAgICAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgaW4gb3JkZXIgdG8gaW5pdGlhbGl6ZSB0aGUgZG9jdW1lbnQgaW5zaWRlIHRoZSBpZnJhbWVcclxuICAgICAgICBpZiAoZG9jdW1lbnQuYm9keSkge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiBkb2N1bWVudC5kb21haW4gaGFzIGJlZW4gbW9kaWZpZWQgaW4gSUUsIHRoaXMgd2lsbCB0aHJvdyBhbiBlcnJvciwgYW5kIHdlIG5lZWQgdG8gc2V0IHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gZG9tYWluIG9mIHRoZSBpZnJhbWUncyBkb2N1bWVudCBtYW51YWxseS4gV2UgY2FuIGRvIHRoaXMgdmlhIGEgamF2YXNjcmlwdDogdXJsIGFzIHRoZSBzcmMgYXR0cmlidXRlXHJcbiAgICAgICAgICAgICAgICAvLyBBbHNvIG5vdGUgdGhhdCB3ZSBtdXN0IGRvIHRoaXMgKmFmdGVyKiB0aGUgaWZyYW1lIGhhcyBiZWVuIGFwcGVuZGVkIHRvIHRoZSBwYWdlLiBPdGhlcndpc2UgaXQgZG9lc24ndCB3b3JrLlxyXG4gICAgICAgICAgICAgICAgY29uc3QgYSA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKCFhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBvbG9naWVzIGZvciB0aGUgbG9nLXNwYW0sIEkgbmVlZCB0byBkbyBzb21ldGhpbmcgdG8ga2VlcCBjbG9zdXJlIGZyb20gb3B0aW1pemluZyBvdXQgdGhlIGFzc2lnbm1lbnQgYWJvdmUuXHJcbiAgICAgICAgICAgICAgICAgICAgbG9nKCdObyBJRSBkb21haW4gc2V0dGluZyByZXF1aXJlZCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkb21haW4gPSBkb2N1bWVudC5kb21haW47XHJcbiAgICAgICAgICAgICAgICBpZnJhbWUuc3JjID1cclxuICAgICAgICAgICAgICAgICAgICBcImphdmFzY3JpcHQ6dm9pZCgoZnVuY3Rpb24oKXtkb2N1bWVudC5vcGVuKCk7ZG9jdW1lbnQuZG9tYWluPSdcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiJztkb2N1bWVudC5jbG9zZSgpO30pKCkpXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIExvbmdQb2xsQ29ubmVjdGlvbiBhdHRlbXB0cyB0byBkZWxheSBpbml0aWFsaXphdGlvbiB1bnRpbCB0aGUgZG9jdW1lbnQgaXMgcmVhZHksIHNvIGhvcGVmdWxseSB0aGlzXHJcbiAgICAgICAgICAgIC8vIG5ldmVyIGdldHMgaGl0LlxyXG4gICAgICAgICAgICB0aHJvdyAnRG9jdW1lbnQgYm9keSBoYXMgbm90IGluaXRpYWxpemVkLiBXYWl0IHRvIGluaXRpYWxpemUgRmlyZWJhc2UgdW50aWwgYWZ0ZXIgdGhlIGRvY3VtZW50IGlzIHJlYWR5Lic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEdldCB0aGUgZG9jdW1lbnQgb2YgdGhlIGlmcmFtZSBpbiBhIGJyb3dzZXItc3BlY2lmaWMgd2F5LlxyXG4gICAgICAgIGlmIChpZnJhbWUuY29udGVudERvY3VtZW50KSB7XHJcbiAgICAgICAgICAgIGlmcmFtZS5kb2MgPSBpZnJhbWUuY29udGVudERvY3VtZW50OyAvLyBGaXJlZm94LCBPcGVyYSwgU2FmYXJpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlmcmFtZS5jb250ZW50V2luZG93KSB7XHJcbiAgICAgICAgICAgIGlmcmFtZS5kb2MgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDsgLy8gSW50ZXJuZXQgRXhwbG9yZXJcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaWZyYW1lLmRvY3VtZW50KSB7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgIGlmcmFtZS5kb2MgPSBpZnJhbWUuZG9jdW1lbnQ7IC8vb3RoZXJzP1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaWZyYW1lO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYW5jZWwgYWxsIG91dHN0YW5kaW5nIHF1ZXJpZXMgYW5kIHJlbW92ZSB0aGUgZnJhbWUuXHJcbiAgICAgKi9cclxuICAgIGNsb3NlKCkge1xyXG4gICAgICAgIC8vTWFyayB0aGlzIGlmcmFtZSBhcyBkZWFkLCBzbyBubyBuZXcgcmVxdWVzdHMgYXJlIHNlbnQuXHJcbiAgICAgICAgdGhpcy5hbGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0aGlzLm15SUZyYW1lKSB7XHJcbiAgICAgICAgICAgIC8vV2UgaGF2ZSB0byBhY3R1YWxseSByZW1vdmUgYWxsIG9mIHRoZSBodG1sIGluc2lkZSB0aGlzIGlmcmFtZSBiZWZvcmUgcmVtb3ZpbmcgaXQgZnJvbSB0aGVcclxuICAgICAgICAgICAgLy93aW5kb3csIG9yIElFIHdpbGwgY29udGludWUgbG9hZGluZyBhbmQgZXhlY3V0aW5nIHRoZSBzY3JpcHQgdGFncyB3ZSd2ZSBhbHJlYWR5IGFkZGVkLCB3aGljaFxyXG4gICAgICAgICAgICAvL2NhbiBsZWFkIHRvIHNvbWUgZXJyb3JzIGJlaW5nIHRocm93bi4gU2V0dGluZyB0ZXh0Q29udGVudCBzZWVtcyB0byBiZSB0aGUgc2FmZXN0IHdheSB0byBkbyB0aGlzLlxyXG4gICAgICAgICAgICB0aGlzLm15SUZyYW1lLmRvYy5ib2R5LnRleHRDb250ZW50ID0gJyc7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubXlJRnJhbWUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMubXlJRnJhbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXlJRnJhbWUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBNYXRoLmZsb29yKDApKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUHJvdGVjdCBmcm9tIGJlaW5nIGNhbGxlZCByZWN1cnNpdmVseS5cclxuICAgICAgICBjb25zdCBvbkRpc2Nvbm5lY3QgPSB0aGlzLm9uRGlzY29ubmVjdDtcclxuICAgICAgICBpZiAob25EaXNjb25uZWN0KSB7XHJcbiAgICAgICAgICAgIHRoaXMub25EaXNjb25uZWN0ID0gbnVsbDtcclxuICAgICAgICAgICAgb25EaXNjb25uZWN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBY3R1YWxseSBzdGFydCB0aGUgbG9uZy1wb2xsaW5nIHNlc3Npb24gYnkgYWRkaW5nIHRoZSBmaXJzdCBzY3JpcHQgdGFnKHMpIHRvIHRoZSBpZnJhbWUuXHJcbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgSUQgb2YgdGhpcyBjb25uZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0gcHcgLSBUaGUgcGFzc3dvcmQgZm9yIHRoaXMgY29ubmVjdGlvblxyXG4gICAgICovXHJcbiAgICBzdGFydExvbmdQb2xsKGlkLCBwdykge1xyXG4gICAgICAgIHRoaXMubXlJRCA9IGlkO1xyXG4gICAgICAgIHRoaXMubXlQVyA9IHB3O1xyXG4gICAgICAgIHRoaXMuYWxpdmUgPSB0cnVlO1xyXG4gICAgICAgIC8vc2VuZCB0aGUgaW5pdGlhbCByZXF1ZXN0LiBJZiB0aGVyZSBhcmUgcmVxdWVzdHMgcXVldWVkLCBtYWtlIHN1cmUgdGhhdCB3ZSB0cmFuc21pdCBhcyBtYW55IGFzIHdlIGFyZSBjdXJyZW50bHkgYWJsZSB0by5cclxuICAgICAgICB3aGlsZSAodGhpcy5uZXdSZXF1ZXN0XygpKSB7IH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBpcyBjYWxsZWQgYW55IHRpbWUgc29tZW9uZSBtaWdodCB3YW50IGEgc2NyaXB0IHRhZyB0byBiZSBhZGRlZC4gSXQgYWRkcyBhIHNjcmlwdCB0YWcgd2hlbiB0aGVyZSBhcmVuJ3RcclxuICAgICAqIHRvbyBtYW55IG91dHN0YW5kaW5nIHJlcXVlc3RzIGFuZCB3ZSBhcmUgc3RpbGwgYWxpdmUuXHJcbiAgICAgKlxyXG4gICAgICogSWYgdGhlcmUgYXJlIG91dHN0YW5kaW5nIHBhY2tldCBzZWdtZW50cyB0byBzZW5kLCBpdCBzZW5kcyBvbmUuIElmIHRoZXJlIGFyZW4ndCwgaXQgc2VuZHMgYSBsb25nLXBvbGwgYW55d2F5cyBpZlxyXG4gICAgICogbmVlZGVkLlxyXG4gICAgICovXHJcbiAgICBuZXdSZXF1ZXN0XygpIHtcclxuICAgICAgICAvLyBXZSBrZWVwIG9uZSBvdXRzdGFuZGluZyByZXF1ZXN0IG9wZW4gYWxsIHRoZSB0aW1lIHRvIHJlY2VpdmUgZGF0YSwgYnV0IGlmIHdlIG5lZWQgdG8gc2VuZCBkYXRhXHJcbiAgICAgICAgLy8gKHBlbmRpbmdTZWdzLmxlbmd0aCA+IDApIHRoZW4gd2UgY3JlYXRlIGEgbmV3IHJlcXVlc3QgdG8gc2VuZCB0aGUgZGF0YS4gIFRoZSBzZXJ2ZXIgd2lsbCBhdXRvbWF0aWNhbGx5XHJcbiAgICAgICAgLy8gY2xvc2UgdGhlIG9sZCByZXF1ZXN0LlxyXG4gICAgICAgIGlmICh0aGlzLmFsaXZlICYmXHJcbiAgICAgICAgICAgIHRoaXMuc2VuZE5ld1BvbGxzICYmXHJcbiAgICAgICAgICAgIHRoaXMub3V0c3RhbmRpbmdSZXF1ZXN0cy5zaXplIDwgKHRoaXMucGVuZGluZ1NlZ3MubGVuZ3RoID4gMCA/IDIgOiAxKSkge1xyXG4gICAgICAgICAgICAvL2NvbnN0cnVjdCBvdXIgdXJsXHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNlcmlhbCsrO1xyXG4gICAgICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX0lEX1BBUkFNXSA9IHRoaXMubXlJRDtcclxuICAgICAgICAgICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX1BXX1BBUkFNXSA9IHRoaXMubXlQVztcclxuICAgICAgICAgICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX1NFUklBTF9QQVJBTV0gPSB0aGlzLmN1cnJlbnRTZXJpYWw7XHJcbiAgICAgICAgICAgIGxldCB0aGVVUkwgPSB0aGlzLnVybEZuKHVybFBhcmFtcyk7XHJcbiAgICAgICAgICAgIC8vTm93IGFkZCBhcyBtdWNoIGRhdGEgYXMgd2UgY2FuLlxyXG4gICAgICAgICAgICBsZXQgY3VyRGF0YVN0cmluZyA9ICcnO1xyXG4gICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLnBlbmRpbmdTZWdzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIC8vZmlyc3QsIGxldHMgc2VlIGlmIHRoZSBuZXh0IHNlZ21lbnQgd2lsbCBmaXQuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0U2VnID0gdGhpcy5wZW5kaW5nU2Vnc1swXTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0U2VnLmQubGVuZ3RoICtcclxuICAgICAgICAgICAgICAgICAgICBTRUdfSEVBREVSX1NJWkUgK1xyXG4gICAgICAgICAgICAgICAgICAgIGN1ckRhdGFTdHJpbmcubGVuZ3RoIDw9XHJcbiAgICAgICAgICAgICAgICAgICAgTUFYX1VSTF9EQVRBX1NJWkUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2dyZWF0LCB0aGUgc2VnbWVudCB3aWxsIGZpdC4gTGV0cyBhcHBlbmQgaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGhlU2VnID0gdGhpcy5wZW5kaW5nU2Vncy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1ckRhdGFTdHJpbmcgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJEYXRhU3RyaW5nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcmJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBGSVJFQkFTRV9MT05HUE9MTF9TRUdNRU5UX05VTV9QQVJBTSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc9JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVTZWcuc2VnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcmJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBGSVJFQkFTRV9MT05HUE9MTF9TRUdNRU5UU19JTl9QQUNLRVQgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPScgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlU2VnLnRzICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcmJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBGSVJFQkFTRV9MT05HUE9MTF9EQVRBX1BBUkFNICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJz0nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZVNlZy5kO1xyXG4gICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoZVVSTCA9IHRoZVVSTCArIGN1ckRhdGFTdHJpbmc7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkTG9uZ1BvbGxUYWdfKHRoZVVSTCwgdGhpcy5jdXJyZW50U2VyaWFsKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBRdWV1ZSBhIHBhY2tldCBmb3IgdHJhbnNtaXNzaW9uIHRvIHRoZSBzZXJ2ZXIuXHJcbiAgICAgKiBAcGFyYW0gc2VnbnVtIC0gQSBzZXF1ZW50aWFsIGlkIGZvciB0aGlzIHBhY2tldCBzZWdtZW50IHVzZWQgZm9yIHJlYXNzZW1ibHlcclxuICAgICAqIEBwYXJhbSB0b3RhbHNlZ3MgLSBUaGUgdG90YWwgbnVtYmVyIG9mIHNlZ21lbnRzIGluIHRoaXMgcGFja2V0XHJcbiAgICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIGZvciB0aGlzIHNlZ21lbnQuXHJcbiAgICAgKi9cclxuICAgIGVucXVldWVTZWdtZW50KHNlZ251bSwgdG90YWxzZWdzLCBkYXRhKSB7XHJcbiAgICAgICAgLy9hZGQgdGhpcyB0byB0aGUgcXVldWUgb2Ygc2VnbWVudHMgdG8gc2VuZC5cclxuICAgICAgICB0aGlzLnBlbmRpbmdTZWdzLnB1c2goeyBzZWc6IHNlZ251bSwgdHM6IHRvdGFsc2VncywgZDogZGF0YSB9KTtcclxuICAgICAgICAvL3NlbmQgdGhlIGRhdGEgaW1tZWRpYXRlbHkgaWYgdGhlcmUgaXNuJ3QgYWxyZWFkeSBkYXRhIGJlaW5nIHRyYW5zbWl0dGVkLCB1bmxlc3NcclxuICAgICAgICAvL3N0YXJ0TG9uZ1BvbGwgaGFzbid0IGJlZW4gY2FsbGVkIHlldC5cclxuICAgICAgICBpZiAodGhpcy5hbGl2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLm5ld1JlcXVlc3RfKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSBzY3JpcHQgdGFnIGZvciBhIHJlZ3VsYXIgbG9uZy1wb2xsIHJlcXVlc3QuXHJcbiAgICAgKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCBvZiB0aGUgc2NyaXB0IHRhZy5cclxuICAgICAqIEBwYXJhbSBzZXJpYWwgLSBUaGUgc2VyaWFsIG51bWJlciBvZiB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgYWRkTG9uZ1BvbGxUYWdfKHVybCwgc2VyaWFsKSB7XHJcbiAgICAgICAgLy9yZW1lbWJlciB0aGF0IHdlIHNlbnQgdGhpcyByZXF1ZXN0LlxyXG4gICAgICAgIHRoaXMub3V0c3RhbmRpbmdSZXF1ZXN0cy5hZGQoc2VyaWFsKTtcclxuICAgICAgICBjb25zdCBkb05ld1JlcXVlc3QgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMub3V0c3RhbmRpbmdSZXF1ZXN0cy5kZWxldGUoc2VyaWFsKTtcclxuICAgICAgICAgICAgdGhpcy5uZXdSZXF1ZXN0XygpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gSWYgdGhpcyByZXF1ZXN0IGRvZXNuJ3QgcmV0dXJuIG9uIGl0cyBvd24gYWNjb3JkIChieSB0aGUgc2VydmVyIHNlbmRpbmcgdXMgc29tZSBkYXRhKSwgd2UnbGxcclxuICAgICAgICAvLyBjcmVhdGUgYSBuZXcgb25lIGFmdGVyIHRoZSBLRUVQQUxJVkUgaW50ZXJ2YWwgdG8gbWFrZSBzdXJlIHdlIGFsd2F5cyBrZWVwIGEgZnJlc2ggcmVxdWVzdCBvcGVuLlxyXG4gICAgICAgIGNvbnN0IGtlZXBhbGl2ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGRvTmV3UmVxdWVzdCwgTWF0aC5mbG9vcihLRUVQQUxJVkVfUkVRVUVTVF9JTlRFUlZBTCkpO1xyXG4gICAgICAgIGNvbnN0IHJlYWR5U3RhdGVDQiA9ICgpID0+IHtcclxuICAgICAgICAgICAgLy8gUmVxdWVzdCBjb21wbGV0ZWQuICBDYW5jZWwgdGhlIGtlZXBhbGl2ZS5cclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGtlZXBhbGl2ZVRpbWVvdXQpO1xyXG4gICAgICAgICAgICAvLyBUcmlnZ2VyIGEgbmV3IHJlcXVlc3Qgc28gd2UgY2FuIGNvbnRpbnVlIHJlY2VpdmluZyBkYXRhLlxyXG4gICAgICAgICAgICBkb05ld1JlcXVlc3QoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYWRkVGFnKHVybCwgcmVhZHlTdGF0ZUNCKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGFuIGFyYml0cmFyeSBzY3JpcHQgdGFnIHRvIHRoZSBpZnJhbWUuXHJcbiAgICAgKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCBmb3IgdGhlIHNjcmlwdCB0YWcgc291cmNlLlxyXG4gICAgICogQHBhcmFtIGxvYWRDQiAtIEEgY2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIG9uY2UgdGhlIHNjcmlwdCBoYXMgbG9hZGVkLlxyXG4gICAgICovXHJcbiAgICBhZGRUYWcodXJsLCBsb2FkQ0IpIHtcclxuICAgICAgICBpZiAoaXNOb2RlU2RrKCkpIHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgdGhpcy5kb05vZGVMb25nUG9sbCh1cmwsIGxvYWRDQik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UncmUgYWxyZWFkeSBjbG9zZWQsIGRvbid0IGFkZCB0aGlzIHBvbGxcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2VuZE5ld1BvbGxzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3U2NyaXB0ID0gdGhpcy5teUlGcmFtZS5kb2MuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3U2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcclxuICAgICAgICAgICAgICAgICAgICBuZXdTY3JpcHQuYXN5bmMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1NjcmlwdC5zcmMgPSB1cmw7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgICAgICAgICBuZXdTY3JpcHQub25sb2FkID0gbmV3U2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByc3RhdGUgPSBuZXdTY3JpcHQucmVhZHlTdGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcnN0YXRlIHx8IHJzdGF0ZSA9PT0gJ2xvYWRlZCcgfHwgcnN0YXRlID09PSAnY29tcGxldGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTY3JpcHQub25sb2FkID0gbmV3U2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1NjcmlwdC5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5ld1NjcmlwdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRDQigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1NjcmlwdC5vbmVycm9yID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2coJ0xvbmctcG9sbCBzY3JpcHQgZmFpbGVkIHRvIGxvYWQ6ICcgKyB1cmwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmROZXdQb2xscyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm15SUZyYW1lLmRvYy5ib2R5LmFwcGVuZENoaWxkKG5ld1NjcmlwdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHdlIHNob3VsZCBtYWtlIHRoaXMgZXJyb3IgdmlzaWJsZSBzb21laG93XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIE1hdGguZmxvb3IoMSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQ3VycmVudGx5IHNpbXBsaXN0aWMsIHRoaXMgY2xhc3MgbWFuYWdlcyB3aGF0IHRyYW5zcG9ydCBhIENvbm5lY3Rpb24gc2hvdWxkIHVzZSBhdCB2YXJpb3VzIHN0YWdlcyBvZiBpdHNcclxuICogbGlmZWN5Y2xlLlxyXG4gKlxyXG4gKiBJdCBzdGFydHMgd2l0aCBsb25ncG9sbGluZyBpbiBhIGJyb3dzZXIsIGFuZCBodHRwcG9sbGluZyBvbiBub2RlLiBJdCB0aGVuIHVwZ3JhZGVzIHRvIHdlYnNvY2tldHMgaWZcclxuICogdGhleSBhcmUgYXZhaWxhYmxlLlxyXG4gKi9cclxuY2xhc3MgVHJhbnNwb3J0TWFuYWdlciB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSByZXBvSW5mbyAtIE1ldGFkYXRhIGFyb3VuZCB0aGUgbmFtZXNwYWNlIHdlJ3JlIGNvbm5lY3RpbmcgdG9cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocmVwb0luZm8pIHtcclxuICAgICAgICB0aGlzLmluaXRUcmFuc3BvcnRzXyhyZXBvSW5mbyk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0IEFMTF9UUkFOU1BPUlRTKCkge1xyXG4gICAgICAgIHJldHVybiBbQnJvd3NlclBvbGxDb25uZWN0aW9uLCBXZWJTb2NrZXRDb25uZWN0aW9uXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRyYW5zcG9ydCBoYXMgYmVlbiBzZWxlY3RlZCB0byBlbnN1cmUgV2ViU29ja2V0Q29ubmVjdGlvbiBvciBCcm93c2VyUG9sbENvbm5lY3Rpb24gYXJlIG5vdCBjYWxsZWQgYWZ0ZXJcclxuICAgICAqIFRyYW5zcG9ydE1hbmFnZXIgaGFzIGFscmVhZHkgc2V0IHVwIHRyYW5zcG9ydHNfXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgSVNfVFJBTlNQT1JUX0lOSVRJQUxJWkVEKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdsb2JhbFRyYW5zcG9ydEluaXRpYWxpemVkXztcclxuICAgIH1cclxuICAgIGluaXRUcmFuc3BvcnRzXyhyZXBvSW5mbykge1xyXG4gICAgICAgIGNvbnN0IGlzV2ViU29ja2V0c0F2YWlsYWJsZSA9IFdlYlNvY2tldENvbm5lY3Rpb24gJiYgV2ViU29ja2V0Q29ubmVjdGlvblsnaXNBdmFpbGFibGUnXSgpO1xyXG4gICAgICAgIGxldCBpc1NraXBQb2xsQ29ubmVjdGlvbiA9IGlzV2ViU29ja2V0c0F2YWlsYWJsZSAmJiAhV2ViU29ja2V0Q29ubmVjdGlvbi5wcmV2aW91c2x5RmFpbGVkKCk7XHJcbiAgICAgICAgaWYgKHJlcG9JbmZvLndlYlNvY2tldE9ubHkpIHtcclxuICAgICAgICAgICAgaWYgKCFpc1dlYlNvY2tldHNBdmFpbGFibGUpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oXCJ3c3M6Ly8gVVJMIHVzZWQsIGJ1dCBicm93c2VyIGlzbid0IGtub3duIHRvIHN1cHBvcnQgd2Vic29ja2V0cy4gIFRyeWluZyBhbnl3YXkuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlzU2tpcFBvbGxDb25uZWN0aW9uID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzU2tpcFBvbGxDb25uZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0c18gPSBbV2ViU29ja2V0Q29ubmVjdGlvbl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCB0cmFuc3BvcnRzID0gKHRoaXMudHJhbnNwb3J0c18gPSBbXSk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgdHJhbnNwb3J0IG9mIFRyYW5zcG9ydE1hbmFnZXIuQUxMX1RSQU5TUE9SVFMpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0cmFuc3BvcnQgJiYgdHJhbnNwb3J0Wydpc0F2YWlsYWJsZSddKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnRzLnB1c2godHJhbnNwb3J0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBUcmFuc3BvcnRNYW5hZ2VyLmdsb2JhbFRyYW5zcG9ydEluaXRpYWxpemVkXyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY29uc3RydWN0b3IgZm9yIHRoZSBpbml0aWFsIHRyYW5zcG9ydCB0byB1c2VcclxuICAgICAqL1xyXG4gICAgaW5pdGlhbFRyYW5zcG9ydCgpIHtcclxuICAgICAgICBpZiAodGhpcy50cmFuc3BvcnRzXy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydHNfWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB0cmFuc3BvcnRzIGF2YWlsYWJsZScpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgbmV4dCB0cmFuc3BvcnQsIG9yIG51bGxcclxuICAgICAqL1xyXG4gICAgdXBncmFkZVRyYW5zcG9ydCgpIHtcclxuICAgICAgICBpZiAodGhpcy50cmFuc3BvcnRzXy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydHNfWzFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8vIEtlZXBzIHRyYWNrIG9mIHdoZXRoZXIgdGhlIFRyYW5zcG9ydE1hbmFnZXIgaGFzIGFscmVhZHkgY2hvc2VuIGEgdHJhbnNwb3J0IHRvIHVzZVxyXG5UcmFuc3BvcnRNYW5hZ2VyLmdsb2JhbFRyYW5zcG9ydEluaXRpYWxpemVkXyA9IGZhbHNlO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vLyBBYm9ydCB1cGdyYWRlIGF0dGVtcHQgaWYgaXQgdGFrZXMgbG9uZ2VyIHRoYW4gNjBzLlxyXG5jb25zdCBVUEdSQURFX1RJTUVPVVQgPSA2MDAwMDtcclxuLy8gRm9yIHNvbWUgdHJhbnNwb3J0cyAoV2ViU29ja2V0cyksIHdlIG5lZWQgdG8gXCJ2YWxpZGF0ZVwiIHRoZSB0cmFuc3BvcnQgYnkgZXhjaGFuZ2luZyBhIGZldyByZXF1ZXN0cyBhbmQgcmVzcG9uc2VzLlxyXG4vLyBJZiB3ZSBoYXZlbid0IHNlbnQgZW5vdWdoIHJlcXVlc3RzIHdpdGhpbiA1cywgd2UnbGwgc3RhcnQgc2VuZGluZyBub29wIHBpbmcgcmVxdWVzdHMuXHJcbmNvbnN0IERFTEFZX0JFRk9SRV9TRU5ESU5HX0VYVFJBX1JFUVVFU1RTID0gNTAwMDtcclxuLy8gSWYgdGhlIGluaXRpYWwgZGF0YSBzZW50IHRyaWdnZXJzIGEgbG90IG9mIGJhbmR3aWR0aCAoaS5lLiBpdCdzIGEgbGFyZ2UgcHV0IG9yIGEgbGlzdGVuIGZvciBhIGxhcmdlIGFtb3VudCBvZiBkYXRhKVxyXG4vLyB0aGVuIHdlIG1heSBub3QgYmUgYWJsZSB0byBleGNoYW5nZSBvdXIgcGluZy9wb25nIHJlcXVlc3RzIHdpdGhpbiB0aGUgaGVhbHRoeSB0aW1lb3V0LiAgU28gaWYgd2UgcmVhY2ggdGhlIHRpbWVvdXRcclxuLy8gYnV0IHdlJ3ZlIHNlbnQvcmVjZWl2ZWQgZW5vdWdoIGJ5dGVzLCB3ZSBkb24ndCBjYW5jZWwgdGhlIGNvbm5lY3Rpb24uXHJcbmNvbnN0IEJZVEVTX1NFTlRfSEVBTFRIWV9PVkVSUklERSA9IDEwICogMTAyNDtcclxuY29uc3QgQllURVNfUkVDRUlWRURfSEVBTFRIWV9PVkVSUklERSA9IDEwMCAqIDEwMjQ7XHJcbmNvbnN0IE1FU1NBR0VfVFlQRSA9ICd0JztcclxuY29uc3QgTUVTU0FHRV9EQVRBID0gJ2QnO1xyXG5jb25zdCBDT05UUk9MX1NIVVRET1dOID0gJ3MnO1xyXG5jb25zdCBDT05UUk9MX1JFU0VUID0gJ3InO1xyXG5jb25zdCBDT05UUk9MX0VSUk9SID0gJ2UnO1xyXG5jb25zdCBDT05UUk9MX1BPTkcgPSAnbyc7XHJcbmNvbnN0IFNXSVRDSF9BQ0sgPSAnYSc7XHJcbmNvbnN0IEVORF9UUkFOU01JU1NJT04gPSAnbic7XHJcbmNvbnN0IFBJTkcgPSAncCc7XHJcbmNvbnN0IFNFUlZFUl9IRUxMTyA9ICdoJztcclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgcmVhbC10aW1lIGNvbm5lY3Rpb24gdG8gdGhlIHNlcnZlciB1c2luZyB3aGljaGV2ZXIgbWV0aG9kIHdvcmtzXHJcbiAqIGJlc3QgaW4gdGhlIGN1cnJlbnQgYnJvd3Nlci5cclxuICovXHJcbmNsYXNzIENvbm5lY3Rpb24ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gaWQgLSBhbiBpZCBmb3IgdGhpcyBjb25uZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0gcmVwb0luZm9fIC0gdGhlIGluZm8gZm9yIHRoZSBlbmRwb2ludCB0byBjb25uZWN0IHRvXHJcbiAgICAgKiBAcGFyYW0gYXBwbGljYXRpb25JZF8gLSB0aGUgRmlyZWJhc2UgQXBwIElEIGZvciB0aGlzIHByb2plY3RcclxuICAgICAqIEBwYXJhbSBhcHBDaGVja1Rva2VuXyAtIFRoZSBBcHAgQ2hlY2sgVG9rZW4gZm9yIHRoaXMgZGV2aWNlLlxyXG4gICAgICogQHBhcmFtIGF1dGhUb2tlbl8gLSBUaGUgYXV0aCB0b2tlbiBmb3IgdGhpcyBzZXNzaW9uLlxyXG4gICAgICogQHBhcmFtIG9uTWVzc2FnZV8gLSB0aGUgY2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gYSBzZXJ2ZXItcHVzaCBtZXNzYWdlIGFycml2ZXNcclxuICAgICAqIEBwYXJhbSBvblJlYWR5XyAtIHRoZSBjYWxsYmFjayB0byBiZSB0cmlnZ2VyZWQgd2hlbiB0aGlzIGNvbm5lY3Rpb24gaXMgcmVhZHkgdG8gc2VuZCBtZXNzYWdlcy5cclxuICAgICAqIEBwYXJhbSBvbkRpc2Nvbm5lY3RfIC0gdGhlIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIGEgY29ubmVjdGlvbiB3YXMgbG9zdFxyXG4gICAgICogQHBhcmFtIG9uS2lsbF8gLSB0aGUgY2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gdGhpcyBjb25uZWN0aW9uIGhhcyBwZXJtYW5lbnRseSBzaHV0IGRvd24uXHJcbiAgICAgKiBAcGFyYW0gbGFzdFNlc3Npb25JZCAtIGxhc3Qgc2Vzc2lvbiBpZCBpbiBwZXJzaXN0ZW50IGNvbm5lY3Rpb24uIGlzIHVzZWQgdG8gY2xlYW4gdXAgb2xkIHNlc3Npb24gaW4gcmVhbC10aW1lIHNlcnZlclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihpZCwgcmVwb0luZm9fLCBhcHBsaWNhdGlvbklkXywgYXBwQ2hlY2tUb2tlbl8sIGF1dGhUb2tlbl8sIG9uTWVzc2FnZV8sIG9uUmVhZHlfLCBvbkRpc2Nvbm5lY3RfLCBvbktpbGxfLCBsYXN0U2Vzc2lvbklkKSB7XHJcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgICAgIHRoaXMucmVwb0luZm9fID0gcmVwb0luZm9fO1xyXG4gICAgICAgIHRoaXMuYXBwbGljYXRpb25JZF8gPSBhcHBsaWNhdGlvbklkXztcclxuICAgICAgICB0aGlzLmFwcENoZWNrVG9rZW5fID0gYXBwQ2hlY2tUb2tlbl87XHJcbiAgICAgICAgdGhpcy5hdXRoVG9rZW5fID0gYXV0aFRva2VuXztcclxuICAgICAgICB0aGlzLm9uTWVzc2FnZV8gPSBvbk1lc3NhZ2VfO1xyXG4gICAgICAgIHRoaXMub25SZWFkeV8gPSBvblJlYWR5XztcclxuICAgICAgICB0aGlzLm9uRGlzY29ubmVjdF8gPSBvbkRpc2Nvbm5lY3RfO1xyXG4gICAgICAgIHRoaXMub25LaWxsXyA9IG9uS2lsbF87XHJcbiAgICAgICAgdGhpcy5sYXN0U2Vzc2lvbklkID0gbGFzdFNlc3Npb25JZDtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Db3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nRGF0YU1lc3NhZ2VzID0gW107XHJcbiAgICAgICAgdGhpcy5zdGF0ZV8gPSAwIC8qIFJlYWx0aW1lU3RhdGUuQ09OTkVDVElORyAqLztcclxuICAgICAgICB0aGlzLmxvZ18gPSBsb2dXcmFwcGVyKCdjOicgKyB0aGlzLmlkICsgJzonKTtcclxuICAgICAgICB0aGlzLnRyYW5zcG9ydE1hbmFnZXJfID0gbmV3IFRyYW5zcG9ydE1hbmFnZXIocmVwb0luZm9fKTtcclxuICAgICAgICB0aGlzLmxvZ18oJ0Nvbm5lY3Rpb24gY3JlYXRlZCcpO1xyXG4gICAgICAgIHRoaXMuc3RhcnRfKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0cyBhIGNvbm5lY3Rpb24gYXR0ZW1wdFxyXG4gICAgICovXHJcbiAgICBzdGFydF8oKSB7XHJcbiAgICAgICAgY29uc3QgY29ubiA9IHRoaXMudHJhbnNwb3J0TWFuYWdlcl8uaW5pdGlhbFRyYW5zcG9ydCgpO1xyXG4gICAgICAgIHRoaXMuY29ubl8gPSBuZXcgY29ubih0aGlzLm5leHRUcmFuc3BvcnRJZF8oKSwgdGhpcy5yZXBvSW5mb18sIHRoaXMuYXBwbGljYXRpb25JZF8sIHRoaXMuYXBwQ2hlY2tUb2tlbl8sIHRoaXMuYXV0aFRva2VuXywgbnVsbCwgdGhpcy5sYXN0U2Vzc2lvbklkKTtcclxuICAgICAgICAvLyBGb3IgY2VydGFpbiB0cmFuc3BvcnRzIChXZWJTb2NrZXRzKSwgd2UgbmVlZCB0byBzZW5kIGFuZCByZWNlaXZlIHNldmVyYWwgbWVzc2FnZXMgYmFjayBhbmQgZm9ydGggYmVmb3JlIHdlXHJcbiAgICAgICAgLy8gY2FuIGNvbnNpZGVyIHRoZSB0cmFuc3BvcnQgaGVhbHRoeS5cclxuICAgICAgICB0aGlzLnByaW1hcnlSZXNwb25zZXNSZXF1aXJlZF8gPSBjb25uWydyZXNwb25zZXNSZXF1aXJlZFRvQmVIZWFsdGh5J10gfHwgMDtcclxuICAgICAgICBjb25zdCBvbk1lc3NhZ2VSZWNlaXZlZCA9IHRoaXMuY29ublJlY2VpdmVyXyh0aGlzLmNvbm5fKTtcclxuICAgICAgICBjb25zdCBvbkNvbm5lY3Rpb25Mb3N0ID0gdGhpcy5kaXNjb25uUmVjZWl2ZXJfKHRoaXMuY29ubl8pO1xyXG4gICAgICAgIHRoaXMudHhfID0gdGhpcy5jb25uXztcclxuICAgICAgICB0aGlzLnJ4XyA9IHRoaXMuY29ubl87XHJcbiAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pc0hlYWx0aHlfID0gZmFsc2U7XHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBGaXJlZm94IGRvZXNuJ3QgbGlrZSB3aGVuIGNvZGUgZnJvbSBvbmUgaWZyYW1lIHRyaWVzIHRvIGNyZWF0ZSBhbm90aGVyIGlmcmFtZSBieSB3YXkgb2YgdGhlIHBhcmVudCBmcmFtZS5cclxuICAgICAgICAgKiBUaGlzIGNhbiBvY2N1ciBpbiB0aGUgY2FzZSBvZiBhIHJlZGlyZWN0LCBpLmUuIHdlIGd1ZXNzZWQgd3Jvbmcgb24gd2hhdCBzZXJ2ZXIgdG8gY29ubmVjdCB0byBhbmQgcmVjZWl2ZWQgYSByZXNldC5cclxuICAgICAgICAgKiBTb21laG93LCBzZXRUaW1lb3V0IHNlZW1zIHRvIG1ha2UgdGhpcyBvay4gVGhhdCBkb2Vzbid0IG1ha2Ugc2Vuc2UgZnJvbSBhIHNlY3VyaXR5IHBlcnNwZWN0aXZlLCBzaW5jZSB5b3Ugc2hvdWxkXHJcbiAgICAgICAgICogc3RpbGwgaGF2ZSB0aGUgY29udGV4dCBvZiB5b3VyIG9yaWdpbmF0aW5nIGZyYW1lLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyB0aGlzLmNvbm5fIGdldHMgc2V0IHRvIG51bGwgaW4gc29tZSBvZiB0aGUgdGVzdHMuIENoZWNrIHRvIG1ha2Ugc3VyZSBpdCBzdGlsbCBleGlzdHMgYmVmb3JlIHVzaW5nIGl0XHJcbiAgICAgICAgICAgIHRoaXMuY29ubl8gJiYgdGhpcy5jb25uXy5vcGVuKG9uTWVzc2FnZVJlY2VpdmVkLCBvbkNvbm5lY3Rpb25Mb3N0KTtcclxuICAgICAgICB9LCBNYXRoLmZsb29yKDApKTtcclxuICAgICAgICBjb25zdCBoZWFsdGh5VGltZW91dE1TID0gY29ublsnaGVhbHRoeVRpbWVvdXQnXSB8fCAwO1xyXG4gICAgICAgIGlmIChoZWFsdGh5VGltZW91dE1TID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmhlYWx0aHlUaW1lb3V0XyA9IHNldFRpbWVvdXROb25CbG9ja2luZygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWx0aHlUaW1lb3V0XyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNIZWFsdGh5Xykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbm5fICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubl8uYnl0ZXNSZWNlaXZlZCA+IEJZVEVTX1JFQ0VJVkVEX0hFQUxUSFlfT1ZFUlJJREUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdDb25uZWN0aW9uIGV4Y2VlZGVkIGhlYWx0aHkgdGltZW91dCBidXQgaGFzIHJlY2VpdmVkICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uXy5ieXRlc1JlY2VpdmVkICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgYnl0ZXMuICBNYXJraW5nIGNvbm5lY3Rpb24gaGVhbHRoeS4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0hlYWx0aHlfID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uXy5tYXJrQ29ubmVjdGlvbkhlYWx0aHkoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jb25uXyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5fLmJ5dGVzU2VudCA+IEJZVEVTX1NFTlRfSEVBTFRIWV9PVkVSUklERSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ18oJ0Nvbm5lY3Rpb24gZXhjZWVkZWQgaGVhbHRoeSB0aW1lb3V0IGJ1dCBoYXMgc2VudCAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubl8uYnl0ZXNTZW50ICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgYnl0ZXMuICBMZWF2aW5nIGNvbm5lY3Rpb24gYWxpdmUuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IFdlIGRvbid0IHdhbnQgdG8gbWFyayBpdCBoZWFsdGh5LCBzaW5jZSB3ZSBoYXZlIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBieXRlcyBoYXZlIG1hZGUgaXQgdG9cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHNlcnZlci5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nXygnQ2xvc2luZyB1bmhlYWx0aHkgY29ubmVjdGlvbiBhZnRlciB0aW1lb3V0LicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgfSwgTWF0aC5mbG9vcihoZWFsdGh5VGltZW91dE1TKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbmV4dFRyYW5zcG9ydElkXygpIHtcclxuICAgICAgICByZXR1cm4gJ2M6JyArIHRoaXMuaWQgKyAnOicgKyB0aGlzLmNvbm5lY3Rpb25Db3VudCsrO1xyXG4gICAgfVxyXG4gICAgZGlzY29ublJlY2VpdmVyXyhjb25uKSB7XHJcbiAgICAgICAgcmV0dXJuIGV2ZXJDb25uZWN0ZWQgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY29ubiA9PT0gdGhpcy5jb25uXykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkNvbm5lY3Rpb25Mb3N0XyhldmVyQ29ubmVjdGVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjb25uID09PSB0aGlzLnNlY29uZGFyeUNvbm5fKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ18oJ1NlY29uZGFyeSBjb25uZWN0aW9uIGxvc3QuJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uU2Vjb25kYXJ5Q29ubmVjdGlvbkxvc3RfKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ18oJ2Nsb3NpbmcgYW4gb2xkIGNvbm5lY3Rpb24nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjb25uUmVjZWl2ZXJfKGNvbm4pIHtcclxuICAgICAgICByZXR1cm4gKG1lc3NhZ2UpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGVfICE9PSAyIC8qIFJlYWx0aW1lU3RhdGUuRElTQ09OTkVDVEVEICovKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29ubiA9PT0gdGhpcy5yeF8pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uUHJpbWFyeU1lc3NhZ2VSZWNlaXZlZF8obWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb25uID09PSB0aGlzLnNlY29uZGFyeUNvbm5fKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblNlY29uZGFyeU1lc3NhZ2VSZWNlaXZlZF8obWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ18oJ21lc3NhZ2Ugb24gb2xkIGNvbm5lY3Rpb24nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBkYXRhTXNnIC0gQW4gYXJiaXRyYXJ5IGRhdGEgbWVzc2FnZSB0byBiZSBzZW50IHRvIHRoZSBzZXJ2ZXJcclxuICAgICAqL1xyXG4gICAgc2VuZFJlcXVlc3QoZGF0YU1zZykge1xyXG4gICAgICAgIC8vIHdyYXAgaW4gYSBkYXRhIG1lc3NhZ2UgZW52ZWxvcGUgYW5kIHNlbmQgaXQgb25cclxuICAgICAgICBjb25zdCBtc2cgPSB7IHQ6ICdkJywgZDogZGF0YU1zZyB9O1xyXG4gICAgICAgIHRoaXMuc2VuZERhdGFfKG1zZyk7XHJcbiAgICB9XHJcbiAgICB0cnlDbGVhbnVwQ29ubmVjdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy50eF8gPT09IHRoaXMuc2Vjb25kYXJ5Q29ubl8gJiYgdGhpcy5yeF8gPT09IHRoaXMuc2Vjb25kYXJ5Q29ubl8pIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdjbGVhbmluZyB1cCBhbmQgcHJvbW90aW5nIGEgY29ubmVjdGlvbjogJyArIHRoaXMuc2Vjb25kYXJ5Q29ubl8uY29ubklkKTtcclxuICAgICAgICAgICAgdGhpcy5jb25uXyA9IHRoaXMuc2Vjb25kYXJ5Q29ubl87XHJcbiAgICAgICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8gPSBudWxsO1xyXG4gICAgICAgICAgICAvLyB0aGUgc2VydmVyIHdpbGwgc2h1dGRvd24gdGhlIG9sZCBjb25uZWN0aW9uXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25TZWNvbmRhcnlDb250cm9sXyhjb250cm9sRGF0YSkge1xyXG4gICAgICAgIGlmIChNRVNTQUdFX1RZUEUgaW4gY29udHJvbERhdGEpIHtcclxuICAgICAgICAgICAgY29uc3QgY21kID0gY29udHJvbERhdGFbTUVTU0FHRV9UWVBFXTtcclxuICAgICAgICAgICAgaWYgKGNtZCA9PT0gU1dJVENIX0FDSykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGdyYWRlSWZTZWNvbmRhcnlIZWFsdGh5XygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNtZCA9PT0gQ09OVFJPTF9SRVNFVCkge1xyXG4gICAgICAgICAgICAgICAgLy8gTW9zdCBsaWtlbHkgdGhlIHNlc3Npb24gd2Fzbid0IHZhbGlkLiBBYmFuZG9uIHRoZSBzd2l0Y2ggYXR0ZW1wdFxyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdHb3QgYSByZXNldCBvbiBzZWNvbmRhcnksIGNsb3NpbmcgaXQnKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8uY2xvc2UoKTtcclxuICAgICAgICAgICAgICAgIC8vIElmIHdlIHdlcmUgYWxyZWFkeSB1c2luZyB0aGlzIGNvbm5lY3Rpb24gZm9yIHNvbWV0aGluZywgdGhhbiB3ZSBuZWVkIHRvIGZ1bGx5IGNsb3NlXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eF8gPT09IHRoaXMuc2Vjb25kYXJ5Q29ubl8gfHxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ4XyA9PT0gdGhpcy5zZWNvbmRhcnlDb25uXykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbWQgPT09IENPTlRST0xfUE9ORykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdnb3QgcG9uZyBvbiBzZWNvbmRhcnkuJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlY29uZGFyeVJlc3BvbnNlc1JlcXVpcmVkXy0tO1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGdyYWRlSWZTZWNvbmRhcnlIZWFsdGh5XygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25TZWNvbmRhcnlNZXNzYWdlUmVjZWl2ZWRfKHBhcnNlZERhdGEpIHtcclxuICAgICAgICBjb25zdCBsYXllciA9IHJlcXVpcmVLZXkoJ3QnLCBwYXJzZWREYXRhKTtcclxuICAgICAgICBjb25zdCBkYXRhID0gcmVxdWlyZUtleSgnZCcsIHBhcnNlZERhdGEpO1xyXG4gICAgICAgIGlmIChsYXllciA9PT0gJ2MnKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25TZWNvbmRhcnlDb250cm9sXyhkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobGF5ZXIgPT09ICdkJykge1xyXG4gICAgICAgICAgICAvLyBnb3QgYSBkYXRhIG1lc3NhZ2UsIGJ1dCB3ZSdyZSBzdGlsbCBzZWNvbmQgY29ubmVjdGlvbi4gTmVlZCB0byBidWZmZXIgaXQgdXBcclxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nRGF0YU1lc3NhZ2VzLnB1c2goZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcHJvdG9jb2wgbGF5ZXI6ICcgKyBsYXllcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdXBncmFkZUlmU2Vjb25kYXJ5SGVhbHRoeV8oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2Vjb25kYXJ5UmVzcG9uc2VzUmVxdWlyZWRfIDw9IDApIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdTZWNvbmRhcnkgY29ubmVjdGlvbiBpcyBoZWFsdGh5LicpO1xyXG4gICAgICAgICAgICB0aGlzLmlzSGVhbHRoeV8gPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fLm1hcmtDb25uZWN0aW9uSGVhbHRoeSgpO1xyXG4gICAgICAgICAgICB0aGlzLnByb2NlZWRXaXRoVXBncmFkZV8oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFNlbmQgYSBwaW5nIHRvIG1ha2Ugc3VyZSB0aGUgY29ubmVjdGlvbiBpcyBoZWFsdGh5LlxyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ3NlbmRpbmcgcGluZyBvbiBzZWNvbmRhcnkuJyk7XHJcbiAgICAgICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8uc2VuZCh7IHQ6ICdjJywgZDogeyB0OiBQSU5HLCBkOiB7fSB9IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHByb2NlZWRXaXRoVXBncmFkZV8oKSB7XHJcbiAgICAgICAgLy8gdGVsbCB0aGlzIGNvbm5lY3Rpb24gdG8gY29uc2lkZXIgaXRzZWxmIG9wZW5cclxuICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fLnN0YXJ0KCk7XHJcbiAgICAgICAgLy8gc2VuZCBhY2tcclxuICAgICAgICB0aGlzLmxvZ18oJ3NlbmRpbmcgY2xpZW50IGFjayBvbiBzZWNvbmRhcnknKTtcclxuICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fLnNlbmQoeyB0OiAnYycsIGQ6IHsgdDogU1dJVENIX0FDSywgZDoge30gfSB9KTtcclxuICAgICAgICAvLyBzZW5kIGVuZCBwYWNrZXQgb24gcHJpbWFyeSB0cmFuc3BvcnQsIHN3aXRjaCB0byBzZW5kaW5nIG9uIHRoaXMgb25lXHJcbiAgICAgICAgLy8gY2FuIHJlY2VpdmUgb24gdGhpcyBvbmUsIGJ1ZmZlciByZXNwb25zZXMgdW50aWwgZW5kIHJlY2VpdmVkIG9uIHByaW1hcnkgdHJhbnNwb3J0XHJcbiAgICAgICAgdGhpcy5sb2dfKCdFbmRpbmcgdHJhbnNtaXNzaW9uIG9uIHByaW1hcnknKTtcclxuICAgICAgICB0aGlzLmNvbm5fLnNlbmQoeyB0OiAnYycsIGQ6IHsgdDogRU5EX1RSQU5TTUlTU0lPTiwgZDoge30gfSB9KTtcclxuICAgICAgICB0aGlzLnR4XyA9IHRoaXMuc2Vjb25kYXJ5Q29ubl87XHJcbiAgICAgICAgdGhpcy50cnlDbGVhbnVwQ29ubmVjdGlvbigpO1xyXG4gICAgfVxyXG4gICAgb25QcmltYXJ5TWVzc2FnZVJlY2VpdmVkXyhwYXJzZWREYXRhKSB7XHJcbiAgICAgICAgLy8gTXVzdCByZWZlciB0byBwYXJzZWREYXRhIHByb3BlcnRpZXMgaW4gcXVvdGVzLCBzbyBjbG9zdXJlIGRvZXNuJ3QgdG91Y2ggdGhlbS5cclxuICAgICAgICBjb25zdCBsYXllciA9IHJlcXVpcmVLZXkoJ3QnLCBwYXJzZWREYXRhKTtcclxuICAgICAgICBjb25zdCBkYXRhID0gcmVxdWlyZUtleSgnZCcsIHBhcnNlZERhdGEpO1xyXG4gICAgICAgIGlmIChsYXllciA9PT0gJ2MnKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25Db250cm9sXyhkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobGF5ZXIgPT09ICdkJykge1xyXG4gICAgICAgICAgICB0aGlzLm9uRGF0YU1lc3NhZ2VfKGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uRGF0YU1lc3NhZ2VfKG1lc3NhZ2UpIHtcclxuICAgICAgICB0aGlzLm9uUHJpbWFyeVJlc3BvbnNlXygpO1xyXG4gICAgICAgIC8vIFdlIGRvbid0IGRvIGFueXRoaW5nIHdpdGggZGF0YSBtZXNzYWdlcywganVzdCBraWNrIHRoZW0gdXAgYSBsZXZlbFxyXG4gICAgICAgIHRoaXMub25NZXNzYWdlXyhtZXNzYWdlKTtcclxuICAgIH1cclxuICAgIG9uUHJpbWFyeVJlc3BvbnNlXygpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNIZWFsdGh5Xykge1xyXG4gICAgICAgICAgICB0aGlzLnByaW1hcnlSZXNwb25zZXNSZXF1aXJlZF8tLTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucHJpbWFyeVJlc3BvbnNlc1JlcXVpcmVkXyA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ18oJ1ByaW1hcnkgY29ubmVjdGlvbiBpcyBoZWFsdGh5LicpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc0hlYWx0aHlfID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29ubl8ubWFya0Nvbm5lY3Rpb25IZWFsdGh5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvbkNvbnRyb2xfKGNvbnRyb2xEYXRhKSB7XHJcbiAgICAgICAgY29uc3QgY21kID0gcmVxdWlyZUtleShNRVNTQUdFX1RZUEUsIGNvbnRyb2xEYXRhKTtcclxuICAgICAgICBpZiAoTUVTU0FHRV9EQVRBIGluIGNvbnRyb2xEYXRhKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBjb250cm9sRGF0YVtNRVNTQUdFX0RBVEFdO1xyXG4gICAgICAgICAgICBpZiAoY21kID09PSBTRVJWRVJfSEVMTE8pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRzaGFrZVBheWxvYWQgPSBPYmplY3QuYXNzaWduKHt9LCBwYXlsb2FkKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlcG9JbmZvXy5pc1VzaW5nRW11bGF0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBVcG9uIGNvbm5lY3RpbmcsIHRoZSBlbXVsYXRvciB3aWxsIHBhc3MgdGhlIGhvc3RuYW1lIHRoYXQgaXQncyBhd2FyZSBvZiwgYnV0IHdlIHByZWZlciB0aGUgdXNlcidzIHNldCBob3N0bmFtZSB2aWEgYGNvbm5lY3REYXRhYmFzZUVtdWxhdG9yYCBvdmVyIHdoYXQgdGhlIGVtdWxhdG9yIHBhc3Nlcy5cclxuICAgICAgICAgICAgICAgICAgICBoYW5kc2hha2VQYXlsb2FkLmggPSB0aGlzLnJlcG9JbmZvXy5ob3N0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkhhbmRzaGFrZV8oaGFuZHNoYWtlUGF5bG9hZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21kID09PSBFTkRfVFJBTlNNSVNTSU9OKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ18oJ3JlY3ZkIGVuZCB0cmFuc21pc3Npb24gb24gcHJpbWFyeScpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yeF8gPSB0aGlzLnNlY29uZGFyeUNvbm5fO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBlbmRpbmdEYXRhTWVzc2FnZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRGF0YU1lc3NhZ2VfKHRoaXMucGVuZGluZ0RhdGFNZXNzYWdlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdEYXRhTWVzc2FnZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJ5Q2xlYW51cENvbm5lY3Rpb24oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbWQgPT09IENPTlRST0xfU0hVVERPV04pIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgd2FzIHByZXZpb3VzbHkgdGhlICdvbktpbGwnIGNhbGxiYWNrIHBhc3NlZCB0byB0aGUgbG93ZXItbGV2ZWwgY29ubmVjdGlvblxyXG4gICAgICAgICAgICAgICAgLy8gcGF5bG9hZCBpbiB0aGlzIGNhc2UgaXMgdGhlIHJlYXNvbiBmb3IgdGhlIHNodXRkb3duLiBHZW5lcmFsbHkgYSBodW1hbi1yZWFkYWJsZSBlcnJvclxyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkNvbm5lY3Rpb25TaHV0ZG93bl8ocGF5bG9hZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21kID09PSBDT05UUk9MX1JFU0VUKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBwYXlsb2FkIGluIHRoaXMgY2FzZSBpcyB0aGUgaG9zdCB3ZSBzaG91bGQgY29udGFjdFxyXG4gICAgICAgICAgICAgICAgdGhpcy5vblJlc2V0XyhwYXlsb2FkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbWQgPT09IENPTlRST0xfRVJST1IpIHtcclxuICAgICAgICAgICAgICAgIGVycm9yKCdTZXJ2ZXIgRXJyb3I6ICcgKyBwYXlsb2FkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbWQgPT09IENPTlRST0xfUE9ORykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdnb3QgcG9uZyBvbiBwcmltYXJ5LicpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vblByaW1hcnlSZXNwb25zZV8oKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFBpbmdPblByaW1hcnlJZk5lY2Vzc2FyeV8oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGVycm9yKCdVbmtub3duIGNvbnRyb2wgcGFja2V0IGNvbW1hbmQ6ICcgKyBjbWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gaGFuZHNoYWtlIC0gVGhlIGhhbmRzaGFrZSBkYXRhIHJldHVybmVkIGZyb20gdGhlIHNlcnZlclxyXG4gICAgICovXHJcbiAgICBvbkhhbmRzaGFrZV8oaGFuZHNoYWtlKSB7XHJcbiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gaGFuZHNoYWtlLnRzO1xyXG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSBoYW5kc2hha2UudjtcclxuICAgICAgICBjb25zdCBob3N0ID0gaGFuZHNoYWtlLmg7XHJcbiAgICAgICAgdGhpcy5zZXNzaW9uSWQgPSBoYW5kc2hha2UucztcclxuICAgICAgICB0aGlzLnJlcG9JbmZvXy5ob3N0ID0gaG9zdDtcclxuICAgICAgICAvLyBpZiB3ZSd2ZSBhbHJlYWR5IGNsb3NlZCB0aGUgY29ubmVjdGlvbiwgdGhlbiBkb24ndCBib3RoZXIgdHJ5aW5nIHRvIHByb2dyZXNzIGZ1cnRoZXJcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZV8gPT09IDAgLyogUmVhbHRpbWVTdGF0ZS5DT05ORUNUSU5HICovKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubl8uc3RhcnQoKTtcclxuICAgICAgICAgICAgdGhpcy5vbkNvbm5lY3Rpb25Fc3RhYmxpc2hlZF8odGhpcy5jb25uXywgdGltZXN0YW1wKTtcclxuICAgICAgICAgICAgaWYgKFBST1RPQ09MX1ZFUlNJT04gIT09IHZlcnNpb24pIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oJ1Byb3RvY29sIHZlcnNpb24gbWlzbWF0Y2ggZGV0ZWN0ZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBUT0RPOiBkbyB3ZSB3YW50IHRvIHVwZ3JhZGU/IHdoZW4/IG1heWJlIGEgZGVsYXk/XHJcbiAgICAgICAgICAgIHRoaXMudHJ5U3RhcnRVcGdyYWRlXygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRyeVN0YXJ0VXBncmFkZV8oKSB7XHJcbiAgICAgICAgY29uc3QgY29ubiA9IHRoaXMudHJhbnNwb3J0TWFuYWdlcl8udXBncmFkZVRyYW5zcG9ydCgpO1xyXG4gICAgICAgIGlmIChjb25uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRVcGdyYWRlXyhjb25uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGFydFVwZ3JhZGVfKGNvbm4pIHtcclxuICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fID0gbmV3IGNvbm4odGhpcy5uZXh0VHJhbnNwb3J0SWRfKCksIHRoaXMucmVwb0luZm9fLCB0aGlzLmFwcGxpY2F0aW9uSWRfLCB0aGlzLmFwcENoZWNrVG9rZW5fLCB0aGlzLmF1dGhUb2tlbl8sIHRoaXMuc2Vzc2lvbklkKTtcclxuICAgICAgICAvLyBGb3IgY2VydGFpbiB0cmFuc3BvcnRzIChXZWJTb2NrZXRzKSwgd2UgbmVlZCB0byBzZW5kIGFuZCByZWNlaXZlIHNldmVyYWwgbWVzc2FnZXMgYmFjayBhbmQgZm9ydGggYmVmb3JlIHdlXHJcbiAgICAgICAgLy8gY2FuIGNvbnNpZGVyIHRoZSB0cmFuc3BvcnQgaGVhbHRoeS5cclxuICAgICAgICB0aGlzLnNlY29uZGFyeVJlc3BvbnNlc1JlcXVpcmVkXyA9XHJcbiAgICAgICAgICAgIGNvbm5bJ3Jlc3BvbnNlc1JlcXVpcmVkVG9CZUhlYWx0aHknXSB8fCAwO1xyXG4gICAgICAgIGNvbnN0IG9uTWVzc2FnZSA9IHRoaXMuY29ublJlY2VpdmVyXyh0aGlzLnNlY29uZGFyeUNvbm5fKTtcclxuICAgICAgICBjb25zdCBvbkRpc2Nvbm5lY3QgPSB0aGlzLmRpc2Nvbm5SZWNlaXZlcl8odGhpcy5zZWNvbmRhcnlDb25uXyk7XHJcbiAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXy5vcGVuKG9uTWVzc2FnZSwgb25EaXNjb25uZWN0KTtcclxuICAgICAgICAvLyBJZiB3ZSBoYXZlbid0IHN1Y2Nlc3NmdWxseSB1cGdyYWRlZCBhZnRlciBVUEdSQURFX1RJTUVPVVQsIGdpdmUgdXAgYW5kIGtpbGwgdGhlIHNlY29uZGFyeS5cclxuICAgICAgICBzZXRUaW1lb3V0Tm9uQmxvY2tpbmcoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zZWNvbmRhcnlDb25uXykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdUaW1lZCBvdXQgdHJ5aW5nIHRvIHVwZ3JhZGUuJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBNYXRoLmZsb29yKFVQR1JBREVfVElNRU9VVCkpO1xyXG4gICAgfVxyXG4gICAgb25SZXNldF8oaG9zdCkge1xyXG4gICAgICAgIHRoaXMubG9nXygnUmVzZXQgcGFja2V0IHJlY2VpdmVkLiAgTmV3IGhvc3Q6ICcgKyBob3N0KTtcclxuICAgICAgICB0aGlzLnJlcG9JbmZvXy5ob3N0ID0gaG9zdDtcclxuICAgICAgICAvLyBUT0RPOiBpZiB3ZSdyZSBhbHJlYWR5IFwiY29ubmVjdGVkXCIsIHdlIG5lZWQgdG8gdHJpZ2dlciBhIGRpc2Nvbm5lY3QgYXQgdGhlIG5leHQgbGF5ZXIgdXAuXHJcbiAgICAgICAgLy8gV2UgZG9uJ3QgY3VycmVudGx5IHN1cHBvcnQgcmVzZXRzIGFmdGVyIHRoZSBjb25uZWN0aW9uIGhhcyBhbHJlYWR5IGJlZW4gZXN0YWJsaXNoZWRcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZV8gPT09IDEgLyogUmVhbHRpbWVTdGF0ZS5DT05ORUNURUQgKi8pIHtcclxuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gQ2xvc2Ugd2hhdGV2ZXIgY29ubmVjdGlvbnMgd2UgaGF2ZSBvcGVuIGFuZCBzdGFydCBhZ2Fpbi5cclxuICAgICAgICAgICAgdGhpcy5jbG9zZUNvbm5lY3Rpb25zXygpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0XygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uQ29ubmVjdGlvbkVzdGFibGlzaGVkXyhjb25uLCB0aW1lc3RhbXApIHtcclxuICAgICAgICB0aGlzLmxvZ18oJ1JlYWx0aW1lIGNvbm5lY3Rpb24gZXN0YWJsaXNoZWQuJyk7XHJcbiAgICAgICAgdGhpcy5jb25uXyA9IGNvbm47XHJcbiAgICAgICAgdGhpcy5zdGF0ZV8gPSAxIC8qIFJlYWx0aW1lU3RhdGUuQ09OTkVDVEVEICovO1xyXG4gICAgICAgIGlmICh0aGlzLm9uUmVhZHlfKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25SZWFkeV8odGltZXN0YW1wLCB0aGlzLnNlc3Npb25JZCk7XHJcbiAgICAgICAgICAgIHRoaXMub25SZWFkeV8gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiBhZnRlciA1IHNlY29uZHMgd2UgaGF2ZW4ndCBzZW50IGVub3VnaCByZXF1ZXN0cyB0byB0aGUgc2VydmVyIHRvIGdldCB0aGUgY29ubmVjdGlvbiBoZWFsdGh5LFxyXG4gICAgICAgIC8vIHNlbmQgc29tZSBwaW5ncy5cclxuICAgICAgICBpZiAodGhpcy5wcmltYXJ5UmVzcG9uc2VzUmVxdWlyZWRfID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnUHJpbWFyeSBjb25uZWN0aW9uIGlzIGhlYWx0aHkuJyk7XHJcbiAgICAgICAgICAgIHRoaXMuaXNIZWFsdGh5XyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0Tm9uQmxvY2tpbmcoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kUGluZ09uUHJpbWFyeUlmTmVjZXNzYXJ5XygpO1xyXG4gICAgICAgICAgICB9LCBNYXRoLmZsb29yKERFTEFZX0JFRk9SRV9TRU5ESU5HX0VYVFJBX1JFUVVFU1RTKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2VuZFBpbmdPblByaW1hcnlJZk5lY2Vzc2FyeV8oKSB7XHJcbiAgICAgICAgLy8gSWYgdGhlIGNvbm5lY3Rpb24gaXNuJ3QgY29uc2lkZXJlZCBoZWFsdGh5IHlldCwgd2UnbGwgc2VuZCBhIG5vb3AgcGluZyBwYWNrZXQgcmVxdWVzdC5cclxuICAgICAgICBpZiAoIXRoaXMuaXNIZWFsdGh5XyAmJiB0aGlzLnN0YXRlXyA9PT0gMSAvKiBSZWFsdGltZVN0YXRlLkNPTk5FQ1RFRCAqLykge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ3NlbmRpbmcgcGluZyBvbiBwcmltYXJ5LicpO1xyXG4gICAgICAgICAgICB0aGlzLnNlbmREYXRhXyh7IHQ6ICdjJywgZDogeyB0OiBQSU5HLCBkOiB7fSB9IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uU2Vjb25kYXJ5Q29ubmVjdGlvbkxvc3RfKCkge1xyXG4gICAgICAgIGNvbnN0IGNvbm4gPSB0aGlzLnNlY29uZGFyeUNvbm5fO1xyXG4gICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8gPSBudWxsO1xyXG4gICAgICAgIGlmICh0aGlzLnR4XyA9PT0gY29ubiB8fCB0aGlzLnJ4XyA9PT0gY29ubikge1xyXG4gICAgICAgICAgICAvLyB3ZSBhcmUgcmVseWluZyBvbiB0aGlzIGNvbm5lY3Rpb24gYWxyZWFkeSBpbiBzb21lIGNhcGFjaXR5LiBUaGVyZWZvcmUsIGEgZmFpbHVyZSBpcyByZWFsXHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBldmVyQ29ubmVjdGVkIC0gV2hldGhlciBvciBub3QgdGhlIGNvbm5lY3Rpb24gZXZlciByZWFjaGVkIGEgc2VydmVyLiBVc2VkIHRvIGRldGVybWluZSBpZlxyXG4gICAgICogd2Ugc2hvdWxkIGZsdXNoIHRoZSBob3N0IGNhY2hlXHJcbiAgICAgKi9cclxuICAgIG9uQ29ubmVjdGlvbkxvc3RfKGV2ZXJDb25uZWN0ZWQpIHtcclxuICAgICAgICB0aGlzLmNvbm5fID0gbnVsbDtcclxuICAgICAgICAvLyBOT1RFOiBJRiB5b3UncmUgc2VlaW5nIGEgRmlyZWZveCBlcnJvciBmb3IgdGhpcyBsaW5lLCBJIHRoaW5rIGl0IG1pZ2h0IGJlIGJlY2F1c2UgaXQncyBnZXR0aW5nXHJcbiAgICAgICAgLy8gY2FsbGVkIG9uIHdpbmRvdyBjbG9zZSBhbmQgUmVhbHRpbWVTdGF0ZS5DT05ORUNUSU5HIGlzIG5vIGxvbmdlciBkZWZpbmVkLiAgSnVzdCBhIGd1ZXNzLlxyXG4gICAgICAgIGlmICghZXZlckNvbm5lY3RlZCAmJiB0aGlzLnN0YXRlXyA9PT0gMCAvKiBSZWFsdGltZVN0YXRlLkNPTk5FQ1RJTkcgKi8pIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdSZWFsdGltZSBjb25uZWN0aW9uIGZhaWxlZC4nKTtcclxuICAgICAgICAgICAgLy8gU2luY2Ugd2UgZmFpbGVkIHRvIGNvbm5lY3QgYXQgYWxsLCBjbGVhciBhbnkgY2FjaGVkIGVudHJ5IGZvciB0aGlzIG5hbWVzcGFjZSBpbiBjYXNlIHRoZSBtYWNoaW5lIHdlbnQgYXdheVxyXG4gICAgICAgICAgICBpZiAodGhpcy5yZXBvSW5mb18uaXNDYWNoZWFibGVIb3N0KCkpIHtcclxuICAgICAgICAgICAgICAgIFBlcnNpc3RlbnRTdG9yYWdlLnJlbW92ZSgnaG9zdDonICsgdGhpcy5yZXBvSW5mb18uaG9zdCk7XHJcbiAgICAgICAgICAgICAgICAvLyByZXNldCB0aGUgaW50ZXJuYWwgaG9zdCB0byB3aGF0IHdlIHdvdWxkIHNob3cgdGhlIHVzZXIsIGkuZS4gPG5zPi5maXJlYmFzZWlvLmNvbVxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvSW5mb18uaW50ZXJuYWxIb3N0ID0gdGhpcy5yZXBvSW5mb18uaG9zdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlXyA9PT0gMSAvKiBSZWFsdGltZVN0YXRlLkNPTk5FQ1RFRCAqLykge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ1JlYWx0aW1lIGNvbm5lY3Rpb24gbG9zdC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgfVxyXG4gICAgb25Db25uZWN0aW9uU2h1dGRvd25fKHJlYXNvbikge1xyXG4gICAgICAgIHRoaXMubG9nXygnQ29ubmVjdGlvbiBzaHV0ZG93biBjb21tYW5kIHJlY2VpdmVkLiBTaHV0dGluZyBkb3duLi4uJyk7XHJcbiAgICAgICAgaWYgKHRoaXMub25LaWxsXykge1xyXG4gICAgICAgICAgICB0aGlzLm9uS2lsbF8ocmVhc29uKTtcclxuICAgICAgICAgICAgdGhpcy5vbktpbGxfID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB3YW50IHRvIGZpcmUgb25EaXNjb25uZWN0IChraWxsIGlzIGEgZGlmZmVyZW50IGNhc2UpLFxyXG4gICAgICAgIC8vIHNvIGNsZWFyIHRoZSBjYWxsYmFjay5cclxuICAgICAgICB0aGlzLm9uRGlzY29ubmVjdF8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgIH1cclxuICAgIHNlbmREYXRhXyhkYXRhKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVfICE9PSAxIC8qIFJlYWx0aW1lU3RhdGUuQ09OTkVDVEVEICovKSB7XHJcbiAgICAgICAgICAgIHRocm93ICdDb25uZWN0aW9uIGlzIG5vdCBjb25uZWN0ZWQnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy50eF8uc2VuZChkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENsZWFucyB1cCB0aGlzIGNvbm5lY3Rpb24sIGNhbGxpbmcgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xyXG4gICAgICovXHJcbiAgICBjbG9zZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZV8gIT09IDIgLyogUmVhbHRpbWVTdGF0ZS5ESVNDT05ORUNURUQgKi8pIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdDbG9zaW5nIHJlYWx0aW1lIGNvbm5lY3Rpb24uJyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGVfID0gMiAvKiBSZWFsdGltZVN0YXRlLkRJU0NPTk5FQ1RFRCAqLztcclxuICAgICAgICAgICAgdGhpcy5jbG9zZUNvbm5lY3Rpb25zXygpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vbkRpc2Nvbm5lY3RfKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdF8oKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub25EaXNjb25uZWN0XyA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjbG9zZUNvbm5lY3Rpb25zXygpIHtcclxuICAgICAgICB0aGlzLmxvZ18oJ1NodXR0aW5nIGRvd24gYWxsIGNvbm5lY3Rpb25zJyk7XHJcbiAgICAgICAgaWYgKHRoaXMuY29ubl8pIHtcclxuICAgICAgICAgICAgdGhpcy5jb25uXy5jbG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5fID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc2Vjb25kYXJ5Q29ubl8pIHtcclxuICAgICAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXy5jbG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaGVhbHRoeVRpbWVvdXRfKSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmhlYWx0aHlUaW1lb3V0Xyk7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhbHRoeVRpbWVvdXRfID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEludGVyZmFjZSBkZWZpbmluZyB0aGUgc2V0IG9mIGFjdGlvbnMgdGhhdCBjYW4gYmUgcGVyZm9ybWVkIGFnYWluc3QgdGhlIEZpcmViYXNlIHNlcnZlclxyXG4gKiAoYmFzaWNhbGx5IGNvcnJlc3BvbmRzIHRvIG91ciB3aXJlIHByb3RvY29sKS5cclxuICpcclxuICogQGludGVyZmFjZVxyXG4gKi9cclxuY2xhc3MgU2VydmVyQWN0aW9ucyB7XHJcbiAgICBwdXQocGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSwgaGFzaCkgeyB9XHJcbiAgICBtZXJnZShwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlLCBoYXNoKSB7IH1cclxuICAgIC8qKlxyXG4gICAgICogUmVmcmVzaGVzIHRoZSBhdXRoIHRva2VuIGZvciB0aGUgY3VycmVudCBjb25uZWN0aW9uLlxyXG4gICAgICogQHBhcmFtIHRva2VuIC0gVGhlIGF1dGhlbnRpY2F0aW9uIHRva2VuXHJcbiAgICAgKi9cclxuICAgIHJlZnJlc2hBdXRoVG9rZW4odG9rZW4pIHsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZyZXNoZXMgdGhlIGFwcCBjaGVjayB0b2tlbiBmb3IgdGhlIGN1cnJlbnQgY29ubmVjdGlvbi5cclxuICAgICAqIEBwYXJhbSB0b2tlbiBUaGUgYXBwIGNoZWNrIHRva2VuXHJcbiAgICAgKi9cclxuICAgIHJlZnJlc2hBcHBDaGVja1Rva2VuKHRva2VuKSB7IH1cclxuICAgIG9uRGlzY29ubmVjdFB1dChwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlKSB7IH1cclxuICAgIG9uRGlzY29ubmVjdE1lcmdlKHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUpIHsgfVxyXG4gICAgb25EaXNjb25uZWN0Q2FuY2VsKHBhdGhTdHJpbmcsIG9uQ29tcGxldGUpIHsgfVxyXG4gICAgcmVwb3J0U3RhdHMoc3RhdHMpIHsgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBCYXNlIGNsYXNzIHRvIGJlIHVzZWQgaWYgeW91IHdhbnQgdG8gZW1pdCBldmVudHMuIENhbGwgdGhlIGNvbnN0cnVjdG9yIHdpdGhcclxuICogdGhlIHNldCBvZiBhbGxvd2VkIGV2ZW50IG5hbWVzLlxyXG4gKi9cclxuY2xhc3MgRXZlbnRFbWl0dGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGFsbG93ZWRFdmVudHNfKSB7XHJcbiAgICAgICAgdGhpcy5hbGxvd2VkRXZlbnRzXyA9IGFsbG93ZWRFdmVudHNfO1xyXG4gICAgICAgIHRoaXMubGlzdGVuZXJzXyA9IHt9O1xyXG4gICAgICAgIGFzc2VydChBcnJheS5pc0FycmF5KGFsbG93ZWRFdmVudHNfKSAmJiBhbGxvd2VkRXZlbnRzXy5sZW5ndGggPiAwLCAnUmVxdWlyZXMgYSBub24tZW1wdHkgYXJyYXknKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVG8gYmUgY2FsbGVkIGJ5IGRlcml2ZWQgY2xhc3NlcyB0byB0cmlnZ2VyIGV2ZW50cy5cclxuICAgICAqL1xyXG4gICAgdHJpZ2dlcihldmVudFR5cGUsIC4uLnZhckFyZ3MpIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmxpc3RlbmVyc19bZXZlbnRUeXBlXSkpIHtcclxuICAgICAgICAgICAgLy8gQ2xvbmUgdGhlIGxpc3QsIHNpbmNlIGNhbGxiYWNrcyBjb3VsZCBhZGQvcmVtb3ZlIGxpc3RlbmVycy5cclxuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gWy4uLnRoaXMubGlzdGVuZXJzX1tldmVudFR5cGVdXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5jYWxsYmFjay5hcHBseShsaXN0ZW5lcnNbaV0uY29udGV4dCwgdmFyQXJncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvbihldmVudFR5cGUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy52YWxpZGF0ZUV2ZW50VHlwZV8oZXZlbnRUeXBlKTtcclxuICAgICAgICB0aGlzLmxpc3RlbmVyc19bZXZlbnRUeXBlXSA9IHRoaXMubGlzdGVuZXJzX1tldmVudFR5cGVdIHx8IFtdO1xyXG4gICAgICAgIHRoaXMubGlzdGVuZXJzX1tldmVudFR5cGVdLnB1c2goeyBjYWxsYmFjaywgY29udGV4dCB9KTtcclxuICAgICAgICBjb25zdCBldmVudERhdGEgPSB0aGlzLmdldEluaXRpYWxFdmVudChldmVudFR5cGUpO1xyXG4gICAgICAgIGlmIChldmVudERhdGEpIHtcclxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkoY29udGV4dCwgZXZlbnREYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvZmYoZXZlbnRUeXBlLCBjYWxsYmFjaywgY29udGV4dCkge1xyXG4gICAgICAgIHRoaXMudmFsaWRhdGVFdmVudFR5cGVfKGV2ZW50VHlwZSk7XHJcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnNfW2V2ZW50VHlwZV0gfHwgW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tpXS5jYWxsYmFjayA9PT0gY2FsbGJhY2sgJiZcclxuICAgICAgICAgICAgICAgICghY29udGV4dCB8fCBjb250ZXh0ID09PSBsaXN0ZW5lcnNbaV0uY29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2YWxpZGF0ZUV2ZW50VHlwZV8oZXZlbnRUeXBlKSB7XHJcbiAgICAgICAgYXNzZXJ0KHRoaXMuYWxsb3dlZEV2ZW50c18uZmluZChldCA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBldCA9PT0gZXZlbnRUeXBlO1xyXG4gICAgICAgIH0pLCAnVW5rbm93biBldmVudDogJyArIGV2ZW50VHlwZSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIE1vbml0b3JzIG9ubGluZSBzdGF0ZSAoYXMgcmVwb3J0ZWQgYnkgd2luZG93Lm9ubGluZS9vZmZsaW5lIGV2ZW50cykuXHJcbiAqXHJcbiAqIFRoZSBleHBlY3RhdGlvbiBpcyB0aGF0IHRoaXMgY291bGQgaGF2ZSBtYW55IGZhbHNlIHBvc2l0aXZlcyAodGhpbmtzIHdlIGFyZSBvbmxpbmVcclxuICogd2hlbiB3ZSdyZSBub3QpLCBidXQgbm8gZmFsc2UgbmVnYXRpdmVzLiAgU28gd2UgY2FuIHNhZmVseSB1c2UgaXQgdG8gZGV0ZXJtaW5lIHdoZW5cclxuICogd2UgZGVmaW5pdGVseSBjYW5ub3QgcmVhY2ggdGhlIGludGVybmV0LlxyXG4gKi9cclxuY2xhc3MgT25saW5lTW9uaXRvciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihbJ29ubGluZSddKTtcclxuICAgICAgICB0aGlzLm9ubGluZV8gPSB0cnVlO1xyXG4gICAgICAgIC8vIFdlJ3ZlIGhhZCByZXBlYXRlZCBjb21wbGFpbnRzIHRoYXQgQ29yZG92YSBhcHBzIGNhbiBnZXQgc3R1Y2sgXCJvZmZsaW5lXCIsIGUuZy5cclxuICAgICAgICAvLyBodHRwczovL2ZvcnVtLmlvbmljZnJhbWV3b3JrLmNvbS90L2ZpcmViYXNlLWNvbm5lY3Rpb24taXMtbG9zdC1hbmQtbmV2ZXItY29tZS1iYWNrLzQzODEwXHJcbiAgICAgICAgLy8gSXQgd291bGQgc2VlbSB0aGF0IHRoZSAnb25saW5lJyBldmVudCBkb2VzIG5vdCBhbHdheXMgZmlyZSBjb25zaXN0ZW50bHkuIFNvIHdlIGRpc2FibGUgaXRcclxuICAgICAgICAvLyBmb3IgQ29yZG92YS5cclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICAgICAgdHlwZW9mIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgICAgICAhaXNNb2JpbGVDb3Jkb3ZhKCkpIHtcclxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29ubGluZScsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5vbmxpbmVfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbmxpbmVfID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ29ubGluZScsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvZmZsaW5lJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25saW5lXykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25saW5lXyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignb25saW5lJywgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldEluc3RhbmNlKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgT25saW5lTW9uaXRvcigpO1xyXG4gICAgfVxyXG4gICAgZ2V0SW5pdGlhbEV2ZW50KGV2ZW50VHlwZSkge1xyXG4gICAgICAgIGFzc2VydChldmVudFR5cGUgPT09ICdvbmxpbmUnLCAnVW5rbm93biBldmVudCB0eXBlOiAnICsgZXZlbnRUeXBlKTtcclxuICAgICAgICByZXR1cm4gW3RoaXMub25saW5lX107XHJcbiAgICB9XHJcbiAgICBjdXJyZW50bHlPbmxpbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub25saW5lXztcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKiogTWF4aW11bSBrZXkgZGVwdGguICovXHJcbmNvbnN0IE1BWF9QQVRIX0RFUFRIID0gMzI7XHJcbi8qKiBNYXhpbXVtIG51bWJlciBvZiAoVVRGOCkgYnl0ZXMgaW4gYSBGaXJlYmFzZSBwYXRoLiAqL1xyXG5jb25zdCBNQVhfUEFUSF9MRU5HVEhfQllURVMgPSA3Njg7XHJcbi8qKlxyXG4gKiBBbiBpbW11dGFibGUgb2JqZWN0IHJlcHJlc2VudGluZyBhIHBhcnNlZCBwYXRoLiAgSXQncyBpbW11dGFibGUgc28gdGhhdCB5b3VcclxuICogY2FuIHBhc3MgdGhlbSBhcm91bmQgdG8gb3RoZXIgZnVuY3Rpb25zIHdpdGhvdXQgd29ycnlpbmcgYWJvdXQgdGhlbSBjaGFuZ2luZ1xyXG4gKiBpdC5cclxuICovXHJcbmNsYXNzIFBhdGgge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gcGF0aE9yU3RyaW5nIC0gUGF0aCBzdHJpbmcgdG8gcGFyc2UsIG9yIGFub3RoZXIgcGF0aCwgb3IgdGhlIHJhd1xyXG4gICAgICogdG9rZW5zIGFycmF5XHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHBhdGhPclN0cmluZywgcGllY2VOdW0pIHtcclxuICAgICAgICBpZiAocGllY2VOdW0gPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICB0aGlzLnBpZWNlc18gPSBwYXRoT3JTdHJpbmcuc3BsaXQoJy8nKTtcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIGVtcHR5IHBpZWNlcy5cclxuICAgICAgICAgICAgbGV0IGNvcHlUbyA9IDA7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5waWVjZXNfLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5waWVjZXNfW2ldLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBpZWNlc19bY29weVRvXSA9IHRoaXMucGllY2VzX1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBjb3B5VG8rKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnBpZWNlc18ubGVuZ3RoID0gY29weVRvO1xyXG4gICAgICAgICAgICB0aGlzLnBpZWNlTnVtXyA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnBpZWNlc18gPSBwYXRoT3JTdHJpbmc7XHJcbiAgICAgICAgICAgIHRoaXMucGllY2VOdW1fID0gcGllY2VOdW07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgbGV0IHBhdGhTdHJpbmcgPSAnJztcclxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5waWVjZU51bV87IGkgPCB0aGlzLnBpZWNlc18ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGllY2VzX1tpXSAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgIHBhdGhTdHJpbmcgKz0gJy8nICsgdGhpcy5waWVjZXNfW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXRoU3RyaW5nIHx8ICcvJztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBuZXdFbXB0eVBhdGgoKSB7XHJcbiAgICByZXR1cm4gbmV3IFBhdGgoJycpO1xyXG59XHJcbmZ1bmN0aW9uIHBhdGhHZXRGcm9udChwYXRoKSB7XHJcbiAgICBpZiAocGF0aC5waWVjZU51bV8gPj0gcGF0aC5waWVjZXNfLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhdGgucGllY2VzX1twYXRoLnBpZWNlTnVtX107XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2Ygc2VnbWVudHMgaW4gdGhpcyBwYXRoXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXRoR2V0TGVuZ3RoKHBhdGgpIHtcclxuICAgIHJldHVybiBwYXRoLnBpZWNlc18ubGVuZ3RoIC0gcGF0aC5waWVjZU51bV87XHJcbn1cclxuZnVuY3Rpb24gcGF0aFBvcEZyb250KHBhdGgpIHtcclxuICAgIGxldCBwaWVjZU51bSA9IHBhdGgucGllY2VOdW1fO1xyXG4gICAgaWYgKHBpZWNlTnVtIDwgcGF0aC5waWVjZXNfLmxlbmd0aCkge1xyXG4gICAgICAgIHBpZWNlTnVtKys7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFBhdGgocGF0aC5waWVjZXNfLCBwaWVjZU51bSk7XHJcbn1cclxuZnVuY3Rpb24gcGF0aEdldEJhY2socGF0aCkge1xyXG4gICAgaWYgKHBhdGgucGllY2VOdW1fIDwgcGF0aC5waWVjZXNfLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBwYXRoLnBpZWNlc19bcGF0aC5waWVjZXNfLmxlbmd0aCAtIDFdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuZnVuY3Rpb24gcGF0aFRvVXJsRW5jb2RlZFN0cmluZyhwYXRoKSB7XHJcbiAgICBsZXQgcGF0aFN0cmluZyA9ICcnO1xyXG4gICAgZm9yIChsZXQgaSA9IHBhdGgucGllY2VOdW1fOyBpIDwgcGF0aC5waWVjZXNfLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKHBhdGgucGllY2VzX1tpXSAhPT0gJycpIHtcclxuICAgICAgICAgICAgcGF0aFN0cmluZyArPSAnLycgKyBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHBhdGgucGllY2VzX1tpXSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwYXRoU3RyaW5nIHx8ICcvJztcclxufVxyXG4vKipcclxuICogU2hhbGxvdyBjb3B5IG9mIHRoZSBwYXJ0cyBvZiB0aGUgcGF0aC5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIHBhdGhTbGljZShwYXRoLCBiZWdpbiA9IDApIHtcclxuICAgIHJldHVybiBwYXRoLnBpZWNlc18uc2xpY2UocGF0aC5waWVjZU51bV8gKyBiZWdpbik7XHJcbn1cclxuZnVuY3Rpb24gcGF0aFBhcmVudChwYXRoKSB7XHJcbiAgICBpZiAocGF0aC5waWVjZU51bV8gPj0gcGF0aC5waWVjZXNfLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcGllY2VzID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gcGF0aC5waWVjZU51bV87IGkgPCBwYXRoLnBpZWNlc18ubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgcGllY2VzLnB1c2gocGF0aC5waWVjZXNfW2ldKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgUGF0aChwaWVjZXMsIDApO1xyXG59XHJcbmZ1bmN0aW9uIHBhdGhDaGlsZChwYXRoLCBjaGlsZFBhdGhPYmopIHtcclxuICAgIGNvbnN0IHBpZWNlcyA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IHBhdGgucGllY2VOdW1fOyBpIDwgcGF0aC5waWVjZXNfLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgcGllY2VzLnB1c2gocGF0aC5waWVjZXNfW2ldKTtcclxuICAgIH1cclxuICAgIGlmIChjaGlsZFBhdGhPYmogaW5zdGFuY2VvZiBQYXRoKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IGNoaWxkUGF0aE9iai5waWVjZU51bV87IGkgPCBjaGlsZFBhdGhPYmoucGllY2VzXy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBwaWVjZXMucHVzaChjaGlsZFBhdGhPYmoucGllY2VzX1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGRQaWVjZXMgPSBjaGlsZFBhdGhPYmouc3BsaXQoJy8nKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkUGllY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZFBpZWNlc1tpXS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBwaWVjZXMucHVzaChjaGlsZFBpZWNlc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFBhdGgocGllY2VzLCAwKTtcclxufVxyXG4vKipcclxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGVyZSBhcmUgbm8gc2VnbWVudHMgaW4gdGhpcyBwYXRoXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXRoSXNFbXB0eShwYXRoKSB7XHJcbiAgICByZXR1cm4gcGF0aC5waWVjZU51bV8gPj0gcGF0aC5waWVjZXNfLmxlbmd0aDtcclxufVxyXG4vKipcclxuICogQHJldHVybnMgVGhlIHBhdGggZnJvbSBvdXRlclBhdGggdG8gaW5uZXJQYXRoXHJcbiAqL1xyXG5mdW5jdGlvbiBuZXdSZWxhdGl2ZVBhdGgob3V0ZXJQYXRoLCBpbm5lclBhdGgpIHtcclxuICAgIGNvbnN0IG91dGVyID0gcGF0aEdldEZyb250KG91dGVyUGF0aCksIGlubmVyID0gcGF0aEdldEZyb250KGlubmVyUGF0aCk7XHJcbiAgICBpZiAob3V0ZXIgPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gaW5uZXJQYXRoO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAob3V0ZXIgPT09IGlubmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ld1JlbGF0aXZlUGF0aChwYXRoUG9wRnJvbnQob3V0ZXJQYXRoKSwgcGF0aFBvcEZyb250KGlubmVyUGF0aCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJTlRFUk5BTCBFUlJPUjogaW5uZXJQYXRoICgnICtcclxuICAgICAgICAgICAgaW5uZXJQYXRoICtcclxuICAgICAgICAgICAgJykgaXMgbm90IHdpdGhpbiAnICtcclxuICAgICAgICAgICAgJ291dGVyUGF0aCAoJyArXHJcbiAgICAgICAgICAgIG91dGVyUGF0aCArXHJcbiAgICAgICAgICAgICcpJyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIC0xLCAwLCAxIGlmIGxlZnQgaXMgbGVzcywgZXF1YWwsIG9yIGdyZWF0ZXIgdGhhbiB0aGUgcmlnaHQuXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXRoQ29tcGFyZShsZWZ0LCByaWdodCkge1xyXG4gICAgY29uc3QgbGVmdEtleXMgPSBwYXRoU2xpY2UobGVmdCwgMCk7XHJcbiAgICBjb25zdCByaWdodEtleXMgPSBwYXRoU2xpY2UocmlnaHQsIDApO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZWZ0S2V5cy5sZW5ndGggJiYgaSA8IHJpZ2h0S2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGNtcCA9IG5hbWVDb21wYXJlKGxlZnRLZXlzW2ldLCByaWdodEtleXNbaV0pO1xyXG4gICAgICAgIGlmIChjbXAgIT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNtcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobGVmdEtleXMubGVuZ3RoID09PSByaWdodEtleXMubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVmdEtleXMubGVuZ3RoIDwgcmlnaHRLZXlzLmxlbmd0aCA/IC0xIDogMTtcclxufVxyXG4vKipcclxuICogQHJldHVybnMgdHJ1ZSBpZiBwYXRocyBhcmUgdGhlIHNhbWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXRoRXF1YWxzKHBhdGgsIG90aGVyKSB7XHJcbiAgICBpZiAocGF0aEdldExlbmd0aChwYXRoKSAhPT0gcGF0aEdldExlbmd0aChvdGhlcikpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpID0gcGF0aC5waWVjZU51bV8sIGogPSBvdGhlci5waWVjZU51bV87IGkgPD0gcGF0aC5waWVjZXNfLmxlbmd0aDsgaSsrLCBqKyspIHtcclxuICAgICAgICBpZiAocGF0aC5waWVjZXNfW2ldICE9PSBvdGhlci5waWVjZXNfW2pdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG4vKipcclxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGlzIHBhdGggaXMgYSBwYXJlbnQgb2YgKG9yIHRoZSBzYW1lIGFzKSBvdGhlclxyXG4gKi9cclxuZnVuY3Rpb24gcGF0aENvbnRhaW5zKHBhdGgsIG90aGVyKSB7XHJcbiAgICBsZXQgaSA9IHBhdGgucGllY2VOdW1fO1xyXG4gICAgbGV0IGogPSBvdGhlci5waWVjZU51bV87XHJcbiAgICBpZiAocGF0aEdldExlbmd0aChwYXRoKSA+IHBhdGhHZXRMZW5ndGgob3RoZXIpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgd2hpbGUgKGkgPCBwYXRoLnBpZWNlc18ubGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKHBhdGgucGllY2VzX1tpXSAhPT0gb3RoZXIucGllY2VzX1tqXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICsraTtcclxuICAgICAgICArK2o7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG4vKipcclxuICogRHluYW1pYyAobXV0YWJsZSkgcGF0aCB1c2VkIHRvIGNvdW50IHBhdGggbGVuZ3Rocy5cclxuICpcclxuICogVGhpcyBjbGFzcyBpcyB1c2VkIHRvIGVmZmljaWVudGx5IGNoZWNrIHBhdGhzIGZvciB2YWxpZFxyXG4gKiBsZW5ndGggKGluIFVURjggYnl0ZXMpIGFuZCBkZXB0aCAodXNlZCBpbiBwYXRoIHZhbGlkYXRpb24pLlxyXG4gKlxyXG4gKiBUaHJvd3MgRXJyb3IgZXhjZXB0aW9uIGlmIHBhdGggaXMgZXZlciBpbnZhbGlkLlxyXG4gKlxyXG4gKiBUaGUgZGVmaW5pdGlvbiBvZiBhIHBhdGggYWx3YXlzIGJlZ2lucyB3aXRoICcvJy5cclxuICovXHJcbmNsYXNzIFZhbGlkYXRpb25QYXRoIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHBhdGggLSBJbml0aWFsIFBhdGguXHJcbiAgICAgKiBAcGFyYW0gZXJyb3JQcmVmaXhfIC0gUHJlZml4IGZvciBhbnkgZXJyb3IgbWVzc2FnZXMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHBhdGgsIGVycm9yUHJlZml4Xykge1xyXG4gICAgICAgIHRoaXMuZXJyb3JQcmVmaXhfID0gZXJyb3JQcmVmaXhfO1xyXG4gICAgICAgIHRoaXMucGFydHNfID0gcGF0aFNsaWNlKHBhdGgsIDApO1xyXG4gICAgICAgIC8qKiBJbml0aWFsaXplIHRvIG51bWJlciBvZiAnLycgY2hhcnMgbmVlZGVkIGluIHBhdGguICovXHJcbiAgICAgICAgdGhpcy5ieXRlTGVuZ3RoXyA9IE1hdGgubWF4KDEsIHRoaXMucGFydHNfLmxlbmd0aCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBhcnRzXy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmJ5dGVMZW5ndGhfICs9IHN0cmluZ0xlbmd0aCh0aGlzLnBhcnRzX1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhbGlkYXRpb25QYXRoQ2hlY2tWYWxpZCh0aGlzKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0aW9uUGF0aFB1c2godmFsaWRhdGlvblBhdGgsIGNoaWxkKSB7XHJcbiAgICAvLyBDb3VudCB0aGUgbmVlZGVkICcvJ1xyXG4gICAgaWYgKHZhbGlkYXRpb25QYXRoLnBhcnRzXy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdmFsaWRhdGlvblBhdGguYnl0ZUxlbmd0aF8gKz0gMTtcclxuICAgIH1cclxuICAgIHZhbGlkYXRpb25QYXRoLnBhcnRzXy5wdXNoKGNoaWxkKTtcclxuICAgIHZhbGlkYXRpb25QYXRoLmJ5dGVMZW5ndGhfICs9IHN0cmluZ0xlbmd0aChjaGlsZCk7XHJcbiAgICB2YWxpZGF0aW9uUGF0aENoZWNrVmFsaWQodmFsaWRhdGlvblBhdGgpO1xyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRpb25QYXRoUG9wKHZhbGlkYXRpb25QYXRoKSB7XHJcbiAgICBjb25zdCBsYXN0ID0gdmFsaWRhdGlvblBhdGgucGFydHNfLnBvcCgpO1xyXG4gICAgdmFsaWRhdGlvblBhdGguYnl0ZUxlbmd0aF8gLT0gc3RyaW5nTGVuZ3RoKGxhc3QpO1xyXG4gICAgLy8gVW4tY291bnQgdGhlIHByZXZpb3VzICcvJ1xyXG4gICAgaWYgKHZhbGlkYXRpb25QYXRoLnBhcnRzXy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdmFsaWRhdGlvblBhdGguYnl0ZUxlbmd0aF8gLT0gMTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0aW9uUGF0aENoZWNrVmFsaWQodmFsaWRhdGlvblBhdGgpIHtcclxuICAgIGlmICh2YWxpZGF0aW9uUGF0aC5ieXRlTGVuZ3RoXyA+IE1BWF9QQVRIX0xFTkdUSF9CWVRFUykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcih2YWxpZGF0aW9uUGF0aC5lcnJvclByZWZpeF8gK1xyXG4gICAgICAgICAgICAnaGFzIGEga2V5IHBhdGggbG9uZ2VyIHRoYW4gJyArXHJcbiAgICAgICAgICAgIE1BWF9QQVRIX0xFTkdUSF9CWVRFUyArXHJcbiAgICAgICAgICAgICcgYnl0ZXMgKCcgK1xyXG4gICAgICAgICAgICB2YWxpZGF0aW9uUGF0aC5ieXRlTGVuZ3RoXyArXHJcbiAgICAgICAgICAgICcpLicpO1xyXG4gICAgfVxyXG4gICAgaWYgKHZhbGlkYXRpb25QYXRoLnBhcnRzXy5sZW5ndGggPiBNQVhfUEFUSF9ERVBUSCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcih2YWxpZGF0aW9uUGF0aC5lcnJvclByZWZpeF8gK1xyXG4gICAgICAgICAgICAncGF0aCBzcGVjaWZpZWQgZXhjZWVkcyB0aGUgbWF4aW11bSBkZXB0aCB0aGF0IGNhbiBiZSB3cml0dGVuICgnICtcclxuICAgICAgICAgICAgTUFYX1BBVEhfREVQVEggK1xyXG4gICAgICAgICAgICAnKSBvciBvYmplY3QgY29udGFpbnMgYSBjeWNsZSAnICtcclxuICAgICAgICAgICAgdmFsaWRhdGlvblBhdGhUb0Vycm9yU3RyaW5nKHZhbGlkYXRpb25QYXRoKSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFN0cmluZyBmb3IgdXNlIGluIGVycm9yIG1lc3NhZ2VzIC0gdXNlcyAnLicgbm90YXRpb24gZm9yIHBhdGguXHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0aW9uUGF0aFRvRXJyb3JTdHJpbmcodmFsaWRhdGlvblBhdGgpIHtcclxuICAgIGlmICh2YWxpZGF0aW9uUGF0aC5wYXJ0c18ubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFwiaW4gcHJvcGVydHkgJ1wiICsgdmFsaWRhdGlvblBhdGgucGFydHNfLmpvaW4oJy4nKSArIFwiJ1wiO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIFZpc2liaWxpdHlNb25pdG9yIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKFsndmlzaWJsZSddKTtcclxuICAgICAgICBsZXQgaGlkZGVuO1xyXG4gICAgICAgIGxldCB2aXNpYmlsaXR5Q2hhbmdlO1xyXG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgICAgIHR5cGVvZiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50WydoaWRkZW4nXSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIC8vIE9wZXJhIDEyLjEwIGFuZCBGaXJlZm94IDE4IGFuZCBsYXRlciBzdXBwb3J0XHJcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5Q2hhbmdlID0gJ3Zpc2liaWxpdHljaGFuZ2UnO1xyXG4gICAgICAgICAgICAgICAgaGlkZGVuID0gJ2hpZGRlbic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50Wydtb3pIaWRkZW4nXSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHlDaGFuZ2UgPSAnbW96dmlzaWJpbGl0eWNoYW5nZSc7XHJcbiAgICAgICAgICAgICAgICBoaWRkZW4gPSAnbW96SGlkZGVuJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnRbJ21zSGlkZGVuJ10gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5Q2hhbmdlID0gJ21zdmlzaWJpbGl0eWNoYW5nZSc7XHJcbiAgICAgICAgICAgICAgICBoaWRkZW4gPSAnbXNIaWRkZW4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudFsnd2Via2l0SGlkZGVuJ10gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5Q2hhbmdlID0gJ3dlYmtpdHZpc2liaWxpdHljaGFuZ2UnO1xyXG4gICAgICAgICAgICAgICAgaGlkZGVuID0gJ3dlYmtpdEhpZGRlbic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSW5pdGlhbGx5LCB3ZSBhbHdheXMgYXNzdW1lIHdlIGFyZSB2aXNpYmxlLiBUaGlzIGVuc3VyZXMgdGhhdCBpbiBicm93c2Vyc1xyXG4gICAgICAgIC8vIHdpdGhvdXQgcGFnZSB2aXNpYmlsaXR5IHN1cHBvcnQgb3IgaW4gY2FzZXMgd2hlcmUgd2UgYXJlIG5ldmVyIHZpc2libGVcclxuICAgICAgICAvLyAoZS5nLiBjaHJvbWUgZXh0ZW5zaW9uKSwgd2UgYWN0IGFzIGlmIHdlIGFyZSB2aXNpYmxlLCBpLmUuIGRvbid0IGRlbGF5XHJcbiAgICAgICAgLy8gcmVjb25uZWN0c1xyXG4gICAgICAgIHRoaXMudmlzaWJsZV8gPSB0cnVlO1xyXG4gICAgICAgIGlmICh2aXNpYmlsaXR5Q2hhbmdlKSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIodmlzaWJpbGl0eUNoYW5nZSwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmlzaWJsZSA9ICFkb2N1bWVudFtoaWRkZW5dO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZpc2libGUgIT09IHRoaXMudmlzaWJsZV8pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2libGVfID0gdmlzaWJsZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3Zpc2libGUnLCB2aXNpYmxlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRJbnN0YW5jZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZpc2liaWxpdHlNb25pdG9yKCk7XHJcbiAgICB9XHJcbiAgICBnZXRJbml0aWFsRXZlbnQoZXZlbnRUeXBlKSB7XHJcbiAgICAgICAgYXNzZXJ0KGV2ZW50VHlwZSA9PT0gJ3Zpc2libGUnLCAnVW5rbm93biBldmVudCB0eXBlOiAnICsgZXZlbnRUeXBlKTtcclxuICAgICAgICByZXR1cm4gW3RoaXMudmlzaWJsZV9dO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IFJFQ09OTkVDVF9NSU5fREVMQVkgPSAxMDAwO1xyXG5jb25zdCBSRUNPTk5FQ1RfTUFYX0RFTEFZX0RFRkFVTFQgPSA2MCAqIDUgKiAxMDAwOyAvLyA1IG1pbnV0ZXMgaW4gbWlsbGlzZWNvbmRzIChDYXNlOiAxODU4KVxyXG5jb25zdCBSRUNPTk5FQ1RfTUFYX0RFTEFZX0ZPUl9BRE1JTlMgPSAzMCAqIDEwMDA7IC8vIDMwIHNlY29uZHMgZm9yIGFkbWluIGNsaWVudHMgKGxpa2VseSB0byBiZSBhIGJhY2tlbmQgc2VydmVyKVxyXG5jb25zdCBSRUNPTk5FQ1RfREVMQVlfTVVMVElQTElFUiA9IDEuMztcclxuY29uc3QgUkVDT05ORUNUX0RFTEFZX1JFU0VUX1RJTUVPVVQgPSAzMDAwMDsgLy8gUmVzZXQgZGVsYXkgYmFjayB0byBNSU5fREVMQVkgYWZ0ZXIgYmVpbmcgY29ubmVjdGVkIGZvciAzMHNlYy5cclxuY29uc3QgU0VSVkVSX0tJTExfSU5URVJSVVBUX1JFQVNPTiA9ICdzZXJ2ZXJfa2lsbCc7XHJcbi8vIElmIGF1dGggZmFpbHMgcmVwZWF0ZWRseSwgd2UnbGwgYXNzdW1lIHNvbWV0aGluZyBpcyB3cm9uZyBhbmQgbG9nIGEgd2FybmluZyAvIGJhY2sgb2ZmLlxyXG5jb25zdCBJTlZBTElEX1RPS0VOX1RIUkVTSE9MRCA9IDM7XHJcbi8qKlxyXG4gKiBGaXJlYmFzZSBjb25uZWN0aW9uLiAgQWJzdHJhY3RzIHdpcmUgcHJvdG9jb2wgYW5kIGhhbmRsZXMgcmVjb25uZWN0aW5nLlxyXG4gKlxyXG4gKiBOT1RFOiBBbGwgSlNPTiBvYmplY3RzIHNlbnQgdG8gdGhlIHJlYWx0aW1lIGNvbm5lY3Rpb24gbXVzdCBoYXZlIHByb3BlcnR5IG5hbWVzIGVuY2xvc2VkXHJcbiAqIGluIHF1b3RlcyB0byBtYWtlIHN1cmUgdGhlIGNsb3N1cmUgY29tcGlsZXIgZG9lcyBub3QgbWluaWZ5IHRoZW0uXHJcbiAqL1xyXG5jbGFzcyBQZXJzaXN0ZW50Q29ubmVjdGlvbiBleHRlbmRzIFNlcnZlckFjdGlvbnMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gcmVwb0luZm9fIC0gRGF0YSBhYm91dCB0aGUgbmFtZXNwYWNlIHdlIGFyZSBjb25uZWN0aW5nIHRvXHJcbiAgICAgKiBAcGFyYW0gYXBwbGljYXRpb25JZF8gLSBUaGUgRmlyZWJhc2UgQXBwIElEIGZvciB0aGlzIHByb2plY3RcclxuICAgICAqIEBwYXJhbSBvbkRhdGFVcGRhdGVfIC0gQSBjYWxsYmFjayBmb3IgbmV3IGRhdGEgZnJvbSB0aGUgc2VydmVyXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHJlcG9JbmZvXywgYXBwbGljYXRpb25JZF8sIG9uRGF0YVVwZGF0ZV8sIG9uQ29ubmVjdFN0YXR1c18sIG9uU2VydmVySW5mb1VwZGF0ZV8sIGF1dGhUb2tlblByb3ZpZGVyXywgYXBwQ2hlY2tUb2tlblByb3ZpZGVyXywgYXV0aE92ZXJyaWRlXykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5yZXBvSW5mb18gPSByZXBvSW5mb187XHJcbiAgICAgICAgdGhpcy5hcHBsaWNhdGlvbklkXyA9IGFwcGxpY2F0aW9uSWRfO1xyXG4gICAgICAgIHRoaXMub25EYXRhVXBkYXRlXyA9IG9uRGF0YVVwZGF0ZV87XHJcbiAgICAgICAgdGhpcy5vbkNvbm5lY3RTdGF0dXNfID0gb25Db25uZWN0U3RhdHVzXztcclxuICAgICAgICB0aGlzLm9uU2VydmVySW5mb1VwZGF0ZV8gPSBvblNlcnZlckluZm9VcGRhdGVfO1xyXG4gICAgICAgIHRoaXMuYXV0aFRva2VuUHJvdmlkZXJfID0gYXV0aFRva2VuUHJvdmlkZXJfO1xyXG4gICAgICAgIHRoaXMuYXBwQ2hlY2tUb2tlblByb3ZpZGVyXyA9IGFwcENoZWNrVG9rZW5Qcm92aWRlcl87XHJcbiAgICAgICAgdGhpcy5hdXRoT3ZlcnJpZGVfID0gYXV0aE92ZXJyaWRlXztcclxuICAgICAgICAvLyBVc2VkIGZvciBkaWFnbm9zdGljIGxvZ2dpbmcuXHJcbiAgICAgICAgdGhpcy5pZCA9IFBlcnNpc3RlbnRDb25uZWN0aW9uLm5leHRQZXJzaXN0ZW50Q29ubmVjdGlvbklkXysrO1xyXG4gICAgICAgIHRoaXMubG9nXyA9IGxvZ1dyYXBwZXIoJ3A6JyArIHRoaXMuaWQgKyAnOicpO1xyXG4gICAgICAgIHRoaXMuaW50ZXJydXB0UmVhc29uc18gPSB7fTtcclxuICAgICAgICB0aGlzLmxpc3RlbnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5vdXRzdGFuZGluZ1B1dHNfID0gW107XHJcbiAgICAgICAgdGhpcy5vdXRzdGFuZGluZ0dldHNfID0gW107XHJcbiAgICAgICAgdGhpcy5vdXRzdGFuZGluZ1B1dENvdW50XyA9IDA7XHJcbiAgICAgICAgdGhpcy5vdXRzdGFuZGluZ0dldENvdW50XyA9IDA7XHJcbiAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RSZXF1ZXN0UXVldWVfID0gW107XHJcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRfID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5yZWNvbm5lY3REZWxheV8gPSBSRUNPTk5FQ1RfTUlOX0RFTEFZO1xyXG4gICAgICAgIHRoaXMubWF4UmVjb25uZWN0RGVsYXlfID0gUkVDT05ORUNUX01BWF9ERUxBWV9ERUZBVUxUO1xyXG4gICAgICAgIHRoaXMuc2VjdXJpdHlEZWJ1Z0NhbGxiYWNrXyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5sYXN0U2Vzc2lvbklkID0gbnVsbDtcclxuICAgICAgICB0aGlzLmVzdGFibGlzaENvbm5lY3Rpb25UaW1lcl8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMudmlzaWJsZV8gPSBmYWxzZTtcclxuICAgICAgICAvLyBCZWZvcmUgd2UgZ2V0IGNvbm5lY3RlZCwgd2Uga2VlcCBhIHF1ZXVlIG9mIHBlbmRpbmcgbWVzc2FnZXMgdG8gc2VuZC5cclxuICAgICAgICB0aGlzLnJlcXVlc3RDQkhhc2hfID0ge307XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0TnVtYmVyXyA9IDA7XHJcbiAgICAgICAgdGhpcy5yZWFsdGltZV8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYXV0aFRva2VuXyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja1Rva2VuXyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5mb3JjZVRva2VuUmVmcmVzaF8gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmludmFsaWRBdXRoVG9rZW5Db3VudF8gPSAwO1xyXG4gICAgICAgIHRoaXMuaW52YWxpZEFwcENoZWNrVG9rZW5Db3VudF8gPSAwO1xyXG4gICAgICAgIHRoaXMuZmlyc3RDb25uZWN0aW9uXyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5sYXN0Q29ubmVjdGlvbkF0dGVtcHRUaW1lXyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5sYXN0Q29ubmVjdGlvbkVzdGFibGlzaGVkVGltZV8gPSBudWxsO1xyXG4gICAgICAgIGlmIChhdXRoT3ZlcnJpZGVfICYmICFpc05vZGVTZGsoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dGggb3ZlcnJpZGUgc3BlY2lmaWVkIGluIG9wdGlvbnMsIGJ1dCBub3Qgc3VwcG9ydGVkIG9uIG5vbiBOb2RlLmpzIHBsYXRmb3JtcycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBWaXNpYmlsaXR5TW9uaXRvci5nZXRJbnN0YW5jZSgpLm9uKCd2aXNpYmxlJywgdGhpcy5vblZpc2libGVfLCB0aGlzKTtcclxuICAgICAgICBpZiAocmVwb0luZm9fLmhvc3QuaW5kZXhPZignZmJsb2NhbCcpID09PSAtMSkge1xyXG4gICAgICAgICAgICBPbmxpbmVNb25pdG9yLmdldEluc3RhbmNlKCkub24oJ29ubGluZScsIHRoaXMub25PbmxpbmVfLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZW5kUmVxdWVzdChhY3Rpb24sIGJvZHksIG9uUmVzcG9uc2UpIHtcclxuICAgICAgICBjb25zdCBjdXJSZXFOdW0gPSArK3RoaXMucmVxdWVzdE51bWJlcl87XHJcbiAgICAgICAgY29uc3QgbXNnID0geyByOiBjdXJSZXFOdW0sIGE6IGFjdGlvbiwgYjogYm9keSB9O1xyXG4gICAgICAgIHRoaXMubG9nXyhzdHJpbmdpZnkobXNnKSk7XHJcbiAgICAgICAgYXNzZXJ0KHRoaXMuY29ubmVjdGVkXywgXCJzZW5kUmVxdWVzdCBjYWxsIHdoZW4gd2UncmUgbm90IGNvbm5lY3RlZCBub3QgYWxsb3dlZC5cIik7XHJcbiAgICAgICAgdGhpcy5yZWFsdGltZV8uc2VuZFJlcXVlc3QobXNnKTtcclxuICAgICAgICBpZiAob25SZXNwb25zZSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RDQkhhc2hfW2N1clJlcU51bV0gPSBvblJlc3BvbnNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldChxdWVyeSkge1xyXG4gICAgICAgIHRoaXMuaW5pdENvbm5lY3Rpb25fKCk7XHJcbiAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICBwOiBxdWVyeS5fcGF0aC50b1N0cmluZygpLFxyXG4gICAgICAgICAgICBxOiBxdWVyeS5fcXVlcnlPYmplY3RcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IG91dHN0YW5kaW5nR2V0ID0ge1xyXG4gICAgICAgICAgICBhY3Rpb246ICdnJyxcclxuICAgICAgICAgICAgcmVxdWVzdCxcclxuICAgICAgICAgICAgb25Db21wbGV0ZTogKG1lc3NhZ2UpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBtZXNzYWdlWydkJ107XHJcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZVsncyddID09PSAnb2snKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShwYXlsb2FkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChwYXlsb2FkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5vdXRzdGFuZGluZ0dldHNfLnB1c2gob3V0c3RhbmRpbmdHZXQpO1xyXG4gICAgICAgIHRoaXMub3V0c3RhbmRpbmdHZXRDb3VudF8rKztcclxuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMub3V0c3RhbmRpbmdHZXRzXy5sZW5ndGggLSAxO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kR2V0XyhpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xyXG4gICAgfVxyXG4gICAgbGlzdGVuKHF1ZXJ5LCBjdXJyZW50SGFzaEZuLCB0YWcsIG9uQ29tcGxldGUpIHtcclxuICAgICAgICB0aGlzLmluaXRDb25uZWN0aW9uXygpO1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5SWQgPSBxdWVyeS5fcXVlcnlJZGVudGlmaWVyO1xyXG4gICAgICAgIGNvbnN0IHBhdGhTdHJpbmcgPSBxdWVyeS5fcGF0aC50b1N0cmluZygpO1xyXG4gICAgICAgIHRoaXMubG9nXygnTGlzdGVuIGNhbGxlZCBmb3IgJyArIHBhdGhTdHJpbmcgKyAnICcgKyBxdWVyeUlkKTtcclxuICAgICAgICBpZiAoIXRoaXMubGlzdGVucy5oYXMocGF0aFN0cmluZykpIHtcclxuICAgICAgICAgICAgdGhpcy5saXN0ZW5zLnNldChwYXRoU3RyaW5nLCBuZXcgTWFwKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhc3NlcnQocXVlcnkuX3F1ZXJ5UGFyYW1zLmlzRGVmYXVsdCgpIHx8ICFxdWVyeS5fcXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCksICdsaXN0ZW4oKSBjYWxsZWQgZm9yIG5vbi1kZWZhdWx0IGJ1dCBjb21wbGV0ZSBxdWVyeScpO1xyXG4gICAgICAgIGFzc2VydCghdGhpcy5saXN0ZW5zLmdldChwYXRoU3RyaW5nKS5oYXMocXVlcnlJZCksIGBsaXN0ZW4oKSBjYWxsZWQgdHdpY2UgZm9yIHNhbWUgcGF0aC9xdWVyeUlkLmApO1xyXG4gICAgICAgIGNvbnN0IGxpc3RlblNwZWMgPSB7XHJcbiAgICAgICAgICAgIG9uQ29tcGxldGUsXHJcbiAgICAgICAgICAgIGhhc2hGbjogY3VycmVudEhhc2hGbixcclxuICAgICAgICAgICAgcXVlcnksXHJcbiAgICAgICAgICAgIHRhZ1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5saXN0ZW5zLmdldChwYXRoU3RyaW5nKS5zZXQocXVlcnlJZCwgbGlzdGVuU3BlYyk7XHJcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRMaXN0ZW5fKGxpc3RlblNwZWMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNlbmRHZXRfKGluZGV4KSB7XHJcbiAgICAgICAgY29uc3QgZ2V0ID0gdGhpcy5vdXRzdGFuZGluZ0dldHNfW2luZGV4XTtcclxuICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KCdnJywgZ2V0LnJlcXVlc3QsIChtZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm91dHN0YW5kaW5nR2V0c19baW5kZXhdO1xyXG4gICAgICAgICAgICB0aGlzLm91dHN0YW5kaW5nR2V0Q291bnRfLS07XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm91dHN0YW5kaW5nR2V0Q291bnRfID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm91dHN0YW5kaW5nR2V0c18gPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZ2V0Lm9uQ29tcGxldGUpIHtcclxuICAgICAgICAgICAgICAgIGdldC5vbkNvbXBsZXRlKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzZW5kTGlzdGVuXyhsaXN0ZW5TcGVjKSB7XHJcbiAgICAgICAgY29uc3QgcXVlcnkgPSBsaXN0ZW5TcGVjLnF1ZXJ5O1xyXG4gICAgICAgIGNvbnN0IHBhdGhTdHJpbmcgPSBxdWVyeS5fcGF0aC50b1N0cmluZygpO1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5SWQgPSBxdWVyeS5fcXVlcnlJZGVudGlmaWVyO1xyXG4gICAgICAgIHRoaXMubG9nXygnTGlzdGVuIG9uICcgKyBwYXRoU3RyaW5nICsgJyBmb3IgJyArIHF1ZXJ5SWQpO1xyXG4gICAgICAgIGNvbnN0IHJlcSA9IHsgLypwYXRoKi8gcDogcGF0aFN0cmluZyB9O1xyXG4gICAgICAgIGNvbnN0IGFjdGlvbiA9ICdxJztcclxuICAgICAgICAvLyBPbmx5IGJvdGhlciB0byBzZW5kIHF1ZXJ5IGlmIGl0J3Mgbm9uLWRlZmF1bHQuXHJcbiAgICAgICAgaWYgKGxpc3RlblNwZWMudGFnKSB7XHJcbiAgICAgICAgICAgIHJlcVsncSddID0gcXVlcnkuX3F1ZXJ5T2JqZWN0O1xyXG4gICAgICAgICAgICByZXFbJ3QnXSA9IGxpc3RlblNwZWMudGFnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXFbIC8qaGFzaCovJ2gnXSA9IGxpc3RlblNwZWMuaGFzaEZuKCk7XHJcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChhY3Rpb24sIHJlcSwgKG1lc3NhZ2UpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IG1lc3NhZ2VbIC8qZGF0YSovJ2QnXTtcclxuICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gbWVzc2FnZVsgLypzdGF0dXMqLydzJ107XHJcbiAgICAgICAgICAgIC8vIHByaW50IHdhcm5pbmdzIGluIGFueSBjYXNlLi4uXHJcbiAgICAgICAgICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLndhcm5Pbkxpc3Rlbldhcm5pbmdzXyhwYXlsb2FkLCBxdWVyeSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRMaXN0ZW5TcGVjID0gdGhpcy5saXN0ZW5zLmdldChwYXRoU3RyaW5nKSAmJlxyXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5zLmdldChwYXRoU3RyaW5nKS5nZXQocXVlcnlJZCk7XHJcbiAgICAgICAgICAgIC8vIG9ubHkgdHJpZ2dlciBhY3Rpb25zIGlmIHRoZSBsaXN0ZW4gaGFzbid0IGJlZW4gcmVtb3ZlZCBhbmQgcmVhZGRlZFxyXG4gICAgICAgICAgICBpZiAoY3VycmVudExpc3RlblNwZWMgPT09IGxpc3RlblNwZWMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nXygnbGlzdGVuIHJlc3BvbnNlJywgbWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzICE9PSAnb2snKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5fKHBhdGhTdHJpbmcsIHF1ZXJ5SWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlblNwZWMub25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlblNwZWMub25Db21wbGV0ZShzdGF0dXMsIHBheWxvYWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgd2Fybk9uTGlzdGVuV2FybmluZ3NfKHBheWxvYWQsIHF1ZXJ5KSB7XHJcbiAgICAgICAgaWYgKHBheWxvYWQgJiYgdHlwZW9mIHBheWxvYWQgPT09ICdvYmplY3QnICYmIGNvbnRhaW5zKHBheWxvYWQsICd3JykpIHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgY29uc3Qgd2FybmluZ3MgPSBzYWZlR2V0KHBheWxvYWQsICd3Jyk7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHdhcm5pbmdzKSAmJiB+d2FybmluZ3MuaW5kZXhPZignbm9faW5kZXgnKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXhTcGVjID0gJ1wiLmluZGV4T25cIjogXCInICsgcXVlcnkuX3F1ZXJ5UGFyYW1zLmdldEluZGV4KCkudG9TdHJpbmcoKSArICdcIic7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleFBhdGggPSBxdWVyeS5fcGF0aC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgd2FybihgVXNpbmcgYW4gdW5zcGVjaWZpZWQgaW5kZXguIFlvdXIgZGF0YSB3aWxsIGJlIGRvd25sb2FkZWQgYW5kIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBmaWx0ZXJlZCBvbiB0aGUgY2xpZW50LiBDb25zaWRlciBhZGRpbmcgJHtpbmRleFNwZWN9IGF0IGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGAke2luZGV4UGF0aH0gdG8geW91ciBzZWN1cml0eSBydWxlcyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVmcmVzaEF1dGhUb2tlbih0b2tlbikge1xyXG4gICAgICAgIHRoaXMuYXV0aFRva2VuXyA9IHRva2VuO1xyXG4gICAgICAgIHRoaXMubG9nXygnQXV0aCB0b2tlbiByZWZyZXNoZWQnKTtcclxuICAgICAgICBpZiAodGhpcy5hdXRoVG9rZW5fKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJ5QXV0aCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy9JZiB3ZSdyZSBjb25uZWN0ZWQgd2Ugd2FudCB0byBsZXQgdGhlIHNlcnZlciBrbm93IHRvIHVuYXV0aGVudGljYXRlIHVzLiBJZiB3ZSdyZSBub3QgY29ubmVjdGVkLCBzaW1wbHkgZGVsZXRlXHJcbiAgICAgICAgICAgIC8vdGhlIGNyZWRlbnRpYWwgc28gd2UgZG9udCBiZWNvbWUgYXV0aGVudGljYXRlZCBuZXh0IHRpbWUgd2UgY29ubmVjdC5cclxuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kUmVxdWVzdCgndW5hdXRoJywge30sICgpID0+IHsgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZWR1Y2VSZWNvbm5lY3REZWxheUlmQWRtaW5DcmVkZW50aWFsXyh0b2tlbik7XHJcbiAgICB9XHJcbiAgICByZWR1Y2VSZWNvbm5lY3REZWxheUlmQWRtaW5DcmVkZW50aWFsXyhjcmVkZW50aWFsKSB7XHJcbiAgICAgICAgLy8gTk9URTogVGhpcyBpc24ndCBpbnRlbmRlZCB0byBiZSBidWxsZXRwcm9vZiAoYSBtYWxpY2lvdXMgZGV2ZWxvcGVyIGNhbiBhbHdheXMganVzdCBtb2RpZnkgdGhlIGNsaWVudCkuXHJcbiAgICAgICAgLy8gQWRkaXRpb25hbGx5LCB3ZSBkb24ndCBib3RoZXIgcmVzZXR0aW5nIHRoZSBtYXggZGVsYXkgYmFjayB0byB0aGUgZGVmYXVsdCBpZiBhdXRoIGZhaWxzIC8gZXhwaXJlcy5cclxuICAgICAgICBjb25zdCBpc0ZpcmViYXNlU2VjcmV0ID0gY3JlZGVudGlhbCAmJiBjcmVkZW50aWFsLmxlbmd0aCA9PT0gNDA7XHJcbiAgICAgICAgaWYgKGlzRmlyZWJhc2VTZWNyZXQgfHwgaXNBZG1pbihjcmVkZW50aWFsKSkge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ0FkbWluIGF1dGggY3JlZGVudGlhbCBkZXRlY3RlZC4gIFJlZHVjaW5nIG1heCByZWNvbm5lY3QgdGltZS4nKTtcclxuICAgICAgICAgICAgdGhpcy5tYXhSZWNvbm5lY3REZWxheV8gPSBSRUNPTk5FQ1RfTUFYX0RFTEFZX0ZPUl9BRE1JTlM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVmcmVzaEFwcENoZWNrVG9rZW4odG9rZW4pIHtcclxuICAgICAgICB0aGlzLmFwcENoZWNrVG9rZW5fID0gdG9rZW47XHJcbiAgICAgICAgdGhpcy5sb2dfKCdBcHAgY2hlY2sgdG9rZW4gcmVmcmVzaGVkJyk7XHJcbiAgICAgICAgaWYgKHRoaXMuYXBwQ2hlY2tUb2tlbl8pIHtcclxuICAgICAgICAgICAgdGhpcy50cnlBcHBDaGVjaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy9JZiB3ZSdyZSBjb25uZWN0ZWQgd2Ugd2FudCB0byBsZXQgdGhlIHNlcnZlciBrbm93IHRvIHVuYXV0aGVudGljYXRlIHVzLlxyXG4gICAgICAgICAgICAvL0lmIHdlJ3JlIG5vdCBjb25uZWN0ZWQsIHNpbXBseSBkZWxldGUgdGhlIGNyZWRlbnRpYWwgc28gd2UgZG9udCBiZWNvbWVcclxuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRlZCBuZXh0IHRpbWUgd2UgY29ubmVjdC5cclxuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kUmVxdWVzdCgndW5hcHBlY2snLCB7fSwgKCkgPT4geyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXR0ZW1wdHMgdG8gYXV0aGVudGljYXRlIHdpdGggdGhlIGdpdmVuIGNyZWRlbnRpYWxzLiBJZiB0aGUgYXV0aGVudGljYXRpb24gYXR0ZW1wdCBmYWlscywgaXQncyB0cmlnZ2VyZWQgbGlrZVxyXG4gICAgICogYSBhdXRoIHJldm9rZWQgKHRoZSBjb25uZWN0aW9uIGlzIGNsb3NlZCkuXHJcbiAgICAgKi9cclxuICAgIHRyeUF1dGgoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkXyAmJiB0aGlzLmF1dGhUb2tlbl8pIHtcclxuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLmF1dGhUb2tlbl87XHJcbiAgICAgICAgICAgIGNvbnN0IGF1dGhNZXRob2QgPSBpc1ZhbGlkRm9ybWF0KHRva2VuKSA/ICdhdXRoJyA6ICdnYXV0aCc7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3REYXRhID0geyBjcmVkOiB0b2tlbiB9O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hdXRoT3ZlcnJpZGVfID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0RGF0YVsnbm9hdXRoJ10gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLmF1dGhPdmVycmlkZV8gPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0RGF0YVsnYXV0aHZhciddID0gdGhpcy5hdXRoT3ZlcnJpZGVfO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoYXV0aE1ldGhvZCwgcmVxdWVzdERhdGEsIChyZXMpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IHJlc1sgLypzdGF0dXMqLydzJ107XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gcmVzWyAvKmRhdGEqLydkJ10gfHwgJ2Vycm9yJztcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF1dGhUb2tlbl8gPT09IHRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ29rJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmludmFsaWRBdXRoVG9rZW5Db3VudF8gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJpZ2dlcnMgcmVjb25uZWN0IGFuZCBmb3JjZSByZWZyZXNoIGZvciBhdXRoIHRva2VuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25BdXRoUmV2b2tlZF8oc3RhdHVzLCBkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXR0ZW1wdHMgdG8gYXV0aGVudGljYXRlIHdpdGggdGhlIGdpdmVuIHRva2VuLiBJZiB0aGUgYXV0aGVudGljYXRpb25cclxuICAgICAqIGF0dGVtcHQgZmFpbHMsIGl0J3MgdHJpZ2dlcmVkIGxpa2UgdGhlIHRva2VuIHdhcyByZXZva2VkICh0aGUgY29ubmVjdGlvbiBpc1xyXG4gICAgICogY2xvc2VkKS5cclxuICAgICAqL1xyXG4gICAgdHJ5QXBwQ2hlY2soKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkXyAmJiB0aGlzLmFwcENoZWNrVG9rZW5fKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoJ2FwcGNoZWNrJywgeyAndG9rZW4nOiB0aGlzLmFwcENoZWNrVG9rZW5fIH0sIChyZXMpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IHJlc1sgLypzdGF0dXMqLydzJ107XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gcmVzWyAvKmRhdGEqLydkJ10gfHwgJ2Vycm9yJztcclxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmludmFsaWRBcHBDaGVja1Rva2VuQ291bnRfID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25BcHBDaGVja1Jldm9rZWRfKHN0YXR1cywgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGluaGVyaXREb2NcclxuICAgICAqL1xyXG4gICAgdW5saXN0ZW4ocXVlcnksIHRhZykge1xyXG4gICAgICAgIGNvbnN0IHBhdGhTdHJpbmcgPSBxdWVyeS5fcGF0aC50b1N0cmluZygpO1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5SWQgPSBxdWVyeS5fcXVlcnlJZGVudGlmaWVyO1xyXG4gICAgICAgIHRoaXMubG9nXygnVW5saXN0ZW4gY2FsbGVkIGZvciAnICsgcGF0aFN0cmluZyArICcgJyArIHF1ZXJ5SWQpO1xyXG4gICAgICAgIGFzc2VydChxdWVyeS5fcXVlcnlQYXJhbXMuaXNEZWZhdWx0KCkgfHwgIXF1ZXJ5Ll9xdWVyeVBhcmFtcy5sb2Fkc0FsbERhdGEoKSwgJ3VubGlzdGVuKCkgY2FsbGVkIGZvciBub24tZGVmYXVsdCBidXQgY29tcGxldGUgcXVlcnknKTtcclxuICAgICAgICBjb25zdCBsaXN0ZW4gPSB0aGlzLnJlbW92ZUxpc3Rlbl8ocGF0aFN0cmluZywgcXVlcnlJZCk7XHJcbiAgICAgICAgaWYgKGxpc3RlbiAmJiB0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kVW5saXN0ZW5fKHBhdGhTdHJpbmcsIHF1ZXJ5SWQsIHF1ZXJ5Ll9xdWVyeU9iamVjdCwgdGFnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZW5kVW5saXN0ZW5fKHBhdGhTdHJpbmcsIHF1ZXJ5SWQsIHF1ZXJ5T2JqLCB0YWcpIHtcclxuICAgICAgICB0aGlzLmxvZ18oJ1VubGlzdGVuIG9uICcgKyBwYXRoU3RyaW5nICsgJyBmb3IgJyArIHF1ZXJ5SWQpO1xyXG4gICAgICAgIGNvbnN0IHJlcSA9IHsgLypwYXRoKi8gcDogcGF0aFN0cmluZyB9O1xyXG4gICAgICAgIGNvbnN0IGFjdGlvbiA9ICduJztcclxuICAgICAgICAvLyBPbmx5IGJvdGhlciBzZW5kaW5nIHF1ZXJ5SWQgaWYgaXQncyBub24tZGVmYXVsdC5cclxuICAgICAgICBpZiAodGFnKSB7XHJcbiAgICAgICAgICAgIHJlcVsncSddID0gcXVlcnlPYmo7XHJcbiAgICAgICAgICAgIHJlcVsndCddID0gdGFnO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KGFjdGlvbiwgcmVxKTtcclxuICAgIH1cclxuICAgIG9uRGlzY29ubmVjdFB1dChwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgdGhpcy5pbml0Q29ubmVjdGlvbl8oKTtcclxuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZE9uRGlzY29ubmVjdF8oJ28nLCBwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMub25EaXNjb25uZWN0UmVxdWVzdFF1ZXVlXy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHBhdGhTdHJpbmcsXHJcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdvJyxcclxuICAgICAgICAgICAgICAgIGRhdGEsXHJcbiAgICAgICAgICAgICAgICBvbkNvbXBsZXRlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uRGlzY29ubmVjdE1lcmdlKHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUpIHtcclxuICAgICAgICB0aGlzLmluaXRDb25uZWN0aW9uXygpO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kT25EaXNjb25uZWN0Xygnb20nLCBwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMub25EaXNjb25uZWN0UmVxdWVzdFF1ZXVlXy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHBhdGhTdHJpbmcsXHJcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdvbScsXHJcbiAgICAgICAgICAgICAgICBkYXRhLFxyXG4gICAgICAgICAgICAgICAgb25Db21wbGV0ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvbkRpc2Nvbm5lY3RDYW5jZWwocGF0aFN0cmluZywgb25Db21wbGV0ZSkge1xyXG4gICAgICAgIHRoaXMuaW5pdENvbm5lY3Rpb25fKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRPbkRpc2Nvbm5lY3RfKCdvYycsIHBhdGhTdHJpbmcsIG51bGwsIG9uQ29tcGxldGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RSZXF1ZXN0UXVldWVfLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgcGF0aFN0cmluZyxcclxuICAgICAgICAgICAgICAgIGFjdGlvbjogJ29jJyxcclxuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBvbkNvbXBsZXRlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNlbmRPbkRpc2Nvbm5lY3RfKGFjdGlvbiwgcGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSkge1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7IC8qcGF0aCovIHA6IHBhdGhTdHJpbmcsIC8qZGF0YSovIGQ6IGRhdGEgfTtcclxuICAgICAgICB0aGlzLmxvZ18oJ29uRGlzY29ubmVjdCAnICsgYWN0aW9uLCByZXF1ZXN0KTtcclxuICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KGFjdGlvbiwgcmVxdWVzdCwgKHJlc3BvbnNlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChvbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBvbkNvbXBsZXRlKHJlc3BvbnNlWyAvKnN0YXR1cyovJ3MnXSwgcmVzcG9uc2VbIC8qIGRhdGEgKi8nZCddKTtcclxuICAgICAgICAgICAgICAgIH0sIE1hdGguZmxvb3IoMCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBwdXQocGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSwgaGFzaCkge1xyXG4gICAgICAgIHRoaXMucHV0SW50ZXJuYWwoJ3AnLCBwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlLCBoYXNoKTtcclxuICAgIH1cclxuICAgIG1lcmdlKHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUsIGhhc2gpIHtcclxuICAgICAgICB0aGlzLnB1dEludGVybmFsKCdtJywgcGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSwgaGFzaCk7XHJcbiAgICB9XHJcbiAgICBwdXRJbnRlcm5hbChhY3Rpb24sIHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUsIGhhc2gpIHtcclxuICAgICAgICB0aGlzLmluaXRDb25uZWN0aW9uXygpO1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XHJcbiAgICAgICAgICAgIC8qcGF0aCovIHA6IHBhdGhTdHJpbmcsXHJcbiAgICAgICAgICAgIC8qZGF0YSovIGQ6IGRhdGFcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChoYXNoICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmVxdWVzdFsgLypoYXNoKi8naCddID0gaGFzaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETzogT25seSBrZWVwIHRyYWNrIG9mIHRoZSBtb3N0IHJlY2VudCBwdXQgZm9yIGEgZ2l2ZW4gcGF0aD9cclxuICAgICAgICB0aGlzLm91dHN0YW5kaW5nUHV0c18ucHVzaCh7XHJcbiAgICAgICAgICAgIGFjdGlvbixcclxuICAgICAgICAgICAgcmVxdWVzdCxcclxuICAgICAgICAgICAgb25Db21wbGV0ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMub3V0c3RhbmRpbmdQdXRDb3VudF8rKztcclxuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMub3V0c3RhbmRpbmdQdXRzXy5sZW5ndGggLSAxO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kUHV0XyhpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ0J1ZmZlcmluZyBwdXQ6ICcgKyBwYXRoU3RyaW5nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZW5kUHV0XyhpbmRleCkge1xyXG4gICAgICAgIGNvbnN0IGFjdGlvbiA9IHRoaXMub3V0c3RhbmRpbmdQdXRzX1tpbmRleF0uYWN0aW9uO1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLm91dHN0YW5kaW5nUHV0c19baW5kZXhdLnJlcXVlc3Q7XHJcbiAgICAgICAgY29uc3Qgb25Db21wbGV0ZSA9IHRoaXMub3V0c3RhbmRpbmdQdXRzX1tpbmRleF0ub25Db21wbGV0ZTtcclxuICAgICAgICB0aGlzLm91dHN0YW5kaW5nUHV0c19baW5kZXhdLnF1ZXVlZCA9IHRoaXMuY29ubmVjdGVkXztcclxuICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KGFjdGlvbiwgcmVxdWVzdCwgKG1lc3NhZ2UpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKGFjdGlvbiArICcgcmVzcG9uc2UnLCBtZXNzYWdlKTtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMub3V0c3RhbmRpbmdQdXRzX1tpbmRleF07XHJcbiAgICAgICAgICAgIHRoaXMub3V0c3RhbmRpbmdQdXRDb3VudF8tLTtcclxuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgYXJyYXkgb2NjYXNpb25hbGx5LlxyXG4gICAgICAgICAgICBpZiAodGhpcy5vdXRzdGFuZGluZ1B1dENvdW50XyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vdXRzdGFuZGluZ1B1dHNfID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9uQ29tcGxldGUpIHtcclxuICAgICAgICAgICAgICAgIG9uQ29tcGxldGUobWVzc2FnZVsgLypzdGF0dXMqLydzJ10sIG1lc3NhZ2VbIC8qIGRhdGEgKi8nZCddKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmVwb3J0U3RhdHMoc3RhdHMpIHtcclxuICAgICAgICAvLyBJZiB3ZSdyZSBub3QgY29ubmVjdGVkLCB3ZSBqdXN0IGRyb3AgdGhlIHN0YXRzLlxyXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHsgLypjb3VudGVycyovIGM6IHN0YXRzIH07XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygncmVwb3J0U3RhdHMnLCByZXF1ZXN0KTtcclxuICAgICAgICAgICAgdGhpcy5zZW5kUmVxdWVzdCgvKnN0YXRzKi8gJ3MnLCByZXF1ZXN0LCByZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gcmVzdWx0WyAvKnN0YXR1cyovJ3MnXTtcclxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgIT09ICdvaycpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvclJlYXNvbiA9IHJlc3VsdFsgLyogZGF0YSAqLydkJ107XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdyZXBvcnRTdGF0cycsICdFcnJvciBzZW5kaW5nIHN0YXRzOiAnICsgZXJyb3JSZWFzb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvbkRhdGFNZXNzYWdlXyhtZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKCdyJyBpbiBtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgYSByZXNwb25zZVxyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ2Zyb20gc2VydmVyOiAnICsgc3RyaW5naWZ5KG1lc3NhZ2UpKTtcclxuICAgICAgICAgICAgY29uc3QgcmVxTnVtID0gbWVzc2FnZVsnciddO1xyXG4gICAgICAgICAgICBjb25zdCBvblJlc3BvbnNlID0gdGhpcy5yZXF1ZXN0Q0JIYXNoX1tyZXFOdW1dO1xyXG4gICAgICAgICAgICBpZiAob25SZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucmVxdWVzdENCSGFzaF9bcmVxTnVtXTtcclxuICAgICAgICAgICAgICAgIG9uUmVzcG9uc2UobWVzc2FnZVsgLypib2R5Ki8nYiddKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgnZXJyb3InIGluIG1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgdGhyb3cgJ0Egc2VydmVyLXNpZGUgZXJyb3IgaGFzIG9jY3VycmVkOiAnICsgbWVzc2FnZVsnZXJyb3InXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJ2EnIGluIG1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgLy8gYSBhbmQgYiBhcmUgYWN0aW9uIGFuZCBib2R5LCByZXNwZWN0aXZlbHlcclxuICAgICAgICAgICAgdGhpcy5vbkRhdGFQdXNoXyhtZXNzYWdlWydhJ10sIG1lc3NhZ2VbJ2InXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25EYXRhUHVzaF8oYWN0aW9uLCBib2R5KSB7XHJcbiAgICAgICAgdGhpcy5sb2dfKCdoYW5kbGVTZXJ2ZXJNZXNzYWdlJywgYWN0aW9uLCBib2R5KTtcclxuICAgICAgICBpZiAoYWN0aW9uID09PSAnZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5vbkRhdGFVcGRhdGVfKGJvZHlbIC8qcGF0aCovJ3AnXSwgYm9keVsgLypkYXRhKi8nZCddLCBcclxuICAgICAgICAgICAgLyppc01lcmdlKi8gZmFsc2UsIGJvZHlbJ3QnXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFjdGlvbiA9PT0gJ20nKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25EYXRhVXBkYXRlXyhib2R5WyAvKnBhdGgqLydwJ10sIGJvZHlbIC8qZGF0YSovJ2QnXSwgXHJcbiAgICAgICAgICAgIC8qaXNNZXJnZT0qLyB0cnVlLCBib2R5Wyd0J10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhY3Rpb24gPT09ICdjJykge1xyXG4gICAgICAgICAgICB0aGlzLm9uTGlzdGVuUmV2b2tlZF8oYm9keVsgLypwYXRoKi8ncCddLCBib2R5WyAvKnF1ZXJ5Ki8ncSddKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYWN0aW9uID09PSAnYWMnKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25BdXRoUmV2b2tlZF8oYm9keVsgLypzdGF0dXMgY29kZSovJ3MnXSwgYm9keVsgLyogZXhwbGFuYXRpb24gKi8nZCddKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYWN0aW9uID09PSAnYXBjJykge1xyXG4gICAgICAgICAgICB0aGlzLm9uQXBwQ2hlY2tSZXZva2VkXyhib2R5WyAvKnN0YXR1cyBjb2RlKi8ncyddLCBib2R5WyAvKiBleHBsYW5hdGlvbiAqLydkJ10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhY3Rpb24gPT09ICdzZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5vblNlY3VyaXR5RGVidWdQYWNrZXRfKGJvZHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZXJyb3IoJ1VucmVjb2duaXplZCBhY3Rpb24gcmVjZWl2ZWQgZnJvbSBzZXJ2ZXI6ICcgK1xyXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KGFjdGlvbikgK1xyXG4gICAgICAgICAgICAgICAgJ1xcbkFyZSB5b3UgdXNpbmcgdGhlIGxhdGVzdCBjbGllbnQ/Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25SZWFkeV8odGltZXN0YW1wLCBzZXNzaW9uSWQpIHtcclxuICAgICAgICB0aGlzLmxvZ18oJ2Nvbm5lY3Rpb24gcmVhZHknKTtcclxuICAgICAgICB0aGlzLmNvbm5lY3RlZF8gPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubGFzdENvbm5lY3Rpb25Fc3RhYmxpc2hlZFRpbWVfID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVUaW1lc3RhbXBfKHRpbWVzdGFtcCk7XHJcbiAgICAgICAgdGhpcy5sYXN0U2Vzc2lvbklkID0gc2Vzc2lvbklkO1xyXG4gICAgICAgIGlmICh0aGlzLmZpcnN0Q29ubmVjdGlvbl8pIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kQ29ubmVjdFN0YXRzXygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlc3RvcmVTdGF0ZV8oKTtcclxuICAgICAgICB0aGlzLmZpcnN0Q29ubmVjdGlvbl8gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLm9uQ29ubmVjdFN0YXR1c18odHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBzY2hlZHVsZUNvbm5lY3RfKHRpbWVvdXQpIHtcclxuICAgICAgICBhc3NlcnQoIXRoaXMucmVhbHRpbWVfLCBcIlNjaGVkdWxpbmcgYSBjb25uZWN0IHdoZW4gd2UncmUgYWxyZWFkeSBjb25uZWN0ZWQvaW5nP1wiKTtcclxuICAgICAgICBpZiAodGhpcy5lc3RhYmxpc2hDb25uZWN0aW9uVGltZXJfKSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmVzdGFibGlzaENvbm5lY3Rpb25UaW1lcl8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBOT1RFOiBFdmVuIHdoZW4gdGltZW91dCBpcyAwLCBpdCdzIGltcG9ydGFudCB0byBkbyBhIHNldFRpbWVvdXQgdG8gd29yayBhcm91bmQgYW4gaW5mdXJpYXRpbmcgXCJTZWN1cml0eSBFcnJvclwiIGluXHJcbiAgICAgICAgLy8gRmlyZWZveCB3aGVuIHRyeWluZyB0byB3cml0ZSB0byBvdXIgbG9uZy1wb2xsaW5nIGlmcmFtZSBpbiBzb21lIHNjZW5hcmlvcyAoZS5nLiBGb3JnZSBvciBvdXIgdW5pdCB0ZXN0cykuXHJcbiAgICAgICAgdGhpcy5lc3RhYmxpc2hDb25uZWN0aW9uVGltZXJfID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZXN0YWJsaXNoQ29ubmVjdGlvblRpbWVyXyA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuZXN0YWJsaXNoQ29ubmVjdGlvbl8oKTtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICB9LCBNYXRoLmZsb29yKHRpbWVvdXQpKTtcclxuICAgIH1cclxuICAgIGluaXRDb25uZWN0aW9uXygpIHtcclxuICAgICAgICBpZiAoIXRoaXMucmVhbHRpbWVfICYmIHRoaXMuZmlyc3RDb25uZWN0aW9uXykge1xyXG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlQ29ubmVjdF8oMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25WaXNpYmxlXyh2aXNpYmxlKSB7XHJcbiAgICAgICAgLy8gTk9URTogVGFiYmluZyBhd2F5IGFuZCBiYWNrIHRvIGEgd2luZG93IHdpbGwgZGVmZWF0IG91ciByZWNvbm5lY3QgYmFja29mZiwgYnV0IEkgdGhpbmsgdGhhdCdzIGZpbmUuXHJcbiAgICAgICAgaWYgKHZpc2libGUgJiZcclxuICAgICAgICAgICAgIXRoaXMudmlzaWJsZV8gJiZcclxuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3REZWxheV8gPT09IHRoaXMubWF4UmVjb25uZWN0RGVsYXlfKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnV2luZG93IGJlY2FtZSB2aXNpYmxlLiAgUmVkdWNpbmcgZGVsYXkuJyk7XHJcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0RGVsYXlfID0gUkVDT05ORUNUX01JTl9ERUxBWTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnJlYWx0aW1lXykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZUNvbm5lY3RfKDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudmlzaWJsZV8gPSB2aXNpYmxlO1xyXG4gICAgfVxyXG4gICAgb25PbmxpbmVfKG9ubGluZSkge1xyXG4gICAgICAgIGlmIChvbmxpbmUpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdCcm93c2VyIHdlbnQgb25saW5lLicpO1xyXG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdERlbGF5XyA9IFJFQ09OTkVDVF9NSU5fREVMQVk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWFsdGltZV8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVDb25uZWN0XygwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdCcm93c2VyIHdlbnQgb2ZmbGluZS4gIEtpbGxpbmcgY29ubmVjdGlvbi4nKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucmVhbHRpbWVfKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWx0aW1lXy5jbG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25SZWFsdGltZURpc2Nvbm5lY3RfKCkge1xyXG4gICAgICAgIHRoaXMubG9nXygnZGF0YSBjbGllbnQgZGlzY29ubmVjdGVkJyk7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRfID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5yZWFsdGltZV8gPSBudWxsO1xyXG4gICAgICAgIC8vIFNpbmNlIHdlIGRvbid0IGtub3cgaWYgb3VyIHNlbnQgdHJhbnNhY3Rpb25zIHN1Y2NlZWRlZCBvciBub3QsIHdlIG5lZWQgdG8gY2FuY2VsIHRoZW0uXHJcbiAgICAgICAgdGhpcy5jYW5jZWxTZW50VHJhbnNhY3Rpb25zXygpO1xyXG4gICAgICAgIC8vIENsZWFyIG91dCB0aGUgcGVuZGluZyByZXF1ZXN0cy5cclxuICAgICAgICB0aGlzLnJlcXVlc3RDQkhhc2hfID0ge307XHJcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkUmVjb25uZWN0XygpKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy52aXNpYmxlXykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKFwiV2luZG93IGlzbid0IHZpc2libGUuICBEZWxheWluZyByZWNvbm5lY3QuXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3REZWxheV8gPSB0aGlzLm1heFJlY29ubmVjdERlbGF5XztcclxuICAgICAgICAgICAgICAgIHRoaXMubGFzdENvbm5lY3Rpb25BdHRlbXB0VGltZV8gPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmxhc3RDb25uZWN0aW9uRXN0YWJsaXNoZWRUaW1lXykge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UndmUgYmVlbiBjb25uZWN0ZWQgbG9uZyBlbm91Z2gsIHJlc2V0IHJlY29ubmVjdCBkZWxheSB0byBtaW5pbXVtLlxyXG4gICAgICAgICAgICAgICAgY29uc3QgdGltZVNpbmNlTGFzdENvbm5lY3RTdWNjZWVkZWQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMubGFzdENvbm5lY3Rpb25Fc3RhYmxpc2hlZFRpbWVfO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWVTaW5jZUxhc3RDb25uZWN0U3VjY2VlZGVkID4gUkVDT05ORUNUX0RFTEFZX1JFU0VUX1RJTUVPVVQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlY29ubmVjdERlbGF5XyA9IFJFQ09OTkVDVF9NSU5fREVMQVk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RDb25uZWN0aW9uRXN0YWJsaXNoZWRUaW1lXyA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdGltZVNpbmNlTGFzdENvbm5lY3RBdHRlbXB0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLmxhc3RDb25uZWN0aW9uQXR0ZW1wdFRpbWVfO1xyXG4gICAgICAgICAgICBsZXQgcmVjb25uZWN0RGVsYXkgPSBNYXRoLm1heCgwLCB0aGlzLnJlY29ubmVjdERlbGF5XyAtIHRpbWVTaW5jZUxhc3RDb25uZWN0QXR0ZW1wdCk7XHJcbiAgICAgICAgICAgIHJlY29ubmVjdERlbGF5ID0gTWF0aC5yYW5kb20oKSAqIHJlY29ubmVjdERlbGF5O1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ1RyeWluZyB0byByZWNvbm5lY3QgaW4gJyArIHJlY29ubmVjdERlbGF5ICsgJ21zJyk7XHJcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVDb25uZWN0XyhyZWNvbm5lY3REZWxheSk7XHJcbiAgICAgICAgICAgIC8vIEFkanVzdCByZWNvbm5lY3QgZGVsYXkgZm9yIG5leHQgdGltZS5cclxuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3REZWxheV8gPSBNYXRoLm1pbih0aGlzLm1heFJlY29ubmVjdERlbGF5XywgdGhpcy5yZWNvbm5lY3REZWxheV8gKiBSRUNPTk5FQ1RfREVMQVlfTVVMVElQTElFUik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMub25Db25uZWN0U3RhdHVzXyhmYWxzZSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBlc3RhYmxpc2hDb25uZWN0aW9uXygpIHtcclxuICAgICAgICBpZiAodGhpcy5zaG91bGRSZWNvbm5lY3RfKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdNYWtpbmcgYSBjb25uZWN0aW9uIGF0dGVtcHQnKTtcclxuICAgICAgICAgICAgdGhpcy5sYXN0Q29ubmVjdGlvbkF0dGVtcHRUaW1lXyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmxhc3RDb25uZWN0aW9uRXN0YWJsaXNoZWRUaW1lXyA9IG51bGw7XHJcbiAgICAgICAgICAgIGNvbnN0IG9uRGF0YU1lc3NhZ2UgPSB0aGlzLm9uRGF0YU1lc3NhZ2VfLmJpbmQodGhpcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG9uUmVhZHkgPSB0aGlzLm9uUmVhZHlfLmJpbmQodGhpcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG9uRGlzY29ubmVjdCA9IHRoaXMub25SZWFsdGltZURpc2Nvbm5lY3RfLmJpbmQodGhpcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbm5JZCA9IHRoaXMuaWQgKyAnOicgKyBQZXJzaXN0ZW50Q29ubmVjdGlvbi5uZXh0Q29ubmVjdGlvbklkXysrO1xyXG4gICAgICAgICAgICBjb25zdCBsYXN0U2Vzc2lvbklkID0gdGhpcy5sYXN0U2Vzc2lvbklkO1xyXG4gICAgICAgICAgICBsZXQgY2FuY2VsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgbGV0IGNvbm5lY3Rpb24gPSBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBjbG9zZUZuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgb25EaXNjb25uZWN0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbmRSZXF1ZXN0Rm4gPSBmdW5jdGlvbiAobXNnKSB7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnQoY29ubmVjdGlvbiwgXCJzZW5kUmVxdWVzdCBjYWxsIHdoZW4gd2UncmUgbm90IGNvbm5lY3RlZCBub3QgYWxsb3dlZC5cIik7XHJcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLnNlbmRSZXF1ZXN0KG1zZyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMucmVhbHRpbWVfID0ge1xyXG4gICAgICAgICAgICAgICAgY2xvc2U6IGNsb3NlRm4sXHJcbiAgICAgICAgICAgICAgICBzZW5kUmVxdWVzdDogc2VuZFJlcXVlc3RGblxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBmb3JjZVJlZnJlc2ggPSB0aGlzLmZvcmNlVG9rZW5SZWZyZXNoXztcclxuICAgICAgICAgICAgdGhpcy5mb3JjZVRva2VuUmVmcmVzaF8gPSBmYWxzZTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIC8vIEZpcnN0IGZldGNoIGF1dGggYW5kIGFwcCBjaGVjayB0b2tlbiwgYW5kIGVzdGFibGlzaCBjb25uZWN0aW9uIGFmdGVyXHJcbiAgICAgICAgICAgICAgICAvLyBmZXRjaGluZyB0aGUgdG9rZW4gd2FzIHN1Y2Nlc3NmdWxcclxuICAgICAgICAgICAgICAgIGNvbnN0IFthdXRoVG9rZW4sIGFwcENoZWNrVG9rZW5dID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXV0aFRva2VuUHJvdmlkZXJfLmdldFRva2VuKGZvcmNlUmVmcmVzaCksXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBDaGVja1Rva2VuUHJvdmlkZXJfLmdldFRva2VuKGZvcmNlUmVmcmVzaClcclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZygnZ2V0VG9rZW4oKSBjb21wbGV0ZWQuIENyZWF0aW5nIGNvbm5lY3Rpb24uJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRoVG9rZW5fID0gYXV0aFRva2VuICYmIGF1dGhUb2tlbi5hY2Nlc3NUb2tlbjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcENoZWNrVG9rZW5fID0gYXBwQ2hlY2tUb2tlbiAmJiBhcHBDaGVja1Rva2VuLnRva2VuO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24gPSBuZXcgQ29ubmVjdGlvbihjb25uSWQsIHRoaXMucmVwb0luZm9fLCB0aGlzLmFwcGxpY2F0aW9uSWRfLCB0aGlzLmFwcENoZWNrVG9rZW5fLCB0aGlzLmF1dGhUb2tlbl8sIG9uRGF0YU1lc3NhZ2UsIG9uUmVhZHksIG9uRGlzY29ubmVjdCwgXHJcbiAgICAgICAgICAgICAgICAgICAgLyogb25LaWxsPSAqLyByZWFzb24gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKHJlYXNvbiArICcgKCcgKyB0aGlzLnJlcG9JbmZvXy50b1N0cmluZygpICsgJyknKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcnJ1cHQoU0VSVkVSX0tJTExfSU5URVJSVVBUX1JFQVNPTik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgbGFzdFNlc3Npb25JZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2coJ2dldFRva2VuKCkgY29tcGxldGVkIGJ1dCB3YXMgY2FuY2VsZWQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nXygnRmFpbGVkIHRvIGdldCB0b2tlbjogJyArIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXBvSW5mb18ubm9kZUFkbWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbWF5IGJlIGEgY3JpdGljYWwgZXJyb3IgZm9yIHRoZSBBZG1pbiBOb2RlLmpzIFNESywgc28gbG9nIGEgd2FybmluZy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQnV0IGdldFRva2VuKCkgbWF5IGFsc28ganVzdCBoYXZlIHRlbXBvcmFyaWx5IGZhaWxlZCwgc28gd2Ugc3RpbGwgd2FudCB0b1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb250aW51ZSByZXRyeWluZy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlRm4oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGludGVycnVwdChyZWFzb24pIHtcclxuICAgICAgICBsb2coJ0ludGVycnVwdGluZyBjb25uZWN0aW9uIGZvciByZWFzb246ICcgKyByZWFzb24pO1xyXG4gICAgICAgIHRoaXMuaW50ZXJydXB0UmVhc29uc19bcmVhc29uXSA9IHRydWU7XHJcbiAgICAgICAgaWYgKHRoaXMucmVhbHRpbWVfKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVhbHRpbWVfLmNsb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5lc3RhYmxpc2hDb25uZWN0aW9uVGltZXJfKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5lc3RhYmxpc2hDb25uZWN0aW9uVGltZXJfKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXN0YWJsaXNoQ29ubmVjdGlvblRpbWVyXyA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vblJlYWx0aW1lRGlzY29ubmVjdF8oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlc3VtZShyZWFzb24pIHtcclxuICAgICAgICBsb2coJ1Jlc3VtaW5nIGNvbm5lY3Rpb24gZm9yIHJlYXNvbjogJyArIHJlYXNvbik7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuaW50ZXJydXB0UmVhc29uc19bcmVhc29uXTtcclxuICAgICAgICBpZiAoaXNFbXB0eSh0aGlzLmludGVycnVwdFJlYXNvbnNfKSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdERlbGF5XyA9IFJFQ09OTkVDVF9NSU5fREVMQVk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWFsdGltZV8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVDb25uZWN0XygwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGhhbmRsZVRpbWVzdGFtcF8odGltZXN0YW1wKSB7XHJcbiAgICAgICAgY29uc3QgZGVsdGEgPSB0aW1lc3RhbXAgLSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICB0aGlzLm9uU2VydmVySW5mb1VwZGF0ZV8oeyBzZXJ2ZXJUaW1lT2Zmc2V0OiBkZWx0YSB9KTtcclxuICAgIH1cclxuICAgIGNhbmNlbFNlbnRUcmFuc2FjdGlvbnNfKCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vdXRzdGFuZGluZ1B1dHNfLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHB1dCA9IHRoaXMub3V0c3RhbmRpbmdQdXRzX1tpXTtcclxuICAgICAgICAgICAgaWYgKHB1dCAmJiAvKmhhc2gqLyAnaCcgaW4gcHV0LnJlcXVlc3QgJiYgcHV0LnF1ZXVlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHB1dC5vbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHV0Lm9uQ29tcGxldGUoJ2Rpc2Nvbm5lY3QnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm91dHN0YW5kaW5nUHV0c19baV07XHJcbiAgICAgICAgICAgICAgICB0aGlzLm91dHN0YW5kaW5nUHV0Q291bnRfLS07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2xlYW4gdXAgYXJyYXkgb2NjYXNpb25hbGx5LlxyXG4gICAgICAgIGlmICh0aGlzLm91dHN0YW5kaW5nUHV0Q291bnRfID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3V0c3RhbmRpbmdQdXRzXyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uTGlzdGVuUmV2b2tlZF8ocGF0aFN0cmluZywgcXVlcnkpIHtcclxuICAgICAgICAvLyBSZW1vdmUgdGhlIGxpc3RlbiBhbmQgbWFudWZhY3R1cmUgYSBcInBlcm1pc3Npb25fZGVuaWVkXCIgZXJyb3IgZm9yIHRoZSBmYWlsZWQgbGlzdGVuLlxyXG4gICAgICAgIGxldCBxdWVyeUlkO1xyXG4gICAgICAgIGlmICghcXVlcnkpIHtcclxuICAgICAgICAgICAgcXVlcnlJZCA9ICdkZWZhdWx0JztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHF1ZXJ5SWQgPSBxdWVyeS5tYXAocSA9PiBPYmplY3RUb1VuaXF1ZUtleShxKSkuam9pbignJCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBsaXN0ZW4gPSB0aGlzLnJlbW92ZUxpc3Rlbl8ocGF0aFN0cmluZywgcXVlcnlJZCk7XHJcbiAgICAgICAgaWYgKGxpc3RlbiAmJiBsaXN0ZW4ub25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICBsaXN0ZW4ub25Db21wbGV0ZSgncGVybWlzc2lvbl9kZW5pZWQnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZW1vdmVMaXN0ZW5fKHBhdGhTdHJpbmcsIHF1ZXJ5SWQpIHtcclxuICAgICAgICBjb25zdCBub3JtYWxpemVkUGF0aFN0cmluZyA9IG5ldyBQYXRoKHBhdGhTdHJpbmcpLnRvU3RyaW5nKCk7IC8vIG5vcm1hbGl6ZSBwYXRoLlxyXG4gICAgICAgIGxldCBsaXN0ZW47XHJcbiAgICAgICAgaWYgKHRoaXMubGlzdGVucy5oYXMobm9ybWFsaXplZFBhdGhTdHJpbmcpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hcCA9IHRoaXMubGlzdGVucy5nZXQobm9ybWFsaXplZFBhdGhTdHJpbmcpO1xyXG4gICAgICAgICAgICBsaXN0ZW4gPSBtYXAuZ2V0KHF1ZXJ5SWQpO1xyXG4gICAgICAgICAgICBtYXAuZGVsZXRlKHF1ZXJ5SWQpO1xyXG4gICAgICAgICAgICBpZiAobWFwLnNpemUgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVucy5kZWxldGUobm9ybWFsaXplZFBhdGhTdHJpbmcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBhbGwgbGlzdGVucyBmb3IgdGhpcyBwYXRoIGhhcyBhbHJlYWR5IGJlZW4gcmVtb3ZlZFxyXG4gICAgICAgICAgICBsaXN0ZW4gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsaXN0ZW47XHJcbiAgICB9XHJcbiAgICBvbkF1dGhSZXZva2VkXyhzdGF0dXNDb2RlLCBleHBsYW5hdGlvbikge1xyXG4gICAgICAgIGxvZygnQXV0aCB0b2tlbiByZXZva2VkOiAnICsgc3RhdHVzQ29kZSArICcvJyArIGV4cGxhbmF0aW9uKTtcclxuICAgICAgICB0aGlzLmF1dGhUb2tlbl8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZm9yY2VUb2tlblJlZnJlc2hfID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnJlYWx0aW1lXy5jbG9zZSgpO1xyXG4gICAgICAgIGlmIChzdGF0dXNDb2RlID09PSAnaW52YWxpZF90b2tlbicgfHwgc3RhdHVzQ29kZSA9PT0gJ3Blcm1pc3Npb25fZGVuaWVkJykge1xyXG4gICAgICAgICAgICAvLyBXZSdsbCB3YWl0IGEgY291cGxlIHRpbWVzIGJlZm9yZSBsb2dnaW5nIHRoZSB3YXJuaW5nIC8gaW5jcmVhc2luZyB0aGVcclxuICAgICAgICAgICAgLy8gcmV0cnkgcGVyaW9kIHNpbmNlIG9hdXRoIHRva2VucyB3aWxsIHJlcG9ydCBhcyBcImludmFsaWRcIiBpZiB0aGV5J3JlXHJcbiAgICAgICAgICAgIC8vIGp1c3QgZXhwaXJlZC4gUGx1cyB0aGVyZSBtYXkgYmUgdHJhbnNpZW50IGlzc3VlcyB0aGF0IHJlc29sdmUgdGhlbXNlbHZlcy5cclxuICAgICAgICAgICAgdGhpcy5pbnZhbGlkQXV0aFRva2VuQ291bnRfKys7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmludmFsaWRBdXRoVG9rZW5Db3VudF8gPj0gSU5WQUxJRF9UT0tFTl9USFJFU0hPTEQpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNldCBhIGxvbmcgcmVjb25uZWN0IGRlbGF5IGJlY2F1c2UgcmVjb3ZlcnkgaXMgdW5saWtlbHlcclxuICAgICAgICAgICAgICAgIHRoaXMucmVjb25uZWN0RGVsYXlfID0gUkVDT05ORUNUX01BWF9ERUxBWV9GT1JfQURNSU5TO1xyXG4gICAgICAgICAgICAgICAgLy8gTm90aWZ5IHRoZSBhdXRoIHRva2VuIHByb3ZpZGVyIHRoYXQgdGhlIHRva2VuIGlzIGludmFsaWQsIHdoaWNoIHdpbGwgbG9nXHJcbiAgICAgICAgICAgICAgICAvLyBhIHdhcm5pbmdcclxuICAgICAgICAgICAgICAgIHRoaXMuYXV0aFRva2VuUHJvdmlkZXJfLm5vdGlmeUZvckludmFsaWRUb2tlbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25BcHBDaGVja1Jldm9rZWRfKHN0YXR1c0NvZGUsIGV4cGxhbmF0aW9uKSB7XHJcbiAgICAgICAgbG9nKCdBcHAgY2hlY2sgdG9rZW4gcmV2b2tlZDogJyArIHN0YXR1c0NvZGUgKyAnLycgKyBleHBsYW5hdGlvbik7XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja1Rva2VuXyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5mb3JjZVRva2VuUmVmcmVzaF8gPSB0cnVlO1xyXG4gICAgICAgIC8vIE5vdGU6IFdlIGRvbid0IGNsb3NlIHRoZSBjb25uZWN0aW9uIGFzIHRoZSBkZXZlbG9wZXIgbWF5IG5vdCBoYXZlXHJcbiAgICAgICAgLy8gZW5mb3JjZW1lbnQgZW5hYmxlZC4gVGhlIGJhY2tlbmQgY2xvc2VzIGNvbm5lY3Rpb25zIHdpdGggZW5mb3JjZW1lbnRzLlxyXG4gICAgICAgIGlmIChzdGF0dXNDb2RlID09PSAnaW52YWxpZF90b2tlbicgfHwgc3RhdHVzQ29kZSA9PT0gJ3Blcm1pc3Npb25fZGVuaWVkJykge1xyXG4gICAgICAgICAgICAvLyBXZSdsbCB3YWl0IGEgY291cGxlIHRpbWVzIGJlZm9yZSBsb2dnaW5nIHRoZSB3YXJuaW5nIC8gaW5jcmVhc2luZyB0aGVcclxuICAgICAgICAgICAgLy8gcmV0cnkgcGVyaW9kIHNpbmNlIG9hdXRoIHRva2VucyB3aWxsIHJlcG9ydCBhcyBcImludmFsaWRcIiBpZiB0aGV5J3JlXHJcbiAgICAgICAgICAgIC8vIGp1c3QgZXhwaXJlZC4gUGx1cyB0aGVyZSBtYXkgYmUgdHJhbnNpZW50IGlzc3VlcyB0aGF0IHJlc29sdmUgdGhlbXNlbHZlcy5cclxuICAgICAgICAgICAgdGhpcy5pbnZhbGlkQXBwQ2hlY2tUb2tlbkNvdW50XysrO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pbnZhbGlkQXBwQ2hlY2tUb2tlbkNvdW50XyA+PSBJTlZBTElEX1RPS0VOX1RIUkVTSE9MRCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBDaGVja1Rva2VuUHJvdmlkZXJfLm5vdGlmeUZvckludmFsaWRUb2tlbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25TZWN1cml0eURlYnVnUGFja2V0Xyhib2R5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2VjdXJpdHlEZWJ1Z0NhbGxiYWNrXykge1xyXG4gICAgICAgICAgICB0aGlzLnNlY3VyaXR5RGVidWdDYWxsYmFja18oYm9keSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoJ21zZycgaW4gYm9keSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZJUkVCQVNFOiAnICsgYm9keVsnbXNnJ10ucmVwbGFjZSgnXFxuJywgJ1xcbkZJUkVCQVNFOiAnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXN0b3JlU3RhdGVfKCkge1xyXG4gICAgICAgIC8vUmUtYXV0aGVudGljYXRlIG91cnNlbHZlcyBpZiB3ZSBoYXZlIGEgY3JlZGVudGlhbCBzdG9yZWQuXHJcbiAgICAgICAgdGhpcy50cnlBdXRoKCk7XHJcbiAgICAgICAgdGhpcy50cnlBcHBDaGVjaygpO1xyXG4gICAgICAgIC8vIFB1dHMgZGVwZW5kIG9uIGhhdmluZyByZWNlaXZlZCB0aGUgY29ycmVzcG9uZGluZyBkYXRhIHVwZGF0ZSBmcm9tIHRoZSBzZXJ2ZXIgYmVmb3JlIHRoZXkgY29tcGxldGUsIHNvIHdlIG11c3RcclxuICAgICAgICAvLyBtYWtlIHN1cmUgdG8gc2VuZCBsaXN0ZW5zIGJlZm9yZSBwdXRzLlxyXG4gICAgICAgIGZvciAoY29uc3QgcXVlcmllcyBvZiB0aGlzLmxpc3RlbnMudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5TcGVjIG9mIHF1ZXJpZXMudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZExpc3Rlbl8obGlzdGVuU3BlYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm91dHN0YW5kaW5nUHV0c18ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3V0c3RhbmRpbmdQdXRzX1tpXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kUHV0XyhpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAodGhpcy5vbkRpc2Nvbm5lY3RSZXF1ZXN0UXVldWVfLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5vbkRpc2Nvbm5lY3RSZXF1ZXN0UXVldWVfLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZE9uRGlzY29ubmVjdF8ocmVxdWVzdC5hY3Rpb24sIHJlcXVlc3QucGF0aFN0cmluZywgcmVxdWVzdC5kYXRhLCByZXF1ZXN0Lm9uQ29tcGxldGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMub3V0c3RhbmRpbmdHZXRzXy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vdXRzdGFuZGluZ0dldHNfW2ldKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRHZXRfKGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZW5kcyBjbGllbnQgc3RhdHMgZm9yIGZpcnN0IGNvbm5lY3Rpb25cclxuICAgICAqL1xyXG4gICAgc2VuZENvbm5lY3RTdGF0c18oKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhdHMgPSB7fTtcclxuICAgICAgICBsZXQgY2xpZW50TmFtZSA9ICdqcyc7XHJcbiAgICAgICAgaWYgKGlzTm9kZVNkaygpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJlcG9JbmZvXy5ub2RlQWRtaW4pIHtcclxuICAgICAgICAgICAgICAgIGNsaWVudE5hbWUgPSAnYWRtaW5fbm9kZSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjbGllbnROYW1lID0gJ25vZGUnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRzWydzZGsuJyArIGNsaWVudE5hbWUgKyAnLicgKyBTREtfVkVSU0lPTi5yZXBsYWNlKC9cXC4vZywgJy0nKV0gPSAxO1xyXG4gICAgICAgIGlmIChpc01vYmlsZUNvcmRvdmEoKSkge1xyXG4gICAgICAgICAgICBzdGF0c1snZnJhbWV3b3JrLmNvcmRvdmEnXSA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xyXG4gICAgICAgICAgICBzdGF0c1snZnJhbWV3b3JrLnJlYWN0bmF0aXZlJ10gPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlcG9ydFN0YXRzKHN0YXRzKTtcclxuICAgIH1cclxuICAgIHNob3VsZFJlY29ubmVjdF8oKSB7XHJcbiAgICAgICAgY29uc3Qgb25saW5lID0gT25saW5lTW9uaXRvci5nZXRJbnN0YW5jZSgpLmN1cnJlbnRseU9ubGluZSgpO1xyXG4gICAgICAgIHJldHVybiBpc0VtcHR5KHRoaXMuaW50ZXJydXB0UmVhc29uc18pICYmIG9ubGluZTtcclxuICAgIH1cclxufVxyXG5QZXJzaXN0ZW50Q29ubmVjdGlvbi5uZXh0UGVyc2lzdGVudENvbm5lY3Rpb25JZF8gPSAwO1xyXG4vKipcclxuICogQ291bnRlciBmb3IgbnVtYmVyIG9mIGNvbm5lY3Rpb25zIGNyZWF0ZWQuIE1haW5seSB1c2VkIGZvciB0YWdnaW5nIGluIHRoZSBsb2dzXHJcbiAqL1xyXG5QZXJzaXN0ZW50Q29ubmVjdGlvbi5uZXh0Q29ubmVjdGlvbklkXyA9IDA7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIE5hbWVkTm9kZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBub2RlKSB7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIFdyYXAobmFtZSwgbm9kZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTmFtZWROb2RlKG5hbWUsIG5vZGUpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIEluZGV4IHtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgQSBzdGFuZGFsb25lIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yXHJcbiAgICAgKiB0aGlzIGluZGV4XHJcbiAgICAgKi9cclxuICAgIGdldENvbXBhcmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZS5iaW5kKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhIGJlZm9yZSBhbmQgYWZ0ZXIgdmFsdWUgZm9yIGEgbm9kZSwgZGV0ZXJtaW5lIGlmIHRoZSBpbmRleGVkIHZhbHVlIGhhcyBjaGFuZ2VkLiBFdmVuIGlmIHRoZXkgYXJlIGRpZmZlcmVudCxcclxuICAgICAqIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgY2hhbmdlcyBhcmUgaXNvbGF0ZWQgdG8gcGFydHMgb2YgdGhlIHNuYXBzaG90IHRoYXQgYXJlIG5vdCBpbmRleGVkLlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBwb3J0aW9uIG9mIHRoZSBzbmFwc2hvdCBiZWluZyBpbmRleGVkIGNoYW5nZWQgYmV0d2VlbiBvbGROb2RlIGFuZCBuZXdOb2RlXHJcbiAgICAgKi9cclxuICAgIGluZGV4ZWRWYWx1ZUNoYW5nZWQob2xkTm9kZSwgbmV3Tm9kZSkge1xyXG4gICAgICAgIGNvbnN0IG9sZFdyYXBwZWQgPSBuZXcgTmFtZWROb2RlKE1JTl9OQU1FLCBvbGROb2RlKTtcclxuICAgICAgICBjb25zdCBuZXdXcmFwcGVkID0gbmV3IE5hbWVkTm9kZShNSU5fTkFNRSwgbmV3Tm9kZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZShvbGRXcmFwcGVkLCBuZXdXcmFwcGVkKSAhPT0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgYSBub2RlIHdyYXBwZXIgdGhhdCB3aWxsIHNvcnQgZXF1YWwgdG8gb3IgbGVzcyB0aGFuXHJcbiAgICAgKiBhbnkgb3RoZXIgbm9kZSB3cmFwcGVyLCB1c2luZyB0aGlzIGluZGV4XHJcbiAgICAgKi9cclxuICAgIG1pblBvc3QoKSB7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICByZXR1cm4gTmFtZWROb2RlLk1JTjtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5sZXQgX19FTVBUWV9OT0RFO1xyXG5jbGFzcyBLZXlJbmRleCBleHRlbmRzIEluZGV4IHtcclxuICAgIHN0YXRpYyBnZXQgX19FTVBUWV9OT0RFKCkge1xyXG4gICAgICAgIHJldHVybiBfX0VNUFRZX05PREU7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgc2V0IF9fRU1QVFlfTk9ERSh2YWwpIHtcclxuICAgICAgICBfX0VNUFRZX05PREUgPSB2YWw7XHJcbiAgICB9XHJcbiAgICBjb21wYXJlKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gbmFtZUNvbXBhcmUoYS5uYW1lLCBiLm5hbWUpO1xyXG4gICAgfVxyXG4gICAgaXNEZWZpbmVkT24obm9kZSkge1xyXG4gICAgICAgIC8vIFdlIGNvdWxkIHByb2JhYmx5IHJldHVybiB0cnVlIGhlcmUgKHNpbmNlIGV2ZXJ5IG5vZGUgaGFzIGEga2V5KSwgYnV0IGl0J3MgbmV2ZXIgY2FsbGVkXHJcbiAgICAgICAgLy8gc28ganVzdCBsZWF2aW5nIHVuaW1wbGVtZW50ZWQgZm9yIG5vdy5cclxuICAgICAgICB0aHJvdyBhc3NlcnRpb25FcnJvcignS2V5SW5kZXguaXNEZWZpbmVkT24gbm90IGV4cGVjdGVkIHRvIGJlIGNhbGxlZC4nKTtcclxuICAgIH1cclxuICAgIGluZGV4ZWRWYWx1ZUNoYW5nZWQob2xkTm9kZSwgbmV3Tm9kZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gVGhlIGtleSBmb3IgYSBub2RlIG5ldmVyIGNoYW5nZXMuXHJcbiAgICB9XHJcbiAgICBtaW5Qb3N0KCkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgcmV0dXJuIE5hbWVkTm9kZS5NSU47XHJcbiAgICB9XHJcbiAgICBtYXhQb3N0KCkge1xyXG4gICAgICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIHJlYWxseSBiZSBjcmVhdGVkIG9uY2UgYW5kIGNhY2hlZCBpbiBhIHN0YXRpYyBwcm9wZXJ0eSwgYnV0XHJcbiAgICAgICAgLy8gTmFtZWROb2RlIGlzbid0IGRlZmluZWQgeWV0LCBzbyBJIGNhbid0IHVzZSBpdCBpbiBhIHN0YXRpYy4gIEJsZWguXHJcbiAgICAgICAgcmV0dXJuIG5ldyBOYW1lZE5vZGUoTUFYX05BTUUsIF9fRU1QVFlfTk9ERSk7XHJcbiAgICB9XHJcbiAgICBtYWtlUG9zdChpbmRleFZhbHVlLCBuYW1lKSB7XHJcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiBpbmRleFZhbHVlID09PSAnc3RyaW5nJywgJ0tleUluZGV4IGluZGV4VmFsdWUgbXVzdCBhbHdheXMgYmUgYSBzdHJpbmcuJyk7XHJcbiAgICAgICAgLy8gV2UganVzdCB1c2UgZW1wdHkgbm9kZSwgYnV0IGl0J2xsIG5ldmVyIGJlIGNvbXBhcmVkLCBzaW5jZSBvdXIgY29tcGFyYXRvciBvbmx5IGxvb2tzIGF0IG5hbWUuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBOYW1lZE5vZGUoaW5kZXhWYWx1ZSwgX19FTVBUWV9OT0RFKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgU3RyaW5nIHJlcHJlc2VudGF0aW9uIGZvciBpbmNsdXNpb24gaW4gYSBxdWVyeSBzcGVjXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiAnLmtleSc7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgS0VZX0lOREVYID0gbmV3IEtleUluZGV4KCk7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBbiBpdGVyYXRvciBvdmVyIGFuIExMUkJOb2RlLlxyXG4gKi9cclxuY2xhc3MgU29ydGVkTWFwSXRlcmF0b3Ige1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gbm9kZSAtIE5vZGUgdG8gaXRlcmF0ZS5cclxuICAgICAqIEBwYXJhbSBpc1JldmVyc2VfIC0gV2hldGhlciBvciBub3QgdG8gaXRlcmF0ZSBpbiByZXZlcnNlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG5vZGUsIHN0YXJ0S2V5LCBjb21wYXJhdG9yLCBpc1JldmVyc2VfLCByZXN1bHRHZW5lcmF0b3JfID0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMuaXNSZXZlcnNlXyA9IGlzUmV2ZXJzZV87XHJcbiAgICAgICAgdGhpcy5yZXN1bHRHZW5lcmF0b3JfID0gcmVzdWx0R2VuZXJhdG9yXztcclxuICAgICAgICB0aGlzLm5vZGVTdGFja18gPSBbXTtcclxuICAgICAgICBsZXQgY21wID0gMTtcclxuICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlO1xyXG4gICAgICAgICAgICBjbXAgPSBzdGFydEtleSA/IGNvbXBhcmF0b3Iobm9kZS5rZXksIHN0YXJ0S2V5KSA6IDE7XHJcbiAgICAgICAgICAgIC8vIGZsaXAgdGhlIGNvbXBhcmlzb24gaWYgd2UncmUgZ29pbmcgaW4gcmV2ZXJzZVxyXG4gICAgICAgICAgICBpZiAoaXNSZXZlcnNlXykge1xyXG4gICAgICAgICAgICAgICAgY21wICo9IC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjbXAgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG5vZGUgaXMgbGVzcyB0aGFuIG91ciBzdGFydCBrZXkuIGlnbm9yZSBpdFxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNSZXZlcnNlXykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgbm9kZSBpcyBleGFjdGx5IGVxdWFsIHRvIG91ciBzdGFydCBrZXkuIFB1c2ggaXQgb24gdGhlIHN0YWNrLCBidXQgc3RvcCBpdGVyYXRpbmc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVTdGFja18ucHVzaChub2RlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBub2RlIGlzIGdyZWF0ZXIgdGhhbiBvdXIgc3RhcnQga2V5LCBhZGQgaXQgdG8gdGhlIHN0YWNrIGFuZCBtb3ZlIHRvIHRoZSBuZXh0IG9uZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlU3RhY2tfLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1JldmVyc2VfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0TmV4dCgpIHtcclxuICAgICAgICBpZiAodGhpcy5ub2RlU3RhY2tfLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLm5vZGVTdGFja18ucG9wKCk7XHJcbiAgICAgICAgbGV0IHJlc3VsdDtcclxuICAgICAgICBpZiAodGhpcy5yZXN1bHRHZW5lcmF0b3JfKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucmVzdWx0R2VuZXJhdG9yXyhub2RlLmtleSwgbm9kZS52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB7IGtleTogbm9kZS5rZXksIHZhbHVlOiBub2RlLnZhbHVlIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzUmV2ZXJzZV8pIHtcclxuICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgd2hpbGUgKCFub2RlLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlU3RhY2tfLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XHJcbiAgICAgICAgICAgIHdoaWxlICghbm9kZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubm9kZVN0YWNrXy5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgaGFzTmV4dCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlU3RhY2tfLmxlbmd0aCA+IDA7XHJcbiAgICB9XHJcbiAgICBwZWVrKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm5vZGVTdGFja18ubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5ub2RlU3RhY2tfW3RoaXMubm9kZVN0YWNrXy5sZW5ndGggLSAxXTtcclxuICAgICAgICBpZiAodGhpcy5yZXN1bHRHZW5lcmF0b3JfKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdEdlbmVyYXRvcl8obm9kZS5rZXksIG5vZGUudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsga2V5OiBub2RlLmtleSwgdmFsdWU6IG5vZGUudmFsdWUgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBub2RlIGluIGEgTGVmdC1sZWFuaW5nIFJlZC1CbGFjayB0cmVlLlxyXG4gKi9cclxuY2xhc3MgTExSQk5vZGUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ga2V5IC0gS2V5IGFzc29jaWF0ZWQgd2l0aCB0aGlzIG5vZGUuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLlxyXG4gICAgICogQHBhcmFtIGNvbG9yIC0gV2hldGhlciB0aGlzIG5vZGUgaXMgcmVkLlxyXG4gICAgICogQHBhcmFtIGxlZnQgLSBMZWZ0IGNoaWxkLlxyXG4gICAgICogQHBhcmFtIHJpZ2h0IC0gUmlnaHQgY2hpbGQuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGtleSwgdmFsdWUsIGNvbG9yLCBsZWZ0LCByaWdodCkge1xyXG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLmNvbG9yID0gY29sb3IgIT0gbnVsbCA/IGNvbG9yIDogTExSQk5vZGUuUkVEO1xyXG4gICAgICAgIHRoaXMubGVmdCA9XHJcbiAgICAgICAgICAgIGxlZnQgIT0gbnVsbCA/IGxlZnQgOiBTb3J0ZWRNYXAuRU1QVFlfTk9ERTtcclxuICAgICAgICB0aGlzLnJpZ2h0ID1cclxuICAgICAgICAgICAgcmlnaHQgIT0gbnVsbCA/IHJpZ2h0IDogU29ydGVkTWFwLkVNUFRZX05PREU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IG5vZGUsIG9wdGlvbmFsbHkgcmVwbGFjaW5nIHBpZWNlcyBvZiBpdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ga2V5IC0gTmV3IGtleSBmb3IgdGhlIG5vZGUsIG9yIG51bGwuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBOZXcgdmFsdWUgZm9yIHRoZSBub2RlLCBvciBudWxsLlxyXG4gICAgICogQHBhcmFtIGNvbG9yIC0gTmV3IGNvbG9yIGZvciB0aGUgbm9kZSwgb3IgbnVsbC5cclxuICAgICAqIEBwYXJhbSBsZWZ0IC0gTmV3IGxlZnQgY2hpbGQgZm9yIHRoZSBub2RlLCBvciBudWxsLlxyXG4gICAgICogQHBhcmFtIHJpZ2h0IC0gTmV3IHJpZ2h0IGNoaWxkIGZvciB0aGUgbm9kZSwgb3IgbnVsbC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBub2RlIGNvcHkuXHJcbiAgICAgKi9cclxuICAgIGNvcHkoa2V5LCB2YWx1ZSwgY29sb3IsIGxlZnQsIHJpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMTFJCTm9kZShrZXkgIT0gbnVsbCA/IGtleSA6IHRoaXMua2V5LCB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiB0aGlzLnZhbHVlLCBjb2xvciAhPSBudWxsID8gY29sb3IgOiB0aGlzLmNvbG9yLCBsZWZ0ICE9IG51bGwgPyBsZWZ0IDogdGhpcy5sZWZ0LCByaWdodCAhPSBudWxsID8gcmlnaHQgOiB0aGlzLnJpZ2h0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIHRvdGFsIG51bWJlciBvZiBub2RlcyBpbiB0aGUgdHJlZS5cclxuICAgICAqL1xyXG4gICAgY291bnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5jb3VudCgpICsgMSArIHRoaXMucmlnaHQuY291bnQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdHJlZSBpcyBlbXB0eS5cclxuICAgICAqL1xyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyYXZlcnNlcyB0aGUgdHJlZSBpbiBrZXkgb3JkZXIgYW5kIGNhbGxzIHRoZSBzcGVjaWZpZWQgYWN0aW9uIGZ1bmN0aW9uXHJcbiAgICAgKiBmb3IgZWFjaCBub2RlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhY3Rpb24gLSBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgZm9yIGVhY2hcclxuICAgICAqICAgbm9kZS4gIElmIGl0IHJldHVybnMgdHJ1ZSwgdHJhdmVyc2FsIGlzIGFib3J0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZmlyc3QgdHJ1dGh5IHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvbiwgb3IgdGhlIGxhc3QgZmFsc2V5XHJcbiAgICAgKiAgIHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvblxyXG4gICAgICovXHJcbiAgICBpbm9yZGVyVHJhdmVyc2FsKGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5sZWZ0Lmlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKSB8fFxyXG4gICAgICAgICAgICAhIWFjdGlvbih0aGlzLmtleSwgdGhpcy52YWx1ZSkgfHxcclxuICAgICAgICAgICAgdGhpcy5yaWdodC5pbm9yZGVyVHJhdmVyc2FsKGFjdGlvbikpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmF2ZXJzZXMgdGhlIHRyZWUgaW4gcmV2ZXJzZSBrZXkgb3JkZXIgYW5kIGNhbGxzIHRoZSBzcGVjaWZpZWQgYWN0aW9uIGZ1bmN0aW9uXHJcbiAgICAgKiBmb3IgZWFjaCBub2RlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhY3Rpb24gLSBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgZm9yIGVhY2hcclxuICAgICAqIG5vZGUuICBJZiBpdCByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0cmF2ZXJzYWwgd2FzIGFib3J0ZWQuXHJcbiAgICAgKi9cclxuICAgIHJldmVyc2VUcmF2ZXJzYWwoYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnJpZ2h0LnJldmVyc2VUcmF2ZXJzYWwoYWN0aW9uKSB8fFxyXG4gICAgICAgICAgICBhY3Rpb24odGhpcy5rZXksIHRoaXMudmFsdWUpIHx8XHJcbiAgICAgICAgICAgIHRoaXMubGVmdC5yZXZlcnNlVHJhdmVyc2FsKGFjdGlvbikpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbWluaW11bSBub2RlIGluIHRoZSB0cmVlLlxyXG4gICAgICovXHJcbiAgICBtaW5fKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxlZnQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5taW5fKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbWF4aW11bSBrZXkgaW4gdGhlIHRyZWUuXHJcbiAgICAgKi9cclxuICAgIG1pbktleSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5taW5fKCkua2V5O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbWF4aW11bSBrZXkgaW4gdGhlIHRyZWUuXHJcbiAgICAgKi9cclxuICAgIG1heEtleSgpIHtcclxuICAgICAgICBpZiAodGhpcy5yaWdodC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMua2V5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmlnaHQubWF4S2V5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ga2V5IC0gS2V5IHRvIGluc2VydC5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGluc2VydC5cclxuICAgICAqIEBwYXJhbSBjb21wYXJhdG9yIC0gQ29tcGFyYXRvci5cclxuICAgICAqIEByZXR1cm5zIE5ldyB0cmVlLCB3aXRoIHRoZSBrZXkvdmFsdWUgYWRkZWQuXHJcbiAgICAgKi9cclxuICAgIGluc2VydChrZXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XHJcbiAgICAgICAgbGV0IG4gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IGNtcCA9IGNvbXBhcmF0b3Ioa2V5LCBuLmtleSk7XHJcbiAgICAgICAgaWYgKGNtcCA8IDApIHtcclxuICAgICAgICAgICAgbiA9IG4uY29weShudWxsLCBudWxsLCBudWxsLCBuLmxlZnQuaW5zZXJ0KGtleSwgdmFsdWUsIGNvbXBhcmF0b3IpLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY21wID09PSAwKSB7XHJcbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgdmFsdWUsIG51bGwsIG51bGwsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbiA9IG4uY29weShudWxsLCBudWxsLCBudWxsLCBudWxsLCBuLnJpZ2h0Lmluc2VydChrZXksIHZhbHVlLCBjb21wYXJhdG9yKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuLmZpeFVwXygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBOZXcgdHJlZSwgd2l0aCB0aGUgbWluaW11bSBrZXkgcmVtb3ZlZC5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlTWluXygpIHtcclxuICAgICAgICBpZiAodGhpcy5sZWZ0LmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gU29ydGVkTWFwLkVNUFRZX05PREU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBuID0gdGhpcztcclxuICAgICAgICBpZiAoIW4ubGVmdC5pc1JlZF8oKSAmJiAhbi5sZWZ0LmxlZnQuaXNSZWRfKCkpIHtcclxuICAgICAgICAgICAgbiA9IG4ubW92ZVJlZExlZnRfKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbi5sZWZ0LnJlbW92ZU1pbl8oKSwgbnVsbCk7XHJcbiAgICAgICAgcmV0dXJuIG4uZml4VXBfKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IG9mIHRoZSBpdGVtIHRvIHJlbW92ZS5cclxuICAgICAqIEBwYXJhbSBjb21wYXJhdG9yIC0gQ29tcGFyYXRvci5cclxuICAgICAqIEByZXR1cm5zIE5ldyB0cmVlLCB3aXRoIHRoZSBzcGVjaWZpZWQgaXRlbSByZW1vdmVkLlxyXG4gICAgICovXHJcbiAgICByZW1vdmUoa2V5LCBjb21wYXJhdG9yKSB7XHJcbiAgICAgICAgbGV0IG4sIHNtYWxsZXN0O1xyXG4gICAgICAgIG4gPSB0aGlzO1xyXG4gICAgICAgIGlmIChjb21wYXJhdG9yKGtleSwgbi5rZXkpIDwgMCkge1xyXG4gICAgICAgICAgICBpZiAoIW4ubGVmdC5pc0VtcHR5KCkgJiYgIW4ubGVmdC5pc1JlZF8oKSAmJiAhbi5sZWZ0LmxlZnQuaXNSZWRfKCkpIHtcclxuICAgICAgICAgICAgICAgIG4gPSBuLm1vdmVSZWRMZWZ0XygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbi5sZWZ0LnJlbW92ZShrZXksIGNvbXBhcmF0b3IpLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChuLmxlZnQuaXNSZWRfKCkpIHtcclxuICAgICAgICAgICAgICAgIG4gPSBuLnJvdGF0ZVJpZ2h0XygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghbi5yaWdodC5pc0VtcHR5KCkgJiYgIW4ucmlnaHQuaXNSZWRfKCkgJiYgIW4ucmlnaHQubGVmdC5pc1JlZF8oKSkge1xyXG4gICAgICAgICAgICAgICAgbiA9IG4ubW92ZVJlZFJpZ2h0XygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjb21wYXJhdG9yKGtleSwgbi5rZXkpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobi5yaWdodC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU29ydGVkTWFwLkVNUFRZX05PREU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzbWFsbGVzdCA9IG4ucmlnaHQubWluXygpO1xyXG4gICAgICAgICAgICAgICAgICAgIG4gPSBuLmNvcHkoc21hbGxlc3Qua2V5LCBzbWFsbGVzdC52YWx1ZSwgbnVsbCwgbnVsbCwgbi5yaWdodC5yZW1vdmVNaW5fKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbi5yaWdodC5yZW1vdmUoa2V5LCBjb21wYXJhdG9yKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuLmZpeFVwXygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoaXMgaXMgYSBSRUQgbm9kZS5cclxuICAgICAqL1xyXG4gICAgaXNSZWRfKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbG9yO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBOZXcgdHJlZSBhZnRlciBwZXJmb3JtaW5nIGFueSBuZWVkZWQgcm90YXRpb25zLlxyXG4gICAgICovXHJcbiAgICBmaXhVcF8oKSB7XHJcbiAgICAgICAgbGV0IG4gPSB0aGlzO1xyXG4gICAgICAgIGlmIChuLnJpZ2h0LmlzUmVkXygpICYmICFuLmxlZnQuaXNSZWRfKCkpIHtcclxuICAgICAgICAgICAgbiA9IG4ucm90YXRlTGVmdF8oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG4ubGVmdC5pc1JlZF8oKSAmJiBuLmxlZnQubGVmdC5pc1JlZF8oKSkge1xyXG4gICAgICAgICAgICBuID0gbi5yb3RhdGVSaWdodF8oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG4ubGVmdC5pc1JlZF8oKSAmJiBuLnJpZ2h0LmlzUmVkXygpKSB7XHJcbiAgICAgICAgICAgIG4gPSBuLmNvbG9yRmxpcF8oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG47XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIE5ldyB0cmVlLCBhZnRlciBtb3ZlUmVkTGVmdC5cclxuICAgICAqL1xyXG4gICAgbW92ZVJlZExlZnRfKCkge1xyXG4gICAgICAgIGxldCBuID0gdGhpcy5jb2xvckZsaXBfKCk7XHJcbiAgICAgICAgaWYgKG4ucmlnaHQubGVmdC5pc1JlZF8oKSkge1xyXG4gICAgICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG51bGwsIG4ucmlnaHQucm90YXRlUmlnaHRfKCkpO1xyXG4gICAgICAgICAgICBuID0gbi5yb3RhdGVMZWZ0XygpO1xyXG4gICAgICAgICAgICBuID0gbi5jb2xvckZsaXBfKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBOZXcgdHJlZSwgYWZ0ZXIgbW92ZVJlZFJpZ2h0LlxyXG4gICAgICovXHJcbiAgICBtb3ZlUmVkUmlnaHRfKCkge1xyXG4gICAgICAgIGxldCBuID0gdGhpcy5jb2xvckZsaXBfKCk7XHJcbiAgICAgICAgaWYgKG4ubGVmdC5sZWZ0LmlzUmVkXygpKSB7XHJcbiAgICAgICAgICAgIG4gPSBuLnJvdGF0ZVJpZ2h0XygpO1xyXG4gICAgICAgICAgICBuID0gbi5jb2xvckZsaXBfKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBOZXcgdHJlZSwgYWZ0ZXIgcm90YXRlTGVmdC5cclxuICAgICAqL1xyXG4gICAgcm90YXRlTGVmdF8oKSB7XHJcbiAgICAgICAgY29uc3QgbmwgPSB0aGlzLmNvcHkobnVsbCwgbnVsbCwgTExSQk5vZGUuUkVELCBudWxsLCB0aGlzLnJpZ2h0LmxlZnQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJpZ2h0LmNvcHkobnVsbCwgbnVsbCwgdGhpcy5jb2xvciwgbmwsIG51bGwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBOZXcgdHJlZSwgYWZ0ZXIgcm90YXRlUmlnaHQuXHJcbiAgICAgKi9cclxuICAgIHJvdGF0ZVJpZ2h0XygpIHtcclxuICAgICAgICBjb25zdCBuciA9IHRoaXMuY29weShudWxsLCBudWxsLCBMTFJCTm9kZS5SRUQsIHRoaXMubGVmdC5yaWdodCwgbnVsbCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5jb3B5KG51bGwsIG51bGwsIHRoaXMuY29sb3IsIG51bGwsIG5yKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgTmV3dCByZWUsIGFmdGVyIGNvbG9yRmxpcC5cclxuICAgICAqL1xyXG4gICAgY29sb3JGbGlwXygpIHtcclxuICAgICAgICBjb25zdCBsZWZ0ID0gdGhpcy5sZWZ0LmNvcHkobnVsbCwgbnVsbCwgIXRoaXMubGVmdC5jb2xvciwgbnVsbCwgbnVsbCk7XHJcbiAgICAgICAgY29uc3QgcmlnaHQgPSB0aGlzLnJpZ2h0LmNvcHkobnVsbCwgbnVsbCwgIXRoaXMucmlnaHQuY29sb3IsIG51bGwsIG51bGwpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvcHkobnVsbCwgbnVsbCwgIXRoaXMuY29sb3IsIGxlZnQsIHJpZ2h0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRm9yIHRlc3RpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiBhbGwgaXMgd2VsbC5cclxuICAgICAqL1xyXG4gICAgY2hlY2tNYXhEZXB0aF8oKSB7XHJcbiAgICAgICAgY29uc3QgYmxhY2tEZXB0aCA9IHRoaXMuY2hlY2tfKCk7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KDIuMCwgYmxhY2tEZXB0aCkgPD0gdGhpcy5jb3VudCgpICsgMTtcclxuICAgIH1cclxuICAgIGNoZWNrXygpIHtcclxuICAgICAgICBpZiAodGhpcy5pc1JlZF8oKSAmJiB0aGlzLmxlZnQuaXNSZWRfKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWQgbm9kZSBoYXMgcmVkIGNoaWxkKCcgKyB0aGlzLmtleSArICcsJyArIHRoaXMudmFsdWUgKyAnKScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5yaWdodC5pc1JlZF8oKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JpZ2h0IGNoaWxkIG9mICgnICsgdGhpcy5rZXkgKyAnLCcgKyB0aGlzLnZhbHVlICsgJykgaXMgcmVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGJsYWNrRGVwdGggPSB0aGlzLmxlZnQuY2hlY2tfKCk7XHJcbiAgICAgICAgaWYgKGJsYWNrRGVwdGggIT09IHRoaXMucmlnaHQuY2hlY2tfKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCbGFjayBkZXB0aHMgZGlmZmVyJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gYmxhY2tEZXB0aCArICh0aGlzLmlzUmVkXygpID8gMCA6IDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5MTFJCTm9kZS5SRUQgPSB0cnVlO1xyXG5MTFJCTm9kZS5CTEFDSyA9IGZhbHNlO1xyXG4vKipcclxuICogUmVwcmVzZW50cyBhbiBlbXB0eSBub2RlIChhIGxlYWYgbm9kZSBpbiB0aGUgUmVkLUJsYWNrIFRyZWUpLlxyXG4gKi9cclxuY2xhc3MgTExSQkVtcHR5Tm9kZSB7XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IG5vZGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIG5vZGUgY29weS5cclxuICAgICAqL1xyXG4gICAgY29weShrZXksIHZhbHVlLCBjb2xvciwgbGVmdCwgcmlnaHQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIHRyZWUsIHdpdGggdGhlIHNwZWNpZmllZCBrZXkvdmFsdWUgYWRkZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtleSAtIEtleSB0byBiZSBhZGRlZC5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGJlIGFkZGVkLlxyXG4gICAgICogQHBhcmFtIGNvbXBhcmF0b3IgLSBDb21wYXJhdG9yLlxyXG4gICAgICogQHJldHVybnMgTmV3IHRyZWUsIHdpdGggaXRlbSBhZGRlZC5cclxuICAgICAqL1xyXG4gICAgaW5zZXJ0KGtleSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcclxuICAgICAgICByZXR1cm4gbmV3IExMUkJOb2RlKGtleSwgdmFsdWUsIG51bGwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgdHJlZSwgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSByZW1vdmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHRvIHJlbW92ZS5cclxuICAgICAqIEBwYXJhbSBjb21wYXJhdG9yIC0gQ29tcGFyYXRvci5cclxuICAgICAqIEByZXR1cm5zIE5ldyB0cmVlLCB3aXRoIGl0ZW0gcmVtb3ZlZC5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlKGtleSwgY29tcGFyYXRvcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdG90YWwgbnVtYmVyIG9mIG5vZGVzIGluIHRoZSB0cmVlLlxyXG4gICAgICovXHJcbiAgICBjb3VudCgpIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdHJlZSBpcyBlbXB0eS5cclxuICAgICAqL1xyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJhdmVyc2VzIHRoZSB0cmVlIGluIGtleSBvcmRlciBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb24gZnVuY3Rpb25cclxuICAgICAqIGZvciBlYWNoIG5vZGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFjdGlvbiAtIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBmb3IgZWFjaFxyXG4gICAgICogbm9kZS4gIElmIGl0IHJldHVybnMgdHJ1ZSwgdHJhdmVyc2FsIGlzIGFib3J0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRyYXZlcnNhbCB3YXMgYWJvcnRlZC5cclxuICAgICAqL1xyXG4gICAgaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyYXZlcnNlcyB0aGUgdHJlZSBpbiByZXZlcnNlIGtleSBvcmRlciBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb24gZnVuY3Rpb25cclxuICAgICAqIGZvciBlYWNoIG5vZGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFjdGlvbiAtIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBmb3IgZWFjaFxyXG4gICAgICogbm9kZS4gIElmIGl0IHJldHVybnMgdHJ1ZSwgdHJhdmVyc2FsIGlzIGFib3J0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRyYXZlcnNhbCB3YXMgYWJvcnRlZC5cclxuICAgICAqL1xyXG4gICAgcmV2ZXJzZVRyYXZlcnNhbChhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBtaW5LZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBtYXhLZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjaGVja18oKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhpcyBub2RlIGlzIHJlZC5cclxuICAgICAqL1xyXG4gICAgaXNSZWRfKCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQW4gaW1tdXRhYmxlIHNvcnRlZCBtYXAgaW1wbGVtZW50YXRpb24sIGJhc2VkIG9uIGEgTGVmdC1sZWFuaW5nIFJlZC1CbGFja1xyXG4gKiB0cmVlLlxyXG4gKi9cclxuY2xhc3MgU29ydGVkTWFwIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGNvbXBhcmF0b3JfIC0gS2V5IGNvbXBhcmF0b3IuXHJcbiAgICAgKiBAcGFyYW0gcm9vdF8gLSBPcHRpb25hbCByb290IG5vZGUgZm9yIHRoZSBtYXAuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvbXBhcmF0b3JfLCByb290XyA9IFNvcnRlZE1hcC5FTVBUWV9OT0RFKSB7XHJcbiAgICAgICAgdGhpcy5jb21wYXJhdG9yXyA9IGNvbXBhcmF0b3JfO1xyXG4gICAgICAgIHRoaXMucm9vdF8gPSByb290XztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIG1hcCwgd2l0aCB0aGUgc3BlY2lmaWVkIGtleS92YWx1ZSBhZGRlZCBvciByZXBsYWNlZC5cclxuICAgICAqIChUT0RPOiBXZSBzaG91bGQgcGVyaGFwcyByZW5hbWUgdGhpcyBtZXRob2QgdG8gJ3B1dCcpXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtleSAtIEtleSB0byBiZSBhZGRlZC5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGJlIGFkZGVkLlxyXG4gICAgICogQHJldHVybnMgTmV3IG1hcCwgd2l0aCBpdGVtIGFkZGVkLlxyXG4gICAgICovXHJcbiAgICBpbnNlcnQoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgU29ydGVkTWFwKHRoaXMuY29tcGFyYXRvcl8sIHRoaXMucm9vdF9cclxuICAgICAgICAgICAgLmluc2VydChrZXksIHZhbHVlLCB0aGlzLmNvbXBhcmF0b3JfKVxyXG4gICAgICAgICAgICAuY29weShudWxsLCBudWxsLCBMTFJCTm9kZS5CTEFDSywgbnVsbCwgbnVsbCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgbWFwLCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5IHJlbW92ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgdG8gcmVtb3ZlLlxyXG4gICAgICogQHJldHVybnMgTmV3IG1hcCwgd2l0aCBpdGVtIHJlbW92ZWQuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZShrZXkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcCh0aGlzLmNvbXBhcmF0b3JfLCB0aGlzLnJvb3RfXHJcbiAgICAgICAgICAgIC5yZW1vdmUoa2V5LCB0aGlzLmNvbXBhcmF0b3JfKVxyXG4gICAgICAgICAgICAuY29weShudWxsLCBudWxsLCBMTFJCTm9kZS5CTEFDSywgbnVsbCwgbnVsbCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgbm9kZSB3aXRoIHRoZSBnaXZlbiBrZXksIG9yIG51bGwuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgdG8gbG9vayB1cC5cclxuICAgICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBvZiB0aGUgbm9kZSB3aXRoIHRoZSBnaXZlbiBrZXksIG9yIG51bGwgaWYgdGhlXHJcbiAgICAgKiBrZXkgZG9lc24ndCBleGlzdC5cclxuICAgICAqL1xyXG4gICAgZ2V0KGtleSkge1xyXG4gICAgICAgIGxldCBjbXA7XHJcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLnJvb3RfO1xyXG4gICAgICAgIHdoaWxlICghbm9kZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgY21wID0gdGhpcy5jb21wYXJhdG9yXyhrZXksIG5vZGUua2V5KTtcclxuICAgICAgICAgICAgaWYgKGNtcCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21wIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUga2V5IG9mIHRoZSBpdGVtICpiZWZvcmUqIHRoZSBzcGVjaWZpZWQga2V5LCBvciBudWxsIGlmIGtleSBpcyB0aGUgZmlyc3QgaXRlbS5cclxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHRvIGZpbmQgdGhlIHByZWRlY2Vzc29yIG9mXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgcHJlZGVjZXNzb3Iga2V5LlxyXG4gICAgICovXHJcbiAgICBnZXRQcmVkZWNlc3NvcktleShrZXkpIHtcclxuICAgICAgICBsZXQgY21wLCBub2RlID0gdGhpcy5yb290XywgcmlnaHRQYXJlbnQgPSBudWxsO1xyXG4gICAgICAgIHdoaWxlICghbm9kZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgY21wID0gdGhpcy5jb21wYXJhdG9yXyhrZXksIG5vZGUua2V5KTtcclxuICAgICAgICAgICAgaWYgKGNtcCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFub2RlLmxlZnQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIW5vZGUucmlnaHQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5rZXk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyaWdodFBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByaWdodFBhcmVudC5rZXk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gZmlyc3QgaXRlbS5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHJpZ2h0UGFyZW50ID0gbm9kZTtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIGZpbmQgcHJlZGVjZXNzb3Iga2V5IGZvciBhIG5vbmV4aXN0ZW50IGtleS4gIFdoYXQgZ2l2ZXM/Jyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG1hcCBpcyBlbXB0eS5cclxuICAgICAqL1xyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb290Xy5pc0VtcHR5KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRoZSB0b3RhbCBudW1iZXIgb2Ygbm9kZXMgaW4gdGhlIG1hcC5cclxuICAgICAqL1xyXG4gICAgY291bnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdF8uY291bnQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIG1pbmltdW0ga2V5IGluIHRoZSBtYXAuXHJcbiAgICAgKi9cclxuICAgIG1pbktleSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb290Xy5taW5LZXkoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIG1heGltdW0ga2V5IGluIHRoZSBtYXAuXHJcbiAgICAgKi9cclxuICAgIG1heEtleSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb290Xy5tYXhLZXkoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJhdmVyc2VzIHRoZSBtYXAgaW4ga2V5IG9yZGVyIGFuZCBjYWxscyB0aGUgc3BlY2lmaWVkIGFjdGlvbiBmdW5jdGlvblxyXG4gICAgICogZm9yIGVhY2gga2V5L3ZhbHVlIHBhaXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFjdGlvbiAtIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxyXG4gICAgICogZm9yIGVhY2gga2V5L3ZhbHVlIHBhaXIuICBJZiBhY3Rpb24gcmV0dXJucyB0cnVlLCB0cmF2ZXJzYWwgaXMgYWJvcnRlZC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBmaXJzdCB0cnV0aHkgdmFsdWUgcmV0dXJuZWQgYnkgYWN0aW9uLCBvciB0aGUgbGFzdCBmYWxzZXlcclxuICAgICAqICAgdmFsdWUgcmV0dXJuZWQgYnkgYWN0aW9uXHJcbiAgICAgKi9cclxuICAgIGlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdF8uaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmF2ZXJzZXMgdGhlIG1hcCBpbiByZXZlcnNlIGtleSBvcmRlciBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb24gZnVuY3Rpb25cclxuICAgICAqIGZvciBlYWNoIGtleS92YWx1ZSBwYWlyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhY3Rpb24gLSBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWRcclxuICAgICAqIGZvciBlYWNoIGtleS92YWx1ZSBwYWlyLiAgSWYgYWN0aW9uIHJldHVybnMgdHJ1ZSwgdHJhdmVyc2FsIGlzIGFib3J0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB0cmF2ZXJzYWwgd2FzIGFib3J0ZWQuXHJcbiAgICAgKi9cclxuICAgIHJldmVyc2VUcmF2ZXJzYWwoYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdF8ucmV2ZXJzZVRyYXZlcnNhbChhY3Rpb24pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIGl0ZXJhdG9yIG92ZXIgdGhlIFNvcnRlZE1hcC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBpdGVyYXRvci5cclxuICAgICAqL1xyXG4gICAgZ2V0SXRlcmF0b3IocmVzdWx0R2VuZXJhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXBJdGVyYXRvcih0aGlzLnJvb3RfLCBudWxsLCB0aGlzLmNvbXBhcmF0b3JfLCBmYWxzZSwgcmVzdWx0R2VuZXJhdG9yKTtcclxuICAgIH1cclxuICAgIGdldEl0ZXJhdG9yRnJvbShrZXksIHJlc3VsdEdlbmVyYXRvcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgU29ydGVkTWFwSXRlcmF0b3IodGhpcy5yb290Xywga2V5LCB0aGlzLmNvbXBhcmF0b3JfLCBmYWxzZSwgcmVzdWx0R2VuZXJhdG9yKTtcclxuICAgIH1cclxuICAgIGdldFJldmVyc2VJdGVyYXRvckZyb20oa2V5LCByZXN1bHRHZW5lcmF0b3IpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcEl0ZXJhdG9yKHRoaXMucm9vdF8sIGtleSwgdGhpcy5jb21wYXJhdG9yXywgdHJ1ZSwgcmVzdWx0R2VuZXJhdG9yKTtcclxuICAgIH1cclxuICAgIGdldFJldmVyc2VJdGVyYXRvcihyZXN1bHRHZW5lcmF0b3IpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcEl0ZXJhdG9yKHRoaXMucm9vdF8sIG51bGwsIHRoaXMuY29tcGFyYXRvcl8sIHRydWUsIHJlc3VsdEdlbmVyYXRvcik7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFsd2F5cyB1c2UgdGhlIHNhbWUgZW1wdHkgbm9kZSwgdG8gcmVkdWNlIG1lbW9yeS5cclxuICovXHJcblNvcnRlZE1hcC5FTVBUWV9OT0RFID0gbmV3IExMUkJFbXB0eU5vZGUoKTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gTkFNRV9PTkxZX0NPTVBBUkFUT1IobGVmdCwgcmlnaHQpIHtcclxuICAgIHJldHVybiBuYW1lQ29tcGFyZShsZWZ0Lm5hbWUsIHJpZ2h0Lm5hbWUpO1xyXG59XHJcbmZ1bmN0aW9uIE5BTUVfQ09NUEFSQVRPUihsZWZ0LCByaWdodCkge1xyXG4gICAgcmV0dXJuIG5hbWVDb21wYXJlKGxlZnQsIHJpZ2h0KTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5sZXQgTUFYX05PREUkMjtcclxuZnVuY3Rpb24gc2V0TWF4Tm9kZSQxKHZhbCkge1xyXG4gICAgTUFYX05PREUkMiA9IHZhbDtcclxufVxyXG5jb25zdCBwcmlvcml0eUhhc2hUZXh0ID0gZnVuY3Rpb24gKHByaW9yaXR5KSB7XHJcbiAgICBpZiAodHlwZW9mIHByaW9yaXR5ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHJldHVybiAnbnVtYmVyOicgKyBkb3VibGVUb0lFRUU3NTRTdHJpbmcocHJpb3JpdHkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuICdzdHJpbmc6JyArIHByaW9yaXR5O1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogVmFsaWRhdGVzIHRoYXQgYSBwcmlvcml0eSBzbmFwc2hvdCBOb2RlIGlzIHZhbGlkLlxyXG4gKi9cclxuY29uc3QgdmFsaWRhdGVQcmlvcml0eU5vZGUgPSBmdW5jdGlvbiAocHJpb3JpdHlOb2RlKSB7XHJcbiAgICBpZiAocHJpb3JpdHlOb2RlLmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgIGNvbnN0IHZhbCA9IHByaW9yaXR5Tm9kZS52YWwoKTtcclxuICAgICAgICBhc3NlcnQodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHxcclxuICAgICAgICAgICAgdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgfHxcclxuICAgICAgICAgICAgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIGNvbnRhaW5zKHZhbCwgJy5zdicpKSwgJ1ByaW9yaXR5IG11c3QgYmUgYSBzdHJpbmcgb3IgbnVtYmVyLicpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYXNzZXJ0KHByaW9yaXR5Tm9kZSA9PT0gTUFYX05PREUkMiB8fCBwcmlvcml0eU5vZGUuaXNFbXB0eSgpLCAncHJpb3JpdHkgb2YgdW5leHBlY3RlZCB0eXBlLicpO1xyXG4gICAgfVxyXG4gICAgLy8gRG9uJ3QgY2FsbCBnZXRQcmlvcml0eSgpIG9uIE1BWF9OT0RFIHRvIGF2b2lkIGhpdHRpbmcgYXNzZXJ0aW9uLlxyXG4gICAgYXNzZXJ0KHByaW9yaXR5Tm9kZSA9PT0gTUFYX05PREUkMiB8fCBwcmlvcml0eU5vZGUuZ2V0UHJpb3JpdHkoKS5pc0VtcHR5KCksIFwiUHJpb3JpdHkgbm9kZXMgY2FuJ3QgaGF2ZSBhIHByaW9yaXR5IG9mIHRoZWlyIG93bi5cIik7XHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmxldCBfX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yO1xyXG4vKipcclxuICogTGVhZk5vZGUgaXMgYSBjbGFzcyBmb3Igc3RvcmluZyBsZWFmIG5vZGVzIGluIGEgRGF0YVNuYXBzaG90LiAgSXRcclxuICogaW1wbGVtZW50cyBOb2RlIGFuZCBzdG9yZXMgdGhlIHZhbHVlIG9mIHRoZSBub2RlIChhIHN0cmluZyxcclxuICogbnVtYmVyLCBvciBib29sZWFuKSBhY2Nlc3NpYmxlIHZpYSBnZXRWYWx1ZSgpLlxyXG4gKi9cclxuY2xhc3MgTGVhZk5vZGUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVfIC0gVGhlIHZhbHVlIHRvIHN0b3JlIGluIHRoaXMgbGVhZiBub2RlLiBUaGUgb2JqZWN0IHR5cGUgaXNcclxuICAgICAqIHBvc3NpYmxlIGluIHRoZSBldmVudCBvZiBhIGRlZmVycmVkIHZhbHVlXHJcbiAgICAgKiBAcGFyYW0gcHJpb3JpdHlOb2RlXyAtIFRoZSBwcmlvcml0eSBvZiB0aGlzIG5vZGUuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHZhbHVlXywgcHJpb3JpdHlOb2RlXyA9IExlYWZOb2RlLl9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3IuRU1QVFlfTk9ERSkge1xyXG4gICAgICAgIHRoaXMudmFsdWVfID0gdmFsdWVfO1xyXG4gICAgICAgIHRoaXMucHJpb3JpdHlOb2RlXyA9IHByaW9yaXR5Tm9kZV87XHJcbiAgICAgICAgdGhpcy5sYXp5SGFzaF8gPSBudWxsO1xyXG4gICAgICAgIGFzc2VydCh0aGlzLnZhbHVlXyAhPT0gdW5kZWZpbmVkICYmIHRoaXMudmFsdWVfICE9PSBudWxsLCBcIkxlYWZOb2RlIHNob3VsZG4ndCBiZSBjcmVhdGVkIHdpdGggbnVsbC91bmRlZmluZWQgdmFsdWUuXCIpO1xyXG4gICAgICAgIHZhbGlkYXRlUHJpb3JpdHlOb2RlKHRoaXMucHJpb3JpdHlOb2RlXyk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgc2V0IF9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3IodmFsKSB7XHJcbiAgICAgICAgX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3RvciA9IHZhbDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXQgX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICByZXR1cm4gX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3RvcjtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgaXNMZWFmTm9kZSgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgZ2V0UHJpb3JpdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpb3JpdHlOb2RlXztcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgdXBkYXRlUHJpb3JpdHkobmV3UHJpb3JpdHlOb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMZWFmTm9kZSh0aGlzLnZhbHVlXywgbmV3UHJpb3JpdHlOb2RlKTtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lKSB7XHJcbiAgICAgICAgLy8gSGFjayB0byB0cmVhdCBwcmlvcml0eSBhcyBhIHJlZ3VsYXIgY2hpbGRcclxuICAgICAgICBpZiAoY2hpbGROYW1lID09PSAnLnByaW9yaXR5Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmlvcml0eU5vZGVfO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIExlYWZOb2RlLl9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3IuRU1QVFlfTk9ERTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGdldENoaWxkKHBhdGgpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkocGF0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBhdGhHZXRGcm9udChwYXRoKSA9PT0gJy5wcmlvcml0eScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJpb3JpdHlOb2RlXztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBMZWFmTm9kZS5fX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yLkVNUFRZX05PREU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaGFzQ2hpbGQoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBnZXRQcmVkZWNlc3NvckNoaWxkTmFtZShjaGlsZE5hbWUsIGNoaWxkTm9kZSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICB1cGRhdGVJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUsIG5ld0NoaWxkTm9kZSkge1xyXG4gICAgICAgIGlmIChjaGlsZE5hbWUgPT09ICcucHJpb3JpdHknKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZVByaW9yaXR5KG5ld0NoaWxkTm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG5ld0NoaWxkTm9kZS5pc0VtcHR5KCkgJiYgY2hpbGROYW1lICE9PSAnLnByaW9yaXR5Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBMZWFmTm9kZS5fX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yLkVNUFRZX05PREUudXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lLCBuZXdDaGlsZE5vZGUpLnVwZGF0ZVByaW9yaXR5KHRoaXMucHJpb3JpdHlOb2RlXyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICB1cGRhdGVDaGlsZChwYXRoLCBuZXdDaGlsZE5vZGUpIHtcclxuICAgICAgICBjb25zdCBmcm9udCA9IHBhdGhHZXRGcm9udChwYXRoKTtcclxuICAgICAgICBpZiAoZnJvbnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld0NoaWxkTm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobmV3Q2hpbGROb2RlLmlzRW1wdHkoKSAmJiBmcm9udCAhPT0gJy5wcmlvcml0eScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhc3NlcnQoZnJvbnQgIT09ICcucHJpb3JpdHknIHx8IHBhdGhHZXRMZW5ndGgocGF0aCkgPT09IDEsICcucHJpb3JpdHkgbXVzdCBiZSB0aGUgbGFzdCB0b2tlbiBpbiBhIHBhdGgnKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlSW1tZWRpYXRlQ2hpbGQoZnJvbnQsIExlYWZOb2RlLl9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3IuRU1QVFlfTk9ERS51cGRhdGVDaGlsZChwYXRoUG9wRnJvbnQocGF0aCksIG5ld0NoaWxkTm9kZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIG51bUNoaWxkcmVuKCkge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBmb3JFYWNoQ2hpbGQoaW5kZXgsIGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHZhbChleHBvcnRGb3JtYXQpIHtcclxuICAgICAgICBpZiAoZXhwb3J0Rm9ybWF0ICYmICF0aGlzLmdldFByaW9yaXR5KCkuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAnLnZhbHVlJzogdGhpcy5nZXRWYWx1ZSgpLFxyXG4gICAgICAgICAgICAgICAgJy5wcmlvcml0eSc6IHRoaXMuZ2V0UHJpb3JpdHkoKS52YWwoKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGhhc2goKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGF6eUhhc2hfID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGxldCB0b0hhc2ggPSAnJztcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnByaW9yaXR5Tm9kZV8uaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0b0hhc2ggKz1cclxuICAgICAgICAgICAgICAgICAgICAncHJpb3JpdHk6JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5SGFzaFRleHQodGhpcy5wcmlvcml0eU5vZGVfLnZhbCgpKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc6JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB0eXBlID0gdHlwZW9mIHRoaXMudmFsdWVfO1xyXG4gICAgICAgICAgICB0b0hhc2ggKz0gdHlwZSArICc6JztcclxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICB0b0hhc2ggKz0gZG91YmxlVG9JRUVFNzU0U3RyaW5nKHRoaXMudmFsdWVfKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRvSGFzaCArPSB0aGlzLnZhbHVlXztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmxhenlIYXNoXyA9IHNoYTEodG9IYXNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGF6eUhhc2hfO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgbGVhZiBub2RlLlxyXG4gICAgICogQHJldHVybnMgVGhlIHZhbHVlIG9mIHRoZSBub2RlLlxyXG4gICAgICovXHJcbiAgICBnZXRWYWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZV87XHJcbiAgICB9XHJcbiAgICBjb21wYXJlVG8ob3RoZXIpIHtcclxuICAgICAgICBpZiAob3RoZXIgPT09IExlYWZOb2RlLl9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3IuRU1QVFlfTk9ERSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3RoZXIgaW5zdGFuY2VvZiBMZWFmTm9kZS5fX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFzc2VydChvdGhlci5pc0xlYWZOb2RlKCksICdVbmtub3duIG5vZGUgdHlwZScpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlVG9MZWFmTm9kZV8ob3RoZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29tcGFyaXNvbiBzcGVjaWZpY2FsbHkgZm9yIHR3byBsZWFmIG5vZGVzXHJcbiAgICAgKi9cclxuICAgIGNvbXBhcmVUb0xlYWZOb2RlXyhvdGhlckxlYWYpIHtcclxuICAgICAgICBjb25zdCBvdGhlckxlYWZUeXBlID0gdHlwZW9mIG90aGVyTGVhZi52YWx1ZV87XHJcbiAgICAgICAgY29uc3QgdGhpc0xlYWZUeXBlID0gdHlwZW9mIHRoaXMudmFsdWVfO1xyXG4gICAgICAgIGNvbnN0IG90aGVySW5kZXggPSBMZWFmTm9kZS5WQUxVRV9UWVBFX09SREVSLmluZGV4T2Yob3RoZXJMZWFmVHlwZSk7XHJcbiAgICAgICAgY29uc3QgdGhpc0luZGV4ID0gTGVhZk5vZGUuVkFMVUVfVFlQRV9PUkRFUi5pbmRleE9mKHRoaXNMZWFmVHlwZSk7XHJcbiAgICAgICAgYXNzZXJ0KG90aGVySW5kZXggPj0gMCwgJ1Vua25vd24gbGVhZiB0eXBlOiAnICsgb3RoZXJMZWFmVHlwZSk7XHJcbiAgICAgICAgYXNzZXJ0KHRoaXNJbmRleCA+PSAwLCAnVW5rbm93biBsZWFmIHR5cGU6ICcgKyB0aGlzTGVhZlR5cGUpO1xyXG4gICAgICAgIGlmIChvdGhlckluZGV4ID09PSB0aGlzSW5kZXgpIHtcclxuICAgICAgICAgICAgLy8gU2FtZSB0eXBlLCBjb21wYXJlIHZhbHVlc1xyXG4gICAgICAgICAgICBpZiAodGhpc0xlYWZUeXBlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgLy8gRGVmZXJyZWQgdmFsdWUgbm9kZXMgYXJlIGFsbCBlcXVhbCwgYnV0IHdlIHNob3VsZCBhbHNvIG5ldmVyIGdldCB0byB0aGlzIHBvaW50Li4uXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIHdvcmtzIGJlY2F1c2UgdHJ1ZSA+IGZhbHNlLCBhbGwgb3RoZXJzIGFyZSBudW1iZXIgb3Igc3RyaW5nIGNvbXBhcmlzb25zXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZV8gPCBvdGhlckxlYWYudmFsdWVfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy52YWx1ZV8gPT09IG90aGVyTGVhZi52YWx1ZV8pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc0luZGV4IC0gb3RoZXJJbmRleDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB3aXRoSW5kZXgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBpc0luZGV4ZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBlcXVhbHMob3RoZXIpIHtcclxuICAgICAgICBpZiAob3RoZXIgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG90aGVyLmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBvdGhlckxlYWYgPSBvdGhlcjtcclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnZhbHVlXyA9PT0gb3RoZXJMZWFmLnZhbHVlXyAmJlxyXG4gICAgICAgICAgICAgICAgdGhpcy5wcmlvcml0eU5vZGVfLmVxdWFscyhvdGhlckxlYWYucHJpb3JpdHlOb2RlXykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlIHNvcnQgb3JkZXIgZm9yIGNvbXBhcmluZyBsZWFmIG5vZGVzIG9mIGRpZmZlcmVudCB0eXBlcy4gSWYgdHdvIGxlYWYgbm9kZXMgaGF2ZVxyXG4gKiB0aGUgc2FtZSB0eXBlLCB0aGUgY29tcGFyaXNvbiBmYWxscyBiYWNrIHRvIHRoZWlyIHZhbHVlXHJcbiAqL1xyXG5MZWFmTm9kZS5WQUxVRV9UWVBFX09SREVSID0gWydvYmplY3QnLCAnYm9vbGVhbicsICdudW1iZXInLCAnc3RyaW5nJ107XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmxldCBub2RlRnJvbUpTT04kMTtcclxubGV0IE1BWF9OT0RFJDE7XHJcbmZ1bmN0aW9uIHNldE5vZGVGcm9tSlNPTih2YWwpIHtcclxuICAgIG5vZGVGcm9tSlNPTiQxID0gdmFsO1xyXG59XHJcbmZ1bmN0aW9uIHNldE1heE5vZGUodmFsKSB7XHJcbiAgICBNQVhfTk9ERSQxID0gdmFsO1xyXG59XHJcbmNsYXNzIFByaW9yaXR5SW5kZXggZXh0ZW5kcyBJbmRleCB7XHJcbiAgICBjb21wYXJlKGEsIGIpIHtcclxuICAgICAgICBjb25zdCBhUHJpb3JpdHkgPSBhLm5vZGUuZ2V0UHJpb3JpdHkoKTtcclxuICAgICAgICBjb25zdCBiUHJpb3JpdHkgPSBiLm5vZGUuZ2V0UHJpb3JpdHkoKTtcclxuICAgICAgICBjb25zdCBpbmRleENtcCA9IGFQcmlvcml0eS5jb21wYXJlVG8oYlByaW9yaXR5KTtcclxuICAgICAgICBpZiAoaW5kZXhDbXAgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5hbWVDb21wYXJlKGEubmFtZSwgYi5uYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbmRleENtcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpc0RlZmluZWRPbihub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuICFub2RlLmdldFByaW9yaXR5KCkuaXNFbXB0eSgpO1xyXG4gICAgfVxyXG4gICAgaW5kZXhlZFZhbHVlQ2hhbmdlZChvbGROb2RlLCBuZXdOb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuICFvbGROb2RlLmdldFByaW9yaXR5KCkuZXF1YWxzKG5ld05vZGUuZ2V0UHJpb3JpdHkoKSk7XHJcbiAgICB9XHJcbiAgICBtaW5Qb3N0KCkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgcmV0dXJuIE5hbWVkTm9kZS5NSU47XHJcbiAgICB9XHJcbiAgICBtYXhQb3N0KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTmFtZWROb2RlKE1BWF9OQU1FLCBuZXcgTGVhZk5vZGUoJ1tQUklPUklUWS1QT1NUXScsIE1BWF9OT0RFJDEpKTtcclxuICAgIH1cclxuICAgIG1ha2VQb3N0KGluZGV4VmFsdWUsIG5hbWUpIHtcclxuICAgICAgICBjb25zdCBwcmlvcml0eU5vZGUgPSBub2RlRnJvbUpTT04kMShpbmRleFZhbHVlKTtcclxuICAgICAgICByZXR1cm4gbmV3IE5hbWVkTm9kZShuYW1lLCBuZXcgTGVhZk5vZGUoJ1tQUklPUklUWS1QT1NUXScsIHByaW9yaXR5Tm9kZSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBTdHJpbmcgcmVwcmVzZW50YXRpb24gZm9yIGluY2x1c2lvbiBpbiBhIHF1ZXJ5IHNwZWNcclxuICAgICAqL1xyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuICcucHJpb3JpdHknO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IFBSSU9SSVRZX0lOREVYID0gbmV3IFByaW9yaXR5SW5kZXgoKTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgTE9HXzIgPSBNYXRoLmxvZygyKTtcclxuY2xhc3MgQmFzZTEyTnVtIHtcclxuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IGxvZ0Jhc2UyID0gKG51bSkgPT4gXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICBwYXJzZUludCgoTWF0aC5sb2cobnVtKSAvIExPR18yKSwgMTApO1xyXG4gICAgICAgIGNvbnN0IGJpdE1hc2sgPSAoYml0cykgPT4gcGFyc2VJbnQoQXJyYXkoYml0cyArIDEpLmpvaW4oJzEnKSwgMik7XHJcbiAgICAgICAgdGhpcy5jb3VudCA9IGxvZ0Jhc2UyKGxlbmd0aCArIDEpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudF8gPSB0aGlzLmNvdW50IC0gMTtcclxuICAgICAgICBjb25zdCBtYXNrID0gYml0TWFzayh0aGlzLmNvdW50KTtcclxuICAgICAgICB0aGlzLmJpdHNfID0gKGxlbmd0aCArIDEpICYgbWFzaztcclxuICAgIH1cclxuICAgIG5leHRCaXRJc09uZSgpIHtcclxuICAgICAgICAvL25vaW5zcGVjdGlvbiBKU0JpdHdpc2VPcGVyYXRvclVzYWdlXHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gISh0aGlzLmJpdHNfICYgKDB4MSA8PCB0aGlzLmN1cnJlbnRfKSk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50Xy0tO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRha2VzIGEgbGlzdCBvZiBjaGlsZCBub2RlcyBhbmQgY29uc3RydWN0cyBhIFNvcnRlZFNldCB1c2luZyB0aGUgZ2l2ZW4gY29tcGFyaXNvblxyXG4gKiBmdW5jdGlvblxyXG4gKlxyXG4gKiBVc2VzIHRoZSBhbGdvcml0aG0gZGVzY3JpYmVkIGluIHRoZSBwYXBlciBsaW5rZWQgaGVyZTpcclxuICogaHR0cDovL2NpdGVzZWVyeC5pc3QucHN1LmVkdS92aWV3ZG9jL3N1bW1hcnk/ZG9pPTEwLjEuMS40Ni4xNDU4XHJcbiAqXHJcbiAqIEBwYXJhbSBjaGlsZExpc3QgLSBVbnNvcnRlZCBsaXN0IG9mIGNoaWxkcmVuXHJcbiAqIEBwYXJhbSBjbXAgLSBUaGUgY29tcGFyaXNvbiBtZXRob2QgdG8gYmUgdXNlZFxyXG4gKiBAcGFyYW0ga2V5Rm4gLSBBbiBvcHRpb25hbCBmdW5jdGlvbiB0byBleHRyYWN0IEsgZnJvbSBhIG5vZGUgd3JhcHBlciwgaWYgSydzXHJcbiAqIHR5cGUgaXMgbm90IE5hbWVkTm9kZVxyXG4gKiBAcGFyYW0gbWFwU29ydEZuIC0gQW4gb3B0aW9uYWwgb3ZlcnJpZGUgZm9yIGNvbXBhcmF0b3IgdXNlZCBieSB0aGUgZ2VuZXJhdGVkIHNvcnRlZCBtYXBcclxuICovXHJcbmNvbnN0IGJ1aWxkQ2hpbGRTZXQgPSBmdW5jdGlvbiAoY2hpbGRMaXN0LCBjbXAsIGtleUZuLCBtYXBTb3J0Rm4pIHtcclxuICAgIGNoaWxkTGlzdC5zb3J0KGNtcCk7XHJcbiAgICBjb25zdCBidWlsZEJhbGFuY2VkVHJlZSA9IGZ1bmN0aW9uIChsb3csIGhpZ2gpIHtcclxuICAgICAgICBjb25zdCBsZW5ndGggPSBoaWdoIC0gbG93O1xyXG4gICAgICAgIGxldCBuYW1lZE5vZGU7XHJcbiAgICAgICAgbGV0IGtleTtcclxuICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgbmFtZWROb2RlID0gY2hpbGRMaXN0W2xvd107XHJcbiAgICAgICAgICAgIGtleSA9IGtleUZuID8ga2V5Rm4obmFtZWROb2RlKSA6IG5hbWVkTm9kZTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMTFJCTm9kZShrZXksIG5hbWVkTm9kZS5ub2RlLCBMTFJCTm9kZS5CTEFDSywgbnVsbCwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICBjb25zdCBtaWRkbGUgPSBwYXJzZUludCgobGVuZ3RoIC8gMiksIDEwKSArIGxvdztcclxuICAgICAgICAgICAgY29uc3QgbGVmdCA9IGJ1aWxkQmFsYW5jZWRUcmVlKGxvdywgbWlkZGxlKTtcclxuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBidWlsZEJhbGFuY2VkVHJlZShtaWRkbGUgKyAxLCBoaWdoKTtcclxuICAgICAgICAgICAgbmFtZWROb2RlID0gY2hpbGRMaXN0W21pZGRsZV07XHJcbiAgICAgICAgICAgIGtleSA9IGtleUZuID8ga2V5Rm4obmFtZWROb2RlKSA6IG5hbWVkTm9kZTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMTFJCTm9kZShrZXksIG5hbWVkTm9kZS5ub2RlLCBMTFJCTm9kZS5CTEFDSywgbGVmdCwgcmlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBidWlsZEZyb20xMkFycmF5ID0gZnVuY3Rpb24gKGJhc2UxMikge1xyXG4gICAgICAgIGxldCBub2RlID0gbnVsbDtcclxuICAgICAgICBsZXQgcm9vdCA9IG51bGw7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gY2hpbGRMaXN0Lmxlbmd0aDtcclxuICAgICAgICBjb25zdCBidWlsZFBlbm5hbnQgPSBmdW5jdGlvbiAoY2h1bmtTaXplLCBjb2xvcikge1xyXG4gICAgICAgICAgICBjb25zdCBsb3cgPSBpbmRleCAtIGNodW5rU2l6ZTtcclxuICAgICAgICAgICAgY29uc3QgaGlnaCA9IGluZGV4O1xyXG4gICAgICAgICAgICBpbmRleCAtPSBjaHVua1NpemU7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkVHJlZSA9IGJ1aWxkQmFsYW5jZWRUcmVlKGxvdyArIDEsIGhpZ2gpO1xyXG4gICAgICAgICAgICBjb25zdCBuYW1lZE5vZGUgPSBjaGlsZExpc3RbbG93XTtcclxuICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5Rm4gPyBrZXlGbihuYW1lZE5vZGUpIDogbmFtZWROb2RlO1xyXG4gICAgICAgICAgICBhdHRhY2hQZW5uYW50KG5ldyBMTFJCTm9kZShrZXksIG5hbWVkTm9kZS5ub2RlLCBjb2xvciwgbnVsbCwgY2hpbGRUcmVlKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBhdHRhY2hQZW5uYW50ID0gZnVuY3Rpb24gKHBlbm5hbnQpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUubGVmdCA9IHBlbm5hbnQ7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gcGVubmFudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJvb3QgPSBwZW5uYW50O1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IHBlbm5hbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFzZTEyLmNvdW50OyArK2kpIHtcclxuICAgICAgICAgICAgY29uc3QgaXNPbmUgPSBiYXNlMTIubmV4dEJpdElzT25lKCk7XHJcbiAgICAgICAgICAgIC8vIFRoZSBudW1iZXIgb2Ygbm9kZXMgdGFrZW4gaW4gZWFjaCBzbGljZSBpcyAyXihhcnIubGVuZ3RoIC0gKGkgKyAxKSlcclxuICAgICAgICAgICAgY29uc3QgY2h1bmtTaXplID0gTWF0aC5wb3coMiwgYmFzZTEyLmNvdW50IC0gKGkgKyAxKSk7XHJcbiAgICAgICAgICAgIGlmIChpc09uZSkge1xyXG4gICAgICAgICAgICAgICAgYnVpbGRQZW5uYW50KGNodW5rU2l6ZSwgTExSQk5vZGUuQkxBQ0spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gY3VycmVudCA9PSAyXHJcbiAgICAgICAgICAgICAgICBidWlsZFBlbm5hbnQoY2h1bmtTaXplLCBMTFJCTm9kZS5CTEFDSyk7XHJcbiAgICAgICAgICAgICAgICBidWlsZFBlbm5hbnQoY2h1bmtTaXplLCBMTFJCTm9kZS5SRUQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByb290O1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGJhc2UxMiA9IG5ldyBCYXNlMTJOdW0oY2hpbGRMaXN0Lmxlbmd0aCk7XHJcbiAgICBjb25zdCByb290ID0gYnVpbGRGcm9tMTJBcnJheShiYXNlMTIpO1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgIHJldHVybiBuZXcgU29ydGVkTWFwKG1hcFNvcnRGbiB8fCBjbXAsIHJvb3QpO1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5sZXQgX2RlZmF1bHRJbmRleE1hcDtcclxuY29uc3QgZmFsbGJhY2tPYmplY3QgPSB7fTtcclxuY2xhc3MgSW5kZXhNYXAge1xyXG4gICAgY29uc3RydWN0b3IoaW5kZXhlc18sIGluZGV4U2V0Xykge1xyXG4gICAgICAgIHRoaXMuaW5kZXhlc18gPSBpbmRleGVzXztcclxuICAgICAgICB0aGlzLmluZGV4U2V0XyA9IGluZGV4U2V0XztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRlZmF1bHQgSW5kZXhNYXAgZm9yIG5vZGVzIHdpdGhvdXQgYSBwcmlvcml0eVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XHJcbiAgICAgICAgYXNzZXJ0KGZhbGxiYWNrT2JqZWN0ICYmIFBSSU9SSVRZX0lOREVYLCAnQ2hpbGRyZW5Ob2RlLnRzIGhhcyBub3QgYmVlbiBsb2FkZWQnKTtcclxuICAgICAgICBfZGVmYXVsdEluZGV4TWFwID1cclxuICAgICAgICAgICAgX2RlZmF1bHRJbmRleE1hcCB8fFxyXG4gICAgICAgICAgICAgICAgbmV3IEluZGV4TWFwKHsgJy5wcmlvcml0eSc6IGZhbGxiYWNrT2JqZWN0IH0sIHsgJy5wcmlvcml0eSc6IFBSSU9SSVRZX0lOREVYIH0pO1xyXG4gICAgICAgIHJldHVybiBfZGVmYXVsdEluZGV4TWFwO1xyXG4gICAgfVxyXG4gICAgZ2V0KGluZGV4S2V5KSB7XHJcbiAgICAgICAgY29uc3Qgc29ydGVkTWFwID0gc2FmZUdldCh0aGlzLmluZGV4ZXNfLCBpbmRleEtleSk7XHJcbiAgICAgICAgaWYgKCFzb3J0ZWRNYXApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBpbmRleCBkZWZpbmVkIGZvciAnICsgaW5kZXhLZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc29ydGVkTWFwIGluc3RhbmNlb2YgU29ydGVkTWFwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzb3J0ZWRNYXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBUaGUgaW5kZXggZXhpc3RzLCBidXQgaXQgZmFsbHMgYmFjayB0byBqdXN0IG5hbWUgY29tcGFyaXNvbi4gUmV0dXJuIG51bGwgc28gdGhhdCB0aGUgY2FsbGluZyBjb2RlIHVzZXMgdGhlXHJcbiAgICAgICAgICAgIC8vIHJlZ3VsYXIgY2hpbGQgbWFwXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGhhc0luZGV4KGluZGV4RGVmaW5pdGlvbikge1xyXG4gICAgICAgIHJldHVybiBjb250YWlucyh0aGlzLmluZGV4U2V0XywgaW5kZXhEZWZpbml0aW9uLnRvU3RyaW5nKCkpO1xyXG4gICAgfVxyXG4gICAgYWRkSW5kZXgoaW5kZXhEZWZpbml0aW9uLCBleGlzdGluZ0NoaWxkcmVuKSB7XHJcbiAgICAgICAgYXNzZXJ0KGluZGV4RGVmaW5pdGlvbiAhPT0gS0VZX0lOREVYLCBcIktleUluZGV4IGFsd2F5cyBleGlzdHMgYW5kIGlzbid0IG1lYW50IHRvIGJlIGFkZGVkIHRvIHRoZSBJbmRleE1hcC5cIik7XHJcbiAgICAgICAgY29uc3QgY2hpbGRMaXN0ID0gW107XHJcbiAgICAgICAgbGV0IHNhd0luZGV4ZWRWYWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IGl0ZXIgPSBleGlzdGluZ0NoaWxkcmVuLmdldEl0ZXJhdG9yKE5hbWVkTm9kZS5XcmFwKTtcclxuICAgICAgICBsZXQgbmV4dCA9IGl0ZXIuZ2V0TmV4dCgpO1xyXG4gICAgICAgIHdoaWxlIChuZXh0KSB7XHJcbiAgICAgICAgICAgIHNhd0luZGV4ZWRWYWx1ZSA9XHJcbiAgICAgICAgICAgICAgICBzYXdJbmRleGVkVmFsdWUgfHwgaW5kZXhEZWZpbml0aW9uLmlzRGVmaW5lZE9uKG5leHQubm9kZSk7XHJcbiAgICAgICAgICAgIGNoaWxkTGlzdC5wdXNoKG5leHQpO1xyXG4gICAgICAgICAgICBuZXh0ID0gaXRlci5nZXROZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBuZXdJbmRleDtcclxuICAgICAgICBpZiAoc2F3SW5kZXhlZFZhbHVlKSB7XHJcbiAgICAgICAgICAgIG5ld0luZGV4ID0gYnVpbGRDaGlsZFNldChjaGlsZExpc3QsIGluZGV4RGVmaW5pdGlvbi5nZXRDb21wYXJlKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbmV3SW5kZXggPSBmYWxsYmFja09iamVjdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaW5kZXhOYW1lID0gaW5kZXhEZWZpbml0aW9uLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgY29uc3QgbmV3SW5kZXhTZXQgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmluZGV4U2V0Xyk7XHJcbiAgICAgICAgbmV3SW5kZXhTZXRbaW5kZXhOYW1lXSA9IGluZGV4RGVmaW5pdGlvbjtcclxuICAgICAgICBjb25zdCBuZXdJbmRleGVzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5pbmRleGVzXyk7XHJcbiAgICAgICAgbmV3SW5kZXhlc1tpbmRleE5hbWVdID0gbmV3SW5kZXg7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleE1hcChuZXdJbmRleGVzLCBuZXdJbmRleFNldCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVuc3VyZSB0aGF0IHRoaXMgbm9kZSBpcyBwcm9wZXJseSB0cmFja2VkIGluIGFueSBpbmRleGVzIHRoYXQgd2UncmUgbWFpbnRhaW5pbmdcclxuICAgICAqL1xyXG4gICAgYWRkVG9JbmRleGVzKG5hbWVkTm9kZSwgZXhpc3RpbmdDaGlsZHJlbikge1xyXG4gICAgICAgIGNvbnN0IG5ld0luZGV4ZXMgPSBtYXAodGhpcy5pbmRleGVzXywgKGluZGV4ZWRDaGlsZHJlbiwgaW5kZXhOYW1lKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gc2FmZUdldCh0aGlzLmluZGV4U2V0XywgaW5kZXhOYW1lKTtcclxuICAgICAgICAgICAgYXNzZXJ0KGluZGV4LCAnTWlzc2luZyBpbmRleCBpbXBsZW1lbnRhdGlvbiBmb3IgJyArIGluZGV4TmFtZSk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleGVkQ2hpbGRyZW4gPT09IGZhbGxiYWNrT2JqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgd2UgbmVlZCB0byBpbmRleCBldmVyeXRoaW5nXHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXguaXNEZWZpbmVkT24obmFtZWROb2RlLm5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBidWlsZCB0aGlzIGluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGRMaXN0ID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlciA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0SXRlcmF0b3IoTmFtZWROb2RlLldyYXApO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gaXRlci5nZXROZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG5leHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQubmFtZSAhPT0gbmFtZWROb2RlLm5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTGlzdC5wdXNoKG5leHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBpdGVyLmdldE5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRMaXN0LnB1c2gobmFtZWROb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVpbGRDaGlsZFNldChjaGlsZExpc3QsIGluZGV4LmdldENvbXBhcmUoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBObyBjaGFuZ2UsIHRoaXMgcmVtYWlucyBhIGZhbGxiYWNrXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrT2JqZWN0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdTbmFwID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmFtZWROb2RlLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgbGV0IG5ld0NoaWxkcmVuID0gaW5kZXhlZENoaWxkcmVuO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nU25hcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuID0gbmV3Q2hpbGRyZW4ucmVtb3ZlKG5ldyBOYW1lZE5vZGUobmFtZWROb2RlLm5hbWUsIGV4aXN0aW5nU25hcCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0NoaWxkcmVuLmluc2VydChuYW1lZE5vZGUsIG5hbWVkTm9kZS5ub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhNYXAobmV3SW5kZXhlcywgdGhpcy5pbmRleFNldF8pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgSW5kZXhNYXAgaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gdmFsdWUgcmVtb3ZlZFxyXG4gICAgICovXHJcbiAgICByZW1vdmVGcm9tSW5kZXhlcyhuYW1lZE5vZGUsIGV4aXN0aW5nQ2hpbGRyZW4pIHtcclxuICAgICAgICBjb25zdCBuZXdJbmRleGVzID0gbWFwKHRoaXMuaW5kZXhlc18sIChpbmRleGVkQ2hpbGRyZW4pID0+IHtcclxuICAgICAgICAgICAgaWYgKGluZGV4ZWRDaGlsZHJlbiA9PT0gZmFsbGJhY2tPYmplY3QpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZhbGxiYWNrLiBKdXN0IHJldHVybiBpdCwgbm90aGluZyB0byBkbyBpbiB0aGlzIGNhc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleGVkQ2hpbGRyZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ1NuYXAgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuYW1lZE5vZGUubmFtZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdTbmFwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ZWRDaGlsZHJlbi5yZW1vdmUobmV3IE5hbWVkTm9kZShuYW1lZE5vZGUubmFtZSwgZXhpc3RpbmdTbmFwKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBObyByZWNvcmQgb2YgdGhpcyBjaGlsZFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleGVkQ2hpbGRyZW47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbmV3IEluZGV4TWFwKG5ld0luZGV4ZXMsIHRoaXMuaW5kZXhTZXRfKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vLyBUT0RPOiBGb3IgbWVtb3J5IHNhdmluZ3MsIGRvbid0IHN0b3JlIHByaW9yaXR5Tm9kZV8gaWYgaXQncyBlbXB0eS5cclxubGV0IEVNUFRZX05PREU7XHJcbi8qKlxyXG4gKiBDaGlsZHJlbk5vZGUgaXMgYSBjbGFzcyBmb3Igc3RvcmluZyBpbnRlcm5hbCBub2RlcyBpbiBhIERhdGFTbmFwc2hvdFxyXG4gKiAoaS5lLiBub2RlcyB3aXRoIGNoaWxkcmVuKS4gIEl0IGltcGxlbWVudHMgTm9kZSBhbmQgc3RvcmVzIHRoZVxyXG4gKiBsaXN0IG9mIGNoaWxkcmVuIGluIHRoZSBjaGlsZHJlbiBwcm9wZXJ0eSwgc29ydGVkIGJ5IGNoaWxkIG5hbWUuXHJcbiAqL1xyXG5jbGFzcyBDaGlsZHJlbk5vZGUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gY2hpbGRyZW5fIC0gTGlzdCBvZiBjaGlsZHJlbiBvZiB0aGlzIG5vZGUuLlxyXG4gICAgICogQHBhcmFtIHByaW9yaXR5Tm9kZV8gLSBUaGUgcHJpb3JpdHkgb2YgdGhpcyBub2RlIChhcyBhIHNuYXBzaG90IG5vZGUpLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihjaGlsZHJlbl8sIHByaW9yaXR5Tm9kZV8sIGluZGV4TWFwXykge1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW5fID0gY2hpbGRyZW5fO1xyXG4gICAgICAgIHRoaXMucHJpb3JpdHlOb2RlXyA9IHByaW9yaXR5Tm9kZV87XHJcbiAgICAgICAgdGhpcy5pbmRleE1hcF8gPSBpbmRleE1hcF87XHJcbiAgICAgICAgdGhpcy5sYXp5SGFzaF8gPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE5vdGU6IFRoZSBvbmx5IHJlYXNvbiB3ZSBhbGxvdyBudWxsIHByaW9yaXR5IGlzIGZvciBFTVBUWV9OT0RFLCBzaW5jZSB3ZSBjYW4ndCB1c2VcclxuICAgICAgICAgKiBFTVBUWV9OT0RFIGFzIHRoZSBwcmlvcml0eSBvZiBFTVBUWV9OT0RFLiAgV2UgbWlnaHQgd2FudCB0byBjb25zaWRlciBtYWtpbmcgRU1QVFlfTk9ERSBpdHMgb3duXHJcbiAgICAgICAgICogY2xhc3MgaW5zdGVhZCBvZiBhbiBlbXB0eSBDaGlsZHJlbk5vZGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaWYgKHRoaXMucHJpb3JpdHlOb2RlXykge1xyXG4gICAgICAgICAgICB2YWxpZGF0ZVByaW9yaXR5Tm9kZSh0aGlzLnByaW9yaXR5Tm9kZV8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbl8uaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIGFzc2VydCghdGhpcy5wcmlvcml0eU5vZGVfIHx8IHRoaXMucHJpb3JpdHlOb2RlXy5pc0VtcHR5KCksICdBbiBlbXB0eSBub2RlIGNhbm5vdCBoYXZlIGEgcHJpb3JpdHknKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0IEVNUFRZX05PREUoKSB7XHJcbiAgICAgICAgcmV0dXJuIChFTVBUWV9OT0RFIHx8XHJcbiAgICAgICAgICAgIChFTVBUWV9OT0RFID0gbmV3IENoaWxkcmVuTm9kZShuZXcgU29ydGVkTWFwKE5BTUVfQ09NUEFSQVRPUiksIG51bGwsIEluZGV4TWFwLkRlZmF1bHQpKSk7XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGlzTGVhZk5vZGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBnZXRQcmlvcml0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wcmlvcml0eU5vZGVfIHx8IEVNUFRZX05PREU7XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIHVwZGF0ZVByaW9yaXR5KG5ld1ByaW9yaXR5Tm9kZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuXy5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgLy8gRG9uJ3QgYWxsb3cgcHJpb3JpdGllcyBvbiBlbXB0eSBub2Rlc1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hpbGRyZW5Ob2RlKHRoaXMuY2hpbGRyZW5fLCBuZXdQcmlvcml0eU5vZGUsIHRoaXMuaW5kZXhNYXBfKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGdldEltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSkge1xyXG4gICAgICAgIC8vIEhhY2sgdG8gdHJlYXQgcHJpb3JpdHkgYXMgYSByZWd1bGFyIGNoaWxkXHJcbiAgICAgICAgaWYgKGNoaWxkTmFtZSA9PT0gJy5wcmlvcml0eScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJpb3JpdHkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZHJlbl8uZ2V0KGNoaWxkTmFtZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBjaGlsZCA9PT0gbnVsbCA/IEVNUFRZX05PREUgOiBjaGlsZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGdldENoaWxkKHBhdGgpIHtcclxuICAgICAgICBjb25zdCBmcm9udCA9IHBhdGhHZXRGcm9udChwYXRoKTtcclxuICAgICAgICBpZiAoZnJvbnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmdldEltbWVkaWF0ZUNoaWxkKGZyb250KS5nZXRDaGlsZChwYXRoUG9wRnJvbnQocGF0aCkpO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBoYXNDaGlsZChjaGlsZE5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbl8uZ2V0KGNoaWxkTmFtZSkgIT09IG51bGw7XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIHVwZGF0ZUltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSwgbmV3Q2hpbGROb2RlKSB7XHJcbiAgICAgICAgYXNzZXJ0KG5ld0NoaWxkTm9kZSwgJ1dlIHNob3VsZCBhbHdheXMgYmUgcGFzc2luZyBzbmFwc2hvdCBub2RlcycpO1xyXG4gICAgICAgIGlmIChjaGlsZE5hbWUgPT09ICcucHJpb3JpdHknKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZVByaW9yaXR5KG5ld0NoaWxkTm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBuYW1lZE5vZGUgPSBuZXcgTmFtZWROb2RlKGNoaWxkTmFtZSwgbmV3Q2hpbGROb2RlKTtcclxuICAgICAgICAgICAgbGV0IG5ld0NoaWxkcmVuLCBuZXdJbmRleE1hcDtcclxuICAgICAgICAgICAgaWYgKG5ld0NoaWxkTm9kZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuID0gdGhpcy5jaGlsZHJlbl8ucmVtb3ZlKGNoaWxkTmFtZSk7XHJcbiAgICAgICAgICAgICAgICBuZXdJbmRleE1hcCA9IHRoaXMuaW5kZXhNYXBfLnJlbW92ZUZyb21JbmRleGVzKG5hbWVkTm9kZSwgdGhpcy5jaGlsZHJlbl8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmV3Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuXy5pbnNlcnQoY2hpbGROYW1lLCBuZXdDaGlsZE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgbmV3SW5kZXhNYXAgPSB0aGlzLmluZGV4TWFwXy5hZGRUb0luZGV4ZXMobmFtZWROb2RlLCB0aGlzLmNoaWxkcmVuXyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbmV3UHJpb3JpdHkgPSBuZXdDaGlsZHJlbi5pc0VtcHR5KClcclxuICAgICAgICAgICAgICAgID8gRU1QVFlfTk9ERVxyXG4gICAgICAgICAgICAgICAgOiB0aGlzLnByaW9yaXR5Tm9kZV87XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hpbGRyZW5Ob2RlKG5ld0NoaWxkcmVuLCBuZXdQcmlvcml0eSwgbmV3SW5kZXhNYXApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgdXBkYXRlQ2hpbGQocGF0aCwgbmV3Q2hpbGROb2RlKSB7XHJcbiAgICAgICAgY29uc3QgZnJvbnQgPSBwYXRoR2V0RnJvbnQocGF0aCk7XHJcbiAgICAgICAgaWYgKGZyb250ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdDaGlsZE5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhc3NlcnQocGF0aEdldEZyb250KHBhdGgpICE9PSAnLnByaW9yaXR5JyB8fCBwYXRoR2V0TGVuZ3RoKHBhdGgpID09PSAxLCAnLnByaW9yaXR5IG11c3QgYmUgdGhlIGxhc3QgdG9rZW4gaW4gYSBwYXRoJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0ltbWVkaWF0ZUNoaWxkID0gdGhpcy5nZXRJbW1lZGlhdGVDaGlsZChmcm9udCkudXBkYXRlQ2hpbGQocGF0aFBvcEZyb250KHBhdGgpLCBuZXdDaGlsZE5vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVJbW1lZGlhdGVDaGlsZChmcm9udCwgbmV3SW1tZWRpYXRlQ2hpbGQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbl8uaXNFbXB0eSgpO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBudW1DaGlsZHJlbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbl8uY291bnQoKTtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgdmFsKGV4cG9ydEZvcm1hdCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb2JqID0ge307XHJcbiAgICAgICAgbGV0IG51bUtleXMgPSAwLCBtYXhLZXkgPSAwLCBhbGxJbnRlZ2VyS2V5cyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5mb3JFYWNoQ2hpbGQoUFJJT1JJVFlfSU5ERVgsIChrZXksIGNoaWxkTm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBvYmpba2V5XSA9IGNoaWxkTm9kZS52YWwoZXhwb3J0Rm9ybWF0KTtcclxuICAgICAgICAgICAgbnVtS2V5cysrO1xyXG4gICAgICAgICAgICBpZiAoYWxsSW50ZWdlcktleXMgJiYgQ2hpbGRyZW5Ob2RlLklOVEVHRVJfUkVHRVhQXy50ZXN0KGtleSkpIHtcclxuICAgICAgICAgICAgICAgIG1heEtleSA9IE1hdGgubWF4KG1heEtleSwgTnVtYmVyKGtleSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYWxsSW50ZWdlcktleXMgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICghZXhwb3J0Rm9ybWF0ICYmIGFsbEludGVnZXJLZXlzICYmIG1heEtleSA8IDIgKiBudW1LZXlzKSB7XHJcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgdG8gYXJyYXkuXHJcbiAgICAgICAgICAgIGNvbnN0IGFycmF5ID0gW107XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW5cclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgICAgICBhcnJheVtrZXldID0gb2JqW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGV4cG9ydEZvcm1hdCAmJiAhdGhpcy5nZXRQcmlvcml0eSgpLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgb2JqWycucHJpb3JpdHknXSA9IHRoaXMuZ2V0UHJpb3JpdHkoKS52YWwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgaGFzaCgpIHtcclxuICAgICAgICBpZiAodGhpcy5sYXp5SGFzaF8gPT09IG51bGwpIHtcclxuICAgICAgICAgICAgbGV0IHRvSGFzaCA9ICcnO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0UHJpb3JpdHkoKS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIHRvSGFzaCArPVxyXG4gICAgICAgICAgICAgICAgICAgICdwcmlvcml0eTonICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHlIYXNoVGV4dCh0aGlzLmdldFByaW9yaXR5KCkudmFsKCkpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJzonO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCAoa2V5LCBjaGlsZE5vZGUpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkSGFzaCA9IGNoaWxkTm9kZS5oYXNoKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRIYXNoICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvSGFzaCArPSAnOicgKyBrZXkgKyAnOicgKyBjaGlsZEhhc2g7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLmxhenlIYXNoXyA9IHRvSGFzaCA9PT0gJycgPyAnJyA6IHNoYTEodG9IYXNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGF6eUhhc2hfO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBnZXRQcmVkZWNlc3NvckNoaWxkTmFtZShjaGlsZE5hbWUsIGNoaWxkTm9kZSwgaW5kZXgpIHtcclxuICAgICAgICBjb25zdCBpZHggPSB0aGlzLnJlc29sdmVJbmRleF8oaW5kZXgpO1xyXG4gICAgICAgIGlmIChpZHgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJlZGVjZXNzb3IgPSBpZHguZ2V0UHJlZGVjZXNzb3JLZXkobmV3IE5hbWVkTm9kZShjaGlsZE5hbWUsIGNoaWxkTm9kZSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJlZGVjZXNzb3IgPyBwcmVkZWNlc3Nvci5uYW1lIDogbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuXy5nZXRQcmVkZWNlc3NvcktleShjaGlsZE5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldEZpcnN0Q2hpbGROYW1lKGluZGV4RGVmaW5pdGlvbikge1xyXG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMucmVzb2x2ZUluZGV4XyhpbmRleERlZmluaXRpb24pO1xyXG4gICAgICAgIGlmIChpZHgpIHtcclxuICAgICAgICAgICAgY29uc3QgbWluS2V5ID0gaWR4Lm1pbktleSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gbWluS2V5ICYmIG1pbktleS5uYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fLm1pbktleSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldEZpcnN0Q2hpbGQoaW5kZXhEZWZpbml0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgbWluS2V5ID0gdGhpcy5nZXRGaXJzdENoaWxkTmFtZShpbmRleERlZmluaXRpb24pO1xyXG4gICAgICAgIGlmIChtaW5LZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOYW1lZE5vZGUobWluS2V5LCB0aGlzLmNoaWxkcmVuXy5nZXQobWluS2V5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGFuIGluZGV4LCByZXR1cm4gdGhlIGtleSBuYW1lIG9mIHRoZSBsYXJnZXN0IHZhbHVlIHdlIGhhdmUsIGFjY29yZGluZyB0byB0aGF0IGluZGV4XHJcbiAgICAgKi9cclxuICAgIGdldExhc3RDaGlsZE5hbWUoaW5kZXhEZWZpbml0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5yZXNvbHZlSW5kZXhfKGluZGV4RGVmaW5pdGlvbik7XHJcbiAgICAgICAgaWYgKGlkeCkge1xyXG4gICAgICAgICAgICBjb25zdCBtYXhLZXkgPSBpZHgubWF4S2V5KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBtYXhLZXkgJiYgbWF4S2V5Lm5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbl8ubWF4S2V5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0TGFzdENoaWxkKGluZGV4RGVmaW5pdGlvbikge1xyXG4gICAgICAgIGNvbnN0IG1heEtleSA9IHRoaXMuZ2V0TGFzdENoaWxkTmFtZShpbmRleERlZmluaXRpb24pO1xyXG4gICAgICAgIGlmIChtYXhLZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOYW1lZE5vZGUobWF4S2V5LCB0aGlzLmNoaWxkcmVuXy5nZXQobWF4S2V5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3JFYWNoQ2hpbGQoaW5kZXgsIGFjdGlvbikge1xyXG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMucmVzb2x2ZUluZGV4XyhpbmRleCk7XHJcbiAgICAgICAgaWYgKGlkeCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaWR4Lmlub3JkZXJUcmF2ZXJzYWwod3JhcHBlZE5vZGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbih3cmFwcGVkTm9kZS5uYW1lLCB3cmFwcGVkTm9kZS5ub2RlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbl8uaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldEl0ZXJhdG9yKGluZGV4RGVmaW5pdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldEl0ZXJhdG9yRnJvbShpbmRleERlZmluaXRpb24ubWluUG9zdCgpLCBpbmRleERlZmluaXRpb24pO1xyXG4gICAgfVxyXG4gICAgZ2V0SXRlcmF0b3JGcm9tKHN0YXJ0UG9zdCwgaW5kZXhEZWZpbml0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5yZXNvbHZlSW5kZXhfKGluZGV4RGVmaW5pdGlvbik7XHJcbiAgICAgICAgaWYgKGlkeCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaWR4LmdldEl0ZXJhdG9yRnJvbShzdGFydFBvc3QsIGtleSA9PiBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLmNoaWxkcmVuXy5nZXRJdGVyYXRvckZyb20oc3RhcnRQb3N0Lm5hbWUsIE5hbWVkTm9kZS5XcmFwKTtcclxuICAgICAgICAgICAgbGV0IG5leHQgPSBpdGVyYXRvci5wZWVrKCk7XHJcbiAgICAgICAgICAgIHdoaWxlIChuZXh0ICE9IG51bGwgJiYgaW5kZXhEZWZpbml0aW9uLmNvbXBhcmUobmV4dCwgc3RhcnRQb3N0KSA8IDApIHtcclxuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmdldE5leHQoKTtcclxuICAgICAgICAgICAgICAgIG5leHQgPSBpdGVyYXRvci5wZWVrKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldFJldmVyc2VJdGVyYXRvcihpbmRleERlZmluaXRpb24pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZXZlcnNlSXRlcmF0b3JGcm9tKGluZGV4RGVmaW5pdGlvbi5tYXhQb3N0KCksIGluZGV4RGVmaW5pdGlvbik7XHJcbiAgICB9XHJcbiAgICBnZXRSZXZlcnNlSXRlcmF0b3JGcm9tKGVuZFBvc3QsIGluZGV4RGVmaW5pdGlvbikge1xyXG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMucmVzb2x2ZUluZGV4XyhpbmRleERlZmluaXRpb24pO1xyXG4gICAgICAgIGlmIChpZHgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlkeC5nZXRSZXZlcnNlSXRlcmF0b3JGcm9tKGVuZFBvc3QsIGtleSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5jaGlsZHJlbl8uZ2V0UmV2ZXJzZUl0ZXJhdG9yRnJvbShlbmRQb3N0Lm5hbWUsIE5hbWVkTm9kZS5XcmFwKTtcclxuICAgICAgICAgICAgbGV0IG5leHQgPSBpdGVyYXRvci5wZWVrKCk7XHJcbiAgICAgICAgICAgIHdoaWxlIChuZXh0ICE9IG51bGwgJiYgaW5kZXhEZWZpbml0aW9uLmNvbXBhcmUobmV4dCwgZW5kUG9zdCkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5nZXROZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBuZXh0ID0gaXRlcmF0b3IucGVlaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb21wYXJlVG8ob3RoZXIpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgaWYgKG90aGVyLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3RoZXIuaXNMZWFmTm9kZSgpIHx8IG90aGVyLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3RoZXIgPT09IE1BWF9OT0RFKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE11c3QgYmUgYW5vdGhlciBub2RlIHdpdGggY2hpbGRyZW4uXHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHdpdGhJbmRleChpbmRleERlZmluaXRpb24pIHtcclxuICAgICAgICBpZiAoaW5kZXhEZWZpbml0aW9uID09PSBLRVlfSU5ERVggfHxcclxuICAgICAgICAgICAgdGhpcy5pbmRleE1hcF8uaGFzSW5kZXgoaW5kZXhEZWZpbml0aW9uKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0luZGV4TWFwID0gdGhpcy5pbmRleE1hcF8uYWRkSW5kZXgoaW5kZXhEZWZpbml0aW9uLCB0aGlzLmNoaWxkcmVuXyk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hpbGRyZW5Ob2RlKHRoaXMuY2hpbGRyZW5fLCB0aGlzLnByaW9yaXR5Tm9kZV8sIG5ld0luZGV4TWFwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpc0luZGV4ZWQoaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gaW5kZXggPT09IEtFWV9JTkRFWCB8fCB0aGlzLmluZGV4TWFwXy5oYXNJbmRleChpbmRleCk7XHJcbiAgICB9XHJcbiAgICBlcXVhbHMob3RoZXIpIHtcclxuICAgICAgICBpZiAob3RoZXIgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG90aGVyLmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBvdGhlckNoaWxkcmVuTm9kZSA9IG90aGVyO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0UHJpb3JpdHkoKS5lcXVhbHMob3RoZXJDaGlsZHJlbk5vZGUuZ2V0UHJpb3JpdHkoKSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNoaWxkcmVuXy5jb3VudCgpID09PSBvdGhlckNoaWxkcmVuTm9kZS5jaGlsZHJlbl8uY291bnQoKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGhpc0l0ZXIgPSB0aGlzLmdldEl0ZXJhdG9yKFBSSU9SSVRZX0lOREVYKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG90aGVySXRlciA9IG90aGVyQ2hpbGRyZW5Ob2RlLmdldEl0ZXJhdG9yKFBSSU9SSVRZX0lOREVYKTtcclxuICAgICAgICAgICAgICAgIGxldCB0aGlzQ3VycmVudCA9IHRoaXNJdGVyLmdldE5leHQoKTtcclxuICAgICAgICAgICAgICAgIGxldCBvdGhlckN1cnJlbnQgPSBvdGhlckl0ZXIuZ2V0TmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXNDdXJyZW50ICYmIG90aGVyQ3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzQ3VycmVudC5uYW1lICE9PSBvdGhlckN1cnJlbnQubmFtZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpc0N1cnJlbnQubm9kZS5lcXVhbHMob3RoZXJDdXJyZW50Lm5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpc0N1cnJlbnQgPSB0aGlzSXRlci5nZXROZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgb3RoZXJDdXJyZW50ID0gb3RoZXJJdGVyLmdldE5leHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzQ3VycmVudCA9PT0gbnVsbCAmJiBvdGhlckN1cnJlbnQgPT09IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBTb3J0ZWRNYXAgb3JkZXJlZCBieSBpbmRleCwgb3IgbnVsbCBpZiB0aGUgZGVmYXVsdCAoYnkta2V5KSBvcmRlcmluZyBjYW4gYmUgdXNlZFxyXG4gICAgICogaW5zdGVhZC5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIHJlc29sdmVJbmRleF8oaW5kZXhEZWZpbml0aW9uKSB7XHJcbiAgICAgICAgaWYgKGluZGV4RGVmaW5pdGlvbiA9PT0gS0VZX0lOREVYKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhNYXBfLmdldChpbmRleERlZmluaXRpb24udG9TdHJpbmcoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbkNoaWxkcmVuTm9kZS5JTlRFR0VSX1JFR0VYUF8gPSAvXigwfFsxLTldXFxkKikkLztcclxuY2xhc3MgTWF4Tm9kZSBleHRlbmRzIENoaWxkcmVuTm9kZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihuZXcgU29ydGVkTWFwKE5BTUVfQ09NUEFSQVRPUiksIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFLCBJbmRleE1hcC5EZWZhdWx0KTtcclxuICAgIH1cclxuICAgIGNvbXBhcmVUbyhvdGhlcikge1xyXG4gICAgICAgIGlmIChvdGhlciA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVxdWFscyhvdGhlcikge1xyXG4gICAgICAgIC8vIE5vdCB0aGF0IHdlIGV2ZXJ5IGNvbXBhcmUgaXQsIGJ1dCBNQVhfTk9ERSBpcyBvbmx5IGV2ZXIgZXF1YWwgdG8gaXRzZWxmXHJcbiAgICAgICAgcmV0dXJuIG90aGVyID09PSB0aGlzO1xyXG4gICAgfVxyXG4gICAgZ2V0UHJpb3JpdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBnZXRJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUpIHtcclxuICAgICAgICByZXR1cm4gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICB9XHJcbiAgICBpc0VtcHR5KCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogTWFya2VyIHRoYXQgd2lsbCBzb3J0IGhpZ2hlciB0aGFuIGFueSBvdGhlciBzbmFwc2hvdC5cclxuICovXHJcbmNvbnN0IE1BWF9OT0RFID0gbmV3IE1heE5vZGUoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTmFtZWROb2RlLCB7XHJcbiAgICBNSU46IHtcclxuICAgICAgICB2YWx1ZTogbmV3IE5hbWVkTm9kZShNSU5fTkFNRSwgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUpXHJcbiAgICB9LFxyXG4gICAgTUFYOiB7XHJcbiAgICAgICAgdmFsdWU6IG5ldyBOYW1lZE5vZGUoTUFYX05BTUUsIE1BWF9OT0RFKVxyXG4gICAgfVxyXG59KTtcclxuLyoqXHJcbiAqIFJlZmVyZW5jZSBFeHRlbnNpb25zXHJcbiAqL1xyXG5LZXlJbmRleC5fX0VNUFRZX05PREUgPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuTGVhZk5vZGUuX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3RvciA9IENoaWxkcmVuTm9kZTtcclxuc2V0TWF4Tm9kZSQxKE1BWF9OT0RFKTtcclxuc2V0TWF4Tm9kZShNQVhfTk9ERSk7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IFVTRV9ISU5aRSA9IHRydWU7XHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgc25hcHNob3Qgbm9kZSByZXByZXNlbnRpbmcgdGhlIHBhc3NlZCBKU09OIGFuZCByZXR1cm5zIGl0LlxyXG4gKiBAcGFyYW0ganNvbiAtIEpTT04gdG8gY3JlYXRlIGEgbm9kZSBmb3IuXHJcbiAqIEBwYXJhbSBwcmlvcml0eSAtIE9wdGlvbmFsIHByaW9yaXR5IHRvIHVzZS4gIFRoaXMgd2lsbCBiZSBpZ25vcmVkIGlmIHRoZVxyXG4gKiBwYXNzZWQgSlNPTiBjb250YWlucyBhIC5wcmlvcml0eSBwcm9wZXJ0eS5cclxuICovXHJcbmZ1bmN0aW9uIG5vZGVGcm9tSlNPTihqc29uLCBwcmlvcml0eSA9IG51bGwpIHtcclxuICAgIGlmIChqc29uID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBqc29uID09PSAnb2JqZWN0JyAmJiAnLnByaW9yaXR5JyBpbiBqc29uKSB7XHJcbiAgICAgICAgcHJpb3JpdHkgPSBqc29uWycucHJpb3JpdHknXTtcclxuICAgIH1cclxuICAgIGFzc2VydChwcmlvcml0eSA9PT0gbnVsbCB8fFxyXG4gICAgICAgIHR5cGVvZiBwcmlvcml0eSA9PT0gJ3N0cmluZycgfHxcclxuICAgICAgICB0eXBlb2YgcHJpb3JpdHkgPT09ICdudW1iZXInIHx8XHJcbiAgICAgICAgKHR5cGVvZiBwcmlvcml0eSA9PT0gJ29iamVjdCcgJiYgJy5zdicgaW4gcHJpb3JpdHkpLCAnSW52YWxpZCBwcmlvcml0eSB0eXBlIGZvdW5kOiAnICsgdHlwZW9mIHByaW9yaXR5KTtcclxuICAgIGlmICh0eXBlb2YganNvbiA9PT0gJ29iamVjdCcgJiYgJy52YWx1ZScgaW4ganNvbiAmJiBqc29uWycudmFsdWUnXSAhPT0gbnVsbCkge1xyXG4gICAgICAgIGpzb24gPSBqc29uWycudmFsdWUnXTtcclxuICAgIH1cclxuICAgIC8vIFZhbGlkIGxlYWYgbm9kZXMgaW5jbHVkZSBub24tb2JqZWN0cyBvciBzZXJ2ZXItdmFsdWUgd3JhcHBlciBvYmplY3RzXHJcbiAgICBpZiAodHlwZW9mIGpzb24gIT09ICdvYmplY3QnIHx8ICcuc3YnIGluIGpzb24pIHtcclxuICAgICAgICBjb25zdCBqc29uTGVhZiA9IGpzb247XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMZWFmTm9kZShqc29uTGVhZiwgbm9kZUZyb21KU09OKHByaW9yaXR5KSk7XHJcbiAgICB9XHJcbiAgICBpZiAoIShqc29uIGluc3RhbmNlb2YgQXJyYXkpICYmIFVTRV9ISU5aRSkge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gW107XHJcbiAgICAgICAgbGV0IGNoaWxkcmVuSGF2ZVByaW9yaXR5ID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgaGluemVKc29uT2JqID0ganNvbjtcclxuICAgICAgICBlYWNoKGhpbnplSnNvbk9iaiwgKGtleSwgY2hpbGQpID0+IHtcclxuICAgICAgICAgICAgaWYgKGtleS5zdWJzdHJpbmcoMCwgMSkgIT09ICcuJykge1xyXG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIG1ldGFkYXRhIG5vZGVzXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZE5vZGUgPSBub2RlRnJvbUpTT04oY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjaGlsZE5vZGUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5IYXZlUHJpb3JpdHkgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbkhhdmVQcmlvcml0eSB8fCAhY2hpbGROb2RlLmdldFByaW9yaXR5KCkuaXNFbXB0eSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobmV3IE5hbWVkTm9kZShrZXksIGNoaWxkTm9kZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNoaWxkU2V0ID0gYnVpbGRDaGlsZFNldChjaGlsZHJlbiwgTkFNRV9PTkxZX0NPTVBBUkFUT1IsIG5hbWVkTm9kZSA9PiBuYW1lZE5vZGUubmFtZSwgTkFNRV9DT01QQVJBVE9SKTtcclxuICAgICAgICBpZiAoY2hpbGRyZW5IYXZlUHJpb3JpdHkpIHtcclxuICAgICAgICAgICAgY29uc3Qgc29ydGVkQ2hpbGRTZXQgPSBidWlsZENoaWxkU2V0KGNoaWxkcmVuLCBQUklPUklUWV9JTkRFWC5nZXRDb21wYXJlKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENoaWxkcmVuTm9kZShjaGlsZFNldCwgbm9kZUZyb21KU09OKHByaW9yaXR5KSwgbmV3IEluZGV4TWFwKHsgJy5wcmlvcml0eSc6IHNvcnRlZENoaWxkU2V0IH0sIHsgJy5wcmlvcml0eSc6IFBSSU9SSVRZX0lOREVYIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hpbGRyZW5Ob2RlKGNoaWxkU2V0LCBub2RlRnJvbUpTT04ocHJpb3JpdHkpLCBJbmRleE1hcC5EZWZhdWx0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsZXQgbm9kZSA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgICAgIGVhY2goanNvbiwgKGtleSwgY2hpbGREYXRhKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChjb250YWlucyhqc29uLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5LnN1YnN0cmluZygwLCAxKSAhPT0gJy4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIG1ldGFkYXRhIG5vZGVzLlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IG5vZGVGcm9tSlNPTihjaGlsZERhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGUuaXNMZWFmTm9kZSgpIHx8ICFjaGlsZE5vZGUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKGtleSwgY2hpbGROb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbm9kZS51cGRhdGVQcmlvcml0eShub2RlRnJvbUpTT04ocHJpb3JpdHkpKTtcclxuICAgIH1cclxufVxyXG5zZXROb2RlRnJvbUpTT04obm9kZUZyb21KU09OKTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgUGF0aEluZGV4IGV4dGVuZHMgSW5kZXgge1xyXG4gICAgY29uc3RydWN0b3IoaW5kZXhQYXRoXykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5pbmRleFBhdGhfID0gaW5kZXhQYXRoXztcclxuICAgICAgICBhc3NlcnQoIXBhdGhJc0VtcHR5KGluZGV4UGF0aF8pICYmIHBhdGhHZXRGcm9udChpbmRleFBhdGhfKSAhPT0gJy5wcmlvcml0eScsIFwiQ2FuJ3QgY3JlYXRlIFBhdGhJbmRleCB3aXRoIGVtcHR5IHBhdGggb3IgLnByaW9yaXR5IGtleVwiKTtcclxuICAgIH1cclxuICAgIGV4dHJhY3RDaGlsZChzbmFwKSB7XHJcbiAgICAgICAgcmV0dXJuIHNuYXAuZ2V0Q2hpbGQodGhpcy5pbmRleFBhdGhfKTtcclxuICAgIH1cclxuICAgIGlzRGVmaW5lZE9uKG5vZGUpIHtcclxuICAgICAgICByZXR1cm4gIW5vZGUuZ2V0Q2hpbGQodGhpcy5pbmRleFBhdGhfKS5pc0VtcHR5KCk7XHJcbiAgICB9XHJcbiAgICBjb21wYXJlKGEsIGIpIHtcclxuICAgICAgICBjb25zdCBhQ2hpbGQgPSB0aGlzLmV4dHJhY3RDaGlsZChhLm5vZGUpO1xyXG4gICAgICAgIGNvbnN0IGJDaGlsZCA9IHRoaXMuZXh0cmFjdENoaWxkKGIubm9kZSk7XHJcbiAgICAgICAgY29uc3QgaW5kZXhDbXAgPSBhQ2hpbGQuY29tcGFyZVRvKGJDaGlsZCk7XHJcbiAgICAgICAgaWYgKGluZGV4Q21wID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuYW1lQ29tcGFyZShhLm5hbWUsIGIubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5kZXhDbXA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbWFrZVBvc3QoaW5kZXhWYWx1ZSwgbmFtZSkge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlTm9kZSA9IG5vZGVGcm9tSlNPTihpbmRleFZhbHVlKTtcclxuICAgICAgICBjb25zdCBub2RlID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUudXBkYXRlQ2hpbGQodGhpcy5pbmRleFBhdGhfLCB2YWx1ZU5vZGUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgTmFtZWROb2RlKG5hbWUsIG5vZGUpO1xyXG4gICAgfVxyXG4gICAgbWF4UG9zdCgpIHtcclxuICAgICAgICBjb25zdCBub2RlID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUudXBkYXRlQ2hpbGQodGhpcy5pbmRleFBhdGhfLCBNQVhfTk9ERSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBOYW1lZE5vZGUoTUFYX05BTUUsIG5vZGUpO1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdGhTbGljZSh0aGlzLmluZGV4UGF0aF8sIDApLmpvaW4oJy8nKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBWYWx1ZUluZGV4IGV4dGVuZHMgSW5kZXgge1xyXG4gICAgY29tcGFyZShhLCBiKSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXhDbXAgPSBhLm5vZGUuY29tcGFyZVRvKGIubm9kZSk7XHJcbiAgICAgICAgaWYgKGluZGV4Q21wID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuYW1lQ29tcGFyZShhLm5hbWUsIGIubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5kZXhDbXA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXNEZWZpbmVkT24obm9kZSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgaW5kZXhlZFZhbHVlQ2hhbmdlZChvbGROb2RlLCBuZXdOb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuICFvbGROb2RlLmVxdWFscyhuZXdOb2RlKTtcclxuICAgIH1cclxuICAgIG1pblBvc3QoKSB7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICByZXR1cm4gTmFtZWROb2RlLk1JTjtcclxuICAgIH1cclxuICAgIG1heFBvc3QoKSB7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICByZXR1cm4gTmFtZWROb2RlLk1BWDtcclxuICAgIH1cclxuICAgIG1ha2VQb3N0KGluZGV4VmFsdWUsIG5hbWUpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZU5vZGUgPSBub2RlRnJvbUpTT04oaW5kZXhWYWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBOYW1lZE5vZGUobmFtZSwgdmFsdWVOb2RlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgU3RyaW5nIHJlcHJlc2VudGF0aW9uIGZvciBpbmNsdXNpb24gaW4gYSBxdWVyeSBzcGVjXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiAnLnZhbHVlJztcclxuICAgIH1cclxufVxyXG5jb25zdCBWQUxVRV9JTkRFWCA9IG5ldyBWYWx1ZUluZGV4KCk7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIGNoYW5nZVZhbHVlKHNuYXBzaG90Tm9kZSkge1xyXG4gICAgcmV0dXJuIHsgdHlwZTogXCJ2YWx1ZVwiIC8qIENoYW5nZVR5cGUuVkFMVUUgKi8sIHNuYXBzaG90Tm9kZSB9O1xyXG59XHJcbmZ1bmN0aW9uIGNoYW5nZUNoaWxkQWRkZWQoY2hpbGROYW1lLCBzbmFwc2hvdE5vZGUpIHtcclxuICAgIHJldHVybiB7IHR5cGU6IFwiY2hpbGRfYWRkZWRcIiAvKiBDaGFuZ2VUeXBlLkNISUxEX0FEREVEICovLCBzbmFwc2hvdE5vZGUsIGNoaWxkTmFtZSB9O1xyXG59XHJcbmZ1bmN0aW9uIGNoYW5nZUNoaWxkUmVtb3ZlZChjaGlsZE5hbWUsIHNuYXBzaG90Tm9kZSkge1xyXG4gICAgcmV0dXJuIHsgdHlwZTogXCJjaGlsZF9yZW1vdmVkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9SRU1PVkVEICovLCBzbmFwc2hvdE5vZGUsIGNoaWxkTmFtZSB9O1xyXG59XHJcbmZ1bmN0aW9uIGNoYW5nZUNoaWxkQ2hhbmdlZChjaGlsZE5hbWUsIHNuYXBzaG90Tm9kZSwgb2xkU25hcCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiBcImNoaWxkX2NoYW5nZWRcIiAvKiBDaGFuZ2VUeXBlLkNISUxEX0NIQU5HRUQgKi8sXHJcbiAgICAgICAgc25hcHNob3ROb2RlLFxyXG4gICAgICAgIGNoaWxkTmFtZSxcclxuICAgICAgICBvbGRTbmFwXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNoYW5nZUNoaWxkTW92ZWQoY2hpbGROYW1lLCBzbmFwc2hvdE5vZGUpIHtcclxuICAgIHJldHVybiB7IHR5cGU6IFwiY2hpbGRfbW92ZWRcIiAvKiBDaGFuZ2VUeXBlLkNISUxEX01PVkVEICovLCBzbmFwc2hvdE5vZGUsIGNoaWxkTmFtZSB9O1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBEb2Vzbid0IHJlYWxseSBmaWx0ZXIgbm9kZXMgYnV0IGFwcGxpZXMgYW4gaW5kZXggdG8gdGhlIG5vZGUgYW5kIGtlZXBzIHRyYWNrIG9mIGFueSBjaGFuZ2VzXHJcbiAqL1xyXG5jbGFzcyBJbmRleGVkRmlsdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGluZGV4Xykge1xyXG4gICAgICAgIHRoaXMuaW5kZXhfID0gaW5kZXhfO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlQ2hpbGQoc25hcCwga2V5LCBuZXdDaGlsZCwgYWZmZWN0ZWRQYXRoLCBzb3VyY2UsIG9wdENoYW5nZUFjY3VtdWxhdG9yKSB7XHJcbiAgICAgICAgYXNzZXJ0KHNuYXAuaXNJbmRleGVkKHRoaXMuaW5kZXhfKSwgJ0Egbm9kZSBtdXN0IGJlIGluZGV4ZWQgaWYgb25seSBhIGNoaWxkIGlzIHVwZGF0ZWQnKTtcclxuICAgICAgICBjb25zdCBvbGRDaGlsZCA9IHNuYXAuZ2V0SW1tZWRpYXRlQ2hpbGQoa2V5KTtcclxuICAgICAgICAvLyBDaGVjayBpZiBhbnl0aGluZyBhY3R1YWxseSBjaGFuZ2VkLlxyXG4gICAgICAgIGlmIChvbGRDaGlsZC5nZXRDaGlsZChhZmZlY3RlZFBhdGgpLmVxdWFscyhuZXdDaGlsZC5nZXRDaGlsZChhZmZlY3RlZFBhdGgpKSkge1xyXG4gICAgICAgICAgICAvLyBUaGVyZSdzIGFuIGVkZ2UgY2FzZSB3aGVyZSBhIGNoaWxkIGNhbiBlbnRlciBvciBsZWF2ZSB0aGUgdmlldyBiZWNhdXNlIGFmZmVjdGVkUGF0aCB3YXMgc2V0IHRvIG51bGwuXHJcbiAgICAgICAgICAgIC8vIEluIHRoaXMgY2FzZSwgYWZmZWN0ZWRQYXRoIHdpbGwgYXBwZWFyIG51bGwgaW4gYm90aCB0aGUgb2xkIGFuZCBuZXcgc25hcHNob3RzLiAgU28gd2UgbmVlZFxyXG4gICAgICAgICAgICAvLyB0byBhdm9pZCB0cmVhdGluZyB0aGVzZSBjYXNlcyBhcyBcIm5vdGhpbmcgY2hhbmdlZC5cIlxyXG4gICAgICAgICAgICBpZiAob2xkQ2hpbGQuaXNFbXB0eSgpID09PSBuZXdDaGlsZC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vdGhpbmcgY2hhbmdlZC5cclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgYXNzZXJ0IHNob3VsZCBiZSB2YWxpZCwgYnV0IGl0J3MgZXhwZW5zaXZlIChjYW4gZG9taW5hdGUgcGVyZiB0ZXN0aW5nKSBzbyBkb24ndCBhY3R1YWxseSBkbyBpdC5cclxuICAgICAgICAgICAgICAgIC8vYXNzZXJ0KG9sZENoaWxkLmVxdWFscyhuZXdDaGlsZCksICdPbGQgYW5kIG5ldyBzbmFwc2hvdHMgc2hvdWxkIGJlIGVxdWFsLicpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNuYXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdENoYW5nZUFjY3VtdWxhdG9yICE9IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNuYXAuaGFzQ2hpbGQoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdENoYW5nZUFjY3VtdWxhdG9yLnRyYWNrQ2hpbGRDaGFuZ2UoY2hhbmdlQ2hpbGRSZW1vdmVkKGtleSwgb2xkQ2hpbGQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydChzbmFwLmlzTGVhZk5vZGUoKSwgJ0EgY2hpbGQgcmVtb3ZlIHdpdGhvdXQgYW4gb2xkIGNoaWxkIG9ubHkgbWFrZXMgc2Vuc2Ugb24gYSBsZWFmIG5vZGUnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvbGRDaGlsZC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIG9wdENoYW5nZUFjY3VtdWxhdG9yLnRyYWNrQ2hpbGRDaGFuZ2UoY2hhbmdlQ2hpbGRBZGRlZChrZXksIG5ld0NoaWxkKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvcHRDaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKGNoYW5nZUNoaWxkQ2hhbmdlZChrZXksIG5ld0NoaWxkLCBvbGRDaGlsZCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzbmFwLmlzTGVhZk5vZGUoKSAmJiBuZXdDaGlsZC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNuYXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIG5vZGUgaXMgaW5kZXhlZFxyXG4gICAgICAgICAgICByZXR1cm4gc25hcC51cGRhdGVJbW1lZGlhdGVDaGlsZChrZXksIG5ld0NoaWxkKS53aXRoSW5kZXgodGhpcy5pbmRleF8pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVwZGF0ZUZ1bGxOb2RlKG9sZFNuYXAsIG5ld1NuYXAsIG9wdENoYW5nZUFjY3VtdWxhdG9yKSB7XHJcbiAgICAgICAgaWYgKG9wdENoYW5nZUFjY3VtdWxhdG9yICE9IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKCFvbGRTbmFwLmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgICAgICAgICAgb2xkU25hcC5mb3JFYWNoQ2hpbGQoUFJJT1JJVFlfSU5ERVgsIChrZXksIGNoaWxkTm9kZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV3U25hcC5oYXNDaGlsZChrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdENoYW5nZUFjY3VtdWxhdG9yLnRyYWNrQ2hpbGRDaGFuZ2UoY2hhbmdlQ2hpbGRSZW1vdmVkKGtleSwgY2hpbGROb2RlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFuZXdTbmFwLmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgICAgICAgICAgbmV3U25hcC5mb3JFYWNoQ2hpbGQoUFJJT1JJVFlfSU5ERVgsIChrZXksIGNoaWxkTm9kZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRTbmFwLmhhc0NoaWxkKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2xkQ2hpbGQgPSBvbGRTbmFwLmdldEltbWVkaWF0ZUNoaWxkKGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb2xkQ2hpbGQuZXF1YWxzKGNoaWxkTm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdENoYW5nZUFjY3VtdWxhdG9yLnRyYWNrQ2hpbGRDaGFuZ2UoY2hhbmdlQ2hpbGRDaGFuZ2VkKGtleSwgY2hpbGROb2RlLCBvbGRDaGlsZCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRDaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKGNoYW5nZUNoaWxkQWRkZWQoa2V5LCBjaGlsZE5vZGUpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3U25hcC53aXRoSW5kZXgodGhpcy5pbmRleF8pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlUHJpb3JpdHkob2xkU25hcCwgbmV3UHJpb3JpdHkpIHtcclxuICAgICAgICBpZiAob2xkU25hcC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9sZFNuYXAudXBkYXRlUHJpb3JpdHkobmV3UHJpb3JpdHkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZpbHRlcnNOb2RlcygpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBnZXRJbmRleGVkRmlsdGVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgZ2V0SW5kZXgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhfO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBGaWx0ZXJzIG5vZGVzIGJ5IHJhbmdlIGFuZCB1c2VzIGFuIEluZGV4RmlsdGVyIHRvIHRyYWNrIGFueSBjaGFuZ2VzIGFmdGVyIGZpbHRlcmluZyB0aGUgbm9kZVxyXG4gKi9cclxuY2xhc3MgUmFuZ2VkRmlsdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xyXG4gICAgICAgIHRoaXMuaW5kZXhlZEZpbHRlcl8gPSBuZXcgSW5kZXhlZEZpbHRlcihwYXJhbXMuZ2V0SW5kZXgoKSk7XHJcbiAgICAgICAgdGhpcy5pbmRleF8gPSBwYXJhbXMuZ2V0SW5kZXgoKTtcclxuICAgICAgICB0aGlzLnN0YXJ0UG9zdF8gPSBSYW5nZWRGaWx0ZXIuZ2V0U3RhcnRQb3N0XyhwYXJhbXMpO1xyXG4gICAgICAgIHRoaXMuZW5kUG9zdF8gPSBSYW5nZWRGaWx0ZXIuZ2V0RW5kUG9zdF8ocGFyYW1zKTtcclxuICAgICAgICB0aGlzLnN0YXJ0SXNJbmNsdXNpdmVfID0gIXBhcmFtcy5zdGFydEFmdGVyU2V0XztcclxuICAgICAgICB0aGlzLmVuZElzSW5jbHVzaXZlXyA9ICFwYXJhbXMuZW5kQmVmb3JlU2V0XztcclxuICAgIH1cclxuICAgIGdldFN0YXJ0UG9zdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGFydFBvc3RfO1xyXG4gICAgfVxyXG4gICAgZ2V0RW5kUG9zdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbmRQb3N0XztcclxuICAgIH1cclxuICAgIG1hdGNoZXMobm9kZSkge1xyXG4gICAgICAgIGNvbnN0IGlzV2l0aGluU3RhcnQgPSB0aGlzLnN0YXJ0SXNJbmNsdXNpdmVfXHJcbiAgICAgICAgICAgID8gdGhpcy5pbmRleF8uY29tcGFyZSh0aGlzLmdldFN0YXJ0UG9zdCgpLCBub2RlKSA8PSAwXHJcbiAgICAgICAgICAgIDogdGhpcy5pbmRleF8uY29tcGFyZSh0aGlzLmdldFN0YXJ0UG9zdCgpLCBub2RlKSA8IDA7XHJcbiAgICAgICAgY29uc3QgaXNXaXRoaW5FbmQgPSB0aGlzLmVuZElzSW5jbHVzaXZlX1xyXG4gICAgICAgICAgICA/IHRoaXMuaW5kZXhfLmNvbXBhcmUobm9kZSwgdGhpcy5nZXRFbmRQb3N0KCkpIDw9IDBcclxuICAgICAgICAgICAgOiB0aGlzLmluZGV4Xy5jb21wYXJlKG5vZGUsIHRoaXMuZ2V0RW5kUG9zdCgpKSA8IDA7XHJcbiAgICAgICAgcmV0dXJuIGlzV2l0aGluU3RhcnQgJiYgaXNXaXRoaW5FbmQ7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVDaGlsZChzbmFwLCBrZXksIG5ld0NoaWxkLCBhZmZlY3RlZFBhdGgsIHNvdXJjZSwgb3B0Q2hhbmdlQWNjdW11bGF0b3IpIHtcclxuICAgICAgICBpZiAoIXRoaXMubWF0Y2hlcyhuZXcgTmFtZWROb2RlKGtleSwgbmV3Q2hpbGQpKSkge1xyXG4gICAgICAgICAgICBuZXdDaGlsZCA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleGVkRmlsdGVyXy51cGRhdGVDaGlsZChzbmFwLCBrZXksIG5ld0NoaWxkLCBhZmZlY3RlZFBhdGgsIHNvdXJjZSwgb3B0Q2hhbmdlQWNjdW11bGF0b3IpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlRnVsbE5vZGUob2xkU25hcCwgbmV3U25hcCwgb3B0Q2hhbmdlQWNjdW11bGF0b3IpIHtcclxuICAgICAgICBpZiAobmV3U25hcC5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSBjaGlsZHJlbiBub2RlIHdpdGggdGhlIGNvcnJlY3QgaW5kZXgsIG5vdCBhIGxlYWYgbm9kZTtcclxuICAgICAgICAgICAgbmV3U25hcCA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZmlsdGVyZWQgPSBuZXdTbmFwLndpdGhJbmRleCh0aGlzLmluZGV4Xyk7XHJcbiAgICAgICAgLy8gRG9uJ3Qgc3VwcG9ydCBwcmlvcml0aWVzIG9uIHF1ZXJpZXNcclxuICAgICAgICBmaWx0ZXJlZCA9IGZpbHRlcmVkLnVwZGF0ZVByaW9yaXR5KENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFKTtcclxuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcclxuICAgICAgICBuZXdTbmFwLmZvckVhY2hDaGlsZChQUklPUklUWV9JTkRFWCwgKGtleSwgY2hpbGROb2RlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghc2VsZi5tYXRjaGVzKG5ldyBOYW1lZE5vZGUoa2V5LCBjaGlsZE5vZGUpKSkge1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC51cGRhdGVJbW1lZGlhdGVDaGlsZChrZXksIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4ZWRGaWx0ZXJfLnVwZGF0ZUZ1bGxOb2RlKG9sZFNuYXAsIGZpbHRlcmVkLCBvcHRDaGFuZ2VBY2N1bXVsYXRvcik7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVQcmlvcml0eShvbGRTbmFwLCBuZXdQcmlvcml0eSkge1xyXG4gICAgICAgIC8vIERvbid0IHN1cHBvcnQgcHJpb3JpdGllcyBvbiBxdWVyaWVzXHJcbiAgICAgICAgcmV0dXJuIG9sZFNuYXA7XHJcbiAgICB9XHJcbiAgICBmaWx0ZXJzTm9kZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBnZXRJbmRleGVkRmlsdGVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4ZWRGaWx0ZXJfO1xyXG4gICAgfVxyXG4gICAgZ2V0SW5kZXgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhfO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldFN0YXJ0UG9zdF8ocGFyYW1zKSB7XHJcbiAgICAgICAgaWYgKHBhcmFtcy5oYXNTdGFydCgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0TmFtZSA9IHBhcmFtcy5nZXRJbmRleFN0YXJ0TmFtZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zLmdldEluZGV4KCkubWFrZVBvc3QocGFyYW1zLmdldEluZGV4U3RhcnRWYWx1ZSgpLCBzdGFydE5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5nZXRJbmRleCgpLm1pblBvc3QoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0RW5kUG9zdF8ocGFyYW1zKSB7XHJcbiAgICAgICAgaWYgKHBhcmFtcy5oYXNFbmQoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBlbmROYW1lID0gcGFyYW1zLmdldEluZGV4RW5kTmFtZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zLmdldEluZGV4KCkubWFrZVBvc3QocGFyYW1zLmdldEluZGV4RW5kVmFsdWUoKSwgZW5kTmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zLmdldEluZGV4KCkubWF4UG9zdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQXBwbGllcyBhIGxpbWl0IGFuZCBhIHJhbmdlIHRvIGEgbm9kZSBhbmQgdXNlcyBSYW5nZWRGaWx0ZXIgdG8gZG8gdGhlIGhlYXZ5IGxpZnRpbmcgd2hlcmUgcG9zc2libGVcclxuICovXHJcbmNsYXNzIExpbWl0ZWRGaWx0ZXIge1xyXG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XHJcbiAgICAgICAgdGhpcy53aXRoaW5EaXJlY3Rpb25hbFN0YXJ0ID0gKG5vZGUpID0+IHRoaXMucmV2ZXJzZV8gPyB0aGlzLndpdGhpbkVuZFBvc3Qobm9kZSkgOiB0aGlzLndpdGhpblN0YXJ0UG9zdChub2RlKTtcclxuICAgICAgICB0aGlzLndpdGhpbkRpcmVjdGlvbmFsRW5kID0gKG5vZGUpID0+IHRoaXMucmV2ZXJzZV8gPyB0aGlzLndpdGhpblN0YXJ0UG9zdChub2RlKSA6IHRoaXMud2l0aGluRW5kUG9zdChub2RlKTtcclxuICAgICAgICB0aGlzLndpdGhpblN0YXJ0UG9zdCA9IChub2RlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbXBhcmVSZXMgPSB0aGlzLmluZGV4Xy5jb21wYXJlKHRoaXMucmFuZ2VkRmlsdGVyXy5nZXRTdGFydFBvc3QoKSwgbm9kZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0SXNJbmNsdXNpdmVfID8gY29tcGFyZVJlcyA8PSAwIDogY29tcGFyZVJlcyA8IDA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLndpdGhpbkVuZFBvc3QgPSAobm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjb21wYXJlUmVzID0gdGhpcy5pbmRleF8uY29tcGFyZShub2RlLCB0aGlzLnJhbmdlZEZpbHRlcl8uZ2V0RW5kUG9zdCgpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5kSXNJbmNsdXNpdmVfID8gY29tcGFyZVJlcyA8PSAwIDogY29tcGFyZVJlcyA8IDA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnJhbmdlZEZpbHRlcl8gPSBuZXcgUmFuZ2VkRmlsdGVyKHBhcmFtcyk7XHJcbiAgICAgICAgdGhpcy5pbmRleF8gPSBwYXJhbXMuZ2V0SW5kZXgoKTtcclxuICAgICAgICB0aGlzLmxpbWl0XyA9IHBhcmFtcy5nZXRMaW1pdCgpO1xyXG4gICAgICAgIHRoaXMucmV2ZXJzZV8gPSAhcGFyYW1zLmlzVmlld0Zyb21MZWZ0KCk7XHJcbiAgICAgICAgdGhpcy5zdGFydElzSW5jbHVzaXZlXyA9ICFwYXJhbXMuc3RhcnRBZnRlclNldF87XHJcbiAgICAgICAgdGhpcy5lbmRJc0luY2x1c2l2ZV8gPSAhcGFyYW1zLmVuZEJlZm9yZVNldF87XHJcbiAgICB9XHJcbiAgICB1cGRhdGVDaGlsZChzbmFwLCBrZXksIG5ld0NoaWxkLCBhZmZlY3RlZFBhdGgsIHNvdXJjZSwgb3B0Q2hhbmdlQWNjdW11bGF0b3IpIHtcclxuICAgICAgICBpZiAoIXRoaXMucmFuZ2VkRmlsdGVyXy5tYXRjaGVzKG5ldyBOYW1lZE5vZGUoa2V5LCBuZXdDaGlsZCkpKSB7XHJcbiAgICAgICAgICAgIG5ld0NoaWxkID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzbmFwLmdldEltbWVkaWF0ZUNoaWxkKGtleSkuZXF1YWxzKG5ld0NoaWxkKSkge1xyXG4gICAgICAgICAgICAvLyBObyBjaGFuZ2VcclxuICAgICAgICAgICAgcmV0dXJuIHNuYXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNuYXAubnVtQ2hpbGRyZW4oKSA8IHRoaXMubGltaXRfKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJhbmdlZEZpbHRlcl9cclxuICAgICAgICAgICAgICAgIC5nZXRJbmRleGVkRmlsdGVyKClcclxuICAgICAgICAgICAgICAgIC51cGRhdGVDaGlsZChzbmFwLCBrZXksIG5ld0NoaWxkLCBhZmZlY3RlZFBhdGgsIHNvdXJjZSwgb3B0Q2hhbmdlQWNjdW11bGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnVsbExpbWl0VXBkYXRlQ2hpbGRfKHNuYXAsIGtleSwgbmV3Q2hpbGQsIHNvdXJjZSwgb3B0Q2hhbmdlQWNjdW11bGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVwZGF0ZUZ1bGxOb2RlKG9sZFNuYXAsIG5ld1NuYXAsIG9wdENoYW5nZUFjY3VtdWxhdG9yKSB7XHJcbiAgICAgICAgbGV0IGZpbHRlcmVkO1xyXG4gICAgICAgIGlmIChuZXdTbmFwLmlzTGVhZk5vZGUoKSB8fCBuZXdTbmFwLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIGNoaWxkcmVuIG5vZGUgd2l0aCB0aGUgY29ycmVjdCBpbmRleCwgbm90IGEgbGVhZiBub2RlO1xyXG4gICAgICAgICAgICBmaWx0ZXJlZCA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFLndpdGhJbmRleCh0aGlzLmluZGV4Xyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5saW1pdF8gKiAyIDwgbmV3U25hcC5udW1DaGlsZHJlbigpICYmXHJcbiAgICAgICAgICAgICAgICBuZXdTbmFwLmlzSW5kZXhlZCh0aGlzLmluZGV4XykpIHtcclxuICAgICAgICAgICAgICAgIC8vIEVhc2llciB0byBidWlsZCB1cCBhIHNuYXBzaG90LCBzaW5jZSB3aGF0IHdlJ3JlIGdpdmVuIGhhcyBtb3JlIHRoYW4gdHdpY2UgdGhlIGVsZW1lbnRzIHdlIHdhbnRcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUud2l0aEluZGV4KHRoaXMuaW5kZXhfKTtcclxuICAgICAgICAgICAgICAgIC8vIGFuY2hvciB0byB0aGUgc3RhcnRQb3N0LCBlbmRQb3N0LCBvciBsYXN0IGVsZW1lbnQgYXMgYXBwcm9wcmlhdGVcclxuICAgICAgICAgICAgICAgIGxldCBpdGVyYXRvcjtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJldmVyc2VfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IgPSBuZXdTbmFwLmdldFJldmVyc2VJdGVyYXRvckZyb20odGhpcy5yYW5nZWRGaWx0ZXJfLmdldEVuZFBvc3QoKSwgdGhpcy5pbmRleF8pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IgPSBuZXdTbmFwLmdldEl0ZXJhdG9yRnJvbSh0aGlzLnJhbmdlZEZpbHRlcl8uZ2V0U3RhcnRQb3N0KCksIHRoaXMuaW5kZXhfKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaXRlcmF0b3IuaGFzTmV4dCgpICYmIGNvdW50IDwgdGhpcy5saW1pdF8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gaXRlcmF0b3IuZ2V0TmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy53aXRoaW5EaXJlY3Rpb25hbFN0YXJ0KG5leHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgbm90IHJlYWNoZWQgdGhlIHN0YXJ0LCBza2lwIHRvIHRoZSBuZXh0IGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLndpdGhpbkRpcmVjdGlvbmFsRW5kKG5leHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgcmVhY2hlZCB0aGUgZW5kLCBzdG9wIGFkZGluZyBlbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkID0gZmlsdGVyZWQudXBkYXRlSW1tZWRpYXRlQ2hpbGQobmV4dC5uYW1lLCBuZXh0Lm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBzbmFwIGNvbnRhaW5zIGxlc3MgdGhhbiB0d2ljZSB0aGUgbGltaXQuIEZhc3RlciB0byBkZWxldGUgZnJvbSB0aGUgc25hcCB0aGFuIGJ1aWxkIHVwIGEgbmV3IG9uZVxyXG4gICAgICAgICAgICAgICAgZmlsdGVyZWQgPSBuZXdTbmFwLndpdGhJbmRleCh0aGlzLmluZGV4Xyk7XHJcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBzdXBwb3J0IHByaW9yaXRpZXMgb24gcXVlcmllc1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC51cGRhdGVQcmlvcml0eShDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaXRlcmF0b3I7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXZlcnNlXykge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gZmlsdGVyZWQuZ2V0UmV2ZXJzZUl0ZXJhdG9yKHRoaXMuaW5kZXhfKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gZmlsdGVyZWQuZ2V0SXRlcmF0b3IodGhpcy5pbmRleF8pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChpdGVyYXRvci5oYXNOZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gaXRlcmF0b3IuZ2V0TmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluUmFuZ2UgPSBjb3VudCA8IHRoaXMubGltaXRfICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMud2l0aGluRGlyZWN0aW9uYWxTdGFydChuZXh0KSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndpdGhpbkRpcmVjdGlvbmFsRW5kKG5leHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpblJhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZCA9IGZpbHRlcmVkLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKG5leHQubmFtZSwgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZWRGaWx0ZXJfXHJcbiAgICAgICAgICAgIC5nZXRJbmRleGVkRmlsdGVyKClcclxuICAgICAgICAgICAgLnVwZGF0ZUZ1bGxOb2RlKG9sZFNuYXAsIGZpbHRlcmVkLCBvcHRDaGFuZ2VBY2N1bXVsYXRvcik7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVQcmlvcml0eShvbGRTbmFwLCBuZXdQcmlvcml0eSkge1xyXG4gICAgICAgIC8vIERvbid0IHN1cHBvcnQgcHJpb3JpdGllcyBvbiBxdWVyaWVzXHJcbiAgICAgICAgcmV0dXJuIG9sZFNuYXA7XHJcbiAgICB9XHJcbiAgICBmaWx0ZXJzTm9kZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBnZXRJbmRleGVkRmlsdGVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlZEZpbHRlcl8uZ2V0SW5kZXhlZEZpbHRlcigpO1xyXG4gICAgfVxyXG4gICAgZ2V0SW5kZXgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhfO1xyXG4gICAgfVxyXG4gICAgZnVsbExpbWl0VXBkYXRlQ2hpbGRfKHNuYXAsIGNoaWxkS2V5LCBjaGlsZFNuYXAsIHNvdXJjZSwgY2hhbmdlQWNjdW11bGF0b3IpIHtcclxuICAgICAgICAvLyBUT0RPOiByZW5hbWUgYWxsIGNhY2hlIHN0dWZmIGV0YyB0byBnZW5lcmFsIHNuYXAgdGVybWlub2xvZ3lcclxuICAgICAgICBsZXQgY21wO1xyXG4gICAgICAgIGlmICh0aGlzLnJldmVyc2VfKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4Q21wID0gdGhpcy5pbmRleF8uZ2V0Q29tcGFyZSgpO1xyXG4gICAgICAgICAgICBjbXAgPSAoYSwgYikgPT4gaW5kZXhDbXAoYiwgYSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjbXAgPSB0aGlzLmluZGV4Xy5nZXRDb21wYXJlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9sZEV2ZW50Q2FjaGUgPSBzbmFwO1xyXG4gICAgICAgIGFzc2VydChvbGRFdmVudENhY2hlLm51bUNoaWxkcmVuKCkgPT09IHRoaXMubGltaXRfLCAnJyk7XHJcbiAgICAgICAgY29uc3QgbmV3Q2hpbGROYW1lZE5vZGUgPSBuZXcgTmFtZWROb2RlKGNoaWxkS2V5LCBjaGlsZFNuYXApO1xyXG4gICAgICAgIGNvbnN0IHdpbmRvd0JvdW5kYXJ5ID0gdGhpcy5yZXZlcnNlX1xyXG4gICAgICAgICAgICA/IG9sZEV2ZW50Q2FjaGUuZ2V0Rmlyc3RDaGlsZCh0aGlzLmluZGV4XylcclxuICAgICAgICAgICAgOiBvbGRFdmVudENhY2hlLmdldExhc3RDaGlsZCh0aGlzLmluZGV4Xyk7XHJcbiAgICAgICAgY29uc3QgaW5SYW5nZSA9IHRoaXMucmFuZ2VkRmlsdGVyXy5tYXRjaGVzKG5ld0NoaWxkTmFtZWROb2RlKTtcclxuICAgICAgICBpZiAob2xkRXZlbnRDYWNoZS5oYXNDaGlsZChjaGlsZEtleSkpIHtcclxuICAgICAgICAgICAgY29uc3Qgb2xkQ2hpbGRTbmFwID0gb2xkRXZlbnRDYWNoZS5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSk7XHJcbiAgICAgICAgICAgIGxldCBuZXh0Q2hpbGQgPSBzb3VyY2UuZ2V0Q2hpbGRBZnRlckNoaWxkKHRoaXMuaW5kZXhfLCB3aW5kb3dCb3VuZGFyeSwgdGhpcy5yZXZlcnNlXyk7XHJcbiAgICAgICAgICAgIHdoaWxlIChuZXh0Q2hpbGQgIT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAgICAgKG5leHRDaGlsZC5uYW1lID09PSBjaGlsZEtleSB8fCBvbGRFdmVudENhY2hlLmhhc0NoaWxkKG5leHRDaGlsZC5uYW1lKSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIGEgd2VpcmQgZWRnZSBjYXNlIHdoZXJlIGEgbm9kZSBpcyB1cGRhdGVkIGFzIHBhcnQgb2YgYSBtZXJnZSBpbiB0aGUgd3JpdGUgdHJlZSwgYnV0IGhhc24ndFxyXG4gICAgICAgICAgICAgICAgLy8gYmVlbiBhcHBsaWVkIHRvIHRoZSBsaW1pdGVkIGZpbHRlciB5ZXQuIElnbm9yZSB0aGlzIG5leHQgY2hpbGQgd2hpY2ggd2lsbCBiZSB1cGRhdGVkIGxhdGVyIGluXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgbGltaXRlZCBmaWx0ZXIuLi5cclxuICAgICAgICAgICAgICAgIG5leHRDaGlsZCA9IHNvdXJjZS5nZXRDaGlsZEFmdGVyQ2hpbGQodGhpcy5pbmRleF8sIG5leHRDaGlsZCwgdGhpcy5yZXZlcnNlXyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgY29tcGFyZU5leHQgPSBuZXh0Q2hpbGQgPT0gbnVsbCA/IDEgOiBjbXAobmV4dENoaWxkLCBuZXdDaGlsZE5hbWVkTm9kZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlbWFpbnNJbldpbmRvdyA9IGluUmFuZ2UgJiYgIWNoaWxkU25hcC5pc0VtcHR5KCkgJiYgY29tcGFyZU5leHQgPj0gMDtcclxuICAgICAgICAgICAgaWYgKHJlbWFpbnNJbldpbmRvdykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZUFjY3VtdWxhdG9yICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKGNoYW5nZUNoaWxkQ2hhbmdlZChjaGlsZEtleSwgY2hpbGRTbmFwLCBvbGRDaGlsZFNuYXApKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBvbGRFdmVudENhY2hlLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5LCBjaGlsZFNuYXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZUFjY3VtdWxhdG9yICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKGNoYW5nZUNoaWxkUmVtb3ZlZChjaGlsZEtleSwgb2xkQ2hpbGRTbmFwKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdFdmVudENhY2hlID0gb2xkRXZlbnRDYWNoZS51cGRhdGVJbW1lZGlhdGVDaGlsZChjaGlsZEtleSwgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENoaWxkSW5SYW5nZSA9IG5leHRDaGlsZCAhPSBudWxsICYmIHRoaXMucmFuZ2VkRmlsdGVyXy5tYXRjaGVzKG5leHRDaGlsZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dENoaWxkSW5SYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VBY2N1bXVsYXRvciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZUFjY3VtdWxhdG9yLnRyYWNrQ2hpbGRDaGFuZ2UoY2hhbmdlQ2hpbGRBZGRlZChuZXh0Q2hpbGQubmFtZSwgbmV4dENoaWxkLm5vZGUpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld0V2ZW50Q2FjaGUudXBkYXRlSW1tZWRpYXRlQ2hpbGQobmV4dENoaWxkLm5hbWUsIG5leHRDaGlsZC5ub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdFdmVudENhY2hlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNoaWxkU25hcC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgLy8gd2UncmUgZGVsZXRpbmcgYSBub2RlLCBidXQgaXQgd2FzIG5vdCBpbiB0aGUgd2luZG93LCBzbyBpZ25vcmUgaXRcclxuICAgICAgICAgICAgcmV0dXJuIHNuYXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGluUmFuZ2UpIHtcclxuICAgICAgICAgICAgaWYgKGNtcCh3aW5kb3dCb3VuZGFyeSwgbmV3Q2hpbGROYW1lZE5vZGUpID49IDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VBY2N1bXVsYXRvciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlQWNjdW11bGF0b3IudHJhY2tDaGlsZENoYW5nZShjaGFuZ2VDaGlsZFJlbW92ZWQod2luZG93Qm91bmRhcnkubmFtZSwgd2luZG93Qm91bmRhcnkubm9kZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUFjY3VtdWxhdG9yLnRyYWNrQ2hpbGRDaGFuZ2UoY2hhbmdlQ2hpbGRBZGRlZChjaGlsZEtleSwgY2hpbGRTbmFwKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2xkRXZlbnRDYWNoZVxyXG4gICAgICAgICAgICAgICAgICAgIC51cGRhdGVJbW1lZGlhdGVDaGlsZChjaGlsZEtleSwgY2hpbGRTbmFwKVxyXG4gICAgICAgICAgICAgICAgICAgIC51cGRhdGVJbW1lZGlhdGVDaGlsZCh3aW5kb3dCb3VuZGFyeS5uYW1lLCBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc25hcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNuYXA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIGlzIGFuIGltbXV0YWJsZS1mcm9tLXRoZS1wdWJsaWMtYXBpIHN0cnVjdCBjb250YWluaW5nIGEgc2V0IG9mIHF1ZXJ5IHBhcmFtZXRlcnMgZGVmaW5pbmcgYVxyXG4gKiByYW5nZSB0byBiZSByZXR1cm5lZCBmb3IgYSBwYXJ0aWN1bGFyIGxvY2F0aW9uLiBJdCBpcyBhc3N1bWVkIHRoYXQgdmFsaWRhdGlvbiBvZiBwYXJhbWV0ZXJzIGlzIGRvbmUgYXQgdGhlXHJcbiAqIHVzZXItZmFjaW5nIEFQSSBsZXZlbCwgc28gaXQgaXMgbm90IGRvbmUgaGVyZS5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jbGFzcyBRdWVyeVBhcmFtcyB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmxpbWl0U2V0XyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc3RhcnRTZXRfID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zdGFydE5hbWVTZXRfID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zdGFydEFmdGVyU2V0XyA9IGZhbHNlOyAvLyBjYW4gb25seSBiZSB0cnVlIGlmIHN0YXJ0U2V0XyBpcyB0cnVlXHJcbiAgICAgICAgdGhpcy5lbmRTZXRfID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5lbmROYW1lU2V0XyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZW5kQmVmb3JlU2V0XyA9IGZhbHNlOyAvLyBjYW4gb25seSBiZSB0cnVlIGlmIGVuZFNldF8gaXMgdHJ1ZVxyXG4gICAgICAgIHRoaXMubGltaXRfID0gMDtcclxuICAgICAgICB0aGlzLnZpZXdGcm9tXyA9ICcnO1xyXG4gICAgICAgIHRoaXMuaW5kZXhTdGFydFZhbHVlXyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pbmRleFN0YXJ0TmFtZV8gPSAnJztcclxuICAgICAgICB0aGlzLmluZGV4RW5kVmFsdWVfID0gbnVsbDtcclxuICAgICAgICB0aGlzLmluZGV4RW5kTmFtZV8gPSAnJztcclxuICAgICAgICB0aGlzLmluZGV4XyA9IFBSSU9SSVRZX0lOREVYO1xyXG4gICAgfVxyXG4gICAgaGFzU3RhcnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRTZXRfO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIGl0IHdvdWxkIHJldHVybiBmcm9tIGxlZnQuXHJcbiAgICAgKi9cclxuICAgIGlzVmlld0Zyb21MZWZ0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLnZpZXdGcm9tXyA9PT0gJycpIHtcclxuICAgICAgICAgICAgLy8gbGltaXQoKSwgcmF0aGVyIHRoYW4gbGltaXRUb0ZpcnN0IG9yIGxpbWl0VG9MYXN0IHdhcyBjYWxsZWQuXHJcbiAgICAgICAgICAgIC8vIFRoaXMgbWVhbnMgdGhhdCBvbmx5IG9uZSBvZiBzdGFydFNldF8gYW5kIGVuZFNldF8gaXMgdHJ1ZS4gVXNlIHRoZW1cclxuICAgICAgICAgICAgLy8gdG8gY2FsY3VsYXRlIHdoaWNoIHNpZGUgb2YgdGhlIHZpZXcgdG8gYW5jaG9yIHRvLiBJZiBuZWl0aGVyIGlzIHNldCxcclxuICAgICAgICAgICAgLy8gYW5jaG9yIHRvIHRoZSBlbmQuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0U2V0XztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXdGcm9tXyA9PT0gXCJsXCIgLyogV0lSRV9QUk9UT0NPTF9DT05TVEFOVFMuVklFV19GUk9NX0xFRlQgKi87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPbmx5IHZhbGlkIHRvIGNhbGwgaWYgaGFzU3RhcnQoKSByZXR1cm5zIHRydWVcclxuICAgICAqL1xyXG4gICAgZ2V0SW5kZXhTdGFydFZhbHVlKCkge1xyXG4gICAgICAgIGFzc2VydCh0aGlzLnN0YXJ0U2V0XywgJ09ubHkgdmFsaWQgaWYgc3RhcnQgaGFzIGJlZW4gc2V0Jyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhTdGFydFZhbHVlXztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT25seSB2YWxpZCB0byBjYWxsIGlmIGhhc1N0YXJ0KCkgcmV0dXJucyB0cnVlLlxyXG4gICAgICogUmV0dXJucyB0aGUgc3RhcnRpbmcga2V5IG5hbWUgZm9yIHRoZSByYW5nZSBkZWZpbmVkIGJ5IHRoZXNlIHF1ZXJ5IHBhcmFtZXRlcnNcclxuICAgICAqL1xyXG4gICAgZ2V0SW5kZXhTdGFydE5hbWUoKSB7XHJcbiAgICAgICAgYXNzZXJ0KHRoaXMuc3RhcnRTZXRfLCAnT25seSB2YWxpZCBpZiBzdGFydCBoYXMgYmVlbiBzZXQnKTtcclxuICAgICAgICBpZiAodGhpcy5zdGFydE5hbWVTZXRfKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4U3RhcnROYW1lXztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNSU5fTkFNRTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBoYXNFbmQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kU2V0XztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT25seSB2YWxpZCB0byBjYWxsIGlmIGhhc0VuZCgpIHJldHVybnMgdHJ1ZS5cclxuICAgICAqL1xyXG4gICAgZ2V0SW5kZXhFbmRWYWx1ZSgpIHtcclxuICAgICAgICBhc3NlcnQodGhpcy5lbmRTZXRfLCAnT25seSB2YWxpZCBpZiBlbmQgaGFzIGJlZW4gc2V0Jyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhFbmRWYWx1ZV87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE9ubHkgdmFsaWQgdG8gY2FsbCBpZiBoYXNFbmQoKSByZXR1cm5zIHRydWUuXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBlbmQga2V5IG5hbWUgZm9yIHRoZSByYW5nZSBkZWZpbmVkIGJ5IHRoZXNlIHF1ZXJ5IHBhcmFtZXRlcnNcclxuICAgICAqL1xyXG4gICAgZ2V0SW5kZXhFbmROYW1lKCkge1xyXG4gICAgICAgIGFzc2VydCh0aGlzLmVuZFNldF8sICdPbmx5IHZhbGlkIGlmIGVuZCBoYXMgYmVlbiBzZXQnKTtcclxuICAgICAgICBpZiAodGhpcy5lbmROYW1lU2V0Xykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleEVuZE5hbWVfO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1BWF9OQU1FO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGhhc0xpbWl0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxpbWl0U2V0XztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiBhIGxpbWl0IGhhcyBiZWVuIHNldCBhbmQgaXQgaGFzIGJlZW4gZXhwbGljaXRseSBhbmNob3JlZFxyXG4gICAgICovXHJcbiAgICBoYXNBbmNob3JlZExpbWl0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxpbWl0U2V0XyAmJiB0aGlzLnZpZXdGcm9tXyAhPT0gJyc7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE9ubHkgdmFsaWQgdG8gY2FsbCBpZiBoYXNMaW1pdCgpIHJldHVybnMgdHJ1ZVxyXG4gICAgICovXHJcbiAgICBnZXRMaW1pdCgpIHtcclxuICAgICAgICBhc3NlcnQodGhpcy5saW1pdFNldF8sICdPbmx5IHZhbGlkIGlmIGxpbWl0IGhhcyBiZWVuIHNldCcpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxpbWl0XztcclxuICAgIH1cclxuICAgIGdldEluZGV4KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4XztcclxuICAgIH1cclxuICAgIGxvYWRzQWxsRGF0YSgpIHtcclxuICAgICAgICByZXR1cm4gISh0aGlzLnN0YXJ0U2V0XyB8fCB0aGlzLmVuZFNldF8gfHwgdGhpcy5saW1pdFNldF8pO1xyXG4gICAgfVxyXG4gICAgaXNEZWZhdWx0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRzQWxsRGF0YSgpICYmIHRoaXMuaW5kZXhfID09PSBQUklPUklUWV9JTkRFWDtcclxuICAgIH1cclxuICAgIGNvcHkoKSB7XHJcbiAgICAgICAgY29uc3QgY29weSA9IG5ldyBRdWVyeVBhcmFtcygpO1xyXG4gICAgICAgIGNvcHkubGltaXRTZXRfID0gdGhpcy5saW1pdFNldF87XHJcbiAgICAgICAgY29weS5saW1pdF8gPSB0aGlzLmxpbWl0XztcclxuICAgICAgICBjb3B5LnN0YXJ0U2V0XyA9IHRoaXMuc3RhcnRTZXRfO1xyXG4gICAgICAgIGNvcHkuc3RhcnRBZnRlclNldF8gPSB0aGlzLnN0YXJ0QWZ0ZXJTZXRfO1xyXG4gICAgICAgIGNvcHkuaW5kZXhTdGFydFZhbHVlXyA9IHRoaXMuaW5kZXhTdGFydFZhbHVlXztcclxuICAgICAgICBjb3B5LnN0YXJ0TmFtZVNldF8gPSB0aGlzLnN0YXJ0TmFtZVNldF87XHJcbiAgICAgICAgY29weS5pbmRleFN0YXJ0TmFtZV8gPSB0aGlzLmluZGV4U3RhcnROYW1lXztcclxuICAgICAgICBjb3B5LmVuZFNldF8gPSB0aGlzLmVuZFNldF87XHJcbiAgICAgICAgY29weS5lbmRCZWZvcmVTZXRfID0gdGhpcy5lbmRCZWZvcmVTZXRfO1xyXG4gICAgICAgIGNvcHkuaW5kZXhFbmRWYWx1ZV8gPSB0aGlzLmluZGV4RW5kVmFsdWVfO1xyXG4gICAgICAgIGNvcHkuZW5kTmFtZVNldF8gPSB0aGlzLmVuZE5hbWVTZXRfO1xyXG4gICAgICAgIGNvcHkuaW5kZXhFbmROYW1lXyA9IHRoaXMuaW5kZXhFbmROYW1lXztcclxuICAgICAgICBjb3B5LmluZGV4XyA9IHRoaXMuaW5kZXhfO1xyXG4gICAgICAgIGNvcHkudmlld0Zyb21fID0gdGhpcy52aWV3RnJvbV87XHJcbiAgICAgICAgcmV0dXJuIGNvcHk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlQYXJhbXNHZXROb2RlRmlsdGVyKHF1ZXJ5UGFyYW1zKSB7XHJcbiAgICBpZiAocXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEluZGV4ZWRGaWx0ZXIocXVlcnlQYXJhbXMuZ2V0SW5kZXgoKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChxdWVyeVBhcmFtcy5oYXNMaW1pdCgpKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMaW1pdGVkRmlsdGVyKHF1ZXJ5UGFyYW1zKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2VkRmlsdGVyKHF1ZXJ5UGFyYW1zKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBxdWVyeVBhcmFtc0xpbWl0VG9GaXJzdChxdWVyeVBhcmFtcywgbmV3TGltaXQpIHtcclxuICAgIGNvbnN0IG5ld1BhcmFtcyA9IHF1ZXJ5UGFyYW1zLmNvcHkoKTtcclxuICAgIG5ld1BhcmFtcy5saW1pdFNldF8gPSB0cnVlO1xyXG4gICAgbmV3UGFyYW1zLmxpbWl0XyA9IG5ld0xpbWl0O1xyXG4gICAgbmV3UGFyYW1zLnZpZXdGcm9tXyA9IFwibFwiIC8qIFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLlZJRVdfRlJPTV9MRUZUICovO1xyXG4gICAgcmV0dXJuIG5ld1BhcmFtcztcclxufVxyXG5mdW5jdGlvbiBxdWVyeVBhcmFtc0xpbWl0VG9MYXN0KHF1ZXJ5UGFyYW1zLCBuZXdMaW1pdCkge1xyXG4gICAgY29uc3QgbmV3UGFyYW1zID0gcXVlcnlQYXJhbXMuY29weSgpO1xyXG4gICAgbmV3UGFyYW1zLmxpbWl0U2V0XyA9IHRydWU7XHJcbiAgICBuZXdQYXJhbXMubGltaXRfID0gbmV3TGltaXQ7XHJcbiAgICBuZXdQYXJhbXMudmlld0Zyb21fID0gXCJyXCIgLyogV0lSRV9QUk9UT0NPTF9DT05TVEFOVFMuVklFV19GUk9NX1JJR0hUICovO1xyXG4gICAgcmV0dXJuIG5ld1BhcmFtcztcclxufVxyXG5mdW5jdGlvbiBxdWVyeVBhcmFtc1N0YXJ0QXQocXVlcnlQYXJhbXMsIGluZGV4VmFsdWUsIGtleSkge1xyXG4gICAgY29uc3QgbmV3UGFyYW1zID0gcXVlcnlQYXJhbXMuY29weSgpO1xyXG4gICAgbmV3UGFyYW1zLnN0YXJ0U2V0XyA9IHRydWU7XHJcbiAgICBpZiAoaW5kZXhWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaW5kZXhWYWx1ZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBuZXdQYXJhbXMuaW5kZXhTdGFydFZhbHVlXyA9IGluZGV4VmFsdWU7XHJcbiAgICBpZiAoa2V5ICE9IG51bGwpIHtcclxuICAgICAgICBuZXdQYXJhbXMuc3RhcnROYW1lU2V0XyA9IHRydWU7XHJcbiAgICAgICAgbmV3UGFyYW1zLmluZGV4U3RhcnROYW1lXyA9IGtleTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIG5ld1BhcmFtcy5zdGFydE5hbWVTZXRfID0gZmFsc2U7XHJcbiAgICAgICAgbmV3UGFyYW1zLmluZGV4U3RhcnROYW1lXyA9ICcnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ld1BhcmFtcztcclxufVxyXG5mdW5jdGlvbiBxdWVyeVBhcmFtc1N0YXJ0QWZ0ZXIocXVlcnlQYXJhbXMsIGluZGV4VmFsdWUsIGtleSkge1xyXG4gICAgbGV0IHBhcmFtcztcclxuICAgIGlmIChxdWVyeVBhcmFtcy5pbmRleF8gPT09IEtFWV9JTkRFWCB8fCAhIWtleSkge1xyXG4gICAgICAgIHBhcmFtcyA9IHF1ZXJ5UGFyYW1zU3RhcnRBdChxdWVyeVBhcmFtcywgaW5kZXhWYWx1ZSwga2V5KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHBhcmFtcyA9IHF1ZXJ5UGFyYW1zU3RhcnRBdChxdWVyeVBhcmFtcywgaW5kZXhWYWx1ZSwgTUFYX05BTUUpO1xyXG4gICAgfVxyXG4gICAgcGFyYW1zLnN0YXJ0QWZ0ZXJTZXRfID0gdHJ1ZTtcclxuICAgIHJldHVybiBwYXJhbXM7XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlQYXJhbXNFbmRBdChxdWVyeVBhcmFtcywgaW5kZXhWYWx1ZSwga2V5KSB7XHJcbiAgICBjb25zdCBuZXdQYXJhbXMgPSBxdWVyeVBhcmFtcy5jb3B5KCk7XHJcbiAgICBuZXdQYXJhbXMuZW5kU2V0XyA9IHRydWU7XHJcbiAgICBpZiAoaW5kZXhWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaW5kZXhWYWx1ZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBuZXdQYXJhbXMuaW5kZXhFbmRWYWx1ZV8gPSBpbmRleFZhbHVlO1xyXG4gICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgbmV3UGFyYW1zLmVuZE5hbWVTZXRfID0gdHJ1ZTtcclxuICAgICAgICBuZXdQYXJhbXMuaW5kZXhFbmROYW1lXyA9IGtleTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIG5ld1BhcmFtcy5lbmROYW1lU2V0XyA9IGZhbHNlO1xyXG4gICAgICAgIG5ld1BhcmFtcy5pbmRleEVuZE5hbWVfID0gJyc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3UGFyYW1zO1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXJ5UGFyYW1zRW5kQmVmb3JlKHF1ZXJ5UGFyYW1zLCBpbmRleFZhbHVlLCBrZXkpIHtcclxuICAgIGxldCBwYXJhbXM7XHJcbiAgICBpZiAocXVlcnlQYXJhbXMuaW5kZXhfID09PSBLRVlfSU5ERVggfHwgISFrZXkpIHtcclxuICAgICAgICBwYXJhbXMgPSBxdWVyeVBhcmFtc0VuZEF0KHF1ZXJ5UGFyYW1zLCBpbmRleFZhbHVlLCBrZXkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcGFyYW1zID0gcXVlcnlQYXJhbXNFbmRBdChxdWVyeVBhcmFtcywgaW5kZXhWYWx1ZSwgTUlOX05BTUUpO1xyXG4gICAgfVxyXG4gICAgcGFyYW1zLmVuZEJlZm9yZVNldF8gPSB0cnVlO1xyXG4gICAgcmV0dXJuIHBhcmFtcztcclxufVxyXG5mdW5jdGlvbiBxdWVyeVBhcmFtc09yZGVyQnkocXVlcnlQYXJhbXMsIGluZGV4KSB7XHJcbiAgICBjb25zdCBuZXdQYXJhbXMgPSBxdWVyeVBhcmFtcy5jb3B5KCk7XHJcbiAgICBuZXdQYXJhbXMuaW5kZXhfID0gaW5kZXg7XHJcbiAgICByZXR1cm4gbmV3UGFyYW1zO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgc2V0IG9mIFJFU1QgcXVlcnkgc3RyaW5nIHBhcmFtZXRlcnMgcmVwcmVzZW50aW5nIHRoaXMgcXVlcnkuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHF1ZXJ5IHN0cmluZyBwYXJhbWV0ZXJzXHJcbiAqL1xyXG5mdW5jdGlvbiBxdWVyeVBhcmFtc1RvUmVzdFF1ZXJ5U3RyaW5nUGFyYW1ldGVycyhxdWVyeVBhcmFtcykge1xyXG4gICAgY29uc3QgcXMgPSB7fTtcclxuICAgIGlmIChxdWVyeVBhcmFtcy5pc0RlZmF1bHQoKSkge1xyXG4gICAgICAgIHJldHVybiBxcztcclxuICAgIH1cclxuICAgIGxldCBvcmRlckJ5O1xyXG4gICAgaWYgKHF1ZXJ5UGFyYW1zLmluZGV4XyA9PT0gUFJJT1JJVFlfSU5ERVgpIHtcclxuICAgICAgICBvcmRlckJ5ID0gXCIkcHJpb3JpdHlcIiAvKiBSRVNUX1FVRVJZX0NPTlNUQU5UUy5QUklPUklUWV9JTkRFWCAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHF1ZXJ5UGFyYW1zLmluZGV4XyA9PT0gVkFMVUVfSU5ERVgpIHtcclxuICAgICAgICBvcmRlckJ5ID0gXCIkdmFsdWVcIiAvKiBSRVNUX1FVRVJZX0NPTlNUQU5UUy5WQUxVRV9JTkRFWCAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHF1ZXJ5UGFyYW1zLmluZGV4XyA9PT0gS0VZX0lOREVYKSB7XHJcbiAgICAgICAgb3JkZXJCeSA9IFwiJGtleVwiIC8qIFJFU1RfUVVFUllfQ09OU1RBTlRTLktFWV9JTkRFWCAqLztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFzc2VydChxdWVyeVBhcmFtcy5pbmRleF8gaW5zdGFuY2VvZiBQYXRoSW5kZXgsICdVbnJlY29nbml6ZWQgaW5kZXggdHlwZSEnKTtcclxuICAgICAgICBvcmRlckJ5ID0gcXVlcnlQYXJhbXMuaW5kZXhfLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICBxc1tcIm9yZGVyQnlcIiAvKiBSRVNUX1FVRVJZX0NPTlNUQU5UUy5PUkRFUl9CWSAqL10gPSBzdHJpbmdpZnkob3JkZXJCeSk7XHJcbiAgICBpZiAocXVlcnlQYXJhbXMuc3RhcnRTZXRfKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhcnRQYXJhbSA9IHF1ZXJ5UGFyYW1zLnN0YXJ0QWZ0ZXJTZXRfXHJcbiAgICAgICAgICAgID8gXCJzdGFydEFmdGVyXCIgLyogUkVTVF9RVUVSWV9DT05TVEFOVFMuU1RBUlRfQUZURVIgKi9cclxuICAgICAgICAgICAgOiBcInN0YXJ0QXRcIiAvKiBSRVNUX1FVRVJZX0NPTlNUQU5UUy5TVEFSVF9BVCAqLztcclxuICAgICAgICBxc1tzdGFydFBhcmFtXSA9IHN0cmluZ2lmeShxdWVyeVBhcmFtcy5pbmRleFN0YXJ0VmFsdWVfKTtcclxuICAgICAgICBpZiAocXVlcnlQYXJhbXMuc3RhcnROYW1lU2V0Xykge1xyXG4gICAgICAgICAgICBxc1tzdGFydFBhcmFtXSArPSAnLCcgKyBzdHJpbmdpZnkocXVlcnlQYXJhbXMuaW5kZXhTdGFydE5hbWVfKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocXVlcnlQYXJhbXMuZW5kU2V0Xykge1xyXG4gICAgICAgIGNvbnN0IGVuZFBhcmFtID0gcXVlcnlQYXJhbXMuZW5kQmVmb3JlU2V0X1xyXG4gICAgICAgICAgICA/IFwiZW5kQmVmb3JlXCIgLyogUkVTVF9RVUVSWV9DT05TVEFOVFMuRU5EX0JFRk9SRSAqL1xyXG4gICAgICAgICAgICA6IFwiZW5kQXRcIiAvKiBSRVNUX1FVRVJZX0NPTlNUQU5UUy5FTkRfQVQgKi87XHJcbiAgICAgICAgcXNbZW5kUGFyYW1dID0gc3RyaW5naWZ5KHF1ZXJ5UGFyYW1zLmluZGV4RW5kVmFsdWVfKTtcclxuICAgICAgICBpZiAocXVlcnlQYXJhbXMuZW5kTmFtZVNldF8pIHtcclxuICAgICAgICAgICAgcXNbZW5kUGFyYW1dICs9ICcsJyArIHN0cmluZ2lmeShxdWVyeVBhcmFtcy5pbmRleEVuZE5hbWVfKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocXVlcnlQYXJhbXMubGltaXRTZXRfKSB7XHJcbiAgICAgICAgaWYgKHF1ZXJ5UGFyYW1zLmlzVmlld0Zyb21MZWZ0KCkpIHtcclxuICAgICAgICAgICAgcXNbXCJsaW1pdFRvRmlyc3RcIiAvKiBSRVNUX1FVRVJZX0NPTlNUQU5UUy5MSU1JVF9UT19GSVJTVCAqL10gPSBxdWVyeVBhcmFtcy5saW1pdF87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBxc1tcImxpbWl0VG9MYXN0XCIgLyogUkVTVF9RVUVSWV9DT05TVEFOVFMuTElNSVRfVE9fTEFTVCAqL10gPSBxdWVyeVBhcmFtcy5saW1pdF87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHFzO1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXJ5UGFyYW1zR2V0UXVlcnlPYmplY3QocXVlcnlQYXJhbXMpIHtcclxuICAgIGNvbnN0IG9iaiA9IHt9O1xyXG4gICAgaWYgKHF1ZXJ5UGFyYW1zLnN0YXJ0U2V0Xykge1xyXG4gICAgICAgIG9ialtcInNwXCIgLyogV0lSRV9QUk9UT0NPTF9DT05TVEFOVFMuSU5ERVhfU1RBUlRfVkFMVUUgKi9dID1cclxuICAgICAgICAgICAgcXVlcnlQYXJhbXMuaW5kZXhTdGFydFZhbHVlXztcclxuICAgICAgICBpZiAocXVlcnlQYXJhbXMuc3RhcnROYW1lU2V0Xykge1xyXG4gICAgICAgICAgICBvYmpbXCJzblwiIC8qIFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLklOREVYX1NUQVJUX05BTUUgKi9dID1cclxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLmluZGV4U3RhcnROYW1lXztcclxuICAgICAgICB9XHJcbiAgICAgICAgb2JqW1wic2luXCIgLyogV0lSRV9QUk9UT0NPTF9DT05TVEFOVFMuSU5ERVhfU1RBUlRfSVNfSU5DTFVTSVZFICovXSA9XHJcbiAgICAgICAgICAgICFxdWVyeVBhcmFtcy5zdGFydEFmdGVyU2V0XztcclxuICAgIH1cclxuICAgIGlmIChxdWVyeVBhcmFtcy5lbmRTZXRfKSB7XHJcbiAgICAgICAgb2JqW1wiZXBcIiAvKiBXSVJFX1BST1RPQ09MX0NPTlNUQU5UUy5JTkRFWF9FTkRfVkFMVUUgKi9dID0gcXVlcnlQYXJhbXMuaW5kZXhFbmRWYWx1ZV87XHJcbiAgICAgICAgaWYgKHF1ZXJ5UGFyYW1zLmVuZE5hbWVTZXRfKSB7XHJcbiAgICAgICAgICAgIG9ialtcImVuXCIgLyogV0lSRV9QUk9UT0NPTF9DT05TVEFOVFMuSU5ERVhfRU5EX05BTUUgKi9dID0gcXVlcnlQYXJhbXMuaW5kZXhFbmROYW1lXztcclxuICAgICAgICB9XHJcbiAgICAgICAgb2JqW1wiZWluXCIgLyogV0lSRV9QUk9UT0NPTF9DT05TVEFOVFMuSU5ERVhfRU5EX0lTX0lOQ0xVU0lWRSAqL10gPVxyXG4gICAgICAgICAgICAhcXVlcnlQYXJhbXMuZW5kQmVmb3JlU2V0XztcclxuICAgIH1cclxuICAgIGlmIChxdWVyeVBhcmFtcy5saW1pdFNldF8pIHtcclxuICAgICAgICBvYmpbXCJsXCIgLyogV0lSRV9QUk9UT0NPTF9DT05TVEFOVFMuTElNSVQgKi9dID0gcXVlcnlQYXJhbXMubGltaXRfO1xyXG4gICAgICAgIGxldCB2aWV3RnJvbSA9IHF1ZXJ5UGFyYW1zLnZpZXdGcm9tXztcclxuICAgICAgICBpZiAodmlld0Zyb20gPT09ICcnKSB7XHJcbiAgICAgICAgICAgIGlmIChxdWVyeVBhcmFtcy5pc1ZpZXdGcm9tTGVmdCgpKSB7XHJcbiAgICAgICAgICAgICAgICB2aWV3RnJvbSA9IFwibFwiIC8qIFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLlZJRVdfRlJPTV9MRUZUICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmlld0Zyb20gPSBcInJcIiAvKiBXSVJFX1BST1RPQ09MX0NPTlNUQU5UUy5WSUVXX0ZST01fUklHSFQgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgb2JqW1widmZcIiAvKiBXSVJFX1BST1RPQ09MX0NPTlNUQU5UUy5WSUVXX0ZST00gKi9dID0gdmlld0Zyb207XHJcbiAgICB9XHJcbiAgICAvLyBGb3Igbm93LCBwcmlvcml0eSBpbmRleCBpcyB0aGUgZGVmYXVsdCwgc28gd2Ugb25seSBzcGVjaWZ5IGlmIGl0J3Mgc29tZSBvdGhlciBpbmRleFxyXG4gICAgaWYgKHF1ZXJ5UGFyYW1zLmluZGV4XyAhPT0gUFJJT1JJVFlfSU5ERVgpIHtcclxuICAgICAgICBvYmpbXCJpXCIgLyogV0lSRV9QUk9UT0NPTF9DT05TVEFOVFMuSU5ERVggKi9dID0gcXVlcnlQYXJhbXMuaW5kZXhfLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2JqO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBTZXJ2ZXJBY3Rpb25zIHRoYXQgY29tbXVuaWNhdGVzIHdpdGggdGhlIHNlcnZlciB2aWEgUkVTVCByZXF1ZXN0cy5cclxuICogVGhpcyBpcyBtb3N0bHkgdXNlZnVsIGZvciBjb21wYXRpYmlsaXR5IHdpdGggY3Jhd2xlcnMsIHdoZXJlIHdlIGRvbid0IHdhbnQgdG8gc3BpbiB1cCBhIGZ1bGxcclxuICogcGVyc2lzdGVudCBjb25uZWN0aW9uICh1c2luZyBXZWJTb2NrZXRzIG9yIGxvbmctcG9sbGluZylcclxuICovXHJcbmNsYXNzIFJlYWRvbmx5UmVzdENsaWVudCBleHRlbmRzIFNlcnZlckFjdGlvbnMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gcmVwb0luZm9fIC0gRGF0YSBhYm91dCB0aGUgbmFtZXNwYWNlIHdlIGFyZSBjb25uZWN0aW5nIHRvXHJcbiAgICAgKiBAcGFyYW0gb25EYXRhVXBkYXRlXyAtIEEgY2FsbGJhY2sgZm9yIG5ldyBkYXRhIGZyb20gdGhlIHNlcnZlclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihyZXBvSW5mb18sIG9uRGF0YVVwZGF0ZV8sIGF1dGhUb2tlblByb3ZpZGVyXywgYXBwQ2hlY2tUb2tlblByb3ZpZGVyXykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5yZXBvSW5mb18gPSByZXBvSW5mb187XHJcbiAgICAgICAgdGhpcy5vbkRhdGFVcGRhdGVfID0gb25EYXRhVXBkYXRlXztcclxuICAgICAgICB0aGlzLmF1dGhUb2tlblByb3ZpZGVyXyA9IGF1dGhUb2tlblByb3ZpZGVyXztcclxuICAgICAgICB0aGlzLmFwcENoZWNrVG9rZW5Qcm92aWRlcl8gPSBhcHBDaGVja1Rva2VuUHJvdmlkZXJfO1xyXG4gICAgICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oLi4uWypdKX0gKi9cclxuICAgICAgICB0aGlzLmxvZ18gPSBsb2dXcmFwcGVyKCdwOnJlc3Q6Jyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2UgZG9uJ3QgYWN0dWFsbHkgbmVlZCB0byB0cmFjayBsaXN0ZW5zLCBleGNlcHQgdG8gcHJldmVudCB1cyBjYWxsaW5nIGFuIG9uQ29tcGxldGUgZm9yIGEgbGlzdGVuXHJcbiAgICAgICAgICogdGhhdCdzIGJlZW4gcmVtb3ZlZC4gOi0vXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5saXN0ZW5zXyA9IHt9O1xyXG4gICAgfVxyXG4gICAgcmVwb3J0U3RhdHMoc3RhdHMpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0TGlzdGVuSWRfKHF1ZXJ5LCB0YWcpIHtcclxuICAgICAgICBpZiAodGFnICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuICd0YWckJyArIHRhZztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFzc2VydChxdWVyeS5fcXVlcnlQYXJhbXMuaXNEZWZhdWx0KCksIFwic2hvdWxkIGhhdmUgYSB0YWcgaWYgaXQncyBub3QgYSBkZWZhdWx0IHF1ZXJ5LlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5Ll9wYXRoLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBsaXN0ZW4ocXVlcnksIGN1cnJlbnRIYXNoRm4sIHRhZywgb25Db21wbGV0ZSkge1xyXG4gICAgICAgIGNvbnN0IHBhdGhTdHJpbmcgPSBxdWVyeS5fcGF0aC50b1N0cmluZygpO1xyXG4gICAgICAgIHRoaXMubG9nXygnTGlzdGVuIGNhbGxlZCBmb3IgJyArIHBhdGhTdHJpbmcgKyAnICcgKyBxdWVyeS5fcXVlcnlJZGVudGlmaWVyKTtcclxuICAgICAgICAvLyBNYXJrIHRoaXMgbGlzdGVuZXIgc28gd2UgY2FuIHRlbGwgaWYgaXQncyByZW1vdmVkLlxyXG4gICAgICAgIGNvbnN0IGxpc3RlbklkID0gUmVhZG9ubHlSZXN0Q2xpZW50LmdldExpc3RlbklkXyhxdWVyeSwgdGFnKTtcclxuICAgICAgICBjb25zdCB0aGlzTGlzdGVuID0ge307XHJcbiAgICAgICAgdGhpcy5saXN0ZW5zX1tsaXN0ZW5JZF0gPSB0aGlzTGlzdGVuO1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5U3RyaW5nUGFyYW1ldGVycyA9IHF1ZXJ5UGFyYW1zVG9SZXN0UXVlcnlTdHJpbmdQYXJhbWV0ZXJzKHF1ZXJ5Ll9xdWVyeVBhcmFtcyk7XHJcbiAgICAgICAgdGhpcy5yZXN0UmVxdWVzdF8ocGF0aFN0cmluZyArICcuanNvbicsIHF1ZXJ5U3RyaW5nUGFyYW1ldGVycywgKGVycm9yLCByZXN1bHQpID0+IHtcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSByZXN1bHQ7XHJcbiAgICAgICAgICAgIGlmIChlcnJvciA9PT0gNDA0KSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGVycm9yID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZXJyb3IgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub25EYXRhVXBkYXRlXyhwYXRoU3RyaW5nLCBkYXRhLCAvKmlzTWVyZ2U9Ki8gZmFsc2UsIHRhZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNhZmVHZXQodGhpcy5saXN0ZW5zXywgbGlzdGVuSWQpID09PSB0aGlzTGlzdGVuKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3RhdHVzO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9ICdvayc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlcnJvciA9PT0gNDAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gJ3Blcm1pc3Npb25fZGVuaWVkJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9ICdyZXN0X2Vycm9yOicgKyBlcnJvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG9uQ29tcGxldGUoc3RhdHVzLCBudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICB1bmxpc3RlbihxdWVyeSwgdGFnKSB7XHJcbiAgICAgICAgY29uc3QgbGlzdGVuSWQgPSBSZWFkb25seVJlc3RDbGllbnQuZ2V0TGlzdGVuSWRfKHF1ZXJ5LCB0YWcpO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLmxpc3RlbnNfW2xpc3RlbklkXTtcclxuICAgIH1cclxuICAgIGdldChxdWVyeSkge1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5U3RyaW5nUGFyYW1ldGVycyA9IHF1ZXJ5UGFyYW1zVG9SZXN0UXVlcnlTdHJpbmdQYXJhbWV0ZXJzKHF1ZXJ5Ll9xdWVyeVBhcmFtcyk7XHJcbiAgICAgICAgY29uc3QgcGF0aFN0cmluZyA9IHF1ZXJ5Ll9wYXRoLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgICAgICB0aGlzLnJlc3RSZXF1ZXN0XyhwYXRoU3RyaW5nICsgJy5qc29uJywgcXVlcnlTdHJpbmdQYXJhbWV0ZXJzLCAoZXJyb3IsIHJlc3VsdCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZGF0YSA9IHJlc3VsdDtcclxuICAgICAgICAgICAgaWYgKGVycm9yID09PSA0MDQpIHtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgZXJyb3IgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlcnJvciA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkRhdGFVcGRhdGVfKHBhdGhTdHJpbmcsIGRhdGEsIFxyXG4gICAgICAgICAgICAgICAgLyppc01lcmdlPSovIGZhbHNlLCBcclxuICAgICAgICAgICAgICAgIC8qdGFnPSovIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShkYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChuZXcgRXJyb3IoZGF0YSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIHJlZnJlc2hBdXRoVG9rZW4odG9rZW4pIHtcclxuICAgICAgICAvLyBuby1vcCBzaW5jZSB3ZSBqdXN0IGFsd2F5cyBjYWxsIGdldFRva2VuLlxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQZXJmb3JtcyBhIFJFU1QgcmVxdWVzdCB0byB0aGUgZ2l2ZW4gcGF0aCwgd2l0aCB0aGUgcHJvdmlkZWQgcXVlcnkgc3RyaW5nIHBhcmFtZXRlcnMsXHJcbiAgICAgKiBhbmQgYW55IGF1dGggY3JlZGVudGlhbHMgd2UgaGF2ZS5cclxuICAgICAqL1xyXG4gICAgcmVzdFJlcXVlc3RfKHBhdGhTdHJpbmcsIHF1ZXJ5U3RyaW5nUGFyYW1ldGVycyA9IHt9LCBjYWxsYmFjaykge1xyXG4gICAgICAgIHF1ZXJ5U3RyaW5nUGFyYW1ldGVyc1snZm9ybWF0J10gPSAnZXhwb3J0JztcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICB0aGlzLmF1dGhUb2tlblByb3ZpZGVyXy5nZXRUb2tlbigvKmZvcmNlUmVmcmVzaD0qLyBmYWxzZSksXHJcbiAgICAgICAgICAgIHRoaXMuYXBwQ2hlY2tUb2tlblByb3ZpZGVyXy5nZXRUb2tlbigvKmZvcmNlUmVmcmVzaD0qLyBmYWxzZSlcclxuICAgICAgICBdKS50aGVuKChbYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuXSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoYXV0aFRva2VuICYmIGF1dGhUb2tlbi5hY2Nlc3NUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgcXVlcnlTdHJpbmdQYXJhbWV0ZXJzWydhdXRoJ10gPSBhdXRoVG9rZW4uYWNjZXNzVG9rZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGFwcENoZWNrVG9rZW4gJiYgYXBwQ2hlY2tUb2tlbi50b2tlbikge1xyXG4gICAgICAgICAgICAgICAgcXVlcnlTdHJpbmdQYXJhbWV0ZXJzWydhYyddID0gYXBwQ2hlY2tUb2tlbi50b2tlbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB1cmwgPSAodGhpcy5yZXBvSW5mb18uc2VjdXJlID8gJ2h0dHBzOi8vJyA6ICdodHRwOi8vJykgK1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvSW5mb18uaG9zdCArXHJcbiAgICAgICAgICAgICAgICBwYXRoU3RyaW5nICtcclxuICAgICAgICAgICAgICAgICc/JyArXHJcbiAgICAgICAgICAgICAgICAnbnM9JyArXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlcG9JbmZvXy5uYW1lc3BhY2UgK1xyXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmcocXVlcnlTdHJpbmdQYXJhbWV0ZXJzKTtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdTZW5kaW5nIFJFU1QgcmVxdWVzdCBmb3IgJyArIHVybCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrICYmIHhoci5yZWFkeVN0YXRlID09PSA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdSRVNUIFJlc3BvbnNlIGZvciAnICsgdXJsICsgJyByZWNlaXZlZC4gc3RhdHVzOicsIHhoci5zdGF0dXMsICdyZXNwb25zZTonLCB4aHIucmVzcG9uc2VUZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0ganNvbkV2YWwoeGhyLnJlc3BvbnNlVGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oJ0ZhaWxlZCB0byBwYXJzZSBKU09OIHJlc3BvbnNlIGZvciAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc6ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5yZXNwb25zZVRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyA0MDEgYW5kIDQwNCBhcmUgZXhwZWN0ZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzICE9PSA0MDEgJiYgeGhyLnN0YXR1cyAhPT0gNDA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuKCdHb3QgdW5zdWNjZXNzZnVsIFJFU1QgcmVzcG9uc2UgZm9yICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBTdGF0dXM6ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zdGF0dXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHhoci5zdGF0dXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIC8qYXN5bmNocm9ub3VzPSovIHRydWUpO1xyXG4gICAgICAgICAgICB4aHIuc2VuZCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBNdXRhYmxlIG9iamVjdCB3aGljaCBiYXNpY2FsbHkganVzdCBzdG9yZXMgYSByZWZlcmVuY2UgdG8gdGhlIFwibGF0ZXN0XCIgaW1tdXRhYmxlIHNuYXBzaG90LlxyXG4gKi9cclxuY2xhc3MgU25hcHNob3RIb2xkZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5yb290Tm9kZV8gPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgIH1cclxuICAgIGdldE5vZGUocGF0aCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvb3ROb2RlXy5nZXRDaGlsZChwYXRoKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVNuYXBzaG90KHBhdGgsIG5ld1NuYXBzaG90Tm9kZSkge1xyXG4gICAgICAgIHRoaXMucm9vdE5vZGVfID0gdGhpcy5yb290Tm9kZV8udXBkYXRlQ2hpbGQocGF0aCwgbmV3U25hcHNob3ROb2RlKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBuZXdTcGFyc2VTbmFwc2hvdFRyZWUoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHZhbHVlOiBudWxsLFxyXG4gICAgICAgIGNoaWxkcmVuOiBuZXcgTWFwKClcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIFN0b3JlcyB0aGUgZ2l2ZW4gbm9kZSBhdCB0aGUgc3BlY2lmaWVkIHBhdGguIElmIHRoZXJlIGlzIGFscmVhZHkgYSBub2RlXHJcbiAqIGF0IGEgc2hhbGxvd2VyIHBhdGgsIGl0IG1lcmdlcyB0aGUgbmV3IGRhdGEgaW50byB0aGF0IHNuYXBzaG90IG5vZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBwYXRoIC0gUGF0aCB0byBsb29rIHVwIHNuYXBzaG90IGZvci5cclxuICogQHBhcmFtIGRhdGEgLSBUaGUgbmV3IGRhdGEsIG9yIG51bGwuXHJcbiAqL1xyXG5mdW5jdGlvbiBzcGFyc2VTbmFwc2hvdFRyZWVSZW1lbWJlcihzcGFyc2VTbmFwc2hvdFRyZWUsIHBhdGgsIGRhdGEpIHtcclxuICAgIGlmIChwYXRoSXNFbXB0eShwYXRoKSkge1xyXG4gICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZS52YWx1ZSA9IGRhdGE7XHJcbiAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlLmNoaWxkcmVuLmNsZWFyKCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzcGFyc2VTbmFwc2hvdFRyZWUudmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWUudmFsdWUgPSBzcGFyc2VTbmFwc2hvdFRyZWUudmFsdWUudXBkYXRlQ2hpbGQocGF0aCwgZGF0YSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBjaGlsZEtleSA9IHBhdGhHZXRGcm9udChwYXRoKTtcclxuICAgICAgICBpZiAoIXNwYXJzZVNuYXBzaG90VHJlZS5jaGlsZHJlbi5oYXMoY2hpbGRLZXkpKSB7XHJcbiAgICAgICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZS5jaGlsZHJlbi5zZXQoY2hpbGRLZXksIG5ld1NwYXJzZVNuYXBzaG90VHJlZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2hpbGQgPSBzcGFyc2VTbmFwc2hvdFRyZWUuY2hpbGRyZW4uZ2V0KGNoaWxkS2V5KTtcclxuICAgICAgICBwYXRoID0gcGF0aFBvcEZyb250KHBhdGgpO1xyXG4gICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZVJlbWVtYmVyKGNoaWxkLCBwYXRoLCBkYXRhKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUHVyZ2UgdGhlIGRhdGEgYXQgcGF0aCBmcm9tIHRoZSBjYWNoZS5cclxuICpcclxuICogQHBhcmFtIHBhdGggLSBQYXRoIHRvIGxvb2sgdXAgc25hcHNob3QgZm9yLlxyXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoaXMgbm9kZSBzaG91bGQgbm93IGJlIHJlbW92ZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBzcGFyc2VTbmFwc2hvdFRyZWVGb3JnZXQoc3BhcnNlU25hcHNob3RUcmVlLCBwYXRoKSB7XHJcbiAgICBpZiAocGF0aElzRW1wdHkocGF0aCkpIHtcclxuICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWUudmFsdWUgPSBudWxsO1xyXG4gICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZS5jaGlsZHJlbi5jbGVhcigpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKHNwYXJzZVNuYXBzaG90VHJlZS52YWx1ZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAoc3BhcnNlU25hcHNob3RUcmVlLnZhbHVlLmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UncmUgdHJ5aW5nIHRvIGZvcmdldCBhIG5vZGUgdGhhdCBkb2Vzbid0IGV4aXN0XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHNwYXJzZVNuYXBzaG90VHJlZS52YWx1ZTtcclxuICAgICAgICAgICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZS52YWx1ZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZS5mb3JFYWNoQ2hpbGQoUFJJT1JJVFlfSU5ERVgsIChrZXksIHRyZWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWVSZW1lbWJlcihzcGFyc2VTbmFwc2hvdFRyZWUsIG5ldyBQYXRoKGtleSksIHRyZWUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3BhcnNlU25hcHNob3RUcmVlRm9yZ2V0KHNwYXJzZVNuYXBzaG90VHJlZSwgcGF0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc3BhcnNlU25hcHNob3RUcmVlLmNoaWxkcmVuLnNpemUgPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkS2V5ID0gcGF0aEdldEZyb250KHBhdGgpO1xyXG4gICAgICAgICAgICBwYXRoID0gcGF0aFBvcEZyb250KHBhdGgpO1xyXG4gICAgICAgICAgICBpZiAoc3BhcnNlU25hcHNob3RUcmVlLmNoaWxkcmVuLmhhcyhjaGlsZEtleSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNhZmVUb1JlbW92ZSA9IHNwYXJzZVNuYXBzaG90VHJlZUZvcmdldChzcGFyc2VTbmFwc2hvdFRyZWUuY2hpbGRyZW4uZ2V0KGNoaWxkS2V5KSwgcGF0aCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2FmZVRvUmVtb3ZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlLmNoaWxkcmVuLmRlbGV0ZShjaGlsZEtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHNwYXJzZVNuYXBzaG90VHJlZS5jaGlsZHJlbi5zaXplID09PSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZWN1cnNpdmVseSBpdGVyYXRlcyB0aHJvdWdoIGFsbCBvZiB0aGUgc3RvcmVkIHRyZWUgYW5kIGNhbGxzIHRoZVxyXG4gKiBjYWxsYmFjayBvbiBlYWNoIG9uZS5cclxuICpcclxuICogQHBhcmFtIHByZWZpeFBhdGggLSBQYXRoIHRvIGxvb2sgdXAgbm9kZSBmb3IuXHJcbiAqIEBwYXJhbSBmdW5jIC0gVGhlIGZ1bmN0aW9uIHRvIGludm9rZSBmb3IgZWFjaCB0cmVlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3BhcnNlU25hcHNob3RUcmVlRm9yRWFjaFRyZWUoc3BhcnNlU25hcHNob3RUcmVlLCBwcmVmaXhQYXRoLCBmdW5jKSB7XHJcbiAgICBpZiAoc3BhcnNlU25hcHNob3RUcmVlLnZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgZnVuYyhwcmVmaXhQYXRoLCBzcGFyc2VTbmFwc2hvdFRyZWUudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlRm9yRWFjaENoaWxkKHNwYXJzZVNuYXBzaG90VHJlZSwgKGtleSwgdHJlZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwYXRoID0gbmV3IFBhdGgocHJlZml4UGF0aC50b1N0cmluZygpICsgJy8nICsga2V5KTtcclxuICAgICAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlRm9yRWFjaFRyZWUodHJlZSwgcGF0aCwgZnVuYyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEl0ZXJhdGVzIHRocm91Z2ggZWFjaCBpbW1lZGlhdGUgY2hpbGQgYW5kIHRyaWdnZXJzIHRoZSBjYWxsYmFjay5cclxuICogT25seSBzZWVtcyB0byBiZSB1c2VkIGluIHRlc3RzLlxyXG4gKlxyXG4gKiBAcGFyYW0gZnVuYyAtIFRoZSBmdW5jdGlvbiB0byBpbnZva2UgZm9yIGVhY2ggY2hpbGQuXHJcbiAqL1xyXG5mdW5jdGlvbiBzcGFyc2VTbmFwc2hvdFRyZWVGb3JFYWNoQ2hpbGQoc3BhcnNlU25hcHNob3RUcmVlLCBmdW5jKSB7XHJcbiAgICBzcGFyc2VTbmFwc2hvdFRyZWUuY2hpbGRyZW4uZm9yRWFjaCgodHJlZSwga2V5KSA9PiB7XHJcbiAgICAgICAgZnVuYyhrZXksIHRyZWUpO1xyXG4gICAgfSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGRlbHRhIGZyb20gdGhlIHByZXZpb3VzIGNhbGwgdG8gZ2V0IHN0YXRzLlxyXG4gKlxyXG4gKiBAcGFyYW0gY29sbGVjdGlvbl8gLSBUaGUgY29sbGVjdGlvbiB0byBcImxpc3RlblwiIHRvLlxyXG4gKi9cclxuY2xhc3MgU3RhdHNMaXN0ZW5lciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb2xsZWN0aW9uXykge1xyXG4gICAgICAgIHRoaXMuY29sbGVjdGlvbl8gPSBjb2xsZWN0aW9uXztcclxuICAgICAgICB0aGlzLmxhc3RfID0gbnVsbDtcclxuICAgIH1cclxuICAgIGdldCgpIHtcclxuICAgICAgICBjb25zdCBuZXdTdGF0cyA9IHRoaXMuY29sbGVjdGlvbl8uZ2V0KCk7XHJcbiAgICAgICAgY29uc3QgZGVsdGEgPSBPYmplY3QuYXNzaWduKHt9LCBuZXdTdGF0cyk7XHJcbiAgICAgICAgaWYgKHRoaXMubGFzdF8pIHtcclxuICAgICAgICAgICAgZWFjaCh0aGlzLmxhc3RfLCAoc3RhdCwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgIGRlbHRhW3N0YXRdID0gZGVsdGFbc3RhdF0gLSB2YWx1ZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGFzdF8gPSBuZXdTdGF0cztcclxuICAgICAgICByZXR1cm4gZGVsdGE7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLy8gQXNzdW1pbmcgc29tZSBhcHBzIG1heSBoYXZlIGEgc2hvcnQgYW1vdW50IG9mIHRpbWUgb24gcGFnZSwgYW5kIGEgYnVsayBvZiBmaXJlYmFzZSBvcGVyYXRpb25zIHByb2JhYmx5XHJcbi8vIGhhcHBlbiBvbiBwYWdlIGxvYWQsIHdlIHRyeSB0byByZXBvcnQgb3VyIGZpcnN0IHNldCBvZiBzdGF0cyBwcmV0dHkgcXVpY2tseSwgYnV0IHdlIHdhaXQgYXQgbGVhc3QgMTBcclxuLy8gc2Vjb25kcyB0byB0cnkgdG8gZW5zdXJlIHRoZSBGaXJlYmFzZSBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkIC8gc2V0dGxlZC5cclxuY29uc3QgRklSU1RfU1RBVFNfTUlOX1RJTUUgPSAxMCAqIDEwMDA7XHJcbmNvbnN0IEZJUlNUX1NUQVRTX01BWF9USU1FID0gMzAgKiAxMDAwO1xyXG4vLyBXZSdsbCBjb250aW51ZSB0byByZXBvcnQgc3RhdHMgb24gYXZlcmFnZSBldmVyeSA1IG1pbnV0ZXMuXHJcbmNvbnN0IFJFUE9SVF9TVEFUU19JTlRFUlZBTCA9IDUgKiA2MCAqIDEwMDA7XHJcbmNsYXNzIFN0YXRzUmVwb3J0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoY29sbGVjdGlvbiwgc2VydmVyXykge1xyXG4gICAgICAgIHRoaXMuc2VydmVyXyA9IHNlcnZlcl87XHJcbiAgICAgICAgdGhpcy5zdGF0c1RvUmVwb3J0XyA9IHt9O1xyXG4gICAgICAgIHRoaXMuc3RhdHNMaXN0ZW5lcl8gPSBuZXcgU3RhdHNMaXN0ZW5lcihjb2xsZWN0aW9uKTtcclxuICAgICAgICBjb25zdCB0aW1lb3V0ID0gRklSU1RfU1RBVFNfTUlOX1RJTUUgK1xyXG4gICAgICAgICAgICAoRklSU1RfU1RBVFNfTUFYX1RJTUUgLSBGSVJTVF9TVEFUU19NSU5fVElNRSkgKiBNYXRoLnJhbmRvbSgpO1xyXG4gICAgICAgIHNldFRpbWVvdXROb25CbG9ja2luZyh0aGlzLnJlcG9ydFN0YXRzXy5iaW5kKHRoaXMpLCBNYXRoLmZsb29yKHRpbWVvdXQpKTtcclxuICAgIH1cclxuICAgIHJlcG9ydFN0YXRzXygpIHtcclxuICAgICAgICBjb25zdCBzdGF0cyA9IHRoaXMuc3RhdHNMaXN0ZW5lcl8uZ2V0KCk7XHJcbiAgICAgICAgY29uc3QgcmVwb3J0ZWRTdGF0cyA9IHt9O1xyXG4gICAgICAgIGxldCBoYXZlU3RhdHNUb1JlcG9ydCA9IGZhbHNlO1xyXG4gICAgICAgIGVhY2goc3RhdHMsIChzdGF0LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPiAwICYmIGNvbnRhaW5zKHRoaXMuc3RhdHNUb1JlcG9ydF8sIHN0YXQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXBvcnRlZFN0YXRzW3N0YXRdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBoYXZlU3RhdHNUb1JlcG9ydCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoaGF2ZVN0YXRzVG9SZXBvcnQpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJfLnJlcG9ydFN0YXRzKHJlcG9ydGVkU3RhdHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBxdWV1ZSBvdXIgbmV4dCBydW4uXHJcbiAgICAgICAgc2V0VGltZW91dE5vbkJsb2NraW5nKHRoaXMucmVwb3J0U3RhdHNfLmJpbmQodGhpcyksIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDIgKiBSRVBPUlRfU1RBVFNfSU5URVJWQUwpKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICpcclxuICogQGVudW1cclxuICovXHJcbnZhciBPcGVyYXRpb25UeXBlO1xyXG4oZnVuY3Rpb24gKE9wZXJhdGlvblR5cGUpIHtcclxuICAgIE9wZXJhdGlvblR5cGVbT3BlcmF0aW9uVHlwZVtcIk9WRVJXUklURVwiXSA9IDBdID0gXCJPVkVSV1JJVEVcIjtcclxuICAgIE9wZXJhdGlvblR5cGVbT3BlcmF0aW9uVHlwZVtcIk1FUkdFXCJdID0gMV0gPSBcIk1FUkdFXCI7XHJcbiAgICBPcGVyYXRpb25UeXBlW09wZXJhdGlvblR5cGVbXCJBQ0tfVVNFUl9XUklURVwiXSA9IDJdID0gXCJBQ0tfVVNFUl9XUklURVwiO1xyXG4gICAgT3BlcmF0aW9uVHlwZVtPcGVyYXRpb25UeXBlW1wiTElTVEVOX0NPTVBMRVRFXCJdID0gM10gPSBcIkxJU1RFTl9DT01QTEVURVwiO1xyXG59KShPcGVyYXRpb25UeXBlIHx8IChPcGVyYXRpb25UeXBlID0ge30pKTtcclxuZnVuY3Rpb24gbmV3T3BlcmF0aW9uU291cmNlVXNlcigpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZnJvbVVzZXI6IHRydWUsXHJcbiAgICAgICAgZnJvbVNlcnZlcjogZmFsc2UsXHJcbiAgICAgICAgcXVlcnlJZDogbnVsbCxcclxuICAgICAgICB0YWdnZWQ6IGZhbHNlXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIG5ld09wZXJhdGlvblNvdXJjZVNlcnZlcigpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZnJvbVVzZXI6IGZhbHNlLFxyXG4gICAgICAgIGZyb21TZXJ2ZXI6IHRydWUsXHJcbiAgICAgICAgcXVlcnlJZDogbnVsbCxcclxuICAgICAgICB0YWdnZWQ6IGZhbHNlXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIG5ld09wZXJhdGlvblNvdXJjZVNlcnZlclRhZ2dlZFF1ZXJ5KHF1ZXJ5SWQpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZnJvbVVzZXI6IGZhbHNlLFxyXG4gICAgICAgIGZyb21TZXJ2ZXI6IHRydWUsXHJcbiAgICAgICAgcXVlcnlJZCxcclxuICAgICAgICB0YWdnZWQ6IHRydWVcclxuICAgIH07XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgQWNrVXNlcldyaXRlIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGFmZmVjdGVkVHJlZSAtIEEgdHJlZSBjb250YWluaW5nIHRydWUgZm9yIGVhY2ggYWZmZWN0ZWQgcGF0aC4gQWZmZWN0ZWQgcGF0aHMgY2FuJ3Qgb3ZlcmxhcC5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKiogQGluaGVyaXREb2MgKi8gcGF0aCwgXHJcbiAgICAvKiogQGluaGVyaXREb2MgKi8gYWZmZWN0ZWRUcmVlLCBcclxuICAgIC8qKiBAaW5oZXJpdERvYyAqLyByZXZlcnQpIHtcclxuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xyXG4gICAgICAgIHRoaXMuYWZmZWN0ZWRUcmVlID0gYWZmZWN0ZWRUcmVlO1xyXG4gICAgICAgIHRoaXMucmV2ZXJ0ID0gcmV2ZXJ0O1xyXG4gICAgICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgICAgIHRoaXMudHlwZSA9IE9wZXJhdGlvblR5cGUuQUNLX1VTRVJfV1JJVEU7XHJcbiAgICAgICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBuZXdPcGVyYXRpb25Tb3VyY2VVc2VyKCk7XHJcbiAgICB9XHJcbiAgICBvcGVyYXRpb25Gb3JDaGlsZChjaGlsZE5hbWUpIHtcclxuICAgICAgICBpZiAoIXBhdGhJc0VtcHR5KHRoaXMucGF0aCkpIHtcclxuICAgICAgICAgICAgYXNzZXJ0KHBhdGhHZXRGcm9udCh0aGlzLnBhdGgpID09PSBjaGlsZE5hbWUsICdvcGVyYXRpb25Gb3JDaGlsZCBjYWxsZWQgZm9yIHVucmVsYXRlZCBjaGlsZC4nKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBY2tVc2VyV3JpdGUocGF0aFBvcEZyb250KHRoaXMucGF0aCksIHRoaXMuYWZmZWN0ZWRUcmVlLCB0aGlzLnJldmVydCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYWZmZWN0ZWRUcmVlLnZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgYXNzZXJ0KHRoaXMuYWZmZWN0ZWRUcmVlLmNoaWxkcmVuLmlzRW1wdHkoKSwgJ2FmZmVjdGVkVHJlZSBzaG91bGQgbm90IGhhdmUgb3ZlcmxhcHBpbmcgYWZmZWN0ZWQgcGF0aHMuJyk7XHJcbiAgICAgICAgICAgIC8vIEFsbCBjaGlsZCBsb2NhdGlvbnMgYXJlIGFmZmVjdGVkIGFzIHdlbGw7IGp1c3QgcmV0dXJuIHNhbWUgb3BlcmF0aW9uLlxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkVHJlZSA9IHRoaXMuYWZmZWN0ZWRUcmVlLnN1YnRyZWUobmV3IFBhdGgoY2hpbGROYW1lKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWNrVXNlcldyaXRlKG5ld0VtcHR5UGF0aCgpLCBjaGlsZFRyZWUsIHRoaXMucmV2ZXJ0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgTGlzdGVuQ29tcGxldGUge1xyXG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBwYXRoKSB7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcclxuICAgICAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgICAgICB0aGlzLnR5cGUgPSBPcGVyYXRpb25UeXBlLkxJU1RFTl9DT01QTEVURTtcclxuICAgIH1cclxuICAgIG9wZXJhdGlvbkZvckNoaWxkKGNoaWxkTmFtZSkge1xyXG4gICAgICAgIGlmIChwYXRoSXNFbXB0eSh0aGlzLnBhdGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGlzdGVuQ29tcGxldGUodGhpcy5zb3VyY2UsIG5ld0VtcHR5UGF0aCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGlzdGVuQ29tcGxldGUodGhpcy5zb3VyY2UsIHBhdGhQb3BGcm9udCh0aGlzLnBhdGgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgT3ZlcndyaXRlIHtcclxuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgcGF0aCwgc25hcCkge1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgdGhpcy5zbmFwID0gc25hcDtcclxuICAgICAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgICAgICB0aGlzLnR5cGUgPSBPcGVyYXRpb25UeXBlLk9WRVJXUklURTtcclxuICAgIH1cclxuICAgIG9wZXJhdGlvbkZvckNoaWxkKGNoaWxkTmFtZSkge1xyXG4gICAgICAgIGlmIChwYXRoSXNFbXB0eSh0aGlzLnBhdGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgT3ZlcndyaXRlKHRoaXMuc291cmNlLCBuZXdFbXB0eVBhdGgoKSwgdGhpcy5zbmFwLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBPdmVyd3JpdGUodGhpcy5zb3VyY2UsIHBhdGhQb3BGcm9udCh0aGlzLnBhdGgpLCB0aGlzLnNuYXApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBNZXJnZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKiBAaW5oZXJpdERvYyAqLyBzb3VyY2UsIFxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovIHBhdGgsIFxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovIGNoaWxkcmVuKSB7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XHJcbiAgICAgICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICAgICAgdGhpcy50eXBlID0gT3BlcmF0aW9uVHlwZS5NRVJHRTtcclxuICAgIH1cclxuICAgIG9wZXJhdGlvbkZvckNoaWxkKGNoaWxkTmFtZSkge1xyXG4gICAgICAgIGlmIChwYXRoSXNFbXB0eSh0aGlzLnBhdGgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkVHJlZSA9IHRoaXMuY2hpbGRyZW4uc3VidHJlZShuZXcgUGF0aChjaGlsZE5hbWUpKTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkVHJlZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgY2hpbGQgaXMgdW5hZmZlY3RlZFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGRUcmVlLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGEgc25hcHNob3QgZm9yIHRoZSBjaGlsZCBpbiBxdWVzdGlvbi4gIFRoaXMgYmVjb21lcyBhbiBvdmVyd3JpdGUgb2YgdGhlIGNoaWxkLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBPdmVyd3JpdGUodGhpcy5zb3VyY2UsIG5ld0VtcHR5UGF0aCgpLCBjaGlsZFRyZWUudmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIG1lcmdlIGF0IGEgZGVlcGVyIGxldmVsXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1lcmdlKHRoaXMuc291cmNlLCBuZXdFbXB0eVBhdGgoKSwgY2hpbGRUcmVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYXNzZXJ0KHBhdGhHZXRGcm9udCh0aGlzLnBhdGgpID09PSBjaGlsZE5hbWUsIFwiQ2FuJ3QgZ2V0IGEgbWVyZ2UgZm9yIGEgY2hpbGQgbm90IG9uIHRoZSBwYXRoIG9mIHRoZSBvcGVyYXRpb25cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWVyZ2UodGhpcy5zb3VyY2UsIHBhdGhQb3BGcm9udCh0aGlzLnBhdGgpLCB0aGlzLmNoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gKCdPcGVyYXRpb24oJyArXHJcbiAgICAgICAgICAgIHRoaXMucGF0aCArXHJcbiAgICAgICAgICAgICc6ICcgK1xyXG4gICAgICAgICAgICB0aGlzLnNvdXJjZS50b1N0cmluZygpICtcclxuICAgICAgICAgICAgJyBtZXJnZTogJyArXHJcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4udG9TdHJpbmcoKSArXHJcbiAgICAgICAgICAgICcpJyk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEEgY2FjaGUgbm9kZSBvbmx5IHN0b3JlcyBjb21wbGV0ZSBjaGlsZHJlbi4gQWRkaXRpb25hbGx5IGl0IGhvbGRzIGEgZmxhZyB3aGV0aGVyIHRoZSBub2RlIGNhbiBiZSBjb25zaWRlcmVkIGZ1bGx5XHJcbiAqIGluaXRpYWxpemVkIGluIHRoZSBzZW5zZSB0aGF0IHdlIGtub3cgYXQgb25lIHBvaW50IGluIHRpbWUgdGhpcyByZXByZXNlbnRlZCBhIHZhbGlkIHN0YXRlIG9mIHRoZSB3b3JsZCwgZS5nLlxyXG4gKiBpbml0aWFsaXplZCB3aXRoIGRhdGEgZnJvbSB0aGUgc2VydmVyLCBvciBhIGNvbXBsZXRlIG92ZXJ3cml0ZSBieSB0aGUgY2xpZW50LiBUaGUgZmlsdGVyZWQgZmxhZyBhbHNvIHRyYWNrc1xyXG4gKiB3aGV0aGVyIGEgbm9kZSBwb3RlbnRpYWxseSBoYWQgY2hpbGRyZW4gcmVtb3ZlZCBkdWUgdG8gYSBmaWx0ZXIuXHJcbiAqL1xyXG5jbGFzcyBDYWNoZU5vZGUge1xyXG4gICAgY29uc3RydWN0b3Iobm9kZV8sIGZ1bGx5SW5pdGlhbGl6ZWRfLCBmaWx0ZXJlZF8pIHtcclxuICAgICAgICB0aGlzLm5vZGVfID0gbm9kZV87XHJcbiAgICAgICAgdGhpcy5mdWxseUluaXRpYWxpemVkXyA9IGZ1bGx5SW5pdGlhbGl6ZWRfO1xyXG4gICAgICAgIHRoaXMuZmlsdGVyZWRfID0gZmlsdGVyZWRfO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBub2RlIHdhcyBmdWxseSBpbml0aWFsaXplZCB3aXRoIGVpdGhlciBzZXJ2ZXIgZGF0YSBvciBhIGNvbXBsZXRlIG92ZXJ3cml0ZSBieSB0aGUgY2xpZW50XHJcbiAgICAgKi9cclxuICAgIGlzRnVsbHlJbml0aWFsaXplZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mdWxseUluaXRpYWxpemVkXztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgbm9kZSBpcyBwb3RlbnRpYWxseSBtaXNzaW5nIGNoaWxkcmVuIGR1ZSB0byBhIGZpbHRlciBhcHBsaWVkIHRvIHRoZSBub2RlXHJcbiAgICAgKi9cclxuICAgIGlzRmlsdGVyZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyZWRfO1xyXG4gICAgfVxyXG4gICAgaXNDb21wbGV0ZUZvclBhdGgocGF0aCkge1xyXG4gICAgICAgIGlmIChwYXRoSXNFbXB0eShwYXRoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSAmJiAhdGhpcy5maWx0ZXJlZF87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNoaWxkS2V5ID0gcGF0aEdldEZyb250KHBhdGgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlzQ29tcGxldGVGb3JDaGlsZChjaGlsZEtleSk7XHJcbiAgICB9XHJcbiAgICBpc0NvbXBsZXRlRm9yQ2hpbGQoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuICgodGhpcy5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSAmJiAhdGhpcy5maWx0ZXJlZF8pIHx8IHRoaXMubm9kZV8uaGFzQ2hpbGQoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBnZXROb2RlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVfO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBbiBFdmVudEdlbmVyYXRvciBpcyB1c2VkIHRvIGNvbnZlcnQgXCJyYXdcIiBjaGFuZ2VzIChDaGFuZ2UpIGFzIGNvbXB1dGVkIGJ5IHRoZVxyXG4gKiBDYWNoZURpZmZlciBpbnRvIGFjdHVhbCBldmVudHMgKEV2ZW50KSB0aGF0IGNhbiBiZSByYWlzZWQuICBTZWUgZ2VuZXJhdGVFdmVudHNGb3JDaGFuZ2VzKClcclxuICogZm9yIGRldGFpbHMuXHJcbiAqXHJcbiAqL1xyXG5jbGFzcyBFdmVudEdlbmVyYXRvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihxdWVyeV8pIHtcclxuICAgICAgICB0aGlzLnF1ZXJ5XyA9IHF1ZXJ5XztcclxuICAgICAgICB0aGlzLmluZGV4XyA9IHRoaXMucXVlcnlfLl9xdWVyeVBhcmFtcy5nZXRJbmRleCgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBHaXZlbiBhIHNldCBvZiByYXcgY2hhbmdlcyAobm8gbW92ZWQgZXZlbnRzIGFuZCBwcmV2TmFtZSBub3Qgc3BlY2lmaWVkIHlldCksIGFuZCBhIHNldCBvZlxyXG4gKiBFdmVudFJlZ2lzdHJhdGlvbnMgdGhhdCBzaG91bGQgYmUgbm90aWZpZWQgb2YgdGhlc2UgY2hhbmdlcywgZ2VuZXJhdGUgdGhlIGFjdHVhbCBldmVudHMgdG8gYmUgcmFpc2VkLlxyXG4gKlxyXG4gKiBOb3RlczpcclxuICogIC0gY2hpbGRfbW92ZWQgZXZlbnRzIHdpbGwgYmUgc3ludGhlc2l6ZWQgYXQgdGhpcyB0aW1lIGZvciBhbnkgY2hpbGRfY2hhbmdlZCBldmVudHMgdGhhdCBhZmZlY3RcclxuICogICAgb3VyIGluZGV4LlxyXG4gKiAgLSBwcmV2TmFtZSB3aWxsIGJlIGNhbGN1bGF0ZWQgYmFzZWQgb24gdGhlIGluZGV4IG9yZGVyaW5nLlxyXG4gKi9cclxuZnVuY3Rpb24gZXZlbnRHZW5lcmF0b3JHZW5lcmF0ZUV2ZW50c0ZvckNoYW5nZXMoZXZlbnRHZW5lcmF0b3IsIGNoYW5nZXMsIGV2ZW50Q2FjaGUsIGV2ZW50UmVnaXN0cmF0aW9ucykge1xyXG4gICAgY29uc3QgZXZlbnRzID0gW107XHJcbiAgICBjb25zdCBtb3ZlcyA9IFtdO1xyXG4gICAgY2hhbmdlcy5mb3JFYWNoKGNoYW5nZSA9PiB7XHJcbiAgICAgICAgaWYgKGNoYW5nZS50eXBlID09PSBcImNoaWxkX2NoYW5nZWRcIiAvKiBDaGFuZ2VUeXBlLkNISUxEX0NIQU5HRUQgKi8gJiZcclxuICAgICAgICAgICAgZXZlbnRHZW5lcmF0b3IuaW5kZXhfLmluZGV4ZWRWYWx1ZUNoYW5nZWQoY2hhbmdlLm9sZFNuYXAsIGNoYW5nZS5zbmFwc2hvdE5vZGUpKSB7XHJcbiAgICAgICAgICAgIG1vdmVzLnB1c2goY2hhbmdlQ2hpbGRNb3ZlZChjaGFuZ2UuY2hpbGROYW1lLCBjaGFuZ2Uuc25hcHNob3ROb2RlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBldmVudEdlbmVyYXRvckdlbmVyYXRlRXZlbnRzRm9yVHlwZShldmVudEdlbmVyYXRvciwgZXZlbnRzLCBcImNoaWxkX3JlbW92ZWRcIiAvKiBDaGFuZ2VUeXBlLkNISUxEX1JFTU9WRUQgKi8sIGNoYW5nZXMsIGV2ZW50UmVnaXN0cmF0aW9ucywgZXZlbnRDYWNoZSk7XHJcbiAgICBldmVudEdlbmVyYXRvckdlbmVyYXRlRXZlbnRzRm9yVHlwZShldmVudEdlbmVyYXRvciwgZXZlbnRzLCBcImNoaWxkX2FkZGVkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9BRERFRCAqLywgY2hhbmdlcywgZXZlbnRSZWdpc3RyYXRpb25zLCBldmVudENhY2hlKTtcclxuICAgIGV2ZW50R2VuZXJhdG9yR2VuZXJhdGVFdmVudHNGb3JUeXBlKGV2ZW50R2VuZXJhdG9yLCBldmVudHMsIFwiY2hpbGRfbW92ZWRcIiAvKiBDaGFuZ2VUeXBlLkNISUxEX01PVkVEICovLCBtb3ZlcywgZXZlbnRSZWdpc3RyYXRpb25zLCBldmVudENhY2hlKTtcclxuICAgIGV2ZW50R2VuZXJhdG9yR2VuZXJhdGVFdmVudHNGb3JUeXBlKGV2ZW50R2VuZXJhdG9yLCBldmVudHMsIFwiY2hpbGRfY2hhbmdlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfQ0hBTkdFRCAqLywgY2hhbmdlcywgZXZlbnRSZWdpc3RyYXRpb25zLCBldmVudENhY2hlKTtcclxuICAgIGV2ZW50R2VuZXJhdG9yR2VuZXJhdGVFdmVudHNGb3JUeXBlKGV2ZW50R2VuZXJhdG9yLCBldmVudHMsIFwidmFsdWVcIiAvKiBDaGFuZ2VUeXBlLlZBTFVFICovLCBjaGFuZ2VzLCBldmVudFJlZ2lzdHJhdGlvbnMsIGV2ZW50Q2FjaGUpO1xyXG4gICAgcmV0dXJuIGV2ZW50cztcclxufVxyXG4vKipcclxuICogR2l2ZW4gY2hhbmdlcyBvZiBhIHNpbmdsZSBjaGFuZ2UgdHlwZSwgZ2VuZXJhdGUgdGhlIGNvcnJlc3BvbmRpbmcgZXZlbnRzLlxyXG4gKi9cclxuZnVuY3Rpb24gZXZlbnRHZW5lcmF0b3JHZW5lcmF0ZUV2ZW50c0ZvclR5cGUoZXZlbnRHZW5lcmF0b3IsIGV2ZW50cywgZXZlbnRUeXBlLCBjaGFuZ2VzLCByZWdpc3RyYXRpb25zLCBldmVudENhY2hlKSB7XHJcbiAgICBjb25zdCBmaWx0ZXJlZENoYW5nZXMgPSBjaGFuZ2VzLmZpbHRlcihjaGFuZ2UgPT4gY2hhbmdlLnR5cGUgPT09IGV2ZW50VHlwZSk7XHJcbiAgICBmaWx0ZXJlZENoYW5nZXMuc29ydCgoYSwgYikgPT4gZXZlbnRHZW5lcmF0b3JDb21wYXJlQ2hhbmdlcyhldmVudEdlbmVyYXRvciwgYSwgYikpO1xyXG4gICAgZmlsdGVyZWRDaGFuZ2VzLmZvckVhY2goY2hhbmdlID0+IHtcclxuICAgICAgICBjb25zdCBtYXRlcmlhbGl6ZWRDaGFuZ2UgPSBldmVudEdlbmVyYXRvck1hdGVyaWFsaXplU2luZ2xlQ2hhbmdlKGV2ZW50R2VuZXJhdG9yLCBjaGFuZ2UsIGV2ZW50Q2FjaGUpO1xyXG4gICAgICAgIHJlZ2lzdHJhdGlvbnMuZm9yRWFjaChyZWdpc3RyYXRpb24gPT4ge1xyXG4gICAgICAgICAgICBpZiAocmVnaXN0cmF0aW9uLnJlc3BvbmRzVG8oY2hhbmdlLnR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudHMucHVzaChyZWdpc3RyYXRpb24uY3JlYXRlRXZlbnQobWF0ZXJpYWxpemVkQ2hhbmdlLCBldmVudEdlbmVyYXRvci5xdWVyeV8pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZXZlbnRHZW5lcmF0b3JNYXRlcmlhbGl6ZVNpbmdsZUNoYW5nZShldmVudEdlbmVyYXRvciwgY2hhbmdlLCBldmVudENhY2hlKSB7XHJcbiAgICBpZiAoY2hhbmdlLnR5cGUgPT09ICd2YWx1ZScgfHwgY2hhbmdlLnR5cGUgPT09ICdjaGlsZF9yZW1vdmVkJykge1xyXG4gICAgICAgIHJldHVybiBjaGFuZ2U7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjaGFuZ2UucHJldk5hbWUgPSBldmVudENhY2hlLmdldFByZWRlY2Vzc29yQ2hpbGROYW1lKGNoYW5nZS5jaGlsZE5hbWUsIGNoYW5nZS5zbmFwc2hvdE5vZGUsIGV2ZW50R2VuZXJhdG9yLmluZGV4Xyk7XHJcbiAgICAgICAgcmV0dXJuIGNoYW5nZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBldmVudEdlbmVyYXRvckNvbXBhcmVDaGFuZ2VzKGV2ZW50R2VuZXJhdG9yLCBhLCBiKSB7XHJcbiAgICBpZiAoYS5jaGlsZE5hbWUgPT0gbnVsbCB8fCBiLmNoaWxkTmFtZSA9PSBudWxsKSB7XHJcbiAgICAgICAgdGhyb3cgYXNzZXJ0aW9uRXJyb3IoJ1Nob3VsZCBvbmx5IGNvbXBhcmUgY2hpbGRfIGV2ZW50cy4nKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGFXcmFwcGVkID0gbmV3IE5hbWVkTm9kZShhLmNoaWxkTmFtZSwgYS5zbmFwc2hvdE5vZGUpO1xyXG4gICAgY29uc3QgYldyYXBwZWQgPSBuZXcgTmFtZWROb2RlKGIuY2hpbGROYW1lLCBiLnNuYXBzaG90Tm9kZSk7XHJcbiAgICByZXR1cm4gZXZlbnRHZW5lcmF0b3IuaW5kZXhfLmNvbXBhcmUoYVdyYXBwZWQsIGJXcmFwcGVkKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBuZXdWaWV3Q2FjaGUoZXZlbnRDYWNoZSwgc2VydmVyQ2FjaGUpIHtcclxuICAgIHJldHVybiB7IGV2ZW50Q2FjaGUsIHNlcnZlckNhY2hlIH07XHJcbn1cclxuZnVuY3Rpb24gdmlld0NhY2hlVXBkYXRlRXZlbnRTbmFwKHZpZXdDYWNoZSwgZXZlbnRTbmFwLCBjb21wbGV0ZSwgZmlsdGVyZWQpIHtcclxuICAgIHJldHVybiBuZXdWaWV3Q2FjaGUobmV3IENhY2hlTm9kZShldmVudFNuYXAsIGNvbXBsZXRlLCBmaWx0ZXJlZCksIHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZSk7XHJcbn1cclxuZnVuY3Rpb24gdmlld0NhY2hlVXBkYXRlU2VydmVyU25hcCh2aWV3Q2FjaGUsIHNlcnZlclNuYXAsIGNvbXBsZXRlLCBmaWx0ZXJlZCkge1xyXG4gICAgcmV0dXJuIG5ld1ZpZXdDYWNoZSh2aWV3Q2FjaGUuZXZlbnRDYWNoZSwgbmV3IENhY2hlTm9kZShzZXJ2ZXJTbmFwLCBjb21wbGV0ZSwgZmlsdGVyZWQpKTtcclxufVxyXG5mdW5jdGlvbiB2aWV3Q2FjaGVHZXRDb21wbGV0ZUV2ZW50U25hcCh2aWV3Q2FjaGUpIHtcclxuICAgIHJldHVybiB2aWV3Q2FjaGUuZXZlbnRDYWNoZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKVxyXG4gICAgICAgID8gdmlld0NhY2hlLmV2ZW50Q2FjaGUuZ2V0Tm9kZSgpXHJcbiAgICAgICAgOiBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdDYWNoZUdldENvbXBsZXRlU2VydmVyU25hcCh2aWV3Q2FjaGUpIHtcclxuICAgIHJldHVybiB2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuaXNGdWxseUluaXRpYWxpemVkKClcclxuICAgICAgICA/IHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5nZXROb2RlKClcclxuICAgICAgICA6IG51bGw7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxubGV0IGVtcHR5Q2hpbGRyZW5TaW5nbGV0b247XHJcbi8qKlxyXG4gKiBTaW5nbGV0b24gZW1wdHkgY2hpbGRyZW4gY29sbGVjdGlvbi5cclxuICpcclxuICovXHJcbmNvbnN0IEVtcHR5Q2hpbGRyZW4gPSAoKSA9PiB7XHJcbiAgICBpZiAoIWVtcHR5Q2hpbGRyZW5TaW5nbGV0b24pIHtcclxuICAgICAgICBlbXB0eUNoaWxkcmVuU2luZ2xldG9uID0gbmV3IFNvcnRlZE1hcChzdHJpbmdDb21wYXJlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBlbXB0eUNoaWxkcmVuU2luZ2xldG9uO1xyXG59O1xyXG4vKipcclxuICogQSB0cmVlIHdpdGggaW1tdXRhYmxlIGVsZW1lbnRzLlxyXG4gKi9cclxuY2xhc3MgSW1tdXRhYmxlVHJlZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgY2hpbGRyZW4gPSBFbXB0eUNoaWxkcmVuKCkpIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21PYmplY3Qob2JqKSB7XHJcbiAgICAgICAgbGV0IHRyZWUgPSBuZXcgSW1tdXRhYmxlVHJlZShudWxsKTtcclxuICAgICAgICBlYWNoKG9iaiwgKGNoaWxkUGF0aCwgY2hpbGRTbmFwKSA9PiB7XHJcbiAgICAgICAgICAgIHRyZWUgPSB0cmVlLnNldChuZXcgUGF0aChjaGlsZFBhdGgpLCBjaGlsZFNuYXApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0cmVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcnVlIGlmIHRoZSB2YWx1ZSBpcyBlbXB0eSBhbmQgdGhlcmUgYXJlIG5vIGNoaWxkcmVuXHJcbiAgICAgKi9cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPT09IG51bGwgJiYgdGhpcy5jaGlsZHJlbi5pc0VtcHR5KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGEgcGF0aCBhbmQgcHJlZGljYXRlLCByZXR1cm4gdGhlIGZpcnN0IG5vZGUgYW5kIHRoZSBwYXRoIHRvIHRoYXQgbm9kZVxyXG4gICAgICogd2hlcmUgdGhlIHByZWRpY2F0ZSByZXR1cm5zIHRydWUuXHJcbiAgICAgKlxyXG4gICAgICogVE9ETyBEbyBhIHBlcmYgdGVzdCAtLSBJZiB3ZSdyZSBjcmVhdGluZyBhIGJ1bmNoIG9mIGB7cGF0aDogdmFsdWU6fWBcclxuICAgICAqIG9iamVjdHMgb24gdGhlIHdheSBiYWNrIG91dCwgaXQgbWF5IGJlIGJldHRlciB0byBwYXNzIGRvd24gYSBwYXRoU29GYXIgb2JqLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSByZWxhdGl2ZVBhdGggLSBUaGUgcmVtYWluZGVyIG9mIHRoZSBwYXRoXHJcbiAgICAgKiBAcGFyYW0gcHJlZGljYXRlIC0gVGhlIHByZWRpY2F0ZSB0byBzYXRpc2Z5IHRvIHJldHVybiBhIG5vZGVcclxuICAgICAqL1xyXG4gICAgZmluZFJvb3RNb3N0TWF0Y2hpbmdQYXRoQW5kVmFsdWUocmVsYXRpdmVQYXRoLCBwcmVkaWNhdGUpIHtcclxuICAgICAgICBpZiAodGhpcy52YWx1ZSAhPSBudWxsICYmIHByZWRpY2F0ZSh0aGlzLnZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4geyBwYXRoOiBuZXdFbXB0eVBhdGgoKSwgdmFsdWU6IHRoaXMudmFsdWUgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChwYXRoSXNFbXB0eShyZWxhdGl2ZVBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZyb250ID0gcGF0aEdldEZyb250KHJlbGF0aXZlUGF0aCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hpbGRyZW4uZ2V0KGZyb250KTtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkRXhpc3RpbmdQYXRoQW5kVmFsdWUgPSBjaGlsZC5maW5kUm9vdE1vc3RNYXRjaGluZ1BhdGhBbmRWYWx1ZShwYXRoUG9wRnJvbnQocmVsYXRpdmVQYXRoKSwgcHJlZGljYXRlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRFeGlzdGluZ1BhdGhBbmRWYWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZ1bGxQYXRoID0gcGF0aENoaWxkKG5ldyBQYXRoKGZyb250KSwgY2hpbGRFeGlzdGluZ1BhdGhBbmRWYWx1ZS5wYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcGF0aDogZnVsbFBhdGgsIHZhbHVlOiBjaGlsZEV4aXN0aW5nUGF0aEFuZFZhbHVlLnZhbHVlIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRmluZCwgaWYgaXQgZXhpc3RzLCB0aGUgc2hvcnRlc3Qgc3VicGF0aCBvZiB0aGUgZ2l2ZW4gcGF0aCB0aGF0IHBvaW50cyBhIGRlZmluZWRcclxuICAgICAqIHZhbHVlIGluIHRoZSB0cmVlXHJcbiAgICAgKi9cclxuICAgIGZpbmRSb290TW9zdFZhbHVlQW5kUGF0aChyZWxhdGl2ZVBhdGgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5maW5kUm9vdE1vc3RNYXRjaGluZ1BhdGhBbmRWYWx1ZShyZWxhdGl2ZVBhdGgsICgpID0+IHRydWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgc3VidHJlZSBhdCB0aGUgZ2l2ZW4gcGF0aFxyXG4gICAgICovXHJcbiAgICBzdWJ0cmVlKHJlbGF0aXZlUGF0aCkge1xyXG4gICAgICAgIGlmIChwYXRoSXNFbXB0eShyZWxhdGl2ZVBhdGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZnJvbnQgPSBwYXRoR2V0RnJvbnQocmVsYXRpdmVQYXRoKTtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGRUcmVlID0gdGhpcy5jaGlsZHJlbi5nZXQoZnJvbnQpO1xyXG4gICAgICAgICAgICBpZiAoY2hpbGRUcmVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRUcmVlLnN1YnRyZWUocGF0aFBvcEZyb250KHJlbGF0aXZlUGF0aCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbW11dGFibGVUcmVlKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGEgdmFsdWUgYXQgdGhlIHNwZWNpZmllZCBwYXRoLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSByZWxhdGl2ZVBhdGggLSBQYXRoIHRvIHNldCB2YWx1ZSBhdC5cclxuICAgICAqIEBwYXJhbSB0b1NldCAtIFZhbHVlIHRvIHNldC5cclxuICAgICAqIEByZXR1cm5zIFJlc3VsdGluZyB0cmVlLlxyXG4gICAgICovXHJcbiAgICBzZXQocmVsYXRpdmVQYXRoLCB0b1NldCkge1xyXG4gICAgICAgIGlmIChwYXRoSXNFbXB0eShyZWxhdGl2ZVBhdGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW1tdXRhYmxlVHJlZSh0b1NldCwgdGhpcy5jaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBmcm9udCA9IHBhdGhHZXRGcm9udChyZWxhdGl2ZVBhdGgpO1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hpbGRyZW4uZ2V0KGZyb250KSB8fCBuZXcgSW1tdXRhYmxlVHJlZShudWxsKTtcclxuICAgICAgICAgICAgY29uc3QgbmV3Q2hpbGQgPSBjaGlsZC5zZXQocGF0aFBvcEZyb250KHJlbGF0aXZlUGF0aCksIHRvU2V0KTtcclxuICAgICAgICAgICAgY29uc3QgbmV3Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLmluc2VydChmcm9udCwgbmV3Q2hpbGQpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEltbXV0YWJsZVRyZWUodGhpcy52YWx1ZSwgbmV3Q2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgdmFsdWUgYXQgdGhlIHNwZWNpZmllZCBwYXRoLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSByZWxhdGl2ZVBhdGggLSBQYXRoIHRvIHZhbHVlIHRvIHJlbW92ZS5cclxuICAgICAqIEByZXR1cm5zIFJlc3VsdGluZyB0cmVlLlxyXG4gICAgICovXHJcbiAgICByZW1vdmUocmVsYXRpdmVQYXRoKSB7XHJcbiAgICAgICAgaWYgKHBhdGhJc0VtcHR5KHJlbGF0aXZlUGF0aCkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4uaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEltbXV0YWJsZVRyZWUobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEltbXV0YWJsZVRyZWUobnVsbCwgdGhpcy5jaGlsZHJlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZyb250ID0gcGF0aEdldEZyb250KHJlbGF0aXZlUGF0aCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZHJlbi5nZXQoZnJvbnQpO1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0NoaWxkID0gY2hpbGQucmVtb3ZlKHBhdGhQb3BGcm9udChyZWxhdGl2ZVBhdGgpKTtcclxuICAgICAgICAgICAgICAgIGxldCBuZXdDaGlsZHJlbjtcclxuICAgICAgICAgICAgICAgIGlmIChuZXdDaGlsZC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4ucmVtb3ZlKGZyb250KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi5pbnNlcnQoZnJvbnQsIG5ld0NoaWxkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlID09PSBudWxsICYmIG5ld0NoaWxkcmVuLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW1tdXRhYmxlVHJlZShudWxsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW1tdXRhYmxlVHJlZSh0aGlzLnZhbHVlLCBuZXdDaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhIHZhbHVlIGZyb20gdGhlIHRyZWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHJlbGF0aXZlUGF0aCAtIFBhdGggdG8gZ2V0IHZhbHVlIGZvci5cclxuICAgICAqIEByZXR1cm5zIFZhbHVlIGF0IHBhdGgsIG9yIG51bGwuXHJcbiAgICAgKi9cclxuICAgIGdldChyZWxhdGl2ZVBhdGgpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkocmVsYXRpdmVQYXRoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZyb250ID0gcGF0aEdldEZyb250KHJlbGF0aXZlUGF0aCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZHJlbi5nZXQoZnJvbnQpO1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5nZXQocGF0aFBvcEZyb250KHJlbGF0aXZlUGF0aCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlcGxhY2UgdGhlIHN1YnRyZWUgYXQgdGhlIHNwZWNpZmllZCBwYXRoIHdpdGggdGhlIGdpdmVuIG5ldyB0cmVlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSByZWxhdGl2ZVBhdGggLSBQYXRoIHRvIHJlcGxhY2Ugc3VidHJlZSBmb3IuXHJcbiAgICAgKiBAcGFyYW0gbmV3VHJlZSAtIE5ldyB0cmVlLlxyXG4gICAgICogQHJldHVybnMgUmVzdWx0aW5nIHRyZWUuXHJcbiAgICAgKi9cclxuICAgIHNldFRyZWUocmVsYXRpdmVQYXRoLCBuZXdUcmVlKSB7XHJcbiAgICAgICAgaWYgKHBhdGhJc0VtcHR5KHJlbGF0aXZlUGF0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld1RyZWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBmcm9udCA9IHBhdGhHZXRGcm9udChyZWxhdGl2ZVBhdGgpO1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hpbGRyZW4uZ2V0KGZyb250KSB8fCBuZXcgSW1tdXRhYmxlVHJlZShudWxsKTtcclxuICAgICAgICAgICAgY29uc3QgbmV3Q2hpbGQgPSBjaGlsZC5zZXRUcmVlKHBhdGhQb3BGcm9udChyZWxhdGl2ZVBhdGgpLCBuZXdUcmVlKTtcclxuICAgICAgICAgICAgbGV0IG5ld0NoaWxkcmVuO1xyXG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4ucmVtb3ZlKGZyb250KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi5pbnNlcnQoZnJvbnQsIG5ld0NoaWxkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEltbXV0YWJsZVRyZWUodGhpcy52YWx1ZSwgbmV3Q2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGVyZm9ybXMgYSBkZXB0aCBmaXJzdCBmb2xkIG9uIHRoaXMgdHJlZS4gVHJhbnNmb3JtcyBhIHRyZWUgaW50byBhIHNpbmdsZVxyXG4gICAgICogdmFsdWUsIGdpdmVuIGEgZnVuY3Rpb24gdGhhdCBvcGVyYXRlcyBvbiB0aGUgcGF0aCB0byBhIG5vZGUsIGFuIG9wdGlvbmFsXHJcbiAgICAgKiBjdXJyZW50IHZhbHVlLCBhbmQgYSBtYXAgb2YgY2hpbGQgbmFtZXMgdG8gZm9sZGVkIHN1YnRyZWVzXHJcbiAgICAgKi9cclxuICAgIGZvbGQoZm4pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mb2xkXyhuZXdFbXB0eVBhdGgoKSwgZm4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWN1cnNpdmUgaGVscGVyIGZvciBwdWJsaWMtZmFjaW5nIGZvbGQoKSBtZXRob2RcclxuICAgICAqL1xyXG4gICAgZm9sZF8ocGF0aFNvRmFyLCBmbikge1xyXG4gICAgICAgIGNvbnN0IGFjY3VtID0ge307XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5pbm9yZGVyVHJhdmVyc2FsKChjaGlsZEtleSwgY2hpbGRUcmVlKSA9PiB7XHJcbiAgICAgICAgICAgIGFjY3VtW2NoaWxkS2V5XSA9IGNoaWxkVHJlZS5mb2xkXyhwYXRoQ2hpbGQocGF0aFNvRmFyLCBjaGlsZEtleSksIGZuKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZm4ocGF0aFNvRmFyLCB0aGlzLnZhbHVlLCBhY2N1bSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZpbmQgdGhlIGZpcnN0IG1hdGNoaW5nIHZhbHVlIG9uIHRoZSBnaXZlbiBwYXRoLiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBhcHBseWluZyBmIHRvIGl0LlxyXG4gICAgICovXHJcbiAgICBmaW5kT25QYXRoKHBhdGgsIGYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5maW5kT25QYXRoXyhwYXRoLCBuZXdFbXB0eVBhdGgoKSwgZik7XHJcbiAgICB9XHJcbiAgICBmaW5kT25QYXRoXyhwYXRoVG9Gb2xsb3csIHBhdGhTb0ZhciwgZikge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudmFsdWUgPyBmKHBhdGhTb0ZhciwgdGhpcy52YWx1ZSkgOiBmYWxzZTtcclxuICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAocGF0aElzRW1wdHkocGF0aFRvRm9sbG93KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmcm9udCA9IHBhdGhHZXRGcm9udChwYXRoVG9Gb2xsb3cpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENoaWxkID0gdGhpcy5jaGlsZHJlbi5nZXQoZnJvbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHRDaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0Q2hpbGQuZmluZE9uUGF0aF8ocGF0aFBvcEZyb250KHBhdGhUb0ZvbGxvdyksIHBhdGhDaGlsZChwYXRoU29GYXIsIGZyb250KSwgZik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvcmVhY2hPblBhdGgocGF0aCwgZikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZvcmVhY2hPblBhdGhfKHBhdGgsIG5ld0VtcHR5UGF0aCgpLCBmKTtcclxuICAgIH1cclxuICAgIGZvcmVhY2hPblBhdGhfKHBhdGhUb0ZvbGxvdywgY3VycmVudFJlbGF0aXZlUGF0aCwgZikge1xyXG4gICAgICAgIGlmIChwYXRoSXNFbXB0eShwYXRoVG9Gb2xsb3cpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGYoY3VycmVudFJlbGF0aXZlUGF0aCwgdGhpcy52YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZnJvbnQgPSBwYXRoR2V0RnJvbnQocGF0aFRvRm9sbG93KTtcclxuICAgICAgICAgICAgY29uc3QgbmV4dENoaWxkID0gdGhpcy5jaGlsZHJlbi5nZXQoZnJvbnQpO1xyXG4gICAgICAgICAgICBpZiAobmV4dENoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dENoaWxkLmZvcmVhY2hPblBhdGhfKHBhdGhQb3BGcm9udChwYXRoVG9Gb2xsb3cpLCBwYXRoQ2hpbGQoY3VycmVudFJlbGF0aXZlUGF0aCwgZnJvbnQpLCBmKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW1tdXRhYmxlVHJlZShudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbHMgdGhlIGdpdmVuIGZ1bmN0aW9uIGZvciBlYWNoIG5vZGUgaW4gdGhlIHRyZWUgdGhhdCBoYXMgYSB2YWx1ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZiAtIEEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdpdGggdGhlIHBhdGggZnJvbSB0aGUgcm9vdCBvZiB0aGUgdHJlZSB0b1xyXG4gICAgICogYSBub2RlLCBhbmQgdGhlIHZhbHVlIGF0IHRoYXQgbm9kZS4gQ2FsbGVkIGluIGRlcHRoLWZpcnN0IG9yZGVyLlxyXG4gICAgICovXHJcbiAgICBmb3JlYWNoKGYpIHtcclxuICAgICAgICB0aGlzLmZvcmVhY2hfKG5ld0VtcHR5UGF0aCgpLCBmKTtcclxuICAgIH1cclxuICAgIGZvcmVhY2hfKGN1cnJlbnRSZWxhdGl2ZVBhdGgsIGYpIHtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuLmlub3JkZXJUcmF2ZXJzYWwoKGNoaWxkTmFtZSwgY2hpbGRUcmVlKSA9PiB7XHJcbiAgICAgICAgICAgIGNoaWxkVHJlZS5mb3JlYWNoXyhwYXRoQ2hpbGQoY3VycmVudFJlbGF0aXZlUGF0aCwgY2hpbGROYW1lKSwgZik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHRoaXMudmFsdWUpIHtcclxuICAgICAgICAgICAgZihjdXJyZW50UmVsYXRpdmVQYXRoLCB0aGlzLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3JlYWNoQ2hpbGQoZikge1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uaW5vcmRlclRyYXZlcnNhbCgoY2hpbGROYW1lLCBjaGlsZFRyZWUpID0+IHtcclxuICAgICAgICAgICAgaWYgKGNoaWxkVHJlZS52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgZihjaGlsZE5hbWUsIGNoaWxkVHJlZS52YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhpcyBjbGFzcyBob2xkcyBhIGNvbGxlY3Rpb24gb2Ygd3JpdGVzIHRoYXQgY2FuIGJlIGFwcGxpZWQgdG8gbm9kZXMgaW4gdW5pc29uLiBJdCBhYnN0cmFjdHMgYXdheSB0aGUgbG9naWMgd2l0aFxyXG4gKiBkZWFsaW5nIHdpdGggcHJpb3JpdHkgd3JpdGVzIGFuZCBtdWx0aXBsZSBuZXN0ZWQgd3JpdGVzLiBBdCBhbnkgZ2l2ZW4gcGF0aCB0aGVyZSBpcyBvbmx5IGFsbG93ZWQgdG8gYmUgb25lIHdyaXRlXHJcbiAqIG1vZGlmeWluZyB0aGF0IHBhdGguIEFueSB3cml0ZSB0byBhbiBleGlzdGluZyBwYXRoIG9yIHNoYWRvd2luZyBhbiBleGlzdGluZyBwYXRoIHdpbGwgbW9kaWZ5IHRoYXQgZXhpc3Rpbmcgd3JpdGVcclxuICogdG8gcmVmbGVjdCB0aGUgd3JpdGUgYWRkZWQuXHJcbiAqL1xyXG5jbGFzcyBDb21wb3VuZFdyaXRlIHtcclxuICAgIGNvbnN0cnVjdG9yKHdyaXRlVHJlZV8pIHtcclxuICAgICAgICB0aGlzLndyaXRlVHJlZV8gPSB3cml0ZVRyZWVfO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGVtcHR5KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29tcG91bmRXcml0ZShuZXcgSW1tdXRhYmxlVHJlZShudWxsKSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY29tcG91bmRXcml0ZUFkZFdyaXRlKGNvbXBvdW5kV3JpdGUsIHBhdGgsIG5vZGUpIHtcclxuICAgIGlmIChwYXRoSXNFbXB0eShwYXRoKSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29tcG91bmRXcml0ZShuZXcgSW1tdXRhYmxlVHJlZShub2RlKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCByb290bW9zdCA9IGNvbXBvdW5kV3JpdGUud3JpdGVUcmVlXy5maW5kUm9vdE1vc3RWYWx1ZUFuZFBhdGgocGF0aCk7XHJcbiAgICAgICAgaWYgKHJvb3Rtb3N0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgY29uc3Qgcm9vdE1vc3RQYXRoID0gcm9vdG1vc3QucGF0aDtcclxuICAgICAgICAgICAgbGV0IHZhbHVlID0gcm9vdG1vc3QudmFsdWU7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IG5ld1JlbGF0aXZlUGF0aChyb290TW9zdFBhdGgsIHBhdGgpO1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnVwZGF0ZUNoaWxkKHJlbGF0aXZlUGF0aCwgbm9kZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcG91bmRXcml0ZShjb21wb3VuZFdyaXRlLndyaXRlVHJlZV8uc2V0KHJvb3RNb3N0UGF0aCwgdmFsdWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN1YnRyZWUgPSBuZXcgSW1tdXRhYmxlVHJlZShub2RlKTtcclxuICAgICAgICAgICAgY29uc3QgbmV3V3JpdGVUcmVlID0gY29tcG91bmRXcml0ZS53cml0ZVRyZWVfLnNldFRyZWUocGF0aCwgc3VidHJlZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcG91bmRXcml0ZShuZXdXcml0ZVRyZWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjb21wb3VuZFdyaXRlQWRkV3JpdGVzKGNvbXBvdW5kV3JpdGUsIHBhdGgsIHVwZGF0ZXMpIHtcclxuICAgIGxldCBuZXdXcml0ZSA9IGNvbXBvdW5kV3JpdGU7XHJcbiAgICBlYWNoKHVwZGF0ZXMsIChjaGlsZEtleSwgbm9kZSkgPT4ge1xyXG4gICAgICAgIG5ld1dyaXRlID0gY29tcG91bmRXcml0ZUFkZFdyaXRlKG5ld1dyaXRlLCBwYXRoQ2hpbGQocGF0aCwgY2hpbGRLZXkpLCBub2RlKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG5ld1dyaXRlO1xyXG59XHJcbi8qKlxyXG4gKiBXaWxsIHJlbW92ZSBhIHdyaXRlIGF0IHRoZSBnaXZlbiBwYXRoIGFuZCBkZWVwZXIgcGF0aHMuIFRoaXMgd2lsbCA8ZW0+bm90PC9lbT4gbW9kaWZ5IGEgd3JpdGUgYXQgYSBoaWdoZXJcclxuICogbG9jYXRpb24sIHdoaWNoIG11c3QgYmUgcmVtb3ZlZCBieSBjYWxsaW5nIHRoaXMgbWV0aG9kIHdpdGggdGhhdCBwYXRoLlxyXG4gKlxyXG4gKiBAcGFyYW0gY29tcG91bmRXcml0ZSAtIFRoZSBDb21wb3VuZFdyaXRlIHRvIHJlbW92ZS5cclxuICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCBhdCB3aGljaCBhIHdyaXRlIGFuZCBhbGwgZGVlcGVyIHdyaXRlcyBzaG91bGQgYmUgcmVtb3ZlZFxyXG4gKiBAcmV0dXJucyBUaGUgbmV3IENvbXBvdW5kV3JpdGUgd2l0aCB0aGUgcmVtb3ZlZCBwYXRoXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wb3VuZFdyaXRlUmVtb3ZlV3JpdGUoY29tcG91bmRXcml0ZSwgcGF0aCkge1xyXG4gICAgaWYgKHBhdGhJc0VtcHR5KHBhdGgpKSB7XHJcbiAgICAgICAgcmV0dXJuIENvbXBvdW5kV3JpdGUuZW1wdHkoKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IG5ld1dyaXRlVHJlZSA9IGNvbXBvdW5kV3JpdGUud3JpdGVUcmVlXy5zZXRUcmVlKHBhdGgsIG5ldyBJbW11dGFibGVUcmVlKG51bGwpKTtcclxuICAgICAgICByZXR1cm4gbmV3IENvbXBvdW5kV3JpdGUobmV3V3JpdGVUcmVlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIHRoaXMgQ29tcG91bmRXcml0ZSB3aWxsIGZ1bGx5IG92ZXJ3cml0ZSBhIG5vZGUgYXQgYSBnaXZlbiBsb2NhdGlvbiBhbmQgY2FuIHRoZXJlZm9yZSBiZVxyXG4gKiBjb25zaWRlcmVkIFwiY29tcGxldGVcIi5cclxuICpcclxuICogQHBhcmFtIGNvbXBvdW5kV3JpdGUgLSBUaGUgQ29tcG91bmRXcml0ZSB0byBjaGVjay5cclxuICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byBjaGVjayBmb3JcclxuICogQHJldHVybnMgV2hldGhlciB0aGVyZSBpcyBhIGNvbXBsZXRlIHdyaXRlIGF0IHRoYXQgcGF0aFxyXG4gKi9cclxuZnVuY3Rpb24gY29tcG91bmRXcml0ZUhhc0NvbXBsZXRlV3JpdGUoY29tcG91bmRXcml0ZSwgcGF0aCkge1xyXG4gICAgcmV0dXJuIGNvbXBvdW5kV3JpdGVHZXRDb21wbGV0ZU5vZGUoY29tcG91bmRXcml0ZSwgcGF0aCkgIT0gbnVsbDtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIG5vZGUgZm9yIGEgcGF0aCBpZiBhbmQgb25seSBpZiB0aGUgbm9kZSBpcyBhIFwiY29tcGxldGVcIiBvdmVyd3JpdGUgYXQgdGhhdCBwYXRoLiBUaGlzIHdpbGwgbm90IGFnZ3JlZ2F0ZVxyXG4gKiB3cml0ZXMgZnJvbSBkZWVwZXIgcGF0aHMsIGJ1dCB3aWxsIHJldHVybiBjaGlsZCBub2RlcyBmcm9tIGEgbW9yZSBzaGFsbG93IHBhdGguXHJcbiAqXHJcbiAqIEBwYXJhbSBjb21wb3VuZFdyaXRlIC0gVGhlIENvbXBvdW5kV3JpdGUgdG8gZ2V0IHRoZSBub2RlIGZyb20uXHJcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdG8gZ2V0IGEgY29tcGxldGUgd3JpdGVcclxuICogQHJldHVybnMgVGhlIG5vZGUgaWYgY29tcGxldGUgYXQgdGhhdCBwYXRoLCBvciBudWxsIG90aGVyd2lzZS5cclxuICovXHJcbmZ1bmN0aW9uIGNvbXBvdW5kV3JpdGVHZXRDb21wbGV0ZU5vZGUoY29tcG91bmRXcml0ZSwgcGF0aCkge1xyXG4gICAgY29uc3Qgcm9vdG1vc3QgPSBjb21wb3VuZFdyaXRlLndyaXRlVHJlZV8uZmluZFJvb3RNb3N0VmFsdWVBbmRQYXRoKHBhdGgpO1xyXG4gICAgaWYgKHJvb3Rtb3N0ICE9IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gY29tcG91bmRXcml0ZS53cml0ZVRyZWVfXHJcbiAgICAgICAgICAgIC5nZXQocm9vdG1vc3QucGF0aClcclxuICAgICAgICAgICAgLmdldENoaWxkKG5ld1JlbGF0aXZlUGF0aChyb290bW9zdC5wYXRoLCBwYXRoKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0dXJucyBhbGwgY2hpbGRyZW4gdGhhdCBhcmUgZ3VhcmFudGVlZCB0byBiZSBhIGNvbXBsZXRlIG92ZXJ3cml0ZS5cclxuICpcclxuICogQHBhcmFtIGNvbXBvdW5kV3JpdGUgLSBUaGUgQ29tcG91bmRXcml0ZSB0byBnZXQgY2hpbGRyZW4gZnJvbS5cclxuICogQHJldHVybnMgQSBsaXN0IG9mIGFsbCBjb21wbGV0ZSBjaGlsZHJlbi5cclxuICovXHJcbmZ1bmN0aW9uIGNvbXBvdW5kV3JpdGVHZXRDb21wbGV0ZUNoaWxkcmVuKGNvbXBvdW5kV3JpdGUpIHtcclxuICAgIGNvbnN0IGNoaWxkcmVuID0gW107XHJcbiAgICBjb25zdCBub2RlID0gY29tcG91bmRXcml0ZS53cml0ZVRyZWVfLnZhbHVlO1xyXG4gICAgaWYgKG5vZGUgIT0gbnVsbCkge1xyXG4gICAgICAgIC8vIElmIGl0J3MgYSBsZWFmIG5vZGUsIGl0IGhhcyBubyBjaGlsZHJlbjsgc28gbm90aGluZyB0byBkby5cclxuICAgICAgICBpZiAoIW5vZGUuaXNMZWFmTm9kZSgpKSB7XHJcbiAgICAgICAgICAgIG5vZGUuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCAoY2hpbGROYW1lLCBjaGlsZE5vZGUpID0+IHtcclxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobmV3IE5hbWVkTm9kZShjaGlsZE5hbWUsIGNoaWxkTm9kZSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb21wb3VuZFdyaXRlLndyaXRlVHJlZV8uY2hpbGRyZW4uaW5vcmRlclRyYXZlcnNhbCgoY2hpbGROYW1lLCBjaGlsZFRyZWUpID0+IHtcclxuICAgICAgICAgICAgaWYgKGNoaWxkVHJlZS52YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5ldyBOYW1lZE5vZGUoY2hpbGROYW1lLCBjaGlsZFRyZWUudmFsdWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNoaWxkcmVuO1xyXG59XHJcbmZ1bmN0aW9uIGNvbXBvdW5kV3JpdGVDaGlsZENvbXBvdW5kV3JpdGUoY29tcG91bmRXcml0ZSwgcGF0aCkge1xyXG4gICAgaWYgKHBhdGhJc0VtcHR5KHBhdGgpKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBvdW5kV3JpdGU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBzaGFkb3dpbmdOb2RlID0gY29tcG91bmRXcml0ZUdldENvbXBsZXRlTm9kZShjb21wb3VuZFdyaXRlLCBwYXRoKTtcclxuICAgICAgICBpZiAoc2hhZG93aW5nTm9kZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcG91bmRXcml0ZShuZXcgSW1tdXRhYmxlVHJlZShzaGFkb3dpbmdOb2RlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBvdW5kV3JpdGUoY29tcG91bmRXcml0ZS53cml0ZVRyZWVfLnN1YnRyZWUocGF0aCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIHRoaXMgQ29tcG91bmRXcml0ZSBpcyBlbXB0eSBhbmQgdGhlcmVmb3JlIGRvZXMgbm90IG1vZGlmeSBhbnkgbm9kZXMuXHJcbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhpcyBDb21wb3VuZFdyaXRlIGlzIGVtcHR5XHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wb3VuZFdyaXRlSXNFbXB0eShjb21wb3VuZFdyaXRlKSB7XHJcbiAgICByZXR1cm4gY29tcG91bmRXcml0ZS53cml0ZVRyZWVfLmlzRW1wdHkoKTtcclxufVxyXG4vKipcclxuICogQXBwbGllcyB0aGlzIENvbXBvdW5kV3JpdGUgdG8gYSBub2RlLiBUaGUgbm9kZSBpcyByZXR1cm5lZCB3aXRoIGFsbCB3cml0ZXMgZnJvbSB0aGlzIENvbXBvdW5kV3JpdGUgYXBwbGllZCB0byB0aGVcclxuICogbm9kZVxyXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIGFwcGx5IHRoaXMgQ29tcG91bmRXcml0ZSB0b1xyXG4gKiBAcmV0dXJucyBUaGUgbm9kZSB3aXRoIGFsbCB3cml0ZXMgYXBwbGllZFxyXG4gKi9cclxuZnVuY3Rpb24gY29tcG91bmRXcml0ZUFwcGx5KGNvbXBvdW5kV3JpdGUsIG5vZGUpIHtcclxuICAgIHJldHVybiBhcHBseVN1YnRyZWVXcml0ZShuZXdFbXB0eVBhdGgoKSwgY29tcG91bmRXcml0ZS53cml0ZVRyZWVfLCBub2RlKTtcclxufVxyXG5mdW5jdGlvbiBhcHBseVN1YnRyZWVXcml0ZShyZWxhdGl2ZVBhdGgsIHdyaXRlVHJlZSwgbm9kZSkge1xyXG4gICAgaWYgKHdyaXRlVHJlZS52YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgLy8gU2luY2UgdGhlcmUgYSB3cml0ZSBpcyBhbHdheXMgYSBsZWFmLCB3ZSdyZSBkb25lIGhlcmVcclxuICAgICAgICByZXR1cm4gbm9kZS51cGRhdGVDaGlsZChyZWxhdGl2ZVBhdGgsIHdyaXRlVHJlZS52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsZXQgcHJpb3JpdHlXcml0ZSA9IG51bGw7XHJcbiAgICAgICAgd3JpdGVUcmVlLmNoaWxkcmVuLmlub3JkZXJUcmF2ZXJzYWwoKGNoaWxkS2V5LCBjaGlsZFRyZWUpID0+IHtcclxuICAgICAgICAgICAgaWYgKGNoaWxkS2V5ID09PSAnLnByaW9yaXR5Jykge1xyXG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgcHJpb3JpdGllcyBhdCB0aGUgZW5kIHNvIHdlIGRvbid0IHVwZGF0ZSBwcmlvcml0aWVzIGZvciBlaXRoZXIgZW1wdHkgbm9kZXMgb3IgZm9yZ2V0XHJcbiAgICAgICAgICAgICAgICAvLyB0byBhcHBseSBwcmlvcml0aWVzIHRvIGVtcHR5IG5vZGVzIHRoYXQgYXJlIGxhdGVyIGZpbGxlZFxyXG4gICAgICAgICAgICAgICAgYXNzZXJ0KGNoaWxkVHJlZS52YWx1ZSAhPT0gbnVsbCwgJ1ByaW9yaXR5IHdyaXRlcyBtdXN0IGFsd2F5cyBiZSBsZWFmIG5vZGVzJyk7XHJcbiAgICAgICAgICAgICAgICBwcmlvcml0eVdyaXRlID0gY2hpbGRUcmVlLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IGFwcGx5U3VidHJlZVdyaXRlKHBhdGhDaGlsZChyZWxhdGl2ZVBhdGgsIGNoaWxkS2V5KSwgY2hpbGRUcmVlLCBub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIElmIHRoZXJlIHdhcyBhIHByaW9yaXR5IHdyaXRlLCB3ZSBvbmx5IGFwcGx5IGl0IGlmIHRoZSBub2RlIGlzIG5vdCBlbXB0eVxyXG4gICAgICAgIGlmICghbm9kZS5nZXRDaGlsZChyZWxhdGl2ZVBhdGgpLmlzRW1wdHkoKSAmJiBwcmlvcml0eVdyaXRlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnVwZGF0ZUNoaWxkKHBhdGhDaGlsZChyZWxhdGl2ZVBhdGgsICcucHJpb3JpdHknKSwgcHJpb3JpdHlXcml0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgV3JpdGVUcmVlUmVmIGZvciB0aGUgZ2l2ZW4gcGF0aC4gRm9yIHVzZSB3aXRoIGEgbmV3IHN5bmMgcG9pbnQgYXQgdGhlIGdpdmVuIHBhdGguXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVDaGlsZFdyaXRlcyh3cml0ZVRyZWUsIHBhdGgpIHtcclxuICAgIHJldHVybiBuZXdXcml0ZVRyZWVSZWYocGF0aCwgd3JpdGVUcmVlKTtcclxufVxyXG4vKipcclxuICogUmVjb3JkIGEgbmV3IG92ZXJ3cml0ZSBmcm9tIHVzZXIgY29kZS5cclxuICpcclxuICogQHBhcmFtIHZpc2libGUgLSBUaGlzIGlzIHNldCB0byBmYWxzZSBieSBzb21lIHRyYW5zYWN0aW9ucy4gSXQgc2hvdWxkIGJlIGV4Y2x1ZGVkIGZyb20gZXZlbnQgY2FjaGVzXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVBZGRPdmVyd3JpdGUod3JpdGVUcmVlLCBwYXRoLCBzbmFwLCB3cml0ZUlkLCB2aXNpYmxlKSB7XHJcbiAgICBhc3NlcnQod3JpdGVJZCA+IHdyaXRlVHJlZS5sYXN0V3JpdGVJZCwgJ1N0YWNraW5nIGFuIG9sZGVyIHdyaXRlIG9uIHRvcCBvZiBuZXdlciBvbmVzJyk7XHJcbiAgICBpZiAodmlzaWJsZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdmlzaWJsZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICB3cml0ZVRyZWUuYWxsV3JpdGVzLnB1c2goe1xyXG4gICAgICAgIHBhdGgsXHJcbiAgICAgICAgc25hcCxcclxuICAgICAgICB3cml0ZUlkLFxyXG4gICAgICAgIHZpc2libGVcclxuICAgIH0pO1xyXG4gICAgaWYgKHZpc2libGUpIHtcclxuICAgICAgICB3cml0ZVRyZWUudmlzaWJsZVdyaXRlcyA9IGNvbXBvdW5kV3JpdGVBZGRXcml0ZSh3cml0ZVRyZWUudmlzaWJsZVdyaXRlcywgcGF0aCwgc25hcCk7XHJcbiAgICB9XHJcbiAgICB3cml0ZVRyZWUubGFzdFdyaXRlSWQgPSB3cml0ZUlkO1xyXG59XHJcbi8qKlxyXG4gKiBSZWNvcmQgYSBuZXcgbWVyZ2UgZnJvbSB1c2VyIGNvZGUuXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVBZGRNZXJnZSh3cml0ZVRyZWUsIHBhdGgsIGNoYW5nZWRDaGlsZHJlbiwgd3JpdGVJZCkge1xyXG4gICAgYXNzZXJ0KHdyaXRlSWQgPiB3cml0ZVRyZWUubGFzdFdyaXRlSWQsICdTdGFja2luZyBhbiBvbGRlciBtZXJnZSBvbiB0b3Agb2YgbmV3ZXIgb25lcycpO1xyXG4gICAgd3JpdGVUcmVlLmFsbFdyaXRlcy5wdXNoKHtcclxuICAgICAgICBwYXRoLFxyXG4gICAgICAgIGNoaWxkcmVuOiBjaGFuZ2VkQ2hpbGRyZW4sXHJcbiAgICAgICAgd3JpdGVJZCxcclxuICAgICAgICB2aXNpYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzID0gY29tcG91bmRXcml0ZUFkZFdyaXRlcyh3cml0ZVRyZWUudmlzaWJsZVdyaXRlcywgcGF0aCwgY2hhbmdlZENoaWxkcmVuKTtcclxuICAgIHdyaXRlVHJlZS5sYXN0V3JpdGVJZCA9IHdyaXRlSWQ7XHJcbn1cclxuZnVuY3Rpb24gd3JpdGVUcmVlR2V0V3JpdGUod3JpdGVUcmVlLCB3cml0ZUlkKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdyaXRlVHJlZS5hbGxXcml0ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCByZWNvcmQgPSB3cml0ZVRyZWUuYWxsV3JpdGVzW2ldO1xyXG4gICAgICAgIGlmIChyZWNvcmQud3JpdGVJZCA9PT0gd3JpdGVJZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVjb3JkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbi8qKlxyXG4gKiBSZW1vdmUgYSB3cml0ZSAoZWl0aGVyIGFuIG92ZXJ3cml0ZSBvciBtZXJnZSkgdGhhdCBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgYWNrbm93bGVkZ2UgYnkgdGhlIHNlcnZlci4gUmVjYWxjdWxhdGVzXHJcbiAqIHRoZSB0cmVlIGlmIG5lY2Vzc2FyeS4gIFdlIHJldHVybiB0cnVlIGlmIGl0IG1heSBoYXZlIGJlZW4gdmlzaWJsZSwgbWVhbmluZyB2aWV3cyBuZWVkIHRvIHJlZXZhbHVhdGUuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHdyaXRlIG1heSBoYXZlIGJlZW4gdmlzaWJsZSAobWVhbmluZyB3ZSdsbCBuZWVkIHRvIHJlZXZhbHVhdGUgLyByYWlzZVxyXG4gKiBldmVudHMgYXMgYSByZXN1bHQpLlxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlUmVtb3ZlV3JpdGUod3JpdGVUcmVlLCB3cml0ZUlkKSB7XHJcbiAgICAvLyBOb3RlOiBkaXNhYmxpbmcgdGhpcyBjaGVjay4gSXQgY291bGQgYmUgYSB0cmFuc2FjdGlvbiB0aGF0IHByZWVtcHRlZCBhbm90aGVyIHRyYW5zYWN0aW9uLCBhbmQgdGh1cyB3YXMgYXBwbGllZFxyXG4gICAgLy8gb3V0IG9mIG9yZGVyLlxyXG4gICAgLy9jb25zdCB2YWxpZENsZWFyID0gcmV2ZXJ0IHx8IHRoaXMuYWxsV3JpdGVzXy5sZW5ndGggPT09IDAgfHwgd3JpdGVJZCA8PSB0aGlzLmFsbFdyaXRlc19bMF0ud3JpdGVJZDtcclxuICAgIC8vYXNzZXJ0KHZhbGlkQ2xlYXIsIFwiRWl0aGVyIHdlIGRvbid0IGhhdmUgdGhpcyB3cml0ZSwgb3IgaXQncyB0aGUgZmlyc3Qgb25lIGluIHRoZSBxdWV1ZVwiKTtcclxuICAgIGNvbnN0IGlkeCA9IHdyaXRlVHJlZS5hbGxXcml0ZXMuZmluZEluZGV4KHMgPT4ge1xyXG4gICAgICAgIHJldHVybiBzLndyaXRlSWQgPT09IHdyaXRlSWQ7XHJcbiAgICB9KTtcclxuICAgIGFzc2VydChpZHggPj0gMCwgJ3JlbW92ZVdyaXRlIGNhbGxlZCB3aXRoIG5vbmV4aXN0ZW50IHdyaXRlSWQuJyk7XHJcbiAgICBjb25zdCB3cml0ZVRvUmVtb3ZlID0gd3JpdGVUcmVlLmFsbFdyaXRlc1tpZHhdO1xyXG4gICAgd3JpdGVUcmVlLmFsbFdyaXRlcy5zcGxpY2UoaWR4LCAxKTtcclxuICAgIGxldCByZW1vdmVkV3JpdGVXYXNWaXNpYmxlID0gd3JpdGVUb1JlbW92ZS52aXNpYmxlO1xyXG4gICAgbGV0IHJlbW92ZWRXcml0ZU92ZXJsYXBzV2l0aE90aGVyV3JpdGVzID0gZmFsc2U7XHJcbiAgICBsZXQgaSA9IHdyaXRlVHJlZS5hbGxXcml0ZXMubGVuZ3RoIC0gMTtcclxuICAgIHdoaWxlIChyZW1vdmVkV3JpdGVXYXNWaXNpYmxlICYmIGkgPj0gMCkge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRXcml0ZSA9IHdyaXRlVHJlZS5hbGxXcml0ZXNbaV07XHJcbiAgICAgICAgaWYgKGN1cnJlbnRXcml0ZS52aXNpYmxlKSB7XHJcbiAgICAgICAgICAgIGlmIChpID49IGlkeCAmJlxyXG4gICAgICAgICAgICAgICAgd3JpdGVUcmVlUmVjb3JkQ29udGFpbnNQYXRoXyhjdXJyZW50V3JpdGUsIHdyaXRlVG9SZW1vdmUucGF0aCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSByZW1vdmVkIHdyaXRlIHdhcyBjb21wbGV0ZWx5IHNoYWRvd2VkIGJ5IGEgc3Vic2VxdWVudCB3cml0ZS5cclxuICAgICAgICAgICAgICAgIHJlbW92ZWRXcml0ZVdhc1Zpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwYXRoQ29udGFpbnMod3JpdGVUb1JlbW92ZS5wYXRoLCBjdXJyZW50V3JpdGUucGF0aCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIEVpdGhlciB3ZSdyZSBjb3ZlcmluZyBzb21lIHdyaXRlcyBvciB0aGV5J3JlIGNvdmVyaW5nIHBhcnQgb2YgdXMgKGRlcGVuZGluZyBvbiB3aGljaCBjYW1lIGZpcnN0KS5cclxuICAgICAgICAgICAgICAgIHJlbW92ZWRXcml0ZU92ZXJsYXBzV2l0aE90aGVyV3JpdGVzID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpLS07XHJcbiAgICB9XHJcbiAgICBpZiAoIXJlbW92ZWRXcml0ZVdhc1Zpc2libGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChyZW1vdmVkV3JpdGVPdmVybGFwc1dpdGhPdGhlcldyaXRlcykge1xyXG4gICAgICAgIC8vIFRoZXJlJ3Mgc29tZSBzaGFkb3dpbmcgZ29pbmcgb24uIEp1c3QgcmVidWlsZCB0aGUgdmlzaWJsZSB3cml0ZXMgZnJvbSBzY3JhdGNoLlxyXG4gICAgICAgIHdyaXRlVHJlZVJlc2V0VHJlZV8od3JpdGVUcmVlKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIFRoZXJlJ3Mgbm8gc2hhZG93aW5nLiAgV2UgY2FuIHNhZmVseSBqdXN0IHJlbW92ZSB0aGUgd3JpdGUocykgZnJvbSB2aXNpYmxlV3JpdGVzLlxyXG4gICAgICAgIGlmICh3cml0ZVRvUmVtb3ZlLnNuYXApIHtcclxuICAgICAgICAgICAgd3JpdGVUcmVlLnZpc2libGVXcml0ZXMgPSBjb21wb3VuZFdyaXRlUmVtb3ZlV3JpdGUod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHdyaXRlVG9SZW1vdmUucGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHdyaXRlVG9SZW1vdmUuY2hpbGRyZW47XHJcbiAgICAgICAgICAgIGVhY2goY2hpbGRyZW4sIChjaGlsZE5hbWUpID0+IHtcclxuICAgICAgICAgICAgICAgIHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzID0gY29tcG91bmRXcml0ZVJlbW92ZVdyaXRlKHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzLCBwYXRoQ2hpbGQod3JpdGVUb1JlbW92ZS5wYXRoLCBjaGlsZE5hbWUpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHdyaXRlVHJlZVJlY29yZENvbnRhaW5zUGF0aF8od3JpdGVSZWNvcmQsIHBhdGgpIHtcclxuICAgIGlmICh3cml0ZVJlY29yZC5zbmFwKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdGhDb250YWlucyh3cml0ZVJlY29yZC5wYXRoLCBwYXRoKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGZvciAoY29uc3QgY2hpbGROYW1lIGluIHdyaXRlUmVjb3JkLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIGlmICh3cml0ZVJlY29yZC5jaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShjaGlsZE5hbWUpICYmXHJcbiAgICAgICAgICAgICAgICBwYXRoQ29udGFpbnMocGF0aENoaWxkKHdyaXRlUmVjb3JkLnBhdGgsIGNoaWxkTmFtZSksIHBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlLWxheWVyIHRoZSB3cml0ZXMgYW5kIG1lcmdlcyBpbnRvIGEgdHJlZSBzbyB3ZSBjYW4gZWZmaWNpZW50bHkgY2FsY3VsYXRlIGV2ZW50IHNuYXBzaG90c1xyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlUmVzZXRUcmVlXyh3cml0ZVRyZWUpIHtcclxuICAgIHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzID0gd3JpdGVUcmVlTGF5ZXJUcmVlXyh3cml0ZVRyZWUuYWxsV3JpdGVzLCB3cml0ZVRyZWVEZWZhdWx0RmlsdGVyXywgbmV3RW1wdHlQYXRoKCkpO1xyXG4gICAgaWYgKHdyaXRlVHJlZS5hbGxXcml0ZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHdyaXRlVHJlZS5sYXN0V3JpdGVJZCA9XHJcbiAgICAgICAgICAgIHdyaXRlVHJlZS5hbGxXcml0ZXNbd3JpdGVUcmVlLmFsbFdyaXRlcy5sZW5ndGggLSAxXS53cml0ZUlkO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgd3JpdGVUcmVlLmxhc3RXcml0ZUlkID0gLTE7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoZSBkZWZhdWx0IGZpbHRlciB1c2VkIHdoZW4gY29uc3RydWN0aW5nIHRoZSB0cmVlLiBLZWVwIGV2ZXJ5dGhpbmcgdGhhdCdzIHZpc2libGUuXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVEZWZhdWx0RmlsdGVyXyh3cml0ZSkge1xyXG4gICAgcmV0dXJuIHdyaXRlLnZpc2libGU7XHJcbn1cclxuLyoqXHJcbiAqIFN0YXRpYyBtZXRob2QuIEdpdmVuIGFuIGFycmF5IG9mIFdyaXRlUmVjb3JkcywgYSBmaWx0ZXIgZm9yIHdoaWNoIG9uZXMgdG8gaW5jbHVkZSwgYW5kIGEgcGF0aCwgY29uc3RydWN0IHRoZSB0cmVlIG9mXHJcbiAqIGV2ZW50IGRhdGEgYXQgdGhhdCBwYXRoLlxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlTGF5ZXJUcmVlXyh3cml0ZXMsIGZpbHRlciwgdHJlZVJvb3QpIHtcclxuICAgIGxldCBjb21wb3VuZFdyaXRlID0gQ29tcG91bmRXcml0ZS5lbXB0eSgpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3cml0ZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjb25zdCB3cml0ZSA9IHdyaXRlc1tpXTtcclxuICAgICAgICAvLyBUaGVvcnksIGEgbGF0ZXIgc2V0IHdpbGwgZWl0aGVyOlxyXG4gICAgICAgIC8vIGEpIGFib3J0IGEgcmVsZXZhbnQgdHJhbnNhY3Rpb24sIHNvIG5vIG5lZWQgdG8gd29ycnkgYWJvdXQgZXhjbHVkaW5nIGl0IGZyb20gY2FsY3VsYXRpbmcgdGhhdCB0cmFuc2FjdGlvblxyXG4gICAgICAgIC8vIGIpIG5vdCBiZSByZWxldmFudCB0byBhIHRyYW5zYWN0aW9uIChzZXBhcmF0ZSBicmFuY2gpLCBzbyBhZ2FpbiB3aWxsIG5vdCBhZmZlY3QgdGhlIGRhdGEgZm9yIHRoYXQgdHJhbnNhY3Rpb25cclxuICAgICAgICBpZiAoZmlsdGVyKHdyaXRlKSkge1xyXG4gICAgICAgICAgICBjb25zdCB3cml0ZVBhdGggPSB3cml0ZS5wYXRoO1xyXG4gICAgICAgICAgICBsZXQgcmVsYXRpdmVQYXRoO1xyXG4gICAgICAgICAgICBpZiAod3JpdGUuc25hcCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhdGhDb250YWlucyh0cmVlUm9vdCwgd3JpdGVQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlUGF0aCA9IG5ld1JlbGF0aXZlUGF0aCh0cmVlUm9vdCwgd3JpdGVQYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb21wb3VuZFdyaXRlID0gY29tcG91bmRXcml0ZUFkZFdyaXRlKGNvbXBvdW5kV3JpdGUsIHJlbGF0aXZlUGF0aCwgd3JpdGUuc25hcCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXRoQ29udGFpbnMod3JpdGVQYXRoLCB0cmVlUm9vdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZVBhdGggPSBuZXdSZWxhdGl2ZVBhdGgod3JpdGVQYXRoLCB0cmVlUm9vdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG91bmRXcml0ZSA9IGNvbXBvdW5kV3JpdGVBZGRXcml0ZShjb21wb3VuZFdyaXRlLCBuZXdFbXB0eVBhdGgoKSwgd3JpdGUuc25hcC5nZXRDaGlsZChyZWxhdGl2ZVBhdGgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHdyaXRlLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGF0aENvbnRhaW5zKHRyZWVSb290LCB3cml0ZVBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVQYXRoID0gbmV3UmVsYXRpdmVQYXRoKHRyZWVSb290LCB3cml0ZVBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvdW5kV3JpdGUgPSBjb21wb3VuZFdyaXRlQWRkV3JpdGVzKGNvbXBvdW5kV3JpdGUsIHJlbGF0aXZlUGF0aCwgd3JpdGUuY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGF0aENvbnRhaW5zKHdyaXRlUGF0aCwgdHJlZVJvb3QpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVQYXRoID0gbmV3UmVsYXRpdmVQYXRoKHdyaXRlUGF0aCwgdHJlZVJvb3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXRoSXNFbXB0eShyZWxhdGl2ZVBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvdW5kV3JpdGUgPSBjb21wb3VuZFdyaXRlQWRkV3JpdGVzKGNvbXBvdW5kV3JpdGUsIG5ld0VtcHR5UGF0aCgpLCB3cml0ZS5jaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IHNhZmVHZXQod3JpdGUuY2hpbGRyZW4sIHBhdGhHZXRGcm9udChyZWxhdGl2ZVBhdGgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBleGlzdHMgYSBjaGlsZCBpbiB0aGlzIG5vZGUgdGhhdCBtYXRjaGVzIHRoZSByb290IHBhdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlZXBOb2RlID0gY2hpbGQuZ2V0Q2hpbGQocGF0aFBvcEZyb250KHJlbGF0aXZlUGF0aCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG91bmRXcml0ZSA9IGNvbXBvdW5kV3JpdGVBZGRXcml0ZShjb21wb3VuZFdyaXRlLCBuZXdFbXB0eVBhdGgoKSwgZGVlcE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBhc3NlcnRpb25FcnJvcignV3JpdGVSZWNvcmQgc2hvdWxkIGhhdmUgLnNuYXAgb3IgLmNoaWxkcmVuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29tcG91bmRXcml0ZTtcclxufVxyXG4vKipcclxuICogR2l2ZW4gb3B0aW9uYWwsIHVuZGVybHlpbmcgc2VydmVyIGRhdGEsIGFuZCBhbiBvcHRpb25hbCBzZXQgb2YgY29uc3RyYWludHMgKGV4Y2x1ZGUgc29tZSBzZXRzLCBpbmNsdWRlIGhpZGRlblxyXG4gKiB3cml0ZXMpLCBhdHRlbXB0IHRvIGNhbGN1bGF0ZSBhIGNvbXBsZXRlIHNuYXBzaG90IGZvciB0aGUgZ2l2ZW4gcGF0aFxyXG4gKlxyXG4gKiBAcGFyYW0gd3JpdGVJZHNUb0V4Y2x1ZGUgLSBBbiBvcHRpb25hbCBzZXQgdG8gYmUgZXhjbHVkZWRcclxuICogQHBhcmFtIGluY2x1ZGVIaWRkZW5Xcml0ZXMgLSBEZWZhdWx0cyB0byBmYWxzZSwgd2hldGhlciBvciBub3QgdG8gbGF5ZXIgb24gd3JpdGVzIHdpdGggdmlzaWJsZSBzZXQgdG8gZmFsc2VcclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZUNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUod3JpdGVUcmVlLCB0cmVlUGF0aCwgY29tcGxldGVTZXJ2ZXJDYWNoZSwgd3JpdGVJZHNUb0V4Y2x1ZGUsIGluY2x1ZGVIaWRkZW5Xcml0ZXMpIHtcclxuICAgIGlmICghd3JpdGVJZHNUb0V4Y2x1ZGUgJiYgIWluY2x1ZGVIaWRkZW5Xcml0ZXMpIHtcclxuICAgICAgICBjb25zdCBzaGFkb3dpbmdOb2RlID0gY29tcG91bmRXcml0ZUdldENvbXBsZXRlTm9kZSh3cml0ZVRyZWUudmlzaWJsZVdyaXRlcywgdHJlZVBhdGgpO1xyXG4gICAgICAgIGlmIChzaGFkb3dpbmdOb2RlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNoYWRvd2luZ05vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBzdWJNZXJnZSA9IGNvbXBvdW5kV3JpdGVDaGlsZENvbXBvdW5kV3JpdGUod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHRyZWVQYXRoKTtcclxuICAgICAgICAgICAgaWYgKGNvbXBvdW5kV3JpdGVJc0VtcHR5KHN1Yk1lcmdlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlU2VydmVyQ2FjaGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY29tcGxldGVTZXJ2ZXJDYWNoZSA9PSBudWxsICYmXHJcbiAgICAgICAgICAgICAgICAhY29tcG91bmRXcml0ZUhhc0NvbXBsZXRlV3JpdGUoc3ViTWVyZ2UsIG5ld0VtcHR5UGF0aCgpKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2Ugd291bGRuJ3QgaGF2ZSBhIGNvbXBsZXRlIHNuYXBzaG90LCBzaW5jZSB0aGVyZSdzIG5vIHVuZGVybHlpbmcgZGF0YSBhbmQgbm8gY29tcGxldGUgc2hhZG93XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxheWVyZWRDYWNoZSA9IGNvbXBsZXRlU2VydmVyQ2FjaGUgfHwgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcG91bmRXcml0ZUFwcGx5KHN1Yk1lcmdlLCBsYXllcmVkQ2FjaGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgbWVyZ2UgPSBjb21wb3VuZFdyaXRlQ2hpbGRDb21wb3VuZFdyaXRlKHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzLCB0cmVlUGF0aCk7XHJcbiAgICAgICAgaWYgKCFpbmNsdWRlSGlkZGVuV3JpdGVzICYmIGNvbXBvdW5kV3JpdGVJc0VtcHR5KG1lcmdlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcGxldGVTZXJ2ZXJDYWNoZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBzZXJ2ZXIgY2FjaGUgaXMgbnVsbCwgYW5kIHdlIGRvbid0IGhhdmUgYSBjb21wbGV0ZSBjYWNoZSwgd2UgbmVlZCB0byByZXR1cm4gbnVsbFxyXG4gICAgICAgICAgICBpZiAoIWluY2x1ZGVIaWRkZW5Xcml0ZXMgJiZcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlU2VydmVyQ2FjaGUgPT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAgICAgIWNvbXBvdW5kV3JpdGVIYXNDb21wbGV0ZVdyaXRlKG1lcmdlLCBuZXdFbXB0eVBhdGgoKSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyID0gZnVuY3Rpb24gKHdyaXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgod3JpdGUudmlzaWJsZSB8fCBpbmNsdWRlSGlkZGVuV3JpdGVzKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoIXdyaXRlSWRzVG9FeGNsdWRlIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhfndyaXRlSWRzVG9FeGNsdWRlLmluZGV4T2Yod3JpdGUud3JpdGVJZCkpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChwYXRoQ29udGFpbnMod3JpdGUucGF0aCwgdHJlZVBhdGgpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoQ29udGFpbnModHJlZVBhdGgsIHdyaXRlLnBhdGgpKSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWVyZ2VBdFBhdGggPSB3cml0ZVRyZWVMYXllclRyZWVfKHdyaXRlVHJlZS5hbGxXcml0ZXMsIGZpbHRlciwgdHJlZVBhdGgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGF5ZXJlZENhY2hlID0gY29tcGxldGVTZXJ2ZXJDYWNoZSB8fCBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wb3VuZFdyaXRlQXBwbHkobWVyZ2VBdFBhdGgsIGxheWVyZWRDYWNoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFdpdGggb3B0aW9uYWwsIHVuZGVybHlpbmcgc2VydmVyIGRhdGEsIGF0dGVtcHQgdG8gcmV0dXJuIGEgY2hpbGRyZW4gbm9kZSBvZiBjaGlsZHJlbiB0aGF0IHdlIGhhdmUgY29tcGxldGUgZGF0YSBmb3IuXHJcbiAqIFVzZWQgd2hlbiBjcmVhdGluZyBuZXcgdmlld3MsIHRvIHByZS1maWxsIHRoZWlyIGNvbXBsZXRlIGV2ZW50IGNoaWxkcmVuIHNuYXBzaG90LlxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlQ2FsY0NvbXBsZXRlRXZlbnRDaGlsZHJlbih3cml0ZVRyZWUsIHRyZWVQYXRoLCBjb21wbGV0ZVNlcnZlckNoaWxkcmVuKSB7XHJcbiAgICBsZXQgY29tcGxldGVDaGlsZHJlbiA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgY29uc3QgdG9wTGV2ZWxTZXQgPSBjb21wb3VuZFdyaXRlR2V0Q29tcGxldGVOb2RlKHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzLCB0cmVlUGF0aCk7XHJcbiAgICBpZiAodG9wTGV2ZWxTZXQpIHtcclxuICAgICAgICBpZiAoIXRvcExldmVsU2V0LmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgICAgICAvLyB3ZSdyZSBzaGFkb3dpbmcgZXZlcnl0aGluZy4gUmV0dXJuIHRoZSBjaGlsZHJlbi5cclxuICAgICAgICAgICAgdG9wTGV2ZWxTZXQuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCAoY2hpbGROYW1lLCBjaGlsZFNuYXApID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlQ2hpbGRyZW4gPSBjb21wbGV0ZUNoaWxkcmVuLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSwgY2hpbGRTbmFwKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb21wbGV0ZUNoaWxkcmVuO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoY29tcGxldGVTZXJ2ZXJDaGlsZHJlbikge1xyXG4gICAgICAgIC8vIExheWVyIGFueSBjaGlsZHJlbiB3ZSBoYXZlIG9uIHRvcCBvZiB0aGlzXHJcbiAgICAgICAgLy8gV2Uga25vdyB3ZSBkb24ndCBoYXZlIGEgdG9wLWxldmVsIHNldCwgc28ganVzdCBlbnVtZXJhdGUgZXhpc3RpbmcgY2hpbGRyZW5cclxuICAgICAgICBjb25zdCBtZXJnZSA9IGNvbXBvdW5kV3JpdGVDaGlsZENvbXBvdW5kV3JpdGUod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHRyZWVQYXRoKTtcclxuICAgICAgICBjb21wbGV0ZVNlcnZlckNoaWxkcmVuLmZvckVhY2hDaGlsZChQUklPUklUWV9JTkRFWCwgKGNoaWxkTmFtZSwgY2hpbGROb2RlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBjb21wb3VuZFdyaXRlQXBwbHkoY29tcG91bmRXcml0ZUNoaWxkQ29tcG91bmRXcml0ZShtZXJnZSwgbmV3IFBhdGgoY2hpbGROYW1lKSksIGNoaWxkTm9kZSk7XHJcbiAgICAgICAgICAgIGNvbXBsZXRlQ2hpbGRyZW4gPSBjb21wbGV0ZUNoaWxkcmVuLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSwgbm9kZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gQWRkIGFueSBjb21wbGV0ZSBjaGlsZHJlbiB3ZSBoYXZlIGZyb20gdGhlIHNldFxyXG4gICAgICAgIGNvbXBvdW5kV3JpdGVHZXRDb21wbGV0ZUNoaWxkcmVuKG1lcmdlKS5mb3JFYWNoKG5hbWVkTm9kZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbXBsZXRlQ2hpbGRyZW4gPSBjb21wbGV0ZUNoaWxkcmVuLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKG5hbWVkTm9kZS5uYW1lLCBuYW1lZE5vZGUubm9kZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlQ2hpbGRyZW47XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBXZSBkb24ndCBoYXZlIGFueXRoaW5nIHRvIGxheWVyIG9uIHRvcCBvZi4gTGF5ZXIgb24gYW55IGNoaWxkcmVuIHdlIGhhdmVcclxuICAgICAgICAvLyBOb3RlIHRoYXQgd2UgY2FuIHJldHVybiBhbiBlbXB0eSBzbmFwIGlmIHdlIGhhdmUgYSBkZWZpbmVkIGRlbGV0ZVxyXG4gICAgICAgIGNvbnN0IG1lcmdlID0gY29tcG91bmRXcml0ZUNoaWxkQ29tcG91bmRXcml0ZSh3cml0ZVRyZWUudmlzaWJsZVdyaXRlcywgdHJlZVBhdGgpO1xyXG4gICAgICAgIGNvbXBvdW5kV3JpdGVHZXRDb21wbGV0ZUNoaWxkcmVuKG1lcmdlKS5mb3JFYWNoKG5hbWVkTm9kZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbXBsZXRlQ2hpbGRyZW4gPSBjb21wbGV0ZUNoaWxkcmVuLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKG5hbWVkTm9kZS5uYW1lLCBuYW1lZE5vZGUubm9kZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlQ2hpbGRyZW47XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEdpdmVuIHRoYXQgdGhlIHVuZGVybHlpbmcgc2VydmVyIGRhdGEgaGFzIHVwZGF0ZWQsIGRldGVybWluZSB3aGF0LCBpZiBhbnl0aGluZywgbmVlZHMgdG8gYmVcclxuICogYXBwbGllZCB0byB0aGUgZXZlbnQgY2FjaGUuXHJcbiAqXHJcbiAqIFBvc3NpYmlsaXRpZXM6XHJcbiAqXHJcbiAqIDEuIE5vIHdyaXRlcyBhcmUgc2hhZG93aW5nLiBFdmVudHMgc2hvdWxkIGJlIHJhaXNlZCwgdGhlIHNuYXAgdG8gYmUgYXBwbGllZCBjb21lcyBmcm9tIHRoZSBzZXJ2ZXIgZGF0YVxyXG4gKlxyXG4gKiAyLiBTb21lIHdyaXRlIGlzIGNvbXBsZXRlbHkgc2hhZG93aW5nLiBObyBldmVudHMgdG8gYmUgcmFpc2VkXHJcbiAqXHJcbiAqIDMuIElzIHBhcnRpYWxseSBzaGFkb3dlZC4gRXZlbnRzXHJcbiAqXHJcbiAqIEVpdGhlciBleGlzdGluZ0V2ZW50U25hcCBvciBleGlzdGluZ1NlcnZlclNuYXAgbXVzdCBleGlzdFxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlQ2FsY0V2ZW50Q2FjaGVBZnRlclNlcnZlck92ZXJ3cml0ZSh3cml0ZVRyZWUsIHRyZWVQYXRoLCBjaGlsZFBhdGgsIGV4aXN0aW5nRXZlbnRTbmFwLCBleGlzdGluZ1NlcnZlclNuYXApIHtcclxuICAgIGFzc2VydChleGlzdGluZ0V2ZW50U25hcCB8fCBleGlzdGluZ1NlcnZlclNuYXAsICdFaXRoZXIgZXhpc3RpbmdFdmVudFNuYXAgb3IgZXhpc3RpbmdTZXJ2ZXJTbmFwIG11c3QgZXhpc3QnKTtcclxuICAgIGNvbnN0IHBhdGggPSBwYXRoQ2hpbGQodHJlZVBhdGgsIGNoaWxkUGF0aCk7XHJcbiAgICBpZiAoY29tcG91bmRXcml0ZUhhc0NvbXBsZXRlV3JpdGUod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHBhdGgpKSB7XHJcbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB3ZSBjYW4gcHJvYmFibHkgZ3VhcmFudGVlIHRoYXQgd2UncmUgaW4gY2FzZSAyLCBtZWFuaW5nIG5vIGV2ZW50c1xyXG4gICAgICAgIC8vIE1heSBuZWVkIHRvIGNoZWNrIHZpc2liaWxpdHkgd2hpbGUgZG9pbmcgdGhlIGZpbmRSb290TW9zdFZhbHVlQW5kUGF0aCBjYWxsXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBObyBjb21wbGV0ZSBzaGFkb3dpbmcuIFdlJ3JlIGVpdGhlciBwYXJ0aWFsbHkgc2hhZG93aW5nIG9yIG5vdCBzaGFkb3dpbmcgYXQgYWxsLlxyXG4gICAgICAgIGNvbnN0IGNoaWxkTWVyZ2UgPSBjb21wb3VuZFdyaXRlQ2hpbGRDb21wb3VuZFdyaXRlKHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzLCBwYXRoKTtcclxuICAgICAgICBpZiAoY29tcG91bmRXcml0ZUlzRW1wdHkoY2hpbGRNZXJnZSkpIHtcclxuICAgICAgICAgICAgLy8gV2UncmUgbm90IHNoYWRvd2luZyBhdCBhbGwuIENhc2UgMVxyXG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdTZXJ2ZXJTbmFwLmdldENoaWxkKGNoaWxkUGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBUaGlzIGNvdWxkIGJlIG1vcmUgZWZmaWNpZW50IGlmIHRoZSBzZXJ2ZXJOb2RlICsgdXBkYXRlcyBkb2Vzbid0IGNoYW5nZSB0aGUgZXZlbnRTbmFwXHJcbiAgICAgICAgICAgIC8vIEhvd2V2ZXIgdGhpcyBpcyB0cmlja3kgdG8gZmluZCBvdXQsIHNpbmNlIHVzZXIgdXBkYXRlcyBkb24ndCBuZWNlc3NhcnkgY2hhbmdlIHRoZSBzZXJ2ZXJcclxuICAgICAgICAgICAgLy8gc25hcCwgZS5nLiBwcmlvcml0eSB1cGRhdGVzIG9uIGVtcHR5IG5vZGVzLCBvciBkZWVwIGRlbGV0ZXMuIEFub3RoZXIgc3BlY2lhbCBjYXNlIGlzIGlmIHRoZSBzZXJ2ZXJcclxuICAgICAgICAgICAgLy8gYWRkcyBub2RlcywgYnV0IGRvZXNuJ3QgY2hhbmdlIGFueSBleGlzdGluZyB3cml0ZXMuIEl0IGlzIHRoZXJlZm9yZSBub3QgZW5vdWdoIHRvXHJcbiAgICAgICAgICAgIC8vIG9ubHkgY2hlY2sgaWYgdGhlIHVwZGF0ZXMgY2hhbmdlIHRoZSBzZXJ2ZXJOb2RlLlxyXG4gICAgICAgICAgICAvLyBNYXliZSBjaGVjayBpZiB0aGUgbWVyZ2UgdHJlZSBjb250YWlucyB0aGVzZSBzcGVjaWFsIGNhc2VzIGFuZCBvbmx5IGRvIGEgZnVsbCBvdmVyd3JpdGUgaW4gdGhhdCBjYXNlP1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcG91bmRXcml0ZUFwcGx5KGNoaWxkTWVyZ2UsIGV4aXN0aW5nU2VydmVyU25hcC5nZXRDaGlsZChjaGlsZFBhdGgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBjb21wbGV0ZSBjaGlsZCBmb3IgYSBnaXZlbiBzZXJ2ZXIgc25hcCBhZnRlciBhcHBseWluZyBhbGwgdXNlciB3cml0ZXMgb3IgbnVsbCBpZiB0aGVyZSBpcyBub1xyXG4gKiBjb21wbGV0ZSBjaGlsZCBmb3IgdGhpcyBDaGlsZEtleS5cclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZUNhbGNDb21wbGV0ZUNoaWxkKHdyaXRlVHJlZSwgdHJlZVBhdGgsIGNoaWxkS2V5LCBleGlzdGluZ1NlcnZlclNuYXApIHtcclxuICAgIGNvbnN0IHBhdGggPSBwYXRoQ2hpbGQodHJlZVBhdGgsIGNoaWxkS2V5KTtcclxuICAgIGNvbnN0IHNoYWRvd2luZ05vZGUgPSBjb21wb3VuZFdyaXRlR2V0Q29tcGxldGVOb2RlKHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzLCBwYXRoKTtcclxuICAgIGlmIChzaGFkb3dpbmdOb2RlICE9IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gc2hhZG93aW5nTm9kZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChleGlzdGluZ1NlcnZlclNuYXAuaXNDb21wbGV0ZUZvckNoaWxkKGNoaWxkS2V5KSkge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZE1lcmdlID0gY29tcG91bmRXcml0ZUNoaWxkQ29tcG91bmRXcml0ZSh3cml0ZVRyZWUudmlzaWJsZVdyaXRlcywgcGF0aCk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wb3VuZFdyaXRlQXBwbHkoY2hpbGRNZXJnZSwgZXhpc3RpbmdTZXJ2ZXJTbmFwLmdldE5vZGUoKS5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgbm9kZSBpZiB0aGVyZSBpcyBhIGNvbXBsZXRlIG92ZXJ3cml0ZSBmb3IgdGhpcyBwYXRoLiBNb3JlIHNwZWNpZmljYWxseSwgaWYgdGhlcmUgaXMgYSB3cml0ZSBhdFxyXG4gKiBhIGhpZ2hlciBwYXRoLCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBjaGlsZCBvZiB0aGF0IHdyaXRlIHJlbGF0aXZlIHRvIHRoZSB3cml0ZSBhbmQgdGhpcyBwYXRoLlxyXG4gKiBSZXR1cm5zIG51bGwgaWYgdGhlcmUgaXMgbm8gd3JpdGUgYXQgdGhpcyBwYXRoLlxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlU2hhZG93aW5nV3JpdGUod3JpdGVUcmVlLCBwYXRoKSB7XHJcbiAgICByZXR1cm4gY29tcG91bmRXcml0ZUdldENvbXBsZXRlTm9kZSh3cml0ZVRyZWUudmlzaWJsZVdyaXRlcywgcGF0aCk7XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgd2hlbiBwcm9jZXNzaW5nIGNoaWxkIHJlbW92ZSBldmVudHMgb24gYSBxdWVyeS4gSWYgd2UgY2FuLCB3ZSBwdWxsIGluIGNoaWxkcmVuIHRoYXQgd2VyZSBvdXRzaWRlXHJcbiAqIHRoZSB3aW5kb3csIGJ1dCBtYXkgbm93IGJlIGluIHRoZSB3aW5kb3cuXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVDYWxjSW5kZXhlZFNsaWNlKHdyaXRlVHJlZSwgdHJlZVBhdGgsIGNvbXBsZXRlU2VydmVyRGF0YSwgc3RhcnRQb3N0LCBjb3VudCwgcmV2ZXJzZSwgaW5kZXgpIHtcclxuICAgIGxldCB0b0l0ZXJhdGU7XHJcbiAgICBjb25zdCBtZXJnZSA9IGNvbXBvdW5kV3JpdGVDaGlsZENvbXBvdW5kV3JpdGUod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHRyZWVQYXRoKTtcclxuICAgIGNvbnN0IHNoYWRvd2luZ05vZGUgPSBjb21wb3VuZFdyaXRlR2V0Q29tcGxldGVOb2RlKG1lcmdlLCBuZXdFbXB0eVBhdGgoKSk7XHJcbiAgICBpZiAoc2hhZG93aW5nTm9kZSAhPSBudWxsKSB7XHJcbiAgICAgICAgdG9JdGVyYXRlID0gc2hhZG93aW5nTm9kZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNvbXBsZXRlU2VydmVyRGF0YSAhPSBudWxsKSB7XHJcbiAgICAgICAgdG9JdGVyYXRlID0gY29tcG91bmRXcml0ZUFwcGx5KG1lcmdlLCBjb21wbGV0ZVNlcnZlckRhdGEpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gbm8gY2hpbGRyZW4gdG8gaXRlcmF0ZSBvblxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIHRvSXRlcmF0ZSA9IHRvSXRlcmF0ZS53aXRoSW5kZXgoaW5kZXgpO1xyXG4gICAgaWYgKCF0b0l0ZXJhdGUuaXNFbXB0eSgpICYmICF0b0l0ZXJhdGUuaXNMZWFmTm9kZSgpKSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBbXTtcclxuICAgICAgICBjb25zdCBjbXAgPSBpbmRleC5nZXRDb21wYXJlKCk7XHJcbiAgICAgICAgY29uc3QgaXRlciA9IHJldmVyc2VcclxuICAgICAgICAgICAgPyB0b0l0ZXJhdGUuZ2V0UmV2ZXJzZUl0ZXJhdG9yRnJvbShzdGFydFBvc3QsIGluZGV4KVxyXG4gICAgICAgICAgICA6IHRvSXRlcmF0ZS5nZXRJdGVyYXRvckZyb20oc3RhcnRQb3N0LCBpbmRleCk7XHJcbiAgICAgICAgbGV0IG5leHQgPSBpdGVyLmdldE5leHQoKTtcclxuICAgICAgICB3aGlsZSAobmV4dCAmJiBub2Rlcy5sZW5ndGggPCBjb3VudCkge1xyXG4gICAgICAgICAgICBpZiAoY21wKG5leHQsIHN0YXJ0UG9zdCkgIT09IDApIHtcclxuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobmV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbmV4dCA9IGl0ZXIuZ2V0TmV4dCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9kZXM7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbmV3V3JpdGVUcmVlKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB2aXNpYmxlV3JpdGVzOiBDb21wb3VuZFdyaXRlLmVtcHR5KCksXHJcbiAgICAgICAgYWxsV3JpdGVzOiBbXSxcclxuICAgICAgICBsYXN0V3JpdGVJZDogLTFcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIElmIHBvc3NpYmxlLCByZXR1cm5zIGEgY29tcGxldGUgZXZlbnQgY2FjaGUsIHVzaW5nIHRoZSB1bmRlcmx5aW5nIHNlcnZlciBkYXRhIGlmIHBvc3NpYmxlLiBJbiBhZGRpdGlvbiwgY2FuIGJlIHVzZWRcclxuICogdG8gZ2V0IGEgY2FjaGUgdGhhdCBpbmNsdWRlcyBoaWRkZW4gd3JpdGVzLCBhbmQgZXhjbHVkZXMgYXJiaXRyYXJ5IHdyaXRlcy4gTm90ZSB0aGF0IGN1c3RvbWl6aW5nIHRoZSByZXR1cm5lZCBub2RlXHJcbiAqIGNhbiBsZWFkIHRvIGEgbW9yZSBleHBlbnNpdmUgY2FsY3VsYXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB3cml0ZUlkc1RvRXhjbHVkZSAtIE9wdGlvbmFsIHdyaXRlcyB0byBleGNsdWRlLlxyXG4gKiBAcGFyYW0gaW5jbHVkZUhpZGRlbldyaXRlcyAtIERlZmF1bHRzIHRvIGZhbHNlLCB3aGV0aGVyIG9yIG5vdCB0byBsYXllciBvbiB3cml0ZXMgd2l0aCB2aXNpYmxlIHNldCB0byBmYWxzZVxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlUmVmQ2FsY0NvbXBsZXRlRXZlbnRDYWNoZSh3cml0ZVRyZWVSZWYsIGNvbXBsZXRlU2VydmVyQ2FjaGUsIHdyaXRlSWRzVG9FeGNsdWRlLCBpbmNsdWRlSGlkZGVuV3JpdGVzKSB7XHJcbiAgICByZXR1cm4gd3JpdGVUcmVlQ2FsY0NvbXBsZXRlRXZlbnRDYWNoZSh3cml0ZVRyZWVSZWYud3JpdGVUcmVlLCB3cml0ZVRyZWVSZWYudHJlZVBhdGgsIGNvbXBsZXRlU2VydmVyQ2FjaGUsIHdyaXRlSWRzVG9FeGNsdWRlLCBpbmNsdWRlSGlkZGVuV3JpdGVzKTtcclxufVxyXG4vKipcclxuICogSWYgcG9zc2libGUsIHJldHVybnMgYSBjaGlsZHJlbiBub2RlIGNvbnRhaW5pbmcgYWxsIG9mIHRoZSBjb21wbGV0ZSBjaGlsZHJlbiB3ZSBoYXZlIGRhdGEgZm9yLiBUaGUgcmV0dXJuZWQgZGF0YSBpcyBhXHJcbiAqIG1peCBvZiB0aGUgZ2l2ZW4gc2VydmVyIGRhdGEgYW5kIHdyaXRlIGRhdGEuXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVSZWZDYWxjQ29tcGxldGVFdmVudENoaWxkcmVuKHdyaXRlVHJlZVJlZiwgY29tcGxldGVTZXJ2ZXJDaGlsZHJlbikge1xyXG4gICAgcmV0dXJuIHdyaXRlVHJlZUNhbGNDb21wbGV0ZUV2ZW50Q2hpbGRyZW4od3JpdGVUcmVlUmVmLndyaXRlVHJlZSwgd3JpdGVUcmVlUmVmLnRyZWVQYXRoLCBjb21wbGV0ZVNlcnZlckNoaWxkcmVuKTtcclxufVxyXG4vKipcclxuICogR2l2ZW4gdGhhdCBlaXRoZXIgdGhlIHVuZGVybHlpbmcgc2VydmVyIGRhdGEgaGFzIHVwZGF0ZWQgb3IgdGhlIG91dHN0YW5kaW5nIHdyaXRlcyBoYXZlIHVwZGF0ZWQsIGRldGVybWluZSB3aGF0LFxyXG4gKiBpZiBhbnl0aGluZywgbmVlZHMgdG8gYmUgYXBwbGllZCB0byB0aGUgZXZlbnQgY2FjaGUuXHJcbiAqXHJcbiAqIFBvc3NpYmlsaXRpZXM6XHJcbiAqXHJcbiAqIDEuIE5vIHdyaXRlcyBhcmUgc2hhZG93aW5nLiBFdmVudHMgc2hvdWxkIGJlIHJhaXNlZCwgdGhlIHNuYXAgdG8gYmUgYXBwbGllZCBjb21lcyBmcm9tIHRoZSBzZXJ2ZXIgZGF0YVxyXG4gKlxyXG4gKiAyLiBTb21lIHdyaXRlIGlzIGNvbXBsZXRlbHkgc2hhZG93aW5nLiBObyBldmVudHMgdG8gYmUgcmFpc2VkXHJcbiAqXHJcbiAqIDMuIElzIHBhcnRpYWxseSBzaGFkb3dlZC4gRXZlbnRzIHNob3VsZCBiZSByYWlzZWRcclxuICpcclxuICogRWl0aGVyIGV4aXN0aW5nRXZlbnRTbmFwIG9yIGV4aXN0aW5nU2VydmVyU25hcCBtdXN0IGV4aXN0LCB0aGlzIGlzIHZhbGlkYXRlZCB2aWEgYW4gYXNzZXJ0XHJcbiAqXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVSZWZDYWxjRXZlbnRDYWNoZUFmdGVyU2VydmVyT3ZlcndyaXRlKHdyaXRlVHJlZVJlZiwgcGF0aCwgZXhpc3RpbmdFdmVudFNuYXAsIGV4aXN0aW5nU2VydmVyU25hcCkge1xyXG4gICAgcmV0dXJuIHdyaXRlVHJlZUNhbGNFdmVudENhY2hlQWZ0ZXJTZXJ2ZXJPdmVyd3JpdGUod3JpdGVUcmVlUmVmLndyaXRlVHJlZSwgd3JpdGVUcmVlUmVmLnRyZWVQYXRoLCBwYXRoLCBleGlzdGluZ0V2ZW50U25hcCwgZXhpc3RpbmdTZXJ2ZXJTbmFwKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIG5vZGUgaWYgdGhlcmUgaXMgYSBjb21wbGV0ZSBvdmVyd3JpdGUgZm9yIHRoaXMgcGF0aC4gTW9yZSBzcGVjaWZpY2FsbHksIGlmIHRoZXJlIGlzIGEgd3JpdGUgYXRcclxuICogYSBoaWdoZXIgcGF0aCwgdGhpcyB3aWxsIHJldHVybiB0aGUgY2hpbGQgb2YgdGhhdCB3cml0ZSByZWxhdGl2ZSB0byB0aGUgd3JpdGUgYW5kIHRoaXMgcGF0aC5cclxuICogUmV0dXJucyBudWxsIGlmIHRoZXJlIGlzIG5vIHdyaXRlIGF0IHRoaXMgcGF0aC5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZVJlZlNoYWRvd2luZ1dyaXRlKHdyaXRlVHJlZVJlZiwgcGF0aCkge1xyXG4gICAgcmV0dXJuIHdyaXRlVHJlZVNoYWRvd2luZ1dyaXRlKHdyaXRlVHJlZVJlZi53cml0ZVRyZWUsIHBhdGhDaGlsZCh3cml0ZVRyZWVSZWYudHJlZVBhdGgsIHBhdGgpKTtcclxufVxyXG4vKipcclxuICogVGhpcyBtZXRob2QgaXMgdXNlZCB3aGVuIHByb2Nlc3NpbmcgY2hpbGQgcmVtb3ZlIGV2ZW50cyBvbiBhIHF1ZXJ5LiBJZiB3ZSBjYW4sIHdlIHB1bGwgaW4gY2hpbGRyZW4gdGhhdCB3ZXJlIG91dHNpZGVcclxuICogdGhlIHdpbmRvdywgYnV0IG1heSBub3cgYmUgaW4gdGhlIHdpbmRvd1xyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlUmVmQ2FsY0luZGV4ZWRTbGljZSh3cml0ZVRyZWVSZWYsIGNvbXBsZXRlU2VydmVyRGF0YSwgc3RhcnRQb3N0LCBjb3VudCwgcmV2ZXJzZSwgaW5kZXgpIHtcclxuICAgIHJldHVybiB3cml0ZVRyZWVDYWxjSW5kZXhlZFNsaWNlKHdyaXRlVHJlZVJlZi53cml0ZVRyZWUsIHdyaXRlVHJlZVJlZi50cmVlUGF0aCwgY29tcGxldGVTZXJ2ZXJEYXRhLCBzdGFydFBvc3QsIGNvdW50LCByZXZlcnNlLCBpbmRleCk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBjb21wbGV0ZSBjaGlsZCBmb3IgYSBnaXZlbiBzZXJ2ZXIgc25hcCBhZnRlciBhcHBseWluZyBhbGwgdXNlciB3cml0ZXMgb3IgbnVsbCBpZiB0aGVyZSBpcyBub1xyXG4gKiBjb21wbGV0ZSBjaGlsZCBmb3IgdGhpcyBDaGlsZEtleS5cclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUNoaWxkKHdyaXRlVHJlZVJlZiwgY2hpbGRLZXksIGV4aXN0aW5nU2VydmVyQ2FjaGUpIHtcclxuICAgIHJldHVybiB3cml0ZVRyZWVDYWxjQ29tcGxldGVDaGlsZCh3cml0ZVRyZWVSZWYud3JpdGVUcmVlLCB3cml0ZVRyZWVSZWYudHJlZVBhdGgsIGNoaWxkS2V5LCBleGlzdGluZ1NlcnZlckNhY2hlKTtcclxufVxyXG4vKipcclxuICogUmV0dXJuIGEgV3JpdGVUcmVlUmVmIGZvciBhIGNoaWxkLlxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlUmVmQ2hpbGQod3JpdGVUcmVlUmVmLCBjaGlsZE5hbWUpIHtcclxuICAgIHJldHVybiBuZXdXcml0ZVRyZWVSZWYocGF0aENoaWxkKHdyaXRlVHJlZVJlZi50cmVlUGF0aCwgY2hpbGROYW1lKSwgd3JpdGVUcmVlUmVmLndyaXRlVHJlZSk7XHJcbn1cclxuZnVuY3Rpb24gbmV3V3JpdGVUcmVlUmVmKHBhdGgsIHdyaXRlVHJlZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0cmVlUGF0aDogcGF0aCxcclxuICAgICAgICB3cml0ZVRyZWVcclxuICAgIH07XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgQ2hpbGRDaGFuZ2VBY2N1bXVsYXRvciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmNoYW5nZU1hcCA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIHRyYWNrQ2hpbGRDaGFuZ2UoY2hhbmdlKSB7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IGNoYW5nZS50eXBlO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkS2V5ID0gY2hhbmdlLmNoaWxkTmFtZTtcclxuICAgICAgICBhc3NlcnQodHlwZSA9PT0gXCJjaGlsZF9hZGRlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfQURERUQgKi8gfHxcclxuICAgICAgICAgICAgdHlwZSA9PT0gXCJjaGlsZF9jaGFuZ2VkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9DSEFOR0VEICovIHx8XHJcbiAgICAgICAgICAgIHR5cGUgPT09IFwiY2hpbGRfcmVtb3ZlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfUkVNT1ZFRCAqLywgJ09ubHkgY2hpbGQgY2hhbmdlcyBzdXBwb3J0ZWQgZm9yIHRyYWNraW5nJyk7XHJcbiAgICAgICAgYXNzZXJ0KGNoaWxkS2V5ICE9PSAnLnByaW9yaXR5JywgJ09ubHkgbm9uLXByaW9yaXR5IGNoaWxkIGNoYW5nZXMgY2FuIGJlIHRyYWNrZWQuJyk7XHJcbiAgICAgICAgY29uc3Qgb2xkQ2hhbmdlID0gdGhpcy5jaGFuZ2VNYXAuZ2V0KGNoaWxkS2V5KTtcclxuICAgICAgICBpZiAob2xkQ2hhbmdlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZFR5cGUgPSBvbGRDaGFuZ2UudHlwZTtcclxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiY2hpbGRfYWRkZWRcIiAvKiBDaGFuZ2VUeXBlLkNISUxEX0FEREVEICovICYmXHJcbiAgICAgICAgICAgICAgICBvbGRUeXBlID09PSBcImNoaWxkX3JlbW92ZWRcIiAvKiBDaGFuZ2VUeXBlLkNISUxEX1JFTU9WRUQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwLnNldChjaGlsZEtleSwgY2hhbmdlQ2hpbGRDaGFuZ2VkKGNoaWxkS2V5LCBjaGFuZ2Uuc25hcHNob3ROb2RlLCBvbGRDaGFuZ2Uuc25hcHNob3ROb2RlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJjaGlsZF9yZW1vdmVkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9SRU1PVkVEICovICYmXHJcbiAgICAgICAgICAgICAgICBvbGRUeXBlID09PSBcImNoaWxkX2FkZGVkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9BRERFRCAqLykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VNYXAuZGVsZXRlKGNoaWxkS2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSBcImNoaWxkX3JlbW92ZWRcIiAvKiBDaGFuZ2VUeXBlLkNISUxEX1JFTU9WRUQgKi8gJiZcclxuICAgICAgICAgICAgICAgIG9sZFR5cGUgPT09IFwiY2hpbGRfY2hhbmdlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfQ0hBTkdFRCAqLykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VNYXAuc2V0KGNoaWxkS2V5LCBjaGFuZ2VDaGlsZFJlbW92ZWQoY2hpbGRLZXksIG9sZENoYW5nZS5vbGRTbmFwKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJjaGlsZF9jaGFuZ2VkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9DSEFOR0VEICovICYmXHJcbiAgICAgICAgICAgICAgICBvbGRUeXBlID09PSBcImNoaWxkX2FkZGVkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9BRERFRCAqLykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VNYXAuc2V0KGNoaWxkS2V5LCBjaGFuZ2VDaGlsZEFkZGVkKGNoaWxkS2V5LCBjaGFuZ2Uuc25hcHNob3ROb2RlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJjaGlsZF9jaGFuZ2VkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9DSEFOR0VEICovICYmXHJcbiAgICAgICAgICAgICAgICBvbGRUeXBlID09PSBcImNoaWxkX2NoYW5nZWRcIiAvKiBDaGFuZ2VUeXBlLkNISUxEX0NIQU5HRUQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwLnNldChjaGlsZEtleSwgY2hhbmdlQ2hpbGRDaGFuZ2VkKGNoaWxkS2V5LCBjaGFuZ2Uuc25hcHNob3ROb2RlLCBvbGRDaGFuZ2Uub2xkU25hcCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgYXNzZXJ0aW9uRXJyb3IoJ0lsbGVnYWwgY29tYmluYXRpb24gb2YgY2hhbmdlczogJyArXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlICtcclxuICAgICAgICAgICAgICAgICAgICAnIG9jY3VycmVkIGFmdGVyICcgK1xyXG4gICAgICAgICAgICAgICAgICAgIG9sZENoYW5nZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwLnNldChjaGlsZEtleSwgY2hhbmdlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRDaGFuZ2VzKCkge1xyXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuY2hhbmdlTWFwLnZhbHVlcygpKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgQ29tcGxldGVDaGlsZFNvdXJjZSB0aGF0IG5ldmVyIHJldHVybnMgYW55IGFkZGl0aW9uYWwgY2hpbGRyZW5cclxuICovXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuY2xhc3MgTm9Db21wbGV0ZUNoaWxkU291cmNlXyB7XHJcbiAgICBnZXRDb21wbGV0ZUNoaWxkKGNoaWxkS2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBnZXRDaGlsZEFmdGVyQ2hpbGQoaW5kZXgsIGNoaWxkLCByZXZlcnNlKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFNpbmdsZXRvbiBpbnN0YW5jZS5cclxuICovXHJcbmNvbnN0IE5PX0NPTVBMRVRFX0NISUxEX1NPVVJDRSA9IG5ldyBOb0NvbXBsZXRlQ2hpbGRTb3VyY2VfKCk7XHJcbi8qKlxyXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBDb21wbGV0ZUNoaWxkU291cmNlIHRoYXQgdXNlcyBhIFdyaXRlVHJlZSBpbiBhZGRpdGlvbiB0byBhbnkgb3RoZXIgc2VydmVyIGRhdGEgb3JcclxuICogb2xkIGV2ZW50IGNhY2hlcyBhdmFpbGFibGUgdG8gY2FsY3VsYXRlIGNvbXBsZXRlIGNoaWxkcmVuLlxyXG4gKi9cclxuY2xhc3MgV3JpdGVUcmVlQ29tcGxldGVDaGlsZFNvdXJjZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih3cml0ZXNfLCB2aWV3Q2FjaGVfLCBvcHRDb21wbGV0ZVNlcnZlckNhY2hlXyA9IG51bGwpIHtcclxuICAgICAgICB0aGlzLndyaXRlc18gPSB3cml0ZXNfO1xyXG4gICAgICAgIHRoaXMudmlld0NhY2hlXyA9IHZpZXdDYWNoZV87XHJcbiAgICAgICAgdGhpcy5vcHRDb21wbGV0ZVNlcnZlckNhY2hlXyA9IG9wdENvbXBsZXRlU2VydmVyQ2FjaGVfO1xyXG4gICAgfVxyXG4gICAgZ2V0Q29tcGxldGVDaGlsZChjaGlsZEtleSkge1xyXG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnZpZXdDYWNoZV8uZXZlbnRDYWNoZTtcclxuICAgICAgICBpZiAobm9kZS5pc0NvbXBsZXRlRm9yQ2hpbGQoY2hpbGRLZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLmdldE5vZGUoKS5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXJOb2RlID0gdGhpcy5vcHRDb21wbGV0ZVNlcnZlckNhY2hlXyAhPSBudWxsXHJcbiAgICAgICAgICAgICAgICA/IG5ldyBDYWNoZU5vZGUodGhpcy5vcHRDb21wbGV0ZVNlcnZlckNhY2hlXywgdHJ1ZSwgZmFsc2UpXHJcbiAgICAgICAgICAgICAgICA6IHRoaXMudmlld0NhY2hlXy5zZXJ2ZXJDYWNoZTtcclxuICAgICAgICAgICAgcmV0dXJuIHdyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUNoaWxkKHRoaXMud3JpdGVzXywgY2hpbGRLZXksIHNlcnZlck5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldENoaWxkQWZ0ZXJDaGlsZChpbmRleCwgY2hpbGQsIHJldmVyc2UpIHtcclxuICAgICAgICBjb25zdCBjb21wbGV0ZVNlcnZlckRhdGEgPSB0aGlzLm9wdENvbXBsZXRlU2VydmVyQ2FjaGVfICE9IG51bGxcclxuICAgICAgICAgICAgPyB0aGlzLm9wdENvbXBsZXRlU2VydmVyQ2FjaGVfXHJcbiAgICAgICAgICAgIDogdmlld0NhY2hlR2V0Q29tcGxldGVTZXJ2ZXJTbmFwKHRoaXMudmlld0NhY2hlXyk7XHJcbiAgICAgICAgY29uc3Qgbm9kZXMgPSB3cml0ZVRyZWVSZWZDYWxjSW5kZXhlZFNsaWNlKHRoaXMud3JpdGVzXywgY29tcGxldGVTZXJ2ZXJEYXRhLCBjaGlsZCwgMSwgcmV2ZXJzZSwgaW5kZXgpO1xyXG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZXNbMF07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIG5ld1ZpZXdQcm9jZXNzb3IoZmlsdGVyKSB7XHJcbiAgICByZXR1cm4geyBmaWx0ZXIgfTtcclxufVxyXG5mdW5jdGlvbiB2aWV3UHJvY2Vzc29yQXNzZXJ0SW5kZXhlZCh2aWV3UHJvY2Vzc29yLCB2aWV3Q2FjaGUpIHtcclxuICAgIGFzc2VydCh2aWV3Q2FjaGUuZXZlbnRDYWNoZS5nZXROb2RlKCkuaXNJbmRleGVkKHZpZXdQcm9jZXNzb3IuZmlsdGVyLmdldEluZGV4KCkpLCAnRXZlbnQgc25hcCBub3QgaW5kZXhlZCcpO1xyXG4gICAgYXNzZXJ0KHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5nZXROb2RlKCkuaXNJbmRleGVkKHZpZXdQcm9jZXNzb3IuZmlsdGVyLmdldEluZGV4KCkpLCAnU2VydmVyIHNuYXAgbm90IGluZGV4ZWQnKTtcclxufVxyXG5mdW5jdGlvbiB2aWV3UHJvY2Vzc29yQXBwbHlPcGVyYXRpb24odmlld1Byb2Nlc3Nvciwgb2xkVmlld0NhY2hlLCBvcGVyYXRpb24sIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlKSB7XHJcbiAgICBjb25zdCBhY2N1bXVsYXRvciA9IG5ldyBDaGlsZENoYW5nZUFjY3VtdWxhdG9yKCk7XHJcbiAgICBsZXQgbmV3Vmlld0NhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlO1xyXG4gICAgaWYgKG9wZXJhdGlvbi50eXBlID09PSBPcGVyYXRpb25UeXBlLk9WRVJXUklURSkge1xyXG4gICAgICAgIGNvbnN0IG92ZXJ3cml0ZSA9IG9wZXJhdGlvbjtcclxuICAgICAgICBpZiAob3ZlcndyaXRlLnNvdXJjZS5mcm9tVXNlcikge1xyXG4gICAgICAgICAgICBuZXdWaWV3Q2FjaGUgPSB2aWV3UHJvY2Vzc29yQXBwbHlVc2VyT3ZlcndyaXRlKHZpZXdQcm9jZXNzb3IsIG9sZFZpZXdDYWNoZSwgb3ZlcndyaXRlLnBhdGgsIG92ZXJ3cml0ZS5zbmFwLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSwgYWNjdW11bGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYXNzZXJ0KG92ZXJ3cml0ZS5zb3VyY2UuZnJvbVNlcnZlciwgJ1Vua25vd24gc291cmNlLicpO1xyXG4gICAgICAgICAgICAvLyBXZSBmaWx0ZXIgdGhlIG5vZGUgaWYgaXQncyBhIHRhZ2dlZCB1cGRhdGUgb3IgdGhlIG5vZGUgaGFzIGJlZW4gcHJldmlvdXNseSBmaWx0ZXJlZCAgYW5kIHRoZVxyXG4gICAgICAgICAgICAvLyB1cGRhdGUgaXMgbm90IGF0IHRoZSByb290IGluIHdoaWNoIGNhc2UgaXQgaXMgb2sgKGFuZCBuZWNlc3NhcnkpIHRvIG1hcmsgdGhlIG5vZGUgdW5maWx0ZXJlZFxyXG4gICAgICAgICAgICAvLyBhZ2FpblxyXG4gICAgICAgICAgICBmaWx0ZXJTZXJ2ZXJOb2RlID1cclxuICAgICAgICAgICAgICAgIG92ZXJ3cml0ZS5zb3VyY2UudGFnZ2VkIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKG9sZFZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0ZpbHRlcmVkKCkgJiYgIXBhdGhJc0VtcHR5KG92ZXJ3cml0ZS5wYXRoKSk7XHJcbiAgICAgICAgICAgIG5ld1ZpZXdDYWNoZSA9IHZpZXdQcm9jZXNzb3JBcHBseVNlcnZlck92ZXJ3cml0ZSh2aWV3UHJvY2Vzc29yLCBvbGRWaWV3Q2FjaGUsIG92ZXJ3cml0ZS5wYXRoLCBvdmVyd3JpdGUuc25hcCwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGZpbHRlclNlcnZlck5vZGUsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChvcGVyYXRpb24udHlwZSA9PT0gT3BlcmF0aW9uVHlwZS5NRVJHRSkge1xyXG4gICAgICAgIGNvbnN0IG1lcmdlID0gb3BlcmF0aW9uO1xyXG4gICAgICAgIGlmIChtZXJnZS5zb3VyY2UuZnJvbVVzZXIpIHtcclxuICAgICAgICAgICAgbmV3Vmlld0NhY2hlID0gdmlld1Byb2Nlc3NvckFwcGx5VXNlck1lcmdlKHZpZXdQcm9jZXNzb3IsIG9sZFZpZXdDYWNoZSwgbWVyZ2UucGF0aCwgbWVyZ2UuY2hpbGRyZW4sIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhc3NlcnQobWVyZ2Uuc291cmNlLmZyb21TZXJ2ZXIsICdVbmtub3duIHNvdXJjZS4nKTtcclxuICAgICAgICAgICAgLy8gV2UgZmlsdGVyIHRoZSBub2RlIGlmIGl0J3MgYSB0YWdnZWQgdXBkYXRlIG9yIHRoZSBub2RlIGhhcyBiZWVuIHByZXZpb3VzbHkgZmlsdGVyZWRcclxuICAgICAgICAgICAgZmlsdGVyU2VydmVyTm9kZSA9XHJcbiAgICAgICAgICAgICAgICBtZXJnZS5zb3VyY2UudGFnZ2VkIHx8IG9sZFZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0ZpbHRlcmVkKCk7XHJcbiAgICAgICAgICAgIG5ld1ZpZXdDYWNoZSA9IHZpZXdQcm9jZXNzb3JBcHBseVNlcnZlck1lcmdlKHZpZXdQcm9jZXNzb3IsIG9sZFZpZXdDYWNoZSwgbWVyZ2UucGF0aCwgbWVyZ2UuY2hpbGRyZW4sIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAob3BlcmF0aW9uLnR5cGUgPT09IE9wZXJhdGlvblR5cGUuQUNLX1VTRVJfV1JJVEUpIHtcclxuICAgICAgICBjb25zdCBhY2tVc2VyV3JpdGUgPSBvcGVyYXRpb247XHJcbiAgICAgICAgaWYgKCFhY2tVc2VyV3JpdGUucmV2ZXJ0KSB7XHJcbiAgICAgICAgICAgIG5ld1ZpZXdDYWNoZSA9IHZpZXdQcm9jZXNzb3JBY2tVc2VyV3JpdGUodmlld1Byb2Nlc3Nvciwgb2xkVmlld0NhY2hlLCBhY2tVc2VyV3JpdGUucGF0aCwgYWNrVXNlcldyaXRlLmFmZmVjdGVkVHJlZSwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5ld1ZpZXdDYWNoZSA9IHZpZXdQcm9jZXNzb3JSZXZlcnRVc2VyV3JpdGUodmlld1Byb2Nlc3Nvciwgb2xkVmlld0NhY2hlLCBhY2tVc2VyV3JpdGUucGF0aCwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChvcGVyYXRpb24udHlwZSA9PT0gT3BlcmF0aW9uVHlwZS5MSVNURU5fQ09NUExFVEUpIHtcclxuICAgICAgICBuZXdWaWV3Q2FjaGUgPSB2aWV3UHJvY2Vzc29yTGlzdGVuQ29tcGxldGUodmlld1Byb2Nlc3Nvciwgb2xkVmlld0NhY2hlLCBvcGVyYXRpb24ucGF0aCwgd3JpdGVzQ2FjaGUsIGFjY3VtdWxhdG9yKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IGFzc2VydGlvbkVycm9yKCdVbmtub3duIG9wZXJhdGlvbiB0eXBlOiAnICsgb3BlcmF0aW9uLnR5cGUpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgY2hhbmdlcyA9IGFjY3VtdWxhdG9yLmdldENoYW5nZXMoKTtcclxuICAgIHZpZXdQcm9jZXNzb3JNYXliZUFkZFZhbHVlRXZlbnQob2xkVmlld0NhY2hlLCBuZXdWaWV3Q2FjaGUsIGNoYW5nZXMpO1xyXG4gICAgcmV0dXJuIHsgdmlld0NhY2hlOiBuZXdWaWV3Q2FjaGUsIGNoYW5nZXMgfTtcclxufVxyXG5mdW5jdGlvbiB2aWV3UHJvY2Vzc29yTWF5YmVBZGRWYWx1ZUV2ZW50KG9sZFZpZXdDYWNoZSwgbmV3Vmlld0NhY2hlLCBhY2N1bXVsYXRvcikge1xyXG4gICAgY29uc3QgZXZlbnRTbmFwID0gbmV3Vmlld0NhY2hlLmV2ZW50Q2FjaGU7XHJcbiAgICBpZiAoZXZlbnRTbmFwLmlzRnVsbHlJbml0aWFsaXplZCgpKSB7XHJcbiAgICAgICAgY29uc3QgaXNMZWFmT3JFbXB0eSA9IGV2ZW50U25hcC5nZXROb2RlKCkuaXNMZWFmTm9kZSgpIHx8IGV2ZW50U25hcC5nZXROb2RlKCkuaXNFbXB0eSgpO1xyXG4gICAgICAgIGNvbnN0IG9sZENvbXBsZXRlU25hcCA9IHZpZXdDYWNoZUdldENvbXBsZXRlRXZlbnRTbmFwKG9sZFZpZXdDYWNoZSk7XHJcbiAgICAgICAgaWYgKGFjY3VtdWxhdG9yLmxlbmd0aCA+IDAgfHxcclxuICAgICAgICAgICAgIW9sZFZpZXdDYWNoZS5ldmVudENhY2hlLmlzRnVsbHlJbml0aWFsaXplZCgpIHx8XHJcbiAgICAgICAgICAgIChpc0xlYWZPckVtcHR5ICYmICFldmVudFNuYXAuZ2V0Tm9kZSgpLmVxdWFscyhvbGRDb21wbGV0ZVNuYXApKSB8fFxyXG4gICAgICAgICAgICAhZXZlbnRTbmFwLmdldE5vZGUoKS5nZXRQcmlvcml0eSgpLmVxdWFscyhvbGRDb21wbGV0ZVNuYXAuZ2V0UHJpb3JpdHkoKSkpIHtcclxuICAgICAgICAgICAgYWNjdW11bGF0b3IucHVzaChjaGFuZ2VWYWx1ZSh2aWV3Q2FjaGVHZXRDb21wbGV0ZUV2ZW50U25hcChuZXdWaWV3Q2FjaGUpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHZpZXdQcm9jZXNzb3JHZW5lcmF0ZUV2ZW50Q2FjaGVBZnRlclNlcnZlckV2ZW50KHZpZXdQcm9jZXNzb3IsIHZpZXdDYWNoZSwgY2hhbmdlUGF0aCwgd3JpdGVzQ2FjaGUsIHNvdXJjZSwgYWNjdW11bGF0b3IpIHtcclxuICAgIGNvbnN0IG9sZEV2ZW50U25hcCA9IHZpZXdDYWNoZS5ldmVudENhY2hlO1xyXG4gICAgaWYgKHdyaXRlVHJlZVJlZlNoYWRvd2luZ1dyaXRlKHdyaXRlc0NhY2hlLCBjaGFuZ2VQYXRoKSAhPSBudWxsKSB7XHJcbiAgICAgICAgLy8gd2UgaGF2ZSBhIHNoYWRvd2luZyB3cml0ZSwgaWdub3JlIGNoYW5nZXNcclxuICAgICAgICByZXR1cm4gdmlld0NhY2hlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGV0IG5ld0V2ZW50Q2FjaGUsIHNlcnZlck5vZGU7XHJcbiAgICAgICAgaWYgKHBhdGhJc0VtcHR5KGNoYW5nZVBhdGgpKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IGZpZ3VyZSBvdXQgaG93IHRoaXMgcGxheXMgd2l0aCBcInNsaWRpbmcgYWNrIHdpbmRvd3NcIlxyXG4gICAgICAgICAgICBhc3NlcnQodmlld0NhY2hlLnNlcnZlckNhY2hlLmlzRnVsbHlJbml0aWFsaXplZCgpLCAnSWYgY2hhbmdlIHBhdGggaXMgZW1wdHksIHdlIG11c3QgaGF2ZSBjb21wbGV0ZSBzZXJ2ZXIgZGF0YScpO1xyXG4gICAgICAgICAgICBpZiAodmlld0NhY2hlLnNlcnZlckNhY2hlLmlzRmlsdGVyZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBzcGVjaWFsIGNhc2UgdGhpcywgYmVjYXVzZSB3ZSBuZWVkIHRvIG9ubHkgYXBwbHkgd3JpdGVzIHRvIGNvbXBsZXRlIGNoaWxkcmVuLCBvclxyXG4gICAgICAgICAgICAgICAgLy8gd2UgbWlnaHQgZW5kIHVwIHJhaXNpbmcgZXZlbnRzIGZvciBpbmNvbXBsZXRlIGNoaWxkcmVuLiBJZiB0aGUgc2VydmVyIGRhdGEgaXMgZmlsdGVyZWQgZGVlcFxyXG4gICAgICAgICAgICAgICAgLy8gd3JpdGVzIGNhbm5vdCBiZSBndWFyYW50ZWVkIHRvIGJlIGNvbXBsZXRlXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJDYWNoZSA9IHZpZXdDYWNoZUdldENvbXBsZXRlU2VydmVyU25hcCh2aWV3Q2FjaGUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29tcGxldGVDaGlsZHJlbiA9IHNlcnZlckNhY2hlIGluc3RhbmNlb2YgQ2hpbGRyZW5Ob2RlXHJcbiAgICAgICAgICAgICAgICAgICAgPyBzZXJ2ZXJDYWNoZVxyXG4gICAgICAgICAgICAgICAgICAgIDogQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wbGV0ZUV2ZW50Q2hpbGRyZW4gPSB3cml0ZVRyZWVSZWZDYWxjQ29tcGxldGVFdmVudENoaWxkcmVuKHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSB2aWV3UHJvY2Vzc29yLmZpbHRlci51cGRhdGVGdWxsTm9kZSh2aWV3Q2FjaGUuZXZlbnRDYWNoZS5nZXROb2RlKCksIGNvbXBsZXRlRXZlbnRDaGlsZHJlbiwgYWNjdW11bGF0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29tcGxldGVOb2RlID0gd3JpdGVUcmVlUmVmQ2FsY0NvbXBsZXRlRXZlbnRDYWNoZSh3cml0ZXNDYWNoZSwgdmlld0NhY2hlR2V0Q29tcGxldGVTZXJ2ZXJTbmFwKHZpZXdDYWNoZSkpO1xyXG4gICAgICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IHZpZXdQcm9jZXNzb3IuZmlsdGVyLnVwZGF0ZUZ1bGxOb2RlKHZpZXdDYWNoZS5ldmVudENhY2hlLmdldE5vZGUoKSwgY29tcGxldGVOb2RlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkS2V5ID0gcGF0aEdldEZyb250KGNoYW5nZVBhdGgpO1xyXG4gICAgICAgICAgICBpZiAoY2hpbGRLZXkgPT09ICcucHJpb3JpdHknKSB7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnQocGF0aEdldExlbmd0aChjaGFuZ2VQYXRoKSA9PT0gMSwgXCJDYW4ndCBoYXZlIGEgcHJpb3JpdHkgd2l0aCBhZGRpdGlvbmFsIHBhdGggY29tcG9uZW50c1wiKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9sZEV2ZW50Tm9kZSA9IG9sZEV2ZW50U25hcC5nZXROb2RlKCk7XHJcbiAgICAgICAgICAgICAgICBzZXJ2ZXJOb2RlID0gdmlld0NhY2hlLnNlcnZlckNhY2hlLmdldE5vZGUoKTtcclxuICAgICAgICAgICAgICAgIC8vIHdlIG1pZ2h0IGhhdmUgb3ZlcndyaXRlcyBmb3IgdGhpcyBwcmlvcml0eVxyXG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZFByaW9yaXR5ID0gd3JpdGVUcmVlUmVmQ2FsY0V2ZW50Q2FjaGVBZnRlclNlcnZlck92ZXJ3cml0ZSh3cml0ZXNDYWNoZSwgY2hhbmdlUGF0aCwgb2xkRXZlbnROb2RlLCBzZXJ2ZXJOb2RlKTtcclxuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVkUHJpb3JpdHkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSB2aWV3UHJvY2Vzc29yLmZpbHRlci51cGRhdGVQcmlvcml0eShvbGRFdmVudE5vZGUsIHVwZGF0ZWRQcmlvcml0eSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBwcmlvcml0eSBkaWRuJ3QgY2hhbmdlLCBrZWVwIG9sZCBub2RlXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IG9sZEV2ZW50U25hcC5nZXROb2RlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZENoYW5nZVBhdGggPSBwYXRoUG9wRnJvbnQoY2hhbmdlUGF0aCk7XHJcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgY2hpbGRcclxuICAgICAgICAgICAgICAgIGxldCBuZXdFdmVudENoaWxkO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9sZEV2ZW50U25hcC5pc0NvbXBsZXRlRm9yQ2hpbGQoY2hpbGRLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyTm9kZSA9IHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5nZXROb2RlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnRDaGlsZFVwZGF0ZSA9IHdyaXRlVHJlZVJlZkNhbGNFdmVudENhY2hlQWZ0ZXJTZXJ2ZXJPdmVyd3JpdGUod3JpdGVzQ2FjaGUsIGNoYW5nZVBhdGgsIG9sZEV2ZW50U25hcC5nZXROb2RlKCksIHNlcnZlck5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudENoaWxkVXBkYXRlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RXZlbnRDaGlsZCA9IG9sZEV2ZW50U25hcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdldE5vZGUoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnVwZGF0ZUNoaWxkKGNoaWxkQ2hhbmdlUGF0aCwgZXZlbnRDaGlsZFVwZGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RoaW5nIGNoYW5nZWQsIGp1c3Qga2VlcCB0aGUgb2xkIGNoaWxkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2hpbGQgPSBvbGRFdmVudFNuYXAuZ2V0Tm9kZSgpLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdFdmVudENoaWxkID0gd3JpdGVUcmVlUmVmQ2FsY0NvbXBsZXRlQ2hpbGQod3JpdGVzQ2FjaGUsIGNoaWxkS2V5LCB2aWV3Q2FjaGUuc2VydmVyQ2FjaGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG5ld0V2ZW50Q2hpbGQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSB2aWV3UHJvY2Vzc29yLmZpbHRlci51cGRhdGVDaGlsZChvbGRFdmVudFNuYXAuZ2V0Tm9kZSgpLCBjaGlsZEtleSwgbmV3RXZlbnRDaGlsZCwgY2hpbGRDaGFuZ2VQYXRoLCBzb3VyY2UsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIGNvbXBsZXRlIGNoaWxkIGF2YWlsYWJsZSBvciBubyBjaGFuZ2VcclxuICAgICAgICAgICAgICAgICAgICBuZXdFdmVudENhY2hlID0gb2xkRXZlbnRTbmFwLmdldE5vZGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmlld0NhY2hlVXBkYXRlRXZlbnRTbmFwKHZpZXdDYWNoZSwgbmV3RXZlbnRDYWNoZSwgb2xkRXZlbnRTbmFwLmlzRnVsbHlJbml0aWFsaXplZCgpIHx8IHBhdGhJc0VtcHR5KGNoYW5nZVBhdGgpLCB2aWV3UHJvY2Vzc29yLmZpbHRlci5maWx0ZXJzTm9kZXMoKSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmlld1Byb2Nlc3NvckFwcGx5U2VydmVyT3ZlcndyaXRlKHZpZXdQcm9jZXNzb3IsIG9sZFZpZXdDYWNoZSwgY2hhbmdlUGF0aCwgY2hhbmdlZFNuYXAsIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcikge1xyXG4gICAgY29uc3Qgb2xkU2VydmVyU25hcCA9IG9sZFZpZXdDYWNoZS5zZXJ2ZXJDYWNoZTtcclxuICAgIGxldCBuZXdTZXJ2ZXJDYWNoZTtcclxuICAgIGNvbnN0IHNlcnZlckZpbHRlciA9IGZpbHRlclNlcnZlck5vZGVcclxuICAgICAgICA/IHZpZXdQcm9jZXNzb3IuZmlsdGVyXHJcbiAgICAgICAgOiB2aWV3UHJvY2Vzc29yLmZpbHRlci5nZXRJbmRleGVkRmlsdGVyKCk7XHJcbiAgICBpZiAocGF0aElzRW1wdHkoY2hhbmdlUGF0aCkpIHtcclxuICAgICAgICBuZXdTZXJ2ZXJDYWNoZSA9IHNlcnZlckZpbHRlci51cGRhdGVGdWxsTm9kZShvbGRTZXJ2ZXJTbmFwLmdldE5vZGUoKSwgY2hhbmdlZFNuYXAsIG51bGwpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc2VydmVyRmlsdGVyLmZpbHRlcnNOb2RlcygpICYmICFvbGRTZXJ2ZXJTbmFwLmlzRmlsdGVyZWQoKSkge1xyXG4gICAgICAgIC8vIHdlIHdhbnQgdG8gZmlsdGVyIHRoZSBzZXJ2ZXIgbm9kZSwgYnV0IHdlIGRpZG4ndCBmaWx0ZXIgdGhlIHNlcnZlciBub2RlIHlldCwgc28gc2ltdWxhdGUgYSBmdWxsIHVwZGF0ZVxyXG4gICAgICAgIGNvbnN0IG5ld1NlcnZlck5vZGUgPSBvbGRTZXJ2ZXJTbmFwXHJcbiAgICAgICAgICAgIC5nZXROb2RlKClcclxuICAgICAgICAgICAgLnVwZGF0ZUNoaWxkKGNoYW5nZVBhdGgsIGNoYW5nZWRTbmFwKTtcclxuICAgICAgICBuZXdTZXJ2ZXJDYWNoZSA9IHNlcnZlckZpbHRlci51cGRhdGVGdWxsTm9kZShvbGRTZXJ2ZXJTbmFwLmdldE5vZGUoKSwgbmV3U2VydmVyTm9kZSwgbnVsbCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBjaGlsZEtleSA9IHBhdGhHZXRGcm9udChjaGFuZ2VQYXRoKTtcclxuICAgICAgICBpZiAoIW9sZFNlcnZlclNuYXAuaXNDb21wbGV0ZUZvclBhdGgoY2hhbmdlUGF0aCkgJiZcclxuICAgICAgICAgICAgcGF0aEdldExlbmd0aChjaGFuZ2VQYXRoKSA+IDEpIHtcclxuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgdXBkYXRlIGluY29tcGxldGUgbm9kZXMgd2l0aCB1cGRhdGVzIGludGVuZGVkIGZvciBvdGhlciBsaXN0ZW5lcnNcclxuICAgICAgICAgICAgcmV0dXJuIG9sZFZpZXdDYWNoZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2hpbGRDaGFuZ2VQYXRoID0gcGF0aFBvcEZyb250KGNoYW5nZVBhdGgpO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IG9sZFNlcnZlclNuYXAuZ2V0Tm9kZSgpLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5KTtcclxuICAgICAgICBjb25zdCBuZXdDaGlsZE5vZGUgPSBjaGlsZE5vZGUudXBkYXRlQ2hpbGQoY2hpbGRDaGFuZ2VQYXRoLCBjaGFuZ2VkU25hcCk7XHJcbiAgICAgICAgaWYgKGNoaWxkS2V5ID09PSAnLnByaW9yaXR5Jykge1xyXG4gICAgICAgICAgICBuZXdTZXJ2ZXJDYWNoZSA9IHNlcnZlckZpbHRlci51cGRhdGVQcmlvcml0eShvbGRTZXJ2ZXJTbmFwLmdldE5vZGUoKSwgbmV3Q2hpbGROb2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5ld1NlcnZlckNhY2hlID0gc2VydmVyRmlsdGVyLnVwZGF0ZUNoaWxkKG9sZFNlcnZlclNuYXAuZ2V0Tm9kZSgpLCBjaGlsZEtleSwgbmV3Q2hpbGROb2RlLCBjaGlsZENoYW5nZVBhdGgsIE5PX0NPTVBMRVRFX0NISUxEX1NPVVJDRSwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgbmV3Vmlld0NhY2hlID0gdmlld0NhY2hlVXBkYXRlU2VydmVyU25hcChvbGRWaWV3Q2FjaGUsIG5ld1NlcnZlckNhY2hlLCBvbGRTZXJ2ZXJTbmFwLmlzRnVsbHlJbml0aWFsaXplZCgpIHx8IHBhdGhJc0VtcHR5KGNoYW5nZVBhdGgpLCBzZXJ2ZXJGaWx0ZXIuZmlsdGVyc05vZGVzKCkpO1xyXG4gICAgY29uc3Qgc291cmNlID0gbmV3IFdyaXRlVHJlZUNvbXBsZXRlQ2hpbGRTb3VyY2Uod3JpdGVzQ2FjaGUsIG5ld1ZpZXdDYWNoZSwgY29tcGxldGVDYWNoZSk7XHJcbiAgICByZXR1cm4gdmlld1Byb2Nlc3NvckdlbmVyYXRlRXZlbnRDYWNoZUFmdGVyU2VydmVyRXZlbnQodmlld1Byb2Nlc3NvciwgbmV3Vmlld0NhY2hlLCBjaGFuZ2VQYXRoLCB3cml0ZXNDYWNoZSwgc291cmNlLCBhY2N1bXVsYXRvcik7XHJcbn1cclxuZnVuY3Rpb24gdmlld1Byb2Nlc3NvckFwcGx5VXNlck92ZXJ3cml0ZSh2aWV3UHJvY2Vzc29yLCBvbGRWaWV3Q2FjaGUsIGNoYW5nZVBhdGgsIGNoYW5nZWRTbmFwLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSwgYWNjdW11bGF0b3IpIHtcclxuICAgIGNvbnN0IG9sZEV2ZW50U25hcCA9IG9sZFZpZXdDYWNoZS5ldmVudENhY2hlO1xyXG4gICAgbGV0IG5ld1ZpZXdDYWNoZSwgbmV3RXZlbnRDYWNoZTtcclxuICAgIGNvbnN0IHNvdXJjZSA9IG5ldyBXcml0ZVRyZWVDb21wbGV0ZUNoaWxkU291cmNlKHdyaXRlc0NhY2hlLCBvbGRWaWV3Q2FjaGUsIGNvbXBsZXRlQ2FjaGUpO1xyXG4gICAgaWYgKHBhdGhJc0VtcHR5KGNoYW5nZVBhdGgpKSB7XHJcbiAgICAgICAgbmV3RXZlbnRDYWNoZSA9IHZpZXdQcm9jZXNzb3IuZmlsdGVyLnVwZGF0ZUZ1bGxOb2RlKG9sZFZpZXdDYWNoZS5ldmVudENhY2hlLmdldE5vZGUoKSwgY2hhbmdlZFNuYXAsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICBuZXdWaWV3Q2FjaGUgPSB2aWV3Q2FjaGVVcGRhdGVFdmVudFNuYXAob2xkVmlld0NhY2hlLCBuZXdFdmVudENhY2hlLCB0cnVlLCB2aWV3UHJvY2Vzc29yLmZpbHRlci5maWx0ZXJzTm9kZXMoKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBjaGlsZEtleSA9IHBhdGhHZXRGcm9udChjaGFuZ2VQYXRoKTtcclxuICAgICAgICBpZiAoY2hpbGRLZXkgPT09ICcucHJpb3JpdHknKSB7XHJcbiAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSB2aWV3UHJvY2Vzc29yLmZpbHRlci51cGRhdGVQcmlvcml0eShvbGRWaWV3Q2FjaGUuZXZlbnRDYWNoZS5nZXROb2RlKCksIGNoYW5nZWRTbmFwKTtcclxuICAgICAgICAgICAgbmV3Vmlld0NhY2hlID0gdmlld0NhY2hlVXBkYXRlRXZlbnRTbmFwKG9sZFZpZXdDYWNoZSwgbmV3RXZlbnRDYWNoZSwgb2xkRXZlbnRTbmFwLmlzRnVsbHlJbml0aWFsaXplZCgpLCBvbGRFdmVudFNuYXAuaXNGaWx0ZXJlZCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkQ2hhbmdlUGF0aCA9IHBhdGhQb3BGcm9udChjaGFuZ2VQYXRoKTtcclxuICAgICAgICAgICAgY29uc3Qgb2xkQ2hpbGQgPSBvbGRFdmVudFNuYXAuZ2V0Tm9kZSgpLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5KTtcclxuICAgICAgICAgICAgbGV0IG5ld0NoaWxkO1xyXG4gICAgICAgICAgICBpZiAocGF0aElzRW1wdHkoY2hpbGRDaGFuZ2VQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hpbGQgb3ZlcndyaXRlLCB3ZSBjYW4gcmVwbGFjZSB0aGUgY2hpbGRcclxuICAgICAgICAgICAgICAgIG5ld0NoaWxkID0gY2hhbmdlZFNuYXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZE5vZGUgPSBzb3VyY2UuZ2V0Q29tcGxldGVDaGlsZChjaGlsZEtleSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGF0aEdldEJhY2soY2hpbGRDaGFuZ2VQYXRoKSA9PT0gJy5wcmlvcml0eScgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlLmdldENoaWxkKHBhdGhQYXJlbnQoY2hpbGRDaGFuZ2VQYXRoKSkuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBwcmlvcml0eSB1cGRhdGUgb24gYW4gZW1wdHkgbm9kZS4gSWYgdGhpcyBub2RlIGV4aXN0cyBvbiB0aGUgc2VydmVyLCB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VydmVyIHdpbGwgc2VuZCBkb3duIHRoZSBwcmlvcml0eSBpbiB0aGUgdXBkYXRlLCBzbyBpZ25vcmUgZm9yIG5vd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZCA9IGNoaWxkTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkID0gY2hpbGROb2RlLnVwZGF0ZUNoaWxkKGNoaWxkQ2hhbmdlUGF0aCwgY2hhbmdlZFNuYXApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIGNvbXBsZXRlIGNoaWxkIG5vZGUgYXZhaWxhYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQgPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIW9sZENoaWxkLmVxdWFscyhuZXdDaGlsZCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0V2ZW50U25hcCA9IHZpZXdQcm9jZXNzb3IuZmlsdGVyLnVwZGF0ZUNoaWxkKG9sZEV2ZW50U25hcC5nZXROb2RlKCksIGNoaWxkS2V5LCBuZXdDaGlsZCwgY2hpbGRDaGFuZ2VQYXRoLCBzb3VyY2UsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICAgICAgICAgIG5ld1ZpZXdDYWNoZSA9IHZpZXdDYWNoZVVwZGF0ZUV2ZW50U25hcChvbGRWaWV3Q2FjaGUsIG5ld0V2ZW50U25hcCwgb2xkRXZlbnRTbmFwLmlzRnVsbHlJbml0aWFsaXplZCgpLCB2aWV3UHJvY2Vzc29yLmZpbHRlci5maWx0ZXJzTm9kZXMoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXdWaWV3Q2FjaGUgPSBvbGRWaWV3Q2FjaGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3Vmlld0NhY2hlO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdQcm9jZXNzb3JDYWNoZUhhc0NoaWxkKHZpZXdDYWNoZSwgY2hpbGRLZXkpIHtcclxuICAgIHJldHVybiB2aWV3Q2FjaGUuZXZlbnRDYWNoZS5pc0NvbXBsZXRlRm9yQ2hpbGQoY2hpbGRLZXkpO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdQcm9jZXNzb3JBcHBseVVzZXJNZXJnZSh2aWV3UHJvY2Vzc29yLCB2aWV3Q2FjaGUsIHBhdGgsIGNoYW5nZWRDaGlsZHJlbiwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlLCBhY2N1bXVsYXRvcikge1xyXG4gICAgLy8gSEFDSzogSW4gdGhlIGNhc2Ugb2YgYSBsaW1pdCBxdWVyeSwgdGhlcmUgbWF5IGJlIHNvbWUgY2hhbmdlcyB0aGF0IGJ1bXAgdGhpbmdzIG91dCBvZiB0aGVcclxuICAgIC8vIHdpbmRvdyBsZWF2aW5nIHJvb20gZm9yIG5ldyBpdGVtcy4gIEl0J3MgaW1wb3J0YW50IHdlIHByb2Nlc3MgdGhlc2UgY2hhbmdlcyBmaXJzdCwgc28gd2VcclxuICAgIC8vIGl0ZXJhdGUgdGhlIGNoYW5nZXMgdHdpY2UsIGZpcnN0IHByb2Nlc3NpbmcgYW55IHRoYXQgYWZmZWN0IGl0ZW1zIGN1cnJlbnRseSBpbiB2aWV3LlxyXG4gICAgLy8gVE9ETzogSSBjb25zaWRlciBhbiBpdGVtIFwiaW4gdmlld1wiIGlmIGNhY2hlSGFzQ2hpbGQgaXMgdHJ1ZSwgd2hpY2ggY2hlY2tzIGJvdGggdGhlIHNlcnZlclxyXG4gICAgLy8gYW5kIGV2ZW50IHNuYXAuICBJJ20gbm90IHN1cmUgaWYgdGhpcyB3aWxsIHJlc3VsdCBpbiBlZGdlIGNhc2VzIHdoZW4gYSBjaGlsZCBpcyBpbiBvbmUgYnV0XHJcbiAgICAvLyBub3QgdGhlIG90aGVyLlxyXG4gICAgbGV0IGN1clZpZXdDYWNoZSA9IHZpZXdDYWNoZTtcclxuICAgIGNoYW5nZWRDaGlsZHJlbi5mb3JlYWNoKChyZWxhdGl2ZVBhdGgsIGNoaWxkTm9kZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHdyaXRlUGF0aCA9IHBhdGhDaGlsZChwYXRoLCByZWxhdGl2ZVBhdGgpO1xyXG4gICAgICAgIGlmICh2aWV3UHJvY2Vzc29yQ2FjaGVIYXNDaGlsZCh2aWV3Q2FjaGUsIHBhdGhHZXRGcm9udCh3cml0ZVBhdGgpKSkge1xyXG4gICAgICAgICAgICBjdXJWaWV3Q2FjaGUgPSB2aWV3UHJvY2Vzc29yQXBwbHlVc2VyT3ZlcndyaXRlKHZpZXdQcm9jZXNzb3IsIGN1clZpZXdDYWNoZSwgd3JpdGVQYXRoLCBjaGlsZE5vZGUsIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSwgYWNjdW11bGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgY2hhbmdlZENoaWxkcmVuLmZvcmVhY2goKHJlbGF0aXZlUGF0aCwgY2hpbGROb2RlKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgd3JpdGVQYXRoID0gcGF0aENoaWxkKHBhdGgsIHJlbGF0aXZlUGF0aCk7XHJcbiAgICAgICAgaWYgKCF2aWV3UHJvY2Vzc29yQ2FjaGVIYXNDaGlsZCh2aWV3Q2FjaGUsIHBhdGhHZXRGcm9udCh3cml0ZVBhdGgpKSkge1xyXG4gICAgICAgICAgICBjdXJWaWV3Q2FjaGUgPSB2aWV3UHJvY2Vzc29yQXBwbHlVc2VyT3ZlcndyaXRlKHZpZXdQcm9jZXNzb3IsIGN1clZpZXdDYWNoZSwgd3JpdGVQYXRoLCBjaGlsZE5vZGUsIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSwgYWNjdW11bGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGN1clZpZXdDYWNoZTtcclxufVxyXG5mdW5jdGlvbiB2aWV3UHJvY2Vzc29yQXBwbHlNZXJnZSh2aWV3UHJvY2Vzc29yLCBub2RlLCBtZXJnZSkge1xyXG4gICAgbWVyZ2UuZm9yZWFjaCgocmVsYXRpdmVQYXRoLCBjaGlsZE5vZGUpID0+IHtcclxuICAgICAgICBub2RlID0gbm9kZS51cGRhdGVDaGlsZChyZWxhdGl2ZVBhdGgsIGNoaWxkTm9kZSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBub2RlO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdQcm9jZXNzb3JBcHBseVNlcnZlck1lcmdlKHZpZXdQcm9jZXNzb3IsIHZpZXdDYWNoZSwgcGF0aCwgY2hhbmdlZENoaWxkcmVuLCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGUsIGZpbHRlclNlcnZlck5vZGUsIGFjY3VtdWxhdG9yKSB7XHJcbiAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgY2FjaGUgeWV0LCB0aGlzIG1lcmdlIHdhcyBpbnRlbmRlZCBmb3IgYSBwcmV2aW91c2x5IGxpc3RlbiBpbiB0aGUgc2FtZSBsb2NhdGlvbi4gSWdub3JlIGl0IGFuZFxyXG4gICAgLy8gd2FpdCBmb3IgdGhlIGNvbXBsZXRlIGRhdGEgdXBkYXRlIGNvbWluZyBzb29uLlxyXG4gICAgaWYgKHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5nZXROb2RlKCkuaXNFbXB0eSgpICYmXHJcbiAgICAgICAgIXZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSkge1xyXG4gICAgICAgIHJldHVybiB2aWV3Q2FjaGU7XHJcbiAgICB9XHJcbiAgICAvLyBIQUNLOiBJbiB0aGUgY2FzZSBvZiBhIGxpbWl0IHF1ZXJ5LCB0aGVyZSBtYXkgYmUgc29tZSBjaGFuZ2VzIHRoYXQgYnVtcCB0aGluZ3Mgb3V0IG9mIHRoZVxyXG4gICAgLy8gd2luZG93IGxlYXZpbmcgcm9vbSBmb3IgbmV3IGl0ZW1zLiAgSXQncyBpbXBvcnRhbnQgd2UgcHJvY2VzcyB0aGVzZSBjaGFuZ2VzIGZpcnN0LCBzbyB3ZVxyXG4gICAgLy8gaXRlcmF0ZSB0aGUgY2hhbmdlcyB0d2ljZSwgZmlyc3QgcHJvY2Vzc2luZyBhbnkgdGhhdCBhZmZlY3QgaXRlbXMgY3VycmVudGx5IGluIHZpZXcuXHJcbiAgICAvLyBUT0RPOiBJIGNvbnNpZGVyIGFuIGl0ZW0gXCJpbiB2aWV3XCIgaWYgY2FjaGVIYXNDaGlsZCBpcyB0cnVlLCB3aGljaCBjaGVja3MgYm90aCB0aGUgc2VydmVyXHJcbiAgICAvLyBhbmQgZXZlbnQgc25hcC4gIEknbSBub3Qgc3VyZSBpZiB0aGlzIHdpbGwgcmVzdWx0IGluIGVkZ2UgY2FzZXMgd2hlbiBhIGNoaWxkIGlzIGluIG9uZSBidXRcclxuICAgIC8vIG5vdCB0aGUgb3RoZXIuXHJcbiAgICBsZXQgY3VyVmlld0NhY2hlID0gdmlld0NhY2hlO1xyXG4gICAgbGV0IHZpZXdNZXJnZVRyZWU7XHJcbiAgICBpZiAocGF0aElzRW1wdHkocGF0aCkpIHtcclxuICAgICAgICB2aWV3TWVyZ2VUcmVlID0gY2hhbmdlZENoaWxkcmVuO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmlld01lcmdlVHJlZSA9IG5ldyBJbW11dGFibGVUcmVlKG51bGwpLnNldFRyZWUocGF0aCwgY2hhbmdlZENoaWxkcmVuKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHNlcnZlck5vZGUgPSB2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuZ2V0Tm9kZSgpO1xyXG4gICAgdmlld01lcmdlVHJlZS5jaGlsZHJlbi5pbm9yZGVyVHJhdmVyc2FsKChjaGlsZEtleSwgY2hpbGRUcmVlKSA9PiB7XHJcbiAgICAgICAgaWYgKHNlcnZlck5vZGUuaGFzQ2hpbGQoY2hpbGRLZXkpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlcnZlckNoaWxkID0gdmlld0NhY2hlLnNlcnZlckNhY2hlXHJcbiAgICAgICAgICAgICAgICAuZ2V0Tm9kZSgpXHJcbiAgICAgICAgICAgICAgICAuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXkpO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdDaGlsZCA9IHZpZXdQcm9jZXNzb3JBcHBseU1lcmdlKHZpZXdQcm9jZXNzb3IsIHNlcnZlckNoaWxkLCBjaGlsZFRyZWUpO1xyXG4gICAgICAgICAgICBjdXJWaWV3Q2FjaGUgPSB2aWV3UHJvY2Vzc29yQXBwbHlTZXJ2ZXJPdmVyd3JpdGUodmlld1Byb2Nlc3NvciwgY3VyVmlld0NhY2hlLCBuZXcgUGF0aChjaGlsZEtleSksIG5ld0NoaWxkLCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGUsIGZpbHRlclNlcnZlck5vZGUsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHZpZXdNZXJnZVRyZWUuY2hpbGRyZW4uaW5vcmRlclRyYXZlcnNhbCgoY2hpbGRLZXksIGNoaWxkTWVyZ2VUcmVlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaXNVbmtub3duRGVlcE1lcmdlID0gIXZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0NvbXBsZXRlRm9yQ2hpbGQoY2hpbGRLZXkpICYmXHJcbiAgICAgICAgICAgIGNoaWxkTWVyZ2VUcmVlLnZhbHVlID09PSBudWxsO1xyXG4gICAgICAgIGlmICghc2VydmVyTm9kZS5oYXNDaGlsZChjaGlsZEtleSkgJiYgIWlzVW5rbm93bkRlZXBNZXJnZSkge1xyXG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXJDaGlsZCA9IHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZVxyXG4gICAgICAgICAgICAgICAgLmdldE5vZGUoKVxyXG4gICAgICAgICAgICAgICAgLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5KTtcclxuICAgICAgICAgICAgY29uc3QgbmV3Q2hpbGQgPSB2aWV3UHJvY2Vzc29yQXBwbHlNZXJnZSh2aWV3UHJvY2Vzc29yLCBzZXJ2ZXJDaGlsZCwgY2hpbGRNZXJnZVRyZWUpO1xyXG4gICAgICAgICAgICBjdXJWaWV3Q2FjaGUgPSB2aWV3UHJvY2Vzc29yQXBwbHlTZXJ2ZXJPdmVyd3JpdGUodmlld1Byb2Nlc3NvciwgY3VyVmlld0NhY2hlLCBuZXcgUGF0aChjaGlsZEtleSksIG5ld0NoaWxkLCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGUsIGZpbHRlclNlcnZlck5vZGUsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBjdXJWaWV3Q2FjaGU7XHJcbn1cclxuZnVuY3Rpb24gdmlld1Byb2Nlc3NvckFja1VzZXJXcml0ZSh2aWV3UHJvY2Vzc29yLCB2aWV3Q2FjaGUsIGFja1BhdGgsIGFmZmVjdGVkVHJlZSwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGFjY3VtdWxhdG9yKSB7XHJcbiAgICBpZiAod3JpdGVUcmVlUmVmU2hhZG93aW5nV3JpdGUod3JpdGVzQ2FjaGUsIGFja1BhdGgpICE9IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gdmlld0NhY2hlO1xyXG4gICAgfVxyXG4gICAgLy8gT25seSBmaWx0ZXIgc2VydmVyIG5vZGUgaWYgaXQgaXMgY3VycmVudGx5IGZpbHRlcmVkXHJcbiAgICBjb25zdCBmaWx0ZXJTZXJ2ZXJOb2RlID0gdmlld0NhY2hlLnNlcnZlckNhY2hlLmlzRmlsdGVyZWQoKTtcclxuICAgIC8vIEVzc2VudGlhbGx5IHdlJ2xsIGp1c3QgZ2V0IG91ciBleGlzdGluZyBzZXJ2ZXIgY2FjaGUgZm9yIHRoZSBhZmZlY3RlZCBwYXRocyBhbmQgcmUtYXBwbHkgaXQgYXMgYSBzZXJ2ZXIgdXBkYXRlXHJcbiAgICAvLyBub3cgdGhhdCBpdCB3b24ndCBiZSBzaGFkb3dlZC5cclxuICAgIGNvbnN0IHNlcnZlckNhY2hlID0gdmlld0NhY2hlLnNlcnZlckNhY2hlO1xyXG4gICAgaWYgKGFmZmVjdGVkVHJlZS52YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgLy8gVGhpcyBpcyBhbiBvdmVyd3JpdGUuXHJcbiAgICAgICAgaWYgKChwYXRoSXNFbXB0eShhY2tQYXRoKSAmJiBzZXJ2ZXJDYWNoZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSkgfHxcclxuICAgICAgICAgICAgc2VydmVyQ2FjaGUuaXNDb21wbGV0ZUZvclBhdGgoYWNrUGF0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZpZXdQcm9jZXNzb3JBcHBseVNlcnZlck92ZXJ3cml0ZSh2aWV3UHJvY2Vzc29yLCB2aWV3Q2FjaGUsIGFja1BhdGgsIHNlcnZlckNhY2hlLmdldE5vZGUoKS5nZXRDaGlsZChhY2tQYXRoKSwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGZpbHRlclNlcnZlck5vZGUsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocGF0aElzRW1wdHkoYWNrUGF0aCkpIHtcclxuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIGdvb2Z5IGVkZ2UgY2FzZSB3aGVyZSB3ZSBhcmUgYWNraW5nIGRhdGEgYXQgdGhpcyBsb2NhdGlvbiBidXQgZG9uJ3QgaGF2ZSBmdWxsIGRhdGEuICBXZVxyXG4gICAgICAgICAgICAvLyBzaG91bGQganVzdCByZS1hcHBseSB3aGF0ZXZlciB3ZSBoYXZlIGluIG91ciBjYWNoZSBhcyBhIG1lcmdlLlxyXG4gICAgICAgICAgICBsZXQgY2hhbmdlZENoaWxkcmVuID0gbmV3IEltbXV0YWJsZVRyZWUobnVsbCk7XHJcbiAgICAgICAgICAgIHNlcnZlckNhY2hlLmdldE5vZGUoKS5mb3JFYWNoQ2hpbGQoS0VZX0lOREVYLCAobmFtZSwgbm9kZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlZENoaWxkcmVuID0gY2hhbmdlZENoaWxkcmVuLnNldChuZXcgUGF0aChuYW1lKSwgbm9kZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdmlld1Byb2Nlc3NvckFwcGx5U2VydmVyTWVyZ2Uodmlld1Byb2Nlc3Nvciwgdmlld0NhY2hlLCBhY2tQYXRoLCBjaGFuZ2VkQ2hpbGRyZW4sIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdmlld0NhY2hlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIFRoaXMgaXMgYSBtZXJnZS5cclxuICAgICAgICBsZXQgY2hhbmdlZENoaWxkcmVuID0gbmV3IEltbXV0YWJsZVRyZWUobnVsbCk7XHJcbiAgICAgICAgYWZmZWN0ZWRUcmVlLmZvcmVhY2goKG1lcmdlUGF0aCwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc2VydmVyQ2FjaGVQYXRoID0gcGF0aENoaWxkKGFja1BhdGgsIG1lcmdlUGF0aCk7XHJcbiAgICAgICAgICAgIGlmIChzZXJ2ZXJDYWNoZS5pc0NvbXBsZXRlRm9yUGF0aChzZXJ2ZXJDYWNoZVBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VkQ2hpbGRyZW4gPSBjaGFuZ2VkQ2hpbGRyZW4uc2V0KG1lcmdlUGF0aCwgc2VydmVyQ2FjaGUuZ2V0Tm9kZSgpLmdldENoaWxkKHNlcnZlckNhY2hlUGF0aCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHZpZXdQcm9jZXNzb3JBcHBseVNlcnZlck1lcmdlKHZpZXdQcm9jZXNzb3IsIHZpZXdDYWNoZSwgYWNrUGF0aCwgY2hhbmdlZENoaWxkcmVuLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSwgZmlsdGVyU2VydmVyTm9kZSwgYWNjdW11bGF0b3IpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHZpZXdQcm9jZXNzb3JMaXN0ZW5Db21wbGV0ZSh2aWV3UHJvY2Vzc29yLCB2aWV3Q2FjaGUsIHBhdGgsIHdyaXRlc0NhY2hlLCBhY2N1bXVsYXRvcikge1xyXG4gICAgY29uc3Qgb2xkU2VydmVyTm9kZSA9IHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZTtcclxuICAgIGNvbnN0IG5ld1ZpZXdDYWNoZSA9IHZpZXdDYWNoZVVwZGF0ZVNlcnZlclNuYXAodmlld0NhY2hlLCBvbGRTZXJ2ZXJOb2RlLmdldE5vZGUoKSwgb2xkU2VydmVyTm9kZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSB8fCBwYXRoSXNFbXB0eShwYXRoKSwgb2xkU2VydmVyTm9kZS5pc0ZpbHRlcmVkKCkpO1xyXG4gICAgcmV0dXJuIHZpZXdQcm9jZXNzb3JHZW5lcmF0ZUV2ZW50Q2FjaGVBZnRlclNlcnZlckV2ZW50KHZpZXdQcm9jZXNzb3IsIG5ld1ZpZXdDYWNoZSwgcGF0aCwgd3JpdGVzQ2FjaGUsIE5PX0NPTVBMRVRFX0NISUxEX1NPVVJDRSwgYWNjdW11bGF0b3IpO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdQcm9jZXNzb3JSZXZlcnRVc2VyV3JpdGUodmlld1Byb2Nlc3Nvciwgdmlld0NhY2hlLCBwYXRoLCB3cml0ZXNDYWNoZSwgY29tcGxldGVTZXJ2ZXJDYWNoZSwgYWNjdW11bGF0b3IpIHtcclxuICAgIGxldCBjb21wbGV0ZTtcclxuICAgIGlmICh3cml0ZVRyZWVSZWZTaGFkb3dpbmdXcml0ZSh3cml0ZXNDYWNoZSwgcGF0aCkgIT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiB2aWV3Q2FjaGU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBzb3VyY2UgPSBuZXcgV3JpdGVUcmVlQ29tcGxldGVDaGlsZFNvdXJjZSh3cml0ZXNDYWNoZSwgdmlld0NhY2hlLCBjb21wbGV0ZVNlcnZlckNhY2hlKTtcclxuICAgICAgICBjb25zdCBvbGRFdmVudENhY2hlID0gdmlld0NhY2hlLmV2ZW50Q2FjaGUuZ2V0Tm9kZSgpO1xyXG4gICAgICAgIGxldCBuZXdFdmVudENhY2hlO1xyXG4gICAgICAgIGlmIChwYXRoSXNFbXB0eShwYXRoKSB8fCBwYXRoR2V0RnJvbnQocGF0aCkgPT09ICcucHJpb3JpdHknKSB7XHJcbiAgICAgICAgICAgIGxldCBuZXdOb2RlO1xyXG4gICAgICAgICAgICBpZiAodmlld0NhY2hlLnNlcnZlckNhY2hlLmlzRnVsbHlJbml0aWFsaXplZCgpKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdOb2RlID0gd3JpdGVUcmVlUmVmQ2FsY0NvbXBsZXRlRXZlbnRDYWNoZSh3cml0ZXNDYWNoZSwgdmlld0NhY2hlR2V0Q29tcGxldGVTZXJ2ZXJTbmFwKHZpZXdDYWNoZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VydmVyQ2hpbGRyZW4gPSB2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuZ2V0Tm9kZSgpO1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0KHNlcnZlckNoaWxkcmVuIGluc3RhbmNlb2YgQ2hpbGRyZW5Ob2RlLCAnc2VydmVyQ2hpbGRyZW4gd291bGQgYmUgY29tcGxldGUgaWYgbGVhZiBub2RlJyk7XHJcbiAgICAgICAgICAgICAgICBuZXdOb2RlID0gd3JpdGVUcmVlUmVmQ2FsY0NvbXBsZXRlRXZlbnRDaGlsZHJlbih3cml0ZXNDYWNoZSwgc2VydmVyQ2hpbGRyZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5ld05vZGUgPSBuZXdOb2RlO1xyXG4gICAgICAgICAgICBuZXdFdmVudENhY2hlID0gdmlld1Byb2Nlc3Nvci5maWx0ZXIudXBkYXRlRnVsbE5vZGUob2xkRXZlbnRDYWNoZSwgbmV3Tm9kZSwgYWNjdW11bGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGRLZXkgPSBwYXRoR2V0RnJvbnQocGF0aCk7XHJcbiAgICAgICAgICAgIGxldCBuZXdDaGlsZCA9IHdyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUNoaWxkKHdyaXRlc0NhY2hlLCBjaGlsZEtleSwgdmlld0NhY2hlLnNlcnZlckNhY2hlKTtcclxuICAgICAgICAgICAgaWYgKG5ld0NoaWxkID09IG51bGwgJiZcclxuICAgICAgICAgICAgICAgIHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0NvbXBsZXRlRm9yQ2hpbGQoY2hpbGRLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdDaGlsZCA9IG9sZEV2ZW50Q2FjaGUuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdFdmVudENhY2hlID0gdmlld1Byb2Nlc3Nvci5maWx0ZXIudXBkYXRlQ2hpbGQob2xkRXZlbnRDYWNoZSwgY2hpbGRLZXksIG5ld0NoaWxkLCBwYXRoUG9wRnJvbnQocGF0aCksIHNvdXJjZSwgYWNjdW11bGF0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHZpZXdDYWNoZS5ldmVudENhY2hlLmdldE5vZGUoKS5oYXNDaGlsZChjaGlsZEtleSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vIGNvbXBsZXRlIGNoaWxkIGF2YWlsYWJsZSwgZGVsZXRlIHRoZSBleGlzdGluZyBvbmUsIGlmIGFueVxyXG4gICAgICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IHZpZXdQcm9jZXNzb3IuZmlsdGVyLnVwZGF0ZUNoaWxkKG9sZEV2ZW50Q2FjaGUsIGNoaWxkS2V5LCBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSwgcGF0aFBvcEZyb250KHBhdGgpLCBzb3VyY2UsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSBvbGRFdmVudENhY2hlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChuZXdFdmVudENhY2hlLmlzRW1wdHkoKSAmJlxyXG4gICAgICAgICAgICAgICAgdmlld0NhY2hlLnNlcnZlckNhY2hlLmlzRnVsbHlJbml0aWFsaXplZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBtaWdodCBoYXZlIHJldmVydGVkIGFsbCBjaGlsZCB3cml0ZXMuIE1heWJlIHRoZSBvbGQgZXZlbnQgd2FzIGEgbGVhZiBub2RlXHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZSA9IHdyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUod3JpdGVzQ2FjaGUsIHZpZXdDYWNoZUdldENvbXBsZXRlU2VydmVyU25hcCh2aWV3Q2FjaGUpKTtcclxuICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZS5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdFdmVudENhY2hlID0gdmlld1Byb2Nlc3Nvci5maWx0ZXIudXBkYXRlRnVsbE5vZGUobmV3RXZlbnRDYWNoZSwgY29tcGxldGUsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb21wbGV0ZSA9XHJcbiAgICAgICAgICAgIHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSB8fFxyXG4gICAgICAgICAgICAgICAgd3JpdGVUcmVlUmVmU2hhZG93aW5nV3JpdGUod3JpdGVzQ2FjaGUsIG5ld0VtcHR5UGF0aCgpKSAhPSBudWxsO1xyXG4gICAgICAgIHJldHVybiB2aWV3Q2FjaGVVcGRhdGVFdmVudFNuYXAodmlld0NhY2hlLCBuZXdFdmVudENhY2hlLCBjb21wbGV0ZSwgdmlld1Byb2Nlc3Nvci5maWx0ZXIuZmlsdGVyc05vZGVzKCkpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIHZpZXcgcmVwcmVzZW50cyBhIHNwZWNpZmljIGxvY2F0aW9uIGFuZCBxdWVyeSB0aGF0IGhhcyAxIG9yIG1vcmUgZXZlbnQgcmVnaXN0cmF0aW9ucy5cclxuICpcclxuICogSXQgZG9lcyBzZXZlcmFsIHRoaW5nczpcclxuICogIC0gTWFpbnRhaW5zIHRoZSBsaXN0IG9mIGV2ZW50IHJlZ2lzdHJhdGlvbnMgZm9yIHRoaXMgbG9jYXRpb24vcXVlcnkuXHJcbiAqICAtIE1haW50YWlucyBhIGNhY2hlIG9mIHRoZSBkYXRhIHZpc2libGUgZm9yIHRoaXMgbG9jYXRpb24vcXVlcnkuXHJcbiAqICAtIEFwcGxpZXMgbmV3IG9wZXJhdGlvbnMgKHZpYSBhcHBseU9wZXJhdGlvbiksIHVwZGF0ZXMgdGhlIGNhY2hlLCBhbmQgYmFzZWQgb24gdGhlIGV2ZW50XHJcbiAqICAgIHJlZ2lzdHJhdGlvbnMgcmV0dXJucyB0aGUgc2V0IG9mIGV2ZW50cyB0byBiZSByYWlzZWQuXHJcbiAqL1xyXG5jbGFzcyBWaWV3IHtcclxuICAgIGNvbnN0cnVjdG9yKHF1ZXJ5XywgaW5pdGlhbFZpZXdDYWNoZSkge1xyXG4gICAgICAgIHRoaXMucXVlcnlfID0gcXVlcnlfO1xyXG4gICAgICAgIHRoaXMuZXZlbnRSZWdpc3RyYXRpb25zXyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMucXVlcnlfLl9xdWVyeVBhcmFtcztcclxuICAgICAgICBjb25zdCBpbmRleEZpbHRlciA9IG5ldyBJbmRleGVkRmlsdGVyKHBhcmFtcy5nZXRJbmRleCgpKTtcclxuICAgICAgICBjb25zdCBmaWx0ZXIgPSBxdWVyeVBhcmFtc0dldE5vZGVGaWx0ZXIocGFyYW1zKTtcclxuICAgICAgICB0aGlzLnByb2Nlc3Nvcl8gPSBuZXdWaWV3UHJvY2Vzc29yKGZpbHRlcik7XHJcbiAgICAgICAgY29uc3QgaW5pdGlhbFNlcnZlckNhY2hlID0gaW5pdGlhbFZpZXdDYWNoZS5zZXJ2ZXJDYWNoZTtcclxuICAgICAgICBjb25zdCBpbml0aWFsRXZlbnRDYWNoZSA9IGluaXRpYWxWaWV3Q2FjaGUuZXZlbnRDYWNoZTtcclxuICAgICAgICAvLyBEb24ndCBmaWx0ZXIgc2VydmVyIG5vZGUgd2l0aCBvdGhlciBmaWx0ZXIgdGhhbiBpbmRleCwgd2FpdCBmb3IgdGFnZ2VkIGxpc3RlblxyXG4gICAgICAgIGNvbnN0IHNlcnZlclNuYXAgPSBpbmRleEZpbHRlci51cGRhdGVGdWxsTm9kZShDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSwgaW5pdGlhbFNlcnZlckNhY2hlLmdldE5vZGUoKSwgbnVsbCk7XHJcbiAgICAgICAgY29uc3QgZXZlbnRTbmFwID0gZmlsdGVyLnVwZGF0ZUZ1bGxOb2RlKENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFLCBpbml0aWFsRXZlbnRDYWNoZS5nZXROb2RlKCksIG51bGwpO1xyXG4gICAgICAgIGNvbnN0IG5ld1NlcnZlckNhY2hlID0gbmV3IENhY2hlTm9kZShzZXJ2ZXJTbmFwLCBpbml0aWFsU2VydmVyQ2FjaGUuaXNGdWxseUluaXRpYWxpemVkKCksIGluZGV4RmlsdGVyLmZpbHRlcnNOb2RlcygpKTtcclxuICAgICAgICBjb25zdCBuZXdFdmVudENhY2hlID0gbmV3IENhY2hlTm9kZShldmVudFNuYXAsIGluaXRpYWxFdmVudENhY2hlLmlzRnVsbHlJbml0aWFsaXplZCgpLCBmaWx0ZXIuZmlsdGVyc05vZGVzKCkpO1xyXG4gICAgICAgIHRoaXMudmlld0NhY2hlXyA9IG5ld1ZpZXdDYWNoZShuZXdFdmVudENhY2hlLCBuZXdTZXJ2ZXJDYWNoZSk7XHJcbiAgICAgICAgdGhpcy5ldmVudEdlbmVyYXRvcl8gPSBuZXcgRXZlbnRHZW5lcmF0b3IodGhpcy5xdWVyeV8pO1xyXG4gICAgfVxyXG4gICAgZ2V0IHF1ZXJ5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5XztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB2aWV3R2V0U2VydmVyQ2FjaGUodmlldykge1xyXG4gICAgcmV0dXJuIHZpZXcudmlld0NhY2hlXy5zZXJ2ZXJDYWNoZS5nZXROb2RlKCk7XHJcbn1cclxuZnVuY3Rpb24gdmlld0dldENvbXBsZXRlTm9kZSh2aWV3KSB7XHJcbiAgICByZXR1cm4gdmlld0NhY2hlR2V0Q29tcGxldGVFdmVudFNuYXAodmlldy52aWV3Q2FjaGVfKTtcclxufVxyXG5mdW5jdGlvbiB2aWV3R2V0Q29tcGxldGVTZXJ2ZXJDYWNoZSh2aWV3LCBwYXRoKSB7XHJcbiAgICBjb25zdCBjYWNoZSA9IHZpZXdDYWNoZUdldENvbXBsZXRlU2VydmVyU25hcCh2aWV3LnZpZXdDYWNoZV8pO1xyXG4gICAgaWYgKGNhY2hlKSB7XHJcbiAgICAgICAgLy8gSWYgdGhpcyBpc24ndCBhIFwibG9hZHNBbGxEYXRhXCIgdmlldywgdGhlbiBjYWNoZSBpc24ndCBhY3R1YWxseSBhIGNvbXBsZXRlIGNhY2hlIGFuZFxyXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gc2VlIGlmIGl0IGNvbnRhaW5zIHRoZSBjaGlsZCB3ZSdyZSBpbnRlcmVzdGVkIGluLlxyXG4gICAgICAgIGlmICh2aWV3LnF1ZXJ5Ll9xdWVyeVBhcmFtcy5sb2Fkc0FsbERhdGEoKSB8fFxyXG4gICAgICAgICAgICAoIXBhdGhJc0VtcHR5KHBhdGgpICYmXHJcbiAgICAgICAgICAgICAgICAhY2FjaGUuZ2V0SW1tZWRpYXRlQ2hpbGQocGF0aEdldEZyb250KHBhdGgpKS5pc0VtcHR5KCkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWNoZS5nZXRDaGlsZChwYXRoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5mdW5jdGlvbiB2aWV3SXNFbXB0eSh2aWV3KSB7XHJcbiAgICByZXR1cm4gdmlldy5ldmVudFJlZ2lzdHJhdGlvbnNfLmxlbmd0aCA9PT0gMDtcclxufVxyXG5mdW5jdGlvbiB2aWV3QWRkRXZlbnRSZWdpc3RyYXRpb24odmlldywgZXZlbnRSZWdpc3RyYXRpb24pIHtcclxuICAgIHZpZXcuZXZlbnRSZWdpc3RyYXRpb25zXy5wdXNoKGV2ZW50UmVnaXN0cmF0aW9uKTtcclxufVxyXG4vKipcclxuICogQHBhcmFtIGV2ZW50UmVnaXN0cmF0aW9uIC0gSWYgbnVsbCwgcmVtb3ZlIGFsbCBjYWxsYmFja3MuXHJcbiAqIEBwYXJhbSBjYW5jZWxFcnJvciAtIElmIGEgY2FuY2VsRXJyb3IgaXMgcHJvdmlkZWQsIGFwcHJvcHJpYXRlIGNhbmNlbCBldmVudHMgd2lsbCBiZSByZXR1cm5lZC5cclxuICogQHJldHVybnMgQ2FuY2VsIGV2ZW50cywgaWYgY2FuY2VsRXJyb3Igd2FzIHByb3ZpZGVkLlxyXG4gKi9cclxuZnVuY3Rpb24gdmlld1JlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKHZpZXcsIGV2ZW50UmVnaXN0cmF0aW9uLCBjYW5jZWxFcnJvcikge1xyXG4gICAgY29uc3QgY2FuY2VsRXZlbnRzID0gW107XHJcbiAgICBpZiAoY2FuY2VsRXJyb3IpIHtcclxuICAgICAgICBhc3NlcnQoZXZlbnRSZWdpc3RyYXRpb24gPT0gbnVsbCwgJ0EgY2FuY2VsIHNob3VsZCBjYW5jZWwgYWxsIGV2ZW50IHJlZ2lzdHJhdGlvbnMuJyk7XHJcbiAgICAgICAgY29uc3QgcGF0aCA9IHZpZXcucXVlcnkuX3BhdGg7XHJcbiAgICAgICAgdmlldy5ldmVudFJlZ2lzdHJhdGlvbnNfLmZvckVhY2gocmVnaXN0cmF0aW9uID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbWF5YmVFdmVudCA9IHJlZ2lzdHJhdGlvbi5jcmVhdGVDYW5jZWxFdmVudChjYW5jZWxFcnJvciwgcGF0aCk7XHJcbiAgICAgICAgICAgIGlmIChtYXliZUV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICBjYW5jZWxFdmVudHMucHVzaChtYXliZUV2ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKGV2ZW50UmVnaXN0cmF0aW9uKSB7XHJcbiAgICAgICAgbGV0IHJlbWFpbmluZyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmlldy5ldmVudFJlZ2lzdHJhdGlvbnNfLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gdmlldy5ldmVudFJlZ2lzdHJhdGlvbnNfW2ldO1xyXG4gICAgICAgICAgICBpZiAoIWV4aXN0aW5nLm1hdGNoZXMoZXZlbnRSZWdpc3RyYXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICByZW1haW5pbmcucHVzaChleGlzdGluZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnRSZWdpc3RyYXRpb24uaGFzQW55Q2FsbGJhY2soKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UncmUgcmVtb3ZpbmcganVzdCB0aGlzIG9uZVxyXG4gICAgICAgICAgICAgICAgcmVtYWluaW5nID0gcmVtYWluaW5nLmNvbmNhdCh2aWV3LmV2ZW50UmVnaXN0cmF0aW9uc18uc2xpY2UoaSArIDEpKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZpZXcuZXZlbnRSZWdpc3RyYXRpb25zXyA9IHJlbWFpbmluZztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZpZXcuZXZlbnRSZWdpc3RyYXRpb25zXyA9IFtdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNhbmNlbEV2ZW50cztcclxufVxyXG4vKipcclxuICogQXBwbGllcyB0aGUgZ2l2ZW4gT3BlcmF0aW9uLCB1cGRhdGVzIG91ciBjYWNoZSwgYW5kIHJldHVybnMgdGhlIGFwcHJvcHJpYXRlIGV2ZW50cy5cclxuICovXHJcbmZ1bmN0aW9uIHZpZXdBcHBseU9wZXJhdGlvbih2aWV3LCBvcGVyYXRpb24sIHdyaXRlc0NhY2hlLCBjb21wbGV0ZVNlcnZlckNhY2hlKSB7XHJcbiAgICBpZiAob3BlcmF0aW9uLnR5cGUgPT09IE9wZXJhdGlvblR5cGUuTUVSR0UgJiZcclxuICAgICAgICBvcGVyYXRpb24uc291cmNlLnF1ZXJ5SWQgIT09IG51bGwpIHtcclxuICAgICAgICBhc3NlcnQodmlld0NhY2hlR2V0Q29tcGxldGVTZXJ2ZXJTbmFwKHZpZXcudmlld0NhY2hlXyksICdXZSBzaG91bGQgYWx3YXlzIGhhdmUgYSBmdWxsIGNhY2hlIGJlZm9yZSBoYW5kbGluZyBtZXJnZXMnKTtcclxuICAgICAgICBhc3NlcnQodmlld0NhY2hlR2V0Q29tcGxldGVFdmVudFNuYXAodmlldy52aWV3Q2FjaGVfKSwgJ01pc3NpbmcgZXZlbnQgY2FjaGUsIGV2ZW4gdGhvdWdoIHdlIGhhdmUgYSBzZXJ2ZXIgY2FjaGUnKTtcclxuICAgIH1cclxuICAgIGNvbnN0IG9sZFZpZXdDYWNoZSA9IHZpZXcudmlld0NhY2hlXztcclxuICAgIGNvbnN0IHJlc3VsdCA9IHZpZXdQcm9jZXNzb3JBcHBseU9wZXJhdGlvbih2aWV3LnByb2Nlc3Nvcl8sIG9sZFZpZXdDYWNoZSwgb3BlcmF0aW9uLCB3cml0ZXNDYWNoZSwgY29tcGxldGVTZXJ2ZXJDYWNoZSk7XHJcbiAgICB2aWV3UHJvY2Vzc29yQXNzZXJ0SW5kZXhlZCh2aWV3LnByb2Nlc3Nvcl8sIHJlc3VsdC52aWV3Q2FjaGUpO1xyXG4gICAgYXNzZXJ0KHJlc3VsdC52aWV3Q2FjaGUuc2VydmVyQ2FjaGUuaXNGdWxseUluaXRpYWxpemVkKCkgfHxcclxuICAgICAgICAhb2xkVmlld0NhY2hlLnNlcnZlckNhY2hlLmlzRnVsbHlJbml0aWFsaXplZCgpLCAnT25jZSBhIHNlcnZlciBzbmFwIGlzIGNvbXBsZXRlLCBpdCBzaG91bGQgbmV2ZXIgZ28gYmFjaycpO1xyXG4gICAgdmlldy52aWV3Q2FjaGVfID0gcmVzdWx0LnZpZXdDYWNoZTtcclxuICAgIHJldHVybiB2aWV3R2VuZXJhdGVFdmVudHNGb3JDaGFuZ2VzXyh2aWV3LCByZXN1bHQuY2hhbmdlcywgcmVzdWx0LnZpZXdDYWNoZS5ldmVudENhY2hlLmdldE5vZGUoKSwgbnVsbCk7XHJcbn1cclxuZnVuY3Rpb24gdmlld0dldEluaXRpYWxFdmVudHModmlldywgcmVnaXN0cmF0aW9uKSB7XHJcbiAgICBjb25zdCBldmVudFNuYXAgPSB2aWV3LnZpZXdDYWNoZV8uZXZlbnRDYWNoZTtcclxuICAgIGNvbnN0IGluaXRpYWxDaGFuZ2VzID0gW107XHJcbiAgICBpZiAoIWV2ZW50U25hcC5nZXROb2RlKCkuaXNMZWFmTm9kZSgpKSB7XHJcbiAgICAgICAgY29uc3QgZXZlbnROb2RlID0gZXZlbnRTbmFwLmdldE5vZGUoKTtcclxuICAgICAgICBldmVudE5vZGUuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCAoa2V5LCBjaGlsZE5vZGUpID0+IHtcclxuICAgICAgICAgICAgaW5pdGlhbENoYW5nZXMucHVzaChjaGFuZ2VDaGlsZEFkZGVkKGtleSwgY2hpbGROb2RlKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAoZXZlbnRTbmFwLmlzRnVsbHlJbml0aWFsaXplZCgpKSB7XHJcbiAgICAgICAgaW5pdGlhbENoYW5nZXMucHVzaChjaGFuZ2VWYWx1ZShldmVudFNuYXAuZ2V0Tm9kZSgpKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmlld0dlbmVyYXRlRXZlbnRzRm9yQ2hhbmdlc18odmlldywgaW5pdGlhbENoYW5nZXMsIGV2ZW50U25hcC5nZXROb2RlKCksIHJlZ2lzdHJhdGlvbik7XHJcbn1cclxuZnVuY3Rpb24gdmlld0dlbmVyYXRlRXZlbnRzRm9yQ2hhbmdlc18odmlldywgY2hhbmdlcywgZXZlbnRDYWNoZSwgZXZlbnRSZWdpc3RyYXRpb24pIHtcclxuICAgIGNvbnN0IHJlZ2lzdHJhdGlvbnMgPSBldmVudFJlZ2lzdHJhdGlvblxyXG4gICAgICAgID8gW2V2ZW50UmVnaXN0cmF0aW9uXVxyXG4gICAgICAgIDogdmlldy5ldmVudFJlZ2lzdHJhdGlvbnNfO1xyXG4gICAgcmV0dXJuIGV2ZW50R2VuZXJhdG9yR2VuZXJhdGVFdmVudHNGb3JDaGFuZ2VzKHZpZXcuZXZlbnRHZW5lcmF0b3JfLCBjaGFuZ2VzLCBldmVudENhY2hlLCByZWdpc3RyYXRpb25zKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5sZXQgcmVmZXJlbmNlQ29uc3RydWN0b3IkMTtcclxuLyoqXHJcbiAqIFN5bmNQb2ludCByZXByZXNlbnRzIGEgc2luZ2xlIGxvY2F0aW9uIGluIGEgU3luY1RyZWUgd2l0aCAxIG9yIG1vcmUgZXZlbnQgcmVnaXN0cmF0aW9ucywgbWVhbmluZyB3ZSBuZWVkIHRvXHJcbiAqIG1haW50YWluIDEgb3IgbW9yZSBWaWV3cyBhdCB0aGlzIGxvY2F0aW9uIHRvIGNhY2hlIHNlcnZlciBkYXRhIGFuZCByYWlzZSBhcHByb3ByaWF0ZSBldmVudHMgZm9yIHNlcnZlciBjaGFuZ2VzXHJcbiAqIGFuZCB1c2VyIHdyaXRlcyAoc2V0LCB0cmFuc2FjdGlvbiwgdXBkYXRlKS5cclxuICpcclxuICogSXQncyByZXNwb25zaWJsZSBmb3I6XHJcbiAqICAtIE1haW50YWluaW5nIHRoZSBzZXQgb2YgMSBvciBtb3JlIHZpZXdzIG5lY2Vzc2FyeSBhdCB0aGlzIGxvY2F0aW9uIChhIFN5bmNQb2ludCB3aXRoIDAgdmlld3Mgc2hvdWxkIGJlIHJlbW92ZWQpLlxyXG4gKiAgLSBQcm94eWluZyB1c2VyIC8gc2VydmVyIG9wZXJhdGlvbnMgdG8gdGhlIHZpZXdzIGFzIGFwcHJvcHJpYXRlIChpLmUuIGFwcGx5U2VydmVyT3ZlcndyaXRlLFxyXG4gKiAgICBhcHBseVVzZXJPdmVyd3JpdGUsIGV0Yy4pXHJcbiAqL1xyXG5jbGFzcyBTeW5jUG9pbnQge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIFZpZXdzIGJlaW5nIHRyYWNrZWQgYXQgdGhpcyBsb2NhdGlvbiBpbiB0aGUgdHJlZSwgc3RvcmVkIGFzIGEgbWFwIHdoZXJlIHRoZSBrZXkgaXMgYVxyXG4gICAgICAgICAqIHF1ZXJ5SWQgYW5kIHRoZSB2YWx1ZSBpcyB0aGUgVmlldyBmb3IgdGhhdCBxdWVyeS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIE5PVEU6IFRoaXMgbGlzdCB3aWxsIGJlIHF1aXRlIHNtYWxsICh1c3VhbGx5IDEsIGJ1dCBwZXJoYXBzIDIgb3IgMzsgYW55IG1vcmUgaXMgYW4gb2RkIHVzZSBjYXNlKS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnZpZXdzID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHN5bmNQb2ludFNldFJlZmVyZW5jZUNvbnN0cnVjdG9yKHZhbCkge1xyXG4gICAgYXNzZXJ0KCFyZWZlcmVuY2VDb25zdHJ1Y3RvciQxLCAnX19yZWZlcmVuY2VDb25zdHJ1Y3RvciBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQnKTtcclxuICAgIHJlZmVyZW5jZUNvbnN0cnVjdG9yJDEgPSB2YWw7XHJcbn1cclxuZnVuY3Rpb24gc3luY1BvaW50R2V0UmVmZXJlbmNlQ29uc3RydWN0b3IoKSB7XHJcbiAgICBhc3NlcnQocmVmZXJlbmNlQ29uc3RydWN0b3IkMSwgJ1JlZmVyZW5jZS50cyBoYXMgbm90IGJlZW4gbG9hZGVkJyk7XHJcbiAgICByZXR1cm4gcmVmZXJlbmNlQ29uc3RydWN0b3IkMTtcclxufVxyXG5mdW5jdGlvbiBzeW5jUG9pbnRJc0VtcHR5KHN5bmNQb2ludCkge1xyXG4gICAgcmV0dXJuIHN5bmNQb2ludC52aWV3cy5zaXplID09PSAwO1xyXG59XHJcbmZ1bmN0aW9uIHN5bmNQb2ludEFwcGx5T3BlcmF0aW9uKHN5bmNQb2ludCwgb3BlcmF0aW9uLCB3cml0ZXNDYWNoZSwgb3B0Q29tcGxldGVTZXJ2ZXJDYWNoZSkge1xyXG4gICAgY29uc3QgcXVlcnlJZCA9IG9wZXJhdGlvbi5zb3VyY2UucXVlcnlJZDtcclxuICAgIGlmIChxdWVyeUlkICE9PSBudWxsKSB7XHJcbiAgICAgICAgY29uc3QgdmlldyA9IHN5bmNQb2ludC52aWV3cy5nZXQocXVlcnlJZCk7XHJcbiAgICAgICAgYXNzZXJ0KHZpZXcgIT0gbnVsbCwgJ1N5bmNUcmVlIGdhdmUgdXMgYW4gb3AgZm9yIGFuIGludmFsaWQgcXVlcnkuJyk7XHJcbiAgICAgICAgcmV0dXJuIHZpZXdBcHBseU9wZXJhdGlvbih2aWV3LCBvcGVyYXRpb24sIHdyaXRlc0NhY2hlLCBvcHRDb21wbGV0ZVNlcnZlckNhY2hlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxldCBldmVudHMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IHZpZXcgb2Ygc3luY1BvaW50LnZpZXdzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQodmlld0FwcGx5T3BlcmF0aW9uKHZpZXcsIG9wZXJhdGlvbiwgd3JpdGVzQ2FjaGUsIG9wdENvbXBsZXRlU2VydmVyQ2FjaGUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50cztcclxuICAgIH1cclxufVxyXG4vKipcclxuICogR2V0IGEgdmlldyBmb3IgdGhlIHNwZWNpZmllZCBxdWVyeS5cclxuICpcclxuICogQHBhcmFtIHF1ZXJ5IC0gVGhlIHF1ZXJ5IHRvIHJldHVybiBhIHZpZXcgZm9yXHJcbiAqIEBwYXJhbSB3cml0ZXNDYWNoZVxyXG4gKiBAcGFyYW0gc2VydmVyQ2FjaGVcclxuICogQHBhcmFtIHNlcnZlckNhY2hlQ29tcGxldGVcclxuICogQHJldHVybnMgRXZlbnRzIHRvIHJhaXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1BvaW50R2V0VmlldyhzeW5jUG9pbnQsIHF1ZXJ5LCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGUsIHNlcnZlckNhY2hlQ29tcGxldGUpIHtcclxuICAgIGNvbnN0IHF1ZXJ5SWQgPSBxdWVyeS5fcXVlcnlJZGVudGlmaWVyO1xyXG4gICAgY29uc3QgdmlldyA9IHN5bmNQb2ludC52aWV3cy5nZXQocXVlcnlJZCk7XHJcbiAgICBpZiAoIXZpZXcpIHtcclxuICAgICAgICAvLyBUT0RPOiBtYWtlIHdyaXRlc0NhY2hlIHRha2UgZmxhZyBmb3IgY29tcGxldGUgc2VydmVyIG5vZGVcclxuICAgICAgICBsZXQgZXZlbnRDYWNoZSA9IHdyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUod3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlQ29tcGxldGUgPyBzZXJ2ZXJDYWNoZSA6IG51bGwpO1xyXG4gICAgICAgIGxldCBldmVudENhY2hlQ29tcGxldGUgPSBmYWxzZTtcclxuICAgICAgICBpZiAoZXZlbnRDYWNoZSkge1xyXG4gICAgICAgICAgICBldmVudENhY2hlQ29tcGxldGUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzZXJ2ZXJDYWNoZSBpbnN0YW5jZW9mIENoaWxkcmVuTm9kZSkge1xyXG4gICAgICAgICAgICBldmVudENhY2hlID0gd3JpdGVUcmVlUmVmQ2FsY0NvbXBsZXRlRXZlbnRDaGlsZHJlbih3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGUpO1xyXG4gICAgICAgICAgICBldmVudENhY2hlQ29tcGxldGUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGV2ZW50Q2FjaGUgPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgICAgICAgICAgZXZlbnRDYWNoZUNvbXBsZXRlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHZpZXdDYWNoZSA9IG5ld1ZpZXdDYWNoZShuZXcgQ2FjaGVOb2RlKGV2ZW50Q2FjaGUsIGV2ZW50Q2FjaGVDb21wbGV0ZSwgZmFsc2UpLCBuZXcgQ2FjaGVOb2RlKHNlcnZlckNhY2hlLCBzZXJ2ZXJDYWNoZUNvbXBsZXRlLCBmYWxzZSkpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVmlldyhxdWVyeSwgdmlld0NhY2hlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2aWV3O1xyXG59XHJcbi8qKlxyXG4gKiBBZGQgYW4gZXZlbnQgY2FsbGJhY2sgZm9yIHRoZSBzcGVjaWZpZWQgcXVlcnkuXHJcbiAqXHJcbiAqIEBwYXJhbSBxdWVyeVxyXG4gKiBAcGFyYW0gZXZlbnRSZWdpc3RyYXRpb25cclxuICogQHBhcmFtIHdyaXRlc0NhY2hlXHJcbiAqIEBwYXJhbSBzZXJ2ZXJDYWNoZSAtIENvbXBsZXRlIHNlcnZlciBjYWNoZSwgaWYgd2UgaGF2ZSBpdC5cclxuICogQHBhcmFtIHNlcnZlckNhY2hlQ29tcGxldGVcclxuICogQHJldHVybnMgRXZlbnRzIHRvIHJhaXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1BvaW50QWRkRXZlbnRSZWdpc3RyYXRpb24oc3luY1BvaW50LCBxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24sIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSwgc2VydmVyQ2FjaGVDb21wbGV0ZSkge1xyXG4gICAgY29uc3QgdmlldyA9IHN5bmNQb2ludEdldFZpZXcoc3luY1BvaW50LCBxdWVyeSwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlLCBzZXJ2ZXJDYWNoZUNvbXBsZXRlKTtcclxuICAgIGlmICghc3luY1BvaW50LnZpZXdzLmhhcyhxdWVyeS5fcXVlcnlJZGVudGlmaWVyKSkge1xyXG4gICAgICAgIHN5bmNQb2ludC52aWV3cy5zZXQocXVlcnkuX3F1ZXJ5SWRlbnRpZmllciwgdmlldyk7XHJcbiAgICB9XHJcbiAgICAvLyBUaGlzIGlzIGd1YXJhbnRlZWQgdG8gZXhpc3Qgbm93LCB3ZSBqdXN0IGNyZWF0ZWQgYW55dGhpbmcgdGhhdCB3YXMgbWlzc2luZ1xyXG4gICAgdmlld0FkZEV2ZW50UmVnaXN0cmF0aW9uKHZpZXcsIGV2ZW50UmVnaXN0cmF0aW9uKTtcclxuICAgIHJldHVybiB2aWV3R2V0SW5pdGlhbEV2ZW50cyh2aWV3LCBldmVudFJlZ2lzdHJhdGlvbik7XHJcbn1cclxuLyoqXHJcbiAqIFJlbW92ZSBldmVudCBjYWxsYmFjayhzKS4gIFJldHVybiBjYW5jZWxFdmVudHMgaWYgYSBjYW5jZWxFcnJvciBpcyBzcGVjaWZpZWQuXHJcbiAqXHJcbiAqIElmIHF1ZXJ5IGlzIHRoZSBkZWZhdWx0IHF1ZXJ5LCB3ZSdsbCBjaGVjayBhbGwgdmlld3MgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnRSZWdpc3RyYXRpb24uXHJcbiAqIElmIGV2ZW50UmVnaXN0cmF0aW9uIGlzIG51bGwsIHdlJ2xsIHJlbW92ZSBhbGwgY2FsbGJhY2tzIGZvciB0aGUgc3BlY2lmaWVkIHZpZXcocykuXHJcbiAqXHJcbiAqIEBwYXJhbSBldmVudFJlZ2lzdHJhdGlvbiAtIElmIG51bGwsIHJlbW92ZSBhbGwgY2FsbGJhY2tzLlxyXG4gKiBAcGFyYW0gY2FuY2VsRXJyb3IgLSBJZiBhIGNhbmNlbEVycm9yIGlzIHByb3ZpZGVkLCBhcHByb3ByaWF0ZSBjYW5jZWwgZXZlbnRzIHdpbGwgYmUgcmV0dXJuZWQuXHJcbiAqIEByZXR1cm5zIHJlbW92ZWQgcXVlcmllcyBhbmQgYW55IGNhbmNlbCBldmVudHNcclxuICovXHJcbmZ1bmN0aW9uIHN5bmNQb2ludFJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKHN5bmNQb2ludCwgcXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uLCBjYW5jZWxFcnJvcikge1xyXG4gICAgY29uc3QgcXVlcnlJZCA9IHF1ZXJ5Ll9xdWVyeUlkZW50aWZpZXI7XHJcbiAgICBjb25zdCByZW1vdmVkID0gW107XHJcbiAgICBsZXQgY2FuY2VsRXZlbnRzID0gW107XHJcbiAgICBjb25zdCBoYWRDb21wbGV0ZVZpZXcgPSBzeW5jUG9pbnRIYXNDb21wbGV0ZVZpZXcoc3luY1BvaW50KTtcclxuICAgIGlmIChxdWVyeUlkID09PSAnZGVmYXVsdCcpIHtcclxuICAgICAgICAvLyBXaGVuIHlvdSBkbyByZWYub2ZmKC4uLiksIHdlIHNlYXJjaCBhbGwgdmlld3MgZm9yIHRoZSByZWdpc3RyYXRpb24gdG8gcmVtb3ZlLlxyXG4gICAgICAgIGZvciAoY29uc3QgW3ZpZXdRdWVyeUlkLCB2aWV3XSBvZiBzeW5jUG9pbnQudmlld3MuZW50cmllcygpKSB7XHJcbiAgICAgICAgICAgIGNhbmNlbEV2ZW50cyA9IGNhbmNlbEV2ZW50cy5jb25jYXQodmlld1JlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKHZpZXcsIGV2ZW50UmVnaXN0cmF0aW9uLCBjYW5jZWxFcnJvcikpO1xyXG4gICAgICAgICAgICBpZiAodmlld0lzRW1wdHkodmlldykpIHtcclxuICAgICAgICAgICAgICAgIHN5bmNQb2ludC52aWV3cy5kZWxldGUodmlld1F1ZXJ5SWQpO1xyXG4gICAgICAgICAgICAgICAgLy8gV2UnbGwgZGVhbCB3aXRoIGNvbXBsZXRlIHZpZXdzIGxhdGVyLlxyXG4gICAgICAgICAgICAgICAgaWYgKCF2aWV3LnF1ZXJ5Ll9xdWVyeVBhcmFtcy5sb2Fkc0FsbERhdGEoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWQucHVzaCh2aWV3LnF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgY2FsbGJhY2sgZnJvbSB0aGUgc3BlY2lmaWMgdmlldy5cclxuICAgICAgICBjb25zdCB2aWV3ID0gc3luY1BvaW50LnZpZXdzLmdldChxdWVyeUlkKTtcclxuICAgICAgICBpZiAodmlldykge1xyXG4gICAgICAgICAgICBjYW5jZWxFdmVudHMgPSBjYW5jZWxFdmVudHMuY29uY2F0KHZpZXdSZW1vdmVFdmVudFJlZ2lzdHJhdGlvbih2aWV3LCBldmVudFJlZ2lzdHJhdGlvbiwgY2FuY2VsRXJyb3IpKTtcclxuICAgICAgICAgICAgaWYgKHZpZXdJc0VtcHR5KHZpZXcpKSB7XHJcbiAgICAgICAgICAgICAgICBzeW5jUG9pbnQudmlld3MuZGVsZXRlKHF1ZXJ5SWQpO1xyXG4gICAgICAgICAgICAgICAgLy8gV2UnbGwgZGVhbCB3aXRoIGNvbXBsZXRlIHZpZXdzIGxhdGVyLlxyXG4gICAgICAgICAgICAgICAgaWYgKCF2aWV3LnF1ZXJ5Ll9xdWVyeVBhcmFtcy5sb2Fkc0FsbERhdGEoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWQucHVzaCh2aWV3LnF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChoYWRDb21wbGV0ZVZpZXcgJiYgIXN5bmNQb2ludEhhc0NvbXBsZXRlVmlldyhzeW5jUG9pbnQpKSB7XHJcbiAgICAgICAgLy8gV2UgcmVtb3ZlZCBvdXIgbGFzdCBjb21wbGV0ZSB2aWV3LlxyXG4gICAgICAgIHJlbW92ZWQucHVzaChuZXcgKHN5bmNQb2ludEdldFJlZmVyZW5jZUNvbnN0cnVjdG9yKCkpKHF1ZXJ5Ll9yZXBvLCBxdWVyeS5fcGF0aCkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgcmVtb3ZlZCwgZXZlbnRzOiBjYW5jZWxFdmVudHMgfTtcclxufVxyXG5mdW5jdGlvbiBzeW5jUG9pbnRHZXRRdWVyeVZpZXdzKHN5bmNQb2ludCkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICBmb3IgKGNvbnN0IHZpZXcgb2Ygc3luY1BvaW50LnZpZXdzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgaWYgKCF2aWV3LnF1ZXJ5Ll9xdWVyeVBhcmFtcy5sb2Fkc0FsbERhdGEoKSkge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaCh2aWV3KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHRvIHRoZSBkZXNpcmVkIGNvbXBsZXRlIHNuYXBzaG90XHJcbiAqIEByZXR1cm5zIEEgY29tcGxldGUgY2FjaGUsIGlmIGl0IGV4aXN0c1xyXG4gKi9cclxuZnVuY3Rpb24gc3luY1BvaW50R2V0Q29tcGxldGVTZXJ2ZXJDYWNoZShzeW5jUG9pbnQsIHBhdGgpIHtcclxuICAgIGxldCBzZXJ2ZXJDYWNoZSA9IG51bGw7XHJcbiAgICBmb3IgKGNvbnN0IHZpZXcgb2Ygc3luY1BvaW50LnZpZXdzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgc2VydmVyQ2FjaGUgPSBzZXJ2ZXJDYWNoZSB8fCB2aWV3R2V0Q29tcGxldGVTZXJ2ZXJDYWNoZSh2aWV3LCBwYXRoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzZXJ2ZXJDYWNoZTtcclxufVxyXG5mdW5jdGlvbiBzeW5jUG9pbnRWaWV3Rm9yUXVlcnkoc3luY1BvaW50LCBxdWVyeSkge1xyXG4gICAgY29uc3QgcGFyYW1zID0gcXVlcnkuX3F1ZXJ5UGFyYW1zO1xyXG4gICAgaWYgKHBhcmFtcy5sb2Fkc0FsbERhdGEoKSkge1xyXG4gICAgICAgIHJldHVybiBzeW5jUG9pbnRHZXRDb21wbGV0ZVZpZXcoc3luY1BvaW50KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5SWQgPSBxdWVyeS5fcXVlcnlJZGVudGlmaWVyO1xyXG4gICAgICAgIHJldHVybiBzeW5jUG9pbnQudmlld3MuZ2V0KHF1ZXJ5SWQpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHN5bmNQb2ludFZpZXdFeGlzdHNGb3JRdWVyeShzeW5jUG9pbnQsIHF1ZXJ5KSB7XHJcbiAgICByZXR1cm4gc3luY1BvaW50Vmlld0ZvclF1ZXJ5KHN5bmNQb2ludCwgcXVlcnkpICE9IG51bGw7XHJcbn1cclxuZnVuY3Rpb24gc3luY1BvaW50SGFzQ29tcGxldGVWaWV3KHN5bmNQb2ludCkge1xyXG4gICAgcmV0dXJuIHN5bmNQb2ludEdldENvbXBsZXRlVmlldyhzeW5jUG9pbnQpICE9IG51bGw7XHJcbn1cclxuZnVuY3Rpb24gc3luY1BvaW50R2V0Q29tcGxldGVWaWV3KHN5bmNQb2ludCkge1xyXG4gICAgZm9yIChjb25zdCB2aWV3IG9mIHN5bmNQb2ludC52aWV3cy52YWx1ZXMoKSkge1xyXG4gICAgICAgIGlmICh2aWV3LnF1ZXJ5Ll9xdWVyeVBhcmFtcy5sb2Fkc0FsbERhdGEoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdmlldztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5sZXQgcmVmZXJlbmNlQ29uc3RydWN0b3I7XHJcbmZ1bmN0aW9uIHN5bmNUcmVlU2V0UmVmZXJlbmNlQ29uc3RydWN0b3IodmFsKSB7XHJcbiAgICBhc3NlcnQoIXJlZmVyZW5jZUNvbnN0cnVjdG9yLCAnX19yZWZlcmVuY2VDb25zdHJ1Y3RvciBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQnKTtcclxuICAgIHJlZmVyZW5jZUNvbnN0cnVjdG9yID0gdmFsO1xyXG59XHJcbmZ1bmN0aW9uIHN5bmNUcmVlR2V0UmVmZXJlbmNlQ29uc3RydWN0b3IoKSB7XHJcbiAgICBhc3NlcnQocmVmZXJlbmNlQ29uc3RydWN0b3IsICdSZWZlcmVuY2UudHMgaGFzIG5vdCBiZWVuIGxvYWRlZCcpO1xyXG4gICAgcmV0dXJuIHJlZmVyZW5jZUNvbnN0cnVjdG9yO1xyXG59XHJcbi8qKlxyXG4gKiBTdGF0aWMgdHJhY2tlciBmb3IgbmV4dCBxdWVyeSB0YWcuXHJcbiAqL1xyXG5sZXQgc3luY1RyZWVOZXh0UXVlcnlUYWdfID0gMTtcclxuLyoqXHJcbiAqIFN5bmNUcmVlIGlzIHRoZSBjZW50cmFsIGNsYXNzIGZvciBtYW5hZ2luZyBldmVudCBjYWxsYmFjayByZWdpc3RyYXRpb24sIGRhdGEgY2FjaGluZywgdmlld3NcclxuICogKHF1ZXJ5IHByb2Nlc3NpbmcpLCBhbmQgZXZlbnQgZ2VuZXJhdGlvbi4gIFRoZXJlIGFyZSB0eXBpY2FsbHkgdHdvIFN5bmNUcmVlIGluc3RhbmNlcyBmb3JcclxuICogZWFjaCBSZXBvLCBvbmUgZm9yIHRoZSBub3JtYWwgRmlyZWJhc2UgZGF0YSwgYW5kIG9uZSBmb3IgdGhlIC5pbmZvIGRhdGEuXHJcbiAqXHJcbiAqIEl0IGhhcyBhIG51bWJlciBvZiByZXNwb25zaWJpbGl0aWVzLCBpbmNsdWRpbmc6XHJcbiAqICAtIFRyYWNraW5nIGFsbCB1c2VyIGV2ZW50IGNhbGxiYWNrcyAocmVnaXN0ZXJlZCB2aWEgYWRkRXZlbnRSZWdpc3RyYXRpb24oKSBhbmQgcmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24oKSkuXHJcbiAqICAtIEFwcGx5aW5nIGFuZCBjYWNoaW5nIGRhdGEgY2hhbmdlcyBmb3IgdXNlciBzZXQoKSwgdHJhbnNhY3Rpb24oKSwgYW5kIHVwZGF0ZSgpIGNhbGxzXHJcbiAqICAgIChhcHBseVVzZXJPdmVyd3JpdGUoKSwgYXBwbHlVc2VyTWVyZ2UoKSkuXHJcbiAqICAtIEFwcGx5aW5nIGFuZCBjYWNoaW5nIGRhdGEgY2hhbmdlcyBmb3Igc2VydmVyIGRhdGEgY2hhbmdlcyAoYXBwbHlTZXJ2ZXJPdmVyd3JpdGUoKSxcclxuICogICAgYXBwbHlTZXJ2ZXJNZXJnZSgpKS5cclxuICogIC0gR2VuZXJhdGluZyB1c2VyLWZhY2luZyBldmVudHMgZm9yIHNlcnZlciBhbmQgdXNlciBjaGFuZ2VzIChhbGwgb2YgdGhlIGFwcGx5KiBtZXRob2RzXHJcbiAqICAgIHJldHVybiB0aGUgc2V0IG9mIGV2ZW50cyB0aGF0IG5lZWQgdG8gYmUgcmFpc2VkIGFzIGEgcmVzdWx0KS5cclxuICogIC0gTWFpbnRhaW5pbmcgdGhlIGFwcHJvcHJpYXRlIHNldCBvZiBzZXJ2ZXIgbGlzdGVucyB0byBlbnN1cmUgd2UgYXJlIGFsd2F5cyBzdWJzY3JpYmVkXHJcbiAqICAgIHRvIHRoZSBjb3JyZWN0IHNldCBvZiBwYXRocyBhbmQgcXVlcmllcyB0byBzYXRpc2Z5IHRoZSBjdXJyZW50IHNldCBvZiB1c2VyIGV2ZW50XHJcbiAqICAgIGNhbGxiYWNrcyAobGlzdGVucyBhcmUgc3RhcnRlZC9zdG9wcGVkIHVzaW5nIHRoZSBwcm92aWRlZCBsaXN0ZW5Qcm92aWRlcikuXHJcbiAqXHJcbiAqIE5PVEU6IEFsdGhvdWdoIFN5bmNUcmVlIHRyYWNrcyBldmVudCBjYWxsYmFja3MgYW5kIGNhbGN1bGF0ZXMgZXZlbnRzIHRvIHJhaXNlLCB0aGUgYWN0dWFsXHJcbiAqIGV2ZW50cyBhcmUgcmV0dXJuZWQgdG8gdGhlIGNhbGxlciByYXRoZXIgdGhhbiByYWlzZWQgc3luY2hyb25vdXNseS5cclxuICpcclxuICovXHJcbmNsYXNzIFN5bmNUcmVlIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGxpc3RlblByb3ZpZGVyXyAtIFVzZWQgYnkgU3luY1RyZWUgdG8gc3RhcnQgLyBzdG9wIGxpc3RlbmluZ1xyXG4gICAgICogICB0byBzZXJ2ZXIgZGF0YS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobGlzdGVuUHJvdmlkZXJfKSB7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5Qcm92aWRlcl8gPSBsaXN0ZW5Qcm92aWRlcl87XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVHJlZSBvZiBTeW5jUG9pbnRzLiAgVGhlcmUncyBhIFN5bmNQb2ludCBhdCBhbnkgbG9jYXRpb24gdGhhdCBoYXMgMSBvciBtb3JlIHZpZXdzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc3luY1BvaW50VHJlZV8gPSBuZXcgSW1tdXRhYmxlVHJlZShudWxsKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIHRyZWUgb2YgYWxsIHBlbmRpbmcgdXNlciB3cml0ZXMgKHVzZXItaW5pdGlhdGVkIHNldCgpJ3MsIHRyYW5zYWN0aW9uKCkncywgdXBkYXRlKCkncywgZXRjLikuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wZW5kaW5nV3JpdGVUcmVlXyA9IG5ld1dyaXRlVHJlZSgpO1xyXG4gICAgICAgIHRoaXMudGFnVG9RdWVyeU1hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLnF1ZXJ5VG9UYWdNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFwcGx5IHRoZSBkYXRhIGNoYW5nZXMgZm9yIGEgdXNlci1nZW5lcmF0ZWQgc2V0KCkgb3IgdHJhbnNhY3Rpb24oKSBjYWxsLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBFdmVudHMgdG8gcmFpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZUFwcGx5VXNlck92ZXJ3cml0ZShzeW5jVHJlZSwgcGF0aCwgbmV3RGF0YSwgd3JpdGVJZCwgdmlzaWJsZSkge1xyXG4gICAgLy8gUmVjb3JkIHBlbmRpbmcgd3JpdGUuXHJcbiAgICB3cml0ZVRyZWVBZGRPdmVyd3JpdGUoc3luY1RyZWUucGVuZGluZ1dyaXRlVHJlZV8sIHBhdGgsIG5ld0RhdGEsIHdyaXRlSWQsIHZpc2libGUpO1xyXG4gICAgaWYgKCF2aXNpYmxlKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHN5bmNUcmVlQXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfKHN5bmNUcmVlLCBuZXcgT3ZlcndyaXRlKG5ld09wZXJhdGlvblNvdXJjZVVzZXIoKSwgcGF0aCwgbmV3RGF0YSkpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBcHBseSB0aGUgZGF0YSBmcm9tIGEgdXNlci1nZW5lcmF0ZWQgdXBkYXRlKCkgY2FsbFxyXG4gKlxyXG4gKiBAcmV0dXJucyBFdmVudHMgdG8gcmFpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZUFwcGx5VXNlck1lcmdlKHN5bmNUcmVlLCBwYXRoLCBjaGFuZ2VkQ2hpbGRyZW4sIHdyaXRlSWQpIHtcclxuICAgIC8vIFJlY29yZCBwZW5kaW5nIG1lcmdlLlxyXG4gICAgd3JpdGVUcmVlQWRkTWVyZ2Uoc3luY1RyZWUucGVuZGluZ1dyaXRlVHJlZV8sIHBhdGgsIGNoYW5nZWRDaGlsZHJlbiwgd3JpdGVJZCk7XHJcbiAgICBjb25zdCBjaGFuZ2VUcmVlID0gSW1tdXRhYmxlVHJlZS5mcm9tT2JqZWN0KGNoYW5nZWRDaGlsZHJlbik7XHJcbiAgICByZXR1cm4gc3luY1RyZWVBcHBseU9wZXJhdGlvblRvU3luY1BvaW50c18oc3luY1RyZWUsIG5ldyBNZXJnZShuZXdPcGVyYXRpb25Tb3VyY2VVc2VyKCksIHBhdGgsIGNoYW5nZVRyZWUpKTtcclxufVxyXG4vKipcclxuICogQWNrbm93bGVkZ2UgYSBwZW5kaW5nIHVzZXIgd3JpdGUgdGhhdCB3YXMgcHJldmlvdXNseSByZWdpc3RlcmVkIHdpdGggYXBwbHlVc2VyT3ZlcndyaXRlKCkgb3IgYXBwbHlVc2VyTWVyZ2UoKS5cclxuICpcclxuICogQHBhcmFtIHJldmVydCAtIFRydWUgaWYgdGhlIGdpdmVuIHdyaXRlIGZhaWxlZCBhbmQgbmVlZHMgdG8gYmUgcmV2ZXJ0ZWRcclxuICogQHJldHVybnMgRXZlbnRzIHRvIHJhaXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVBY2tVc2VyV3JpdGUoc3luY1RyZWUsIHdyaXRlSWQsIHJldmVydCA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCB3cml0ZSA9IHdyaXRlVHJlZUdldFdyaXRlKHN5bmNUcmVlLnBlbmRpbmdXcml0ZVRyZWVfLCB3cml0ZUlkKTtcclxuICAgIGNvbnN0IG5lZWRUb1JlZXZhbHVhdGUgPSB3cml0ZVRyZWVSZW1vdmVXcml0ZShzeW5jVHJlZS5wZW5kaW5nV3JpdGVUcmVlXywgd3JpdGVJZCk7XHJcbiAgICBpZiAoIW5lZWRUb1JlZXZhbHVhdGUpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsZXQgYWZmZWN0ZWRUcmVlID0gbmV3IEltbXV0YWJsZVRyZWUobnVsbCk7XHJcbiAgICAgICAgaWYgKHdyaXRlLnNuYXAgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBvdmVyd3JpdGVcclxuICAgICAgICAgICAgYWZmZWN0ZWRUcmVlID0gYWZmZWN0ZWRUcmVlLnNldChuZXdFbXB0eVBhdGgoKSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlYWNoKHdyaXRlLmNoaWxkcmVuLCAocGF0aFN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgYWZmZWN0ZWRUcmVlID0gYWZmZWN0ZWRUcmVlLnNldChuZXcgUGF0aChwYXRoU3RyaW5nKSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3luY1RyZWVBcHBseU9wZXJhdGlvblRvU3luY1BvaW50c18oc3luY1RyZWUsIG5ldyBBY2tVc2VyV3JpdGUod3JpdGUucGF0aCwgYWZmZWN0ZWRUcmVlLCByZXZlcnQpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQXBwbHkgbmV3IHNlcnZlciBkYXRhIGZvciB0aGUgc3BlY2lmaWVkIHBhdGguLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBFdmVudHMgdG8gcmFpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZUFwcGx5U2VydmVyT3ZlcndyaXRlKHN5bmNUcmVlLCBwYXRoLCBuZXdEYXRhKSB7XHJcbiAgICByZXR1cm4gc3luY1RyZWVBcHBseU9wZXJhdGlvblRvU3luY1BvaW50c18oc3luY1RyZWUsIG5ldyBPdmVyd3JpdGUobmV3T3BlcmF0aW9uU291cmNlU2VydmVyKCksIHBhdGgsIG5ld0RhdGEpKTtcclxufVxyXG4vKipcclxuICogQXBwbHkgbmV3IHNlcnZlciBkYXRhIHRvIGJlIG1lcmdlZCBpbiBhdCB0aGUgc3BlY2lmaWVkIHBhdGguXHJcbiAqXHJcbiAqIEByZXR1cm5zIEV2ZW50cyB0byByYWlzZS5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQXBwbHlTZXJ2ZXJNZXJnZShzeW5jVHJlZSwgcGF0aCwgY2hhbmdlZENoaWxkcmVuKSB7XHJcbiAgICBjb25zdCBjaGFuZ2VUcmVlID0gSW1tdXRhYmxlVHJlZS5mcm9tT2JqZWN0KGNoYW5nZWRDaGlsZHJlbik7XHJcbiAgICByZXR1cm4gc3luY1RyZWVBcHBseU9wZXJhdGlvblRvU3luY1BvaW50c18oc3luY1RyZWUsIG5ldyBNZXJnZShuZXdPcGVyYXRpb25Tb3VyY2VTZXJ2ZXIoKSwgcGF0aCwgY2hhbmdlVHJlZSkpO1xyXG59XHJcbi8qKlxyXG4gKiBBcHBseSBhIGxpc3RlbiBjb21wbGV0ZSBmb3IgYSBxdWVyeVxyXG4gKlxyXG4gKiBAcmV0dXJucyBFdmVudHMgdG8gcmFpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZUFwcGx5TGlzdGVuQ29tcGxldGUoc3luY1RyZWUsIHBhdGgpIHtcclxuICAgIHJldHVybiBzeW5jVHJlZUFwcGx5T3BlcmF0aW9uVG9TeW5jUG9pbnRzXyhzeW5jVHJlZSwgbmV3IExpc3RlbkNvbXBsZXRlKG5ld09wZXJhdGlvblNvdXJjZVNlcnZlcigpLCBwYXRoKSk7XHJcbn1cclxuLyoqXHJcbiAqIEFwcGx5IGEgbGlzdGVuIGNvbXBsZXRlIGZvciBhIHRhZ2dlZCBxdWVyeVxyXG4gKlxyXG4gKiBAcmV0dXJucyBFdmVudHMgdG8gcmFpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZUFwcGx5VGFnZ2VkTGlzdGVuQ29tcGxldGUoc3luY1RyZWUsIHBhdGgsIHRhZykge1xyXG4gICAgY29uc3QgcXVlcnlLZXkgPSBzeW5jVHJlZVF1ZXJ5S2V5Rm9yVGFnXyhzeW5jVHJlZSwgdGFnKTtcclxuICAgIGlmIChxdWVyeUtleSkge1xyXG4gICAgICAgIGNvbnN0IHIgPSBzeW5jVHJlZVBhcnNlUXVlcnlLZXlfKHF1ZXJ5S2V5KTtcclxuICAgICAgICBjb25zdCBxdWVyeVBhdGggPSByLnBhdGgsIHF1ZXJ5SWQgPSByLnF1ZXJ5SWQ7XHJcbiAgICAgICAgY29uc3QgcmVsYXRpdmVQYXRoID0gbmV3UmVsYXRpdmVQYXRoKHF1ZXJ5UGF0aCwgcGF0aCk7XHJcbiAgICAgICAgY29uc3Qgb3AgPSBuZXcgTGlzdGVuQ29tcGxldGUobmV3T3BlcmF0aW9uU291cmNlU2VydmVyVGFnZ2VkUXVlcnkocXVlcnlJZCksIHJlbGF0aXZlUGF0aCk7XHJcbiAgICAgICAgcmV0dXJuIHN5bmNUcmVlQXBwbHlUYWdnZWRPcGVyYXRpb25fKHN5bmNUcmVlLCBxdWVyeVBhdGgsIG9wKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIFdlJ3ZlIGFscmVhZHkgcmVtb3ZlZCB0aGUgcXVlcnkuIE5vIGJpZyBkZWFsLCBpZ25vcmUgdGhlIHVwZGF0ZVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmVtb3ZlIGV2ZW50IGNhbGxiYWNrKHMpLlxyXG4gKlxyXG4gKiBJZiBxdWVyeSBpcyB0aGUgZGVmYXVsdCBxdWVyeSwgd2UnbGwgY2hlY2sgYWxsIHF1ZXJpZXMgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnRSZWdpc3RyYXRpb24uXHJcbiAqIElmIGV2ZW50UmVnaXN0cmF0aW9uIGlzIG51bGwsIHdlJ2xsIHJlbW92ZSBhbGwgY2FsbGJhY2tzIGZvciB0aGUgc3BlY2lmaWVkIHF1ZXJ5L3F1ZXJpZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSBldmVudFJlZ2lzdHJhdGlvbiAtIElmIG51bGwsIGFsbCBjYWxsYmFja3MgYXJlIHJlbW92ZWQuXHJcbiAqIEBwYXJhbSBjYW5jZWxFcnJvciAtIElmIGEgY2FuY2VsRXJyb3IgaXMgcHJvdmlkZWQsIGFwcHJvcHJpYXRlIGNhbmNlbCBldmVudHMgd2lsbCBiZSByZXR1cm5lZC5cclxuICogQHBhcmFtIHNraXBMaXN0ZW5lckRlZHVwIC0gV2hlbiBwZXJmb3JtaW5nIGEgYGdldCgpYCwgd2UgZG9uJ3QgYWRkIGFueSBuZXcgbGlzdGVuZXJzLCBzbyBub1xyXG4gKiAgZGVkdXBpbmcgbmVlZHMgdG8gdGFrZSBwbGFjZS4gVGhpcyBmbGFnIGFsbG93cyB0b2dnbGluZyBvZiB0aGF0IGJlaGF2aW9yXHJcbiAqIEByZXR1cm5zIENhbmNlbCBldmVudHMsIGlmIGNhbmNlbEVycm9yIHdhcyBwcm92aWRlZC5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlUmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24oc3luY1RyZWUsIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbiwgY2FuY2VsRXJyb3IsIHNraXBMaXN0ZW5lckRlZHVwID0gZmFsc2UpIHtcclxuICAgIC8vIEZpbmQgdGhlIHN5bmNQb2ludCBmaXJzdC4gVGhlbiBkZWFsIHdpdGggd2hldGhlciBvciBub3QgaXQgaGFzIG1hdGNoaW5nIGxpc3RlbmVyc1xyXG4gICAgY29uc3QgcGF0aCA9IHF1ZXJ5Ll9wYXRoO1xyXG4gICAgY29uc3QgbWF5YmVTeW5jUG9pbnQgPSBzeW5jVHJlZS5zeW5jUG9pbnRUcmVlXy5nZXQocGF0aCk7XHJcbiAgICBsZXQgY2FuY2VsRXZlbnRzID0gW107XHJcbiAgICAvLyBBIHJlbW92YWwgb24gYSBkZWZhdWx0IHF1ZXJ5IGFmZmVjdHMgYWxsIHF1ZXJpZXMgYXQgdGhhdCBsb2NhdGlvbi4gQSByZW1vdmFsIG9uIGFuIGluZGV4ZWQgcXVlcnksIGV2ZW4gb25lIHdpdGhvdXRcclxuICAgIC8vIG90aGVyIHF1ZXJ5IGNvbnN0cmFpbnRzLCBkb2VzICpub3QqIGFmZmVjdCBhbGwgcXVlcmllcyBhdCB0aGF0IGxvY2F0aW9uLiBTbyB0aGlzIGNoZWNrIG11c3QgYmUgZm9yICdkZWZhdWx0JywgYW5kXHJcbiAgICAvLyBub3QgbG9hZHNBbGxEYXRhKCkuXHJcbiAgICBpZiAobWF5YmVTeW5jUG9pbnQgJiZcclxuICAgICAgICAocXVlcnkuX3F1ZXJ5SWRlbnRpZmllciA9PT0gJ2RlZmF1bHQnIHx8XHJcbiAgICAgICAgICAgIHN5bmNQb2ludFZpZXdFeGlzdHNGb3JRdWVyeShtYXliZVN5bmNQb2ludCwgcXVlcnkpKSkge1xyXG4gICAgICAgIGNvbnN0IHJlbW92ZWRBbmRFdmVudHMgPSBzeW5jUG9pbnRSZW1vdmVFdmVudFJlZ2lzdHJhdGlvbihtYXliZVN5bmNQb2ludCwgcXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uLCBjYW5jZWxFcnJvcik7XHJcbiAgICAgICAgaWYgKHN5bmNQb2ludElzRW1wdHkobWF5YmVTeW5jUG9pbnQpKSB7XHJcbiAgICAgICAgICAgIHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfID0gc3luY1RyZWUuc3luY1BvaW50VHJlZV8ucmVtb3ZlKHBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZW1vdmVkID0gcmVtb3ZlZEFuZEV2ZW50cy5yZW1vdmVkO1xyXG4gICAgICAgIGNhbmNlbEV2ZW50cyA9IHJlbW92ZWRBbmRFdmVudHMuZXZlbnRzO1xyXG4gICAgICAgIGlmICghc2tpcExpc3RlbmVyRGVkdXApIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdlIG1heSBoYXZlIGp1c3QgcmVtb3ZlZCBvbmUgb2YgbWFueSBsaXN0ZW5lcnMgYW5kIGNhbiBzaG9ydC1jaXJjdWl0IHRoaXMgd2hvbGUgcHJvY2Vzc1xyXG4gICAgICAgICAgICAgKiBXZSBtYXkgYWxzbyBub3QgaGF2ZSByZW1vdmVkIGEgZGVmYXVsdCBsaXN0ZW5lciwgaW4gd2hpY2ggY2FzZSBhbGwgb2YgdGhlIGRlc2NlbmRhbnQgbGlzdGVuZXJzIHNob3VsZCBhbHJlYWR5IGJlXHJcbiAgICAgICAgICAgICAqIHByb3Blcmx5IHNldCB1cC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIC8vIFNpbmNlIGluZGV4ZWQgcXVlcmllcyBjYW4gc2hhZG93IGlmIHRoZXkgZG9uJ3QgaGF2ZSBvdGhlciBxdWVyeSBjb25zdHJhaW50cywgY2hlY2sgZm9yIGxvYWRzQWxsRGF0YSgpLCBpbnN0ZWFkIG9mXHJcbiAgICAgICAgICAgIC8vIHF1ZXJ5SWQgPT09ICdkZWZhdWx0J1xyXG4gICAgICAgICAgICBjb25zdCByZW1vdmluZ0RlZmF1bHQgPSAtMSAhPT1cclxuICAgICAgICAgICAgICAgIHJlbW92ZWQuZmluZEluZGV4KHF1ZXJ5ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcXVlcnkuX3F1ZXJ5UGFyYW1zLmxvYWRzQWxsRGF0YSgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvdmVyZWQgPSBzeW5jVHJlZS5zeW5jUG9pbnRUcmVlXy5maW5kT25QYXRoKHBhdGgsIChyZWxhdGl2ZVBhdGgsIHBhcmVudFN5bmNQb2ludCkgPT4gc3luY1BvaW50SGFzQ29tcGxldGVWaWV3KHBhcmVudFN5bmNQb2ludCkpO1xyXG4gICAgICAgICAgICBpZiAocmVtb3ZpbmdEZWZhdWx0ICYmICFjb3ZlcmVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJ0cmVlID0gc3luY1RyZWUuc3luY1BvaW50VHJlZV8uc3VidHJlZShwYXRoKTtcclxuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGFyZSBwb3RlbnRpYWxseSBjaGlsZCBsaXN0ZW5lcnMuIERldGVybWluZSB3aGF0IGlmIGFueSBsaXN0ZW5zIHdlIG5lZWQgdG8gc2VuZCBiZWZvcmUgZXhlY3V0aW5nIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZhbFxyXG4gICAgICAgICAgICAgICAgaWYgKCFzdWJ0cmVlLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZm9sZCBvdmVyIG91ciBzdWJ0cmVlIGFuZCBjb2xsZWN0IHRoZSBsaXN0ZW5lcnMgdG8gc2VuZFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1ZpZXdzID0gc3luY1RyZWVDb2xsZWN0RGlzdGluY3RWaWV3c0ZvclN1YlRyZWVfKHN1YnRyZWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE9rLCB3ZSd2ZSBjb2xsZWN0ZWQgYWxsIHRoZSBsaXN0ZW5zIHdlIG5lZWQuIFNldCB0aGVtIHVwLlxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3Vmlld3MubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmlldyA9IG5ld1ZpZXdzW2ldLCBuZXdRdWVyeSA9IHZpZXcucXVlcnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVyID0gc3luY1RyZWVDcmVhdGVMaXN0ZW5lckZvclZpZXdfKHN5bmNUcmVlLCB2aWV3KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3luY1RyZWUubGlzdGVuUHJvdmlkZXJfLnN0YXJ0TGlzdGVuaW5nKHN5bmNUcmVlUXVlcnlGb3JMaXN0ZW5pbmdfKG5ld1F1ZXJ5KSwgc3luY1RyZWVUYWdGb3JRdWVyeShzeW5jVHJlZSwgbmV3UXVlcnkpLCBsaXN0ZW5lci5oYXNoRm4sIGxpc3RlbmVyLm9uQ29tcGxldGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSB0aGVyZSdzIG5vdGhpbmcgYmVsb3cgdXMsIHNvIG5vdGhpbmcgd2UgbmVlZCB0byBzdGFydCBsaXN0ZW5pbmcgb25cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBJZiB3ZSByZW1vdmVkIGFueXRoaW5nIGFuZCB3ZSdyZSBub3QgY292ZXJlZCBieSBhIGhpZ2hlciB1cCBsaXN0ZW4sIHdlIG5lZWQgdG8gc3RvcCBsaXN0ZW5pbmcgb24gdGhpcyBxdWVyeVxyXG4gICAgICAgICAgICAvLyBUaGUgYWJvdmUgYmxvY2sgaGFzIHVzIGNvdmVyZWQgaW4gdGVybXMgb2YgbWFraW5nIHN1cmUgd2UncmUgc2V0IHVwIG9uIGxpc3RlbnMgbG93ZXIgaW4gdGhlIHRyZWUuXHJcbiAgICAgICAgICAgIC8vIEFsc28sIG5vdGUgdGhhdCBpZiB3ZSBoYXZlIGEgY2FuY2VsRXJyb3IsIGl0J3MgYWxyZWFkeSBiZWVuIHJlbW92ZWQgYXQgdGhlIHByb3ZpZGVyIGxldmVsLlxyXG4gICAgICAgICAgICBpZiAoIWNvdmVyZWQgJiYgcmVtb3ZlZC5sZW5ndGggPiAwICYmICFjYW5jZWxFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVtb3ZlZCBhIGRlZmF1bHQsIHRoZW4gd2Ugd2VyZW4ndCBsaXN0ZW5pbmcgb24gYW55IG9mIHRoZSBvdGhlciBxdWVyaWVzIGhlcmUuIEp1c3QgY2FuY2VsIHRoZSBvbmVcclxuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQuIE90aGVyd2lzZSwgd2UgbmVlZCB0byBpdGVyYXRlIHRocm91Z2ggYW5kIGNhbmNlbCBlYWNoIGluZGl2aWR1YWwgcXVlcnlcclxuICAgICAgICAgICAgICAgIGlmIChyZW1vdmluZ0RlZmF1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCB0YWcgZGVmYXVsdCBsaXN0ZW5lcnNcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWZhdWx0VGFnID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBzeW5jVHJlZS5saXN0ZW5Qcm92aWRlcl8uc3RvcExpc3RlbmluZyhzeW5jVHJlZVF1ZXJ5Rm9yTGlzdGVuaW5nXyhxdWVyeSksIGRlZmF1bHRUYWcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZC5mb3JFYWNoKChxdWVyeVRvUmVtb3ZlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhZ1RvUmVtb3ZlID0gc3luY1RyZWUucXVlcnlUb1RhZ01hcC5nZXQoc3luY1RyZWVNYWtlUXVlcnlLZXlfKHF1ZXJ5VG9SZW1vdmUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3luY1RyZWUubGlzdGVuUHJvdmlkZXJfLnN0b3BMaXN0ZW5pbmcoc3luY1RyZWVRdWVyeUZvckxpc3RlbmluZ18ocXVlcnlUb1JlbW92ZSksIHRhZ1RvUmVtb3ZlKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBOb3csIGNsZWFyIGFsbCBvZiB0aGUgdGFncyB3ZSdyZSB0cmFja2luZyBmb3IgdGhlIHJlbW92ZWQgbGlzdGVuc1xyXG4gICAgICAgIHN5bmNUcmVlUmVtb3ZlVGFnc18oc3luY1RyZWUsIHJlbW92ZWQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNhbmNlbEV2ZW50cztcclxufVxyXG4vKipcclxuICogQXBwbHkgbmV3IHNlcnZlciBkYXRhIGZvciB0aGUgc3BlY2lmaWVkIHRhZ2dlZCBxdWVyeS5cclxuICpcclxuICogQHJldHVybnMgRXZlbnRzIHRvIHJhaXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVBcHBseVRhZ2dlZFF1ZXJ5T3ZlcndyaXRlKHN5bmNUcmVlLCBwYXRoLCBzbmFwLCB0YWcpIHtcclxuICAgIGNvbnN0IHF1ZXJ5S2V5ID0gc3luY1RyZWVRdWVyeUtleUZvclRhZ18oc3luY1RyZWUsIHRhZyk7XHJcbiAgICBpZiAocXVlcnlLZXkgIT0gbnVsbCkge1xyXG4gICAgICAgIGNvbnN0IHIgPSBzeW5jVHJlZVBhcnNlUXVlcnlLZXlfKHF1ZXJ5S2V5KTtcclxuICAgICAgICBjb25zdCBxdWVyeVBhdGggPSByLnBhdGgsIHF1ZXJ5SWQgPSByLnF1ZXJ5SWQ7XHJcbiAgICAgICAgY29uc3QgcmVsYXRpdmVQYXRoID0gbmV3UmVsYXRpdmVQYXRoKHF1ZXJ5UGF0aCwgcGF0aCk7XHJcbiAgICAgICAgY29uc3Qgb3AgPSBuZXcgT3ZlcndyaXRlKG5ld09wZXJhdGlvblNvdXJjZVNlcnZlclRhZ2dlZFF1ZXJ5KHF1ZXJ5SWQpLCByZWxhdGl2ZVBhdGgsIHNuYXApO1xyXG4gICAgICAgIHJldHVybiBzeW5jVHJlZUFwcGx5VGFnZ2VkT3BlcmF0aW9uXyhzeW5jVHJlZSwgcXVlcnlQYXRoLCBvcCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBRdWVyeSBtdXN0IGhhdmUgYmVlbiByZW1vdmVkIGFscmVhZHlcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFwcGx5IHNlcnZlciBkYXRhIHRvIGJlIG1lcmdlZCBpbiBmb3IgdGhlIHNwZWNpZmllZCB0YWdnZWQgcXVlcnkuXHJcbiAqXHJcbiAqIEByZXR1cm5zIEV2ZW50cyB0byByYWlzZS5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQXBwbHlUYWdnZWRRdWVyeU1lcmdlKHN5bmNUcmVlLCBwYXRoLCBjaGFuZ2VkQ2hpbGRyZW4sIHRhZykge1xyXG4gICAgY29uc3QgcXVlcnlLZXkgPSBzeW5jVHJlZVF1ZXJ5S2V5Rm9yVGFnXyhzeW5jVHJlZSwgdGFnKTtcclxuICAgIGlmIChxdWVyeUtleSkge1xyXG4gICAgICAgIGNvbnN0IHIgPSBzeW5jVHJlZVBhcnNlUXVlcnlLZXlfKHF1ZXJ5S2V5KTtcclxuICAgICAgICBjb25zdCBxdWVyeVBhdGggPSByLnBhdGgsIHF1ZXJ5SWQgPSByLnF1ZXJ5SWQ7XHJcbiAgICAgICAgY29uc3QgcmVsYXRpdmVQYXRoID0gbmV3UmVsYXRpdmVQYXRoKHF1ZXJ5UGF0aCwgcGF0aCk7XHJcbiAgICAgICAgY29uc3QgY2hhbmdlVHJlZSA9IEltbXV0YWJsZVRyZWUuZnJvbU9iamVjdChjaGFuZ2VkQ2hpbGRyZW4pO1xyXG4gICAgICAgIGNvbnN0IG9wID0gbmV3IE1lcmdlKG5ld09wZXJhdGlvblNvdXJjZVNlcnZlclRhZ2dlZFF1ZXJ5KHF1ZXJ5SWQpLCByZWxhdGl2ZVBhdGgsIGNoYW5nZVRyZWUpO1xyXG4gICAgICAgIHJldHVybiBzeW5jVHJlZUFwcGx5VGFnZ2VkT3BlcmF0aW9uXyhzeW5jVHJlZSwgcXVlcnlQYXRoLCBvcCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBXZSd2ZSBhbHJlYWR5IHJlbW92ZWQgdGhlIHF1ZXJ5LiBObyBiaWcgZGVhbCwgaWdub3JlIHRoZSB1cGRhdGVcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFkZCBhbiBldmVudCBjYWxsYmFjayBmb3IgdGhlIHNwZWNpZmllZCBxdWVyeS5cclxuICpcclxuICogQHJldHVybnMgRXZlbnRzIHRvIHJhaXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVBZGRFdmVudFJlZ2lzdHJhdGlvbihzeW5jVHJlZSwgcXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uLCBza2lwU2V0dXBMaXN0ZW5lciA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBwYXRoID0gcXVlcnkuX3BhdGg7XHJcbiAgICBsZXQgc2VydmVyQ2FjaGUgPSBudWxsO1xyXG4gICAgbGV0IGZvdW5kQW5jZXN0b3JEZWZhdWx0VmlldyA9IGZhbHNlO1xyXG4gICAgLy8gQW55IGNvdmVyaW5nIHdyaXRlcyB3aWxsIG5lY2Vzc2FyaWx5IGJlIGF0IHRoZSByb290LCBzbyByZWFsbHkgYWxsIHdlIG5lZWQgdG8gZmluZCBpcyB0aGUgc2VydmVyIGNhY2hlLlxyXG4gICAgLy8gQ29uc2lkZXIgb3B0aW1pemluZyB0aGlzIG9uY2UgdGhlcmUncyBhIGJldHRlciB1bmRlcnN0YW5kaW5nIG9mIHdoYXQgYWN0dWFsIGJlaGF2aW9yIHdpbGwgYmUuXHJcbiAgICBzeW5jVHJlZS5zeW5jUG9pbnRUcmVlXy5mb3JlYWNoT25QYXRoKHBhdGgsIChwYXRoVG9TeW5jUG9pbnQsIHNwKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcmVsYXRpdmVQYXRoID0gbmV3UmVsYXRpdmVQYXRoKHBhdGhUb1N5bmNQb2ludCwgcGF0aCk7XHJcbiAgICAgICAgc2VydmVyQ2FjaGUgPVxyXG4gICAgICAgICAgICBzZXJ2ZXJDYWNoZSB8fCBzeW5jUG9pbnRHZXRDb21wbGV0ZVNlcnZlckNhY2hlKHNwLCByZWxhdGl2ZVBhdGgpO1xyXG4gICAgICAgIGZvdW5kQW5jZXN0b3JEZWZhdWx0VmlldyA9XHJcbiAgICAgICAgICAgIGZvdW5kQW5jZXN0b3JEZWZhdWx0VmlldyB8fCBzeW5jUG9pbnRIYXNDb21wbGV0ZVZpZXcoc3ApO1xyXG4gICAgfSk7XHJcbiAgICBsZXQgc3luY1BvaW50ID0gc3luY1RyZWUuc3luY1BvaW50VHJlZV8uZ2V0KHBhdGgpO1xyXG4gICAgaWYgKCFzeW5jUG9pbnQpIHtcclxuICAgICAgICBzeW5jUG9pbnQgPSBuZXcgU3luY1BvaW50KCk7XHJcbiAgICAgICAgc3luY1RyZWUuc3luY1BvaW50VHJlZV8gPSBzeW5jVHJlZS5zeW5jUG9pbnRUcmVlXy5zZXQocGF0aCwgc3luY1BvaW50KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGZvdW5kQW5jZXN0b3JEZWZhdWx0VmlldyA9XHJcbiAgICAgICAgICAgIGZvdW5kQW5jZXN0b3JEZWZhdWx0VmlldyB8fCBzeW5jUG9pbnRIYXNDb21wbGV0ZVZpZXcoc3luY1BvaW50KTtcclxuICAgICAgICBzZXJ2ZXJDYWNoZSA9XHJcbiAgICAgICAgICAgIHNlcnZlckNhY2hlIHx8IHN5bmNQb2ludEdldENvbXBsZXRlU2VydmVyQ2FjaGUoc3luY1BvaW50LCBuZXdFbXB0eVBhdGgoKSk7XHJcbiAgICB9XHJcbiAgICBsZXQgc2VydmVyQ2FjaGVDb21wbGV0ZTtcclxuICAgIGlmIChzZXJ2ZXJDYWNoZSAhPSBudWxsKSB7XHJcbiAgICAgICAgc2VydmVyQ2FjaGVDb21wbGV0ZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBzZXJ2ZXJDYWNoZUNvbXBsZXRlID0gZmFsc2U7XHJcbiAgICAgICAgc2VydmVyQ2FjaGUgPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgICAgICBjb25zdCBzdWJ0cmVlID0gc3luY1RyZWUuc3luY1BvaW50VHJlZV8uc3VidHJlZShwYXRoKTtcclxuICAgICAgICBzdWJ0cmVlLmZvcmVhY2hDaGlsZCgoY2hpbGROYW1lLCBjaGlsZFN5bmNQb2ludCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjb21wbGV0ZUNhY2hlID0gc3luY1BvaW50R2V0Q29tcGxldGVTZXJ2ZXJDYWNoZShjaGlsZFN5bmNQb2ludCwgbmV3RW1wdHlQYXRoKCkpO1xyXG4gICAgICAgICAgICBpZiAoY29tcGxldGVDYWNoZSkge1xyXG4gICAgICAgICAgICAgICAgc2VydmVyQ2FjaGUgPSBzZXJ2ZXJDYWNoZS51cGRhdGVJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUsIGNvbXBsZXRlQ2FjaGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB2aWV3QWxyZWFkeUV4aXN0cyA9IHN5bmNQb2ludFZpZXdFeGlzdHNGb3JRdWVyeShzeW5jUG9pbnQsIHF1ZXJ5KTtcclxuICAgIGlmICghdmlld0FscmVhZHlFeGlzdHMgJiYgIXF1ZXJ5Ll9xdWVyeVBhcmFtcy5sb2Fkc0FsbERhdGEoKSkge1xyXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gdHJhY2sgYSB0YWcgZm9yIHRoaXMgcXVlcnlcclxuICAgICAgICBjb25zdCBxdWVyeUtleSA9IHN5bmNUcmVlTWFrZVF1ZXJ5S2V5XyhxdWVyeSk7XHJcbiAgICAgICAgYXNzZXJ0KCFzeW5jVHJlZS5xdWVyeVRvVGFnTWFwLmhhcyhxdWVyeUtleSksICdWaWV3IGRvZXMgbm90IGV4aXN0LCBidXQgd2UgaGF2ZSBhIHRhZycpO1xyXG4gICAgICAgIGNvbnN0IHRhZyA9IHN5bmNUcmVlR2V0TmV4dFF1ZXJ5VGFnXygpO1xyXG4gICAgICAgIHN5bmNUcmVlLnF1ZXJ5VG9UYWdNYXAuc2V0KHF1ZXJ5S2V5LCB0YWcpO1xyXG4gICAgICAgIHN5bmNUcmVlLnRhZ1RvUXVlcnlNYXAuc2V0KHRhZywgcXVlcnlLZXkpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgd3JpdGVzQ2FjaGUgPSB3cml0ZVRyZWVDaGlsZFdyaXRlcyhzeW5jVHJlZS5wZW5kaW5nV3JpdGVUcmVlXywgcGF0aCk7XHJcbiAgICBsZXQgZXZlbnRzID0gc3luY1BvaW50QWRkRXZlbnRSZWdpc3RyYXRpb24oc3luY1BvaW50LCBxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24sIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSwgc2VydmVyQ2FjaGVDb21wbGV0ZSk7XHJcbiAgICBpZiAoIXZpZXdBbHJlYWR5RXhpc3RzICYmICFmb3VuZEFuY2VzdG9yRGVmYXVsdFZpZXcgJiYgIXNraXBTZXR1cExpc3RlbmVyKSB7XHJcbiAgICAgICAgY29uc3QgdmlldyA9IHN5bmNQb2ludFZpZXdGb3JRdWVyeShzeW5jUG9pbnQsIHF1ZXJ5KTtcclxuICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHN5bmNUcmVlU2V0dXBMaXN0ZW5lcl8oc3luY1RyZWUsIHF1ZXJ5LCB2aWV3KSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXZlbnRzO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgY29tcGxldGUgY2FjaGUsIGlmIHdlIGhhdmUgb25lLCBvZiB0aGUgZGF0YSBhdCBhIHBhcnRpY3VsYXIgcGF0aC4gSWYgdGhlIGxvY2F0aW9uIGRvZXMgbm90IGhhdmUgYVxyXG4gKiBsaXN0ZW5lciBhYm92ZSBpdCwgd2Ugd2lsbCBnZXQgYSBmYWxzZSBcIm51bGxcIi4gVGhpcyBzaG91bGRuJ3QgYmUgYSBwcm9ibGVtIGJlY2F1c2UgdHJhbnNhY3Rpb25zIHdpbGwgYWx3YXlzXHJcbiAqIGhhdmUgYSBsaXN0ZW5lciBhYm92ZSwgYW5kIGF0b21pYyBvcGVyYXRpb25zIHdvdWxkIGNvcnJlY3RseSBzaG93IGEgaml0dGVyIG9mIDxpbmNyZW1lbnQgdmFsdWU+IC0+XHJcbiAqICAgICA8aW5jcmVtZW50ZWQgdG90YWw+IGFzIHRoZSB3cml0ZSBpcyBhcHBsaWVkIGxvY2FsbHkgYW5kIHRoZW4gYWNrbm93bGVkZ2VkIGF0IHRoZSBzZXJ2ZXIuXHJcbiAqXHJcbiAqIE5vdGU6IHRoaXMgbWV0aG9kIHdpbGwgKmluY2x1ZGUqIGhpZGRlbiB3cml0ZXMgZnJvbSB0cmFuc2FjdGlvbiB3aXRoIGFwcGx5TG9jYWxseSBzZXQgdG8gZmFsc2UuXHJcbiAqXHJcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdG8gdGhlIGRhdGEgd2Ugd2FudFxyXG4gKiBAcGFyYW0gd3JpdGVJZHNUb0V4Y2x1ZGUgLSBBIHNwZWNpZmljIHNldCB0byBiZSBleGNsdWRlZFxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVDYWxjQ29tcGxldGVFdmVudENhY2hlKHN5bmNUcmVlLCBwYXRoLCB3cml0ZUlkc1RvRXhjbHVkZSkge1xyXG4gICAgY29uc3QgaW5jbHVkZUhpZGRlblNldHMgPSB0cnVlO1xyXG4gICAgY29uc3Qgd3JpdGVUcmVlID0gc3luY1RyZWUucGVuZGluZ1dyaXRlVHJlZV87XHJcbiAgICBjb25zdCBzZXJ2ZXJDYWNoZSA9IHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLmZpbmRPblBhdGgocGF0aCwgKHBhdGhTb0Zhciwgc3luY1BvaW50KSA9PiB7XHJcbiAgICAgICAgY29uc3QgcmVsYXRpdmVQYXRoID0gbmV3UmVsYXRpdmVQYXRoKHBhdGhTb0ZhciwgcGF0aCk7XHJcbiAgICAgICAgY29uc3Qgc2VydmVyQ2FjaGUgPSBzeW5jUG9pbnRHZXRDb21wbGV0ZVNlcnZlckNhY2hlKHN5bmNQb2ludCwgcmVsYXRpdmVQYXRoKTtcclxuICAgICAgICBpZiAoc2VydmVyQ2FjaGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNlcnZlckNhY2hlO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHdyaXRlVHJlZUNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUod3JpdGVUcmVlLCBwYXRoLCBzZXJ2ZXJDYWNoZSwgd3JpdGVJZHNUb0V4Y2x1ZGUsIGluY2x1ZGVIaWRkZW5TZXRzKTtcclxufVxyXG5mdW5jdGlvbiBzeW5jVHJlZUdldFNlcnZlclZhbHVlKHN5bmNUcmVlLCBxdWVyeSkge1xyXG4gICAgY29uc3QgcGF0aCA9IHF1ZXJ5Ll9wYXRoO1xyXG4gICAgbGV0IHNlcnZlckNhY2hlID0gbnVsbDtcclxuICAgIC8vIEFueSBjb3ZlcmluZyB3cml0ZXMgd2lsbCBuZWNlc3NhcmlseSBiZSBhdCB0aGUgcm9vdCwgc28gcmVhbGx5IGFsbCB3ZSBuZWVkIHRvIGZpbmQgaXMgdGhlIHNlcnZlciBjYWNoZS5cclxuICAgIC8vIENvbnNpZGVyIG9wdGltaXppbmcgdGhpcyBvbmNlIHRoZXJlJ3MgYSBiZXR0ZXIgdW5kZXJzdGFuZGluZyBvZiB3aGF0IGFjdHVhbCBiZWhhdmlvciB3aWxsIGJlLlxyXG4gICAgc3luY1RyZWUuc3luY1BvaW50VHJlZV8uZm9yZWFjaE9uUGF0aChwYXRoLCAocGF0aFRvU3luY1BvaW50LCBzcCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IG5ld1JlbGF0aXZlUGF0aChwYXRoVG9TeW5jUG9pbnQsIHBhdGgpO1xyXG4gICAgICAgIHNlcnZlckNhY2hlID1cclxuICAgICAgICAgICAgc2VydmVyQ2FjaGUgfHwgc3luY1BvaW50R2V0Q29tcGxldGVTZXJ2ZXJDYWNoZShzcCwgcmVsYXRpdmVQYXRoKTtcclxuICAgIH0pO1xyXG4gICAgbGV0IHN5bmNQb2ludCA9IHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLmdldChwYXRoKTtcclxuICAgIGlmICghc3luY1BvaW50KSB7XHJcbiAgICAgICAgc3luY1BvaW50ID0gbmV3IFN5bmNQb2ludCgpO1xyXG4gICAgICAgIHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfID0gc3luY1RyZWUuc3luY1BvaW50VHJlZV8uc2V0KHBhdGgsIHN5bmNQb2ludCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBzZXJ2ZXJDYWNoZSA9XHJcbiAgICAgICAgICAgIHNlcnZlckNhY2hlIHx8IHN5bmNQb2ludEdldENvbXBsZXRlU2VydmVyQ2FjaGUoc3luY1BvaW50LCBuZXdFbXB0eVBhdGgoKSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzZXJ2ZXJDYWNoZUNvbXBsZXRlID0gc2VydmVyQ2FjaGUgIT0gbnVsbDtcclxuICAgIGNvbnN0IHNlcnZlckNhY2hlTm9kZSA9IHNlcnZlckNhY2hlQ29tcGxldGVcclxuICAgICAgICA/IG5ldyBDYWNoZU5vZGUoc2VydmVyQ2FjaGUsIHRydWUsIGZhbHNlKVxyXG4gICAgICAgIDogbnVsbDtcclxuICAgIGNvbnN0IHdyaXRlc0NhY2hlID0gd3JpdGVUcmVlQ2hpbGRXcml0ZXMoc3luY1RyZWUucGVuZGluZ1dyaXRlVHJlZV8sIHF1ZXJ5Ll9wYXRoKTtcclxuICAgIGNvbnN0IHZpZXcgPSBzeW5jUG9pbnRHZXRWaWV3KHN5bmNQb2ludCwgcXVlcnksIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZUNvbXBsZXRlID8gc2VydmVyQ2FjaGVOb2RlLmdldE5vZGUoKSA6IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFLCBzZXJ2ZXJDYWNoZUNvbXBsZXRlKTtcclxuICAgIHJldHVybiB2aWV3R2V0Q29tcGxldGVOb2RlKHZpZXcpO1xyXG59XHJcbi8qKlxyXG4gKiBBIGhlbHBlciBtZXRob2QgdGhhdCB2aXNpdHMgYWxsIGRlc2NlbmRhbnQgYW5kIGFuY2VzdG9yIFN5bmNQb2ludHMsIGFwcGx5aW5nIHRoZSBvcGVyYXRpb24uXHJcbiAqXHJcbiAqIE5PVEVTOlxyXG4gKiAtIERlc2NlbmRhbnQgU3luY1BvaW50cyB3aWxsIGJlIHZpc2l0ZWQgZmlyc3QgKHNpbmNlIHdlIHJhaXNlIGV2ZW50cyBkZXB0aC1maXJzdCkuXHJcbiAqXHJcbiAqIC0gV2UgY2FsbCBhcHBseU9wZXJhdGlvbigpIG9uIGVhY2ggU3luY1BvaW50IHBhc3NpbmcgdGhyZWUgdGhpbmdzOlxyXG4gKiAgIDEuIEEgdmVyc2lvbiBvZiB0aGUgT3BlcmF0aW9uIHRoYXQgaGFzIGJlZW4gbWFkZSByZWxhdGl2ZSB0byB0aGUgU3luY1BvaW50IGxvY2F0aW9uLlxyXG4gKiAgIDIuIEEgV3JpdGVUcmVlUmVmIG9mIGFueSB3cml0ZXMgd2UgaGF2ZSBjYWNoZWQgYXQgdGhlIFN5bmNQb2ludCBsb2NhdGlvbi5cclxuICogICAzLiBBIHNuYXBzaG90IE5vZGUgd2l0aCBjYWNoZWQgc2VydmVyIGRhdGEsIGlmIHdlIGhhdmUgaXQuXHJcbiAqXHJcbiAqIC0gV2UgY29uY2F0ZW5hdGUgYWxsIG9mIHRoZSBldmVudHMgcmV0dXJuZWQgYnkgZWFjaCBTeW5jUG9pbnQgYW5kIHJldHVybiB0aGUgcmVzdWx0LlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVBcHBseU9wZXJhdGlvblRvU3luY1BvaW50c18oc3luY1RyZWUsIG9wZXJhdGlvbikge1xyXG4gICAgcmV0dXJuIHN5bmNUcmVlQXBwbHlPcGVyYXRpb25IZWxwZXJfKG9wZXJhdGlvbiwgc3luY1RyZWUuc3luY1BvaW50VHJlZV8sIFxyXG4gICAgLypzZXJ2ZXJDYWNoZT0qLyBudWxsLCB3cml0ZVRyZWVDaGlsZFdyaXRlcyhzeW5jVHJlZS5wZW5kaW5nV3JpdGVUcmVlXywgbmV3RW1wdHlQYXRoKCkpKTtcclxufVxyXG4vKipcclxuICogUmVjdXJzaXZlIGhlbHBlciBmb3IgYXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZUFwcGx5T3BlcmF0aW9uSGVscGVyXyhvcGVyYXRpb24sIHN5bmNQb2ludFRyZWUsIHNlcnZlckNhY2hlLCB3cml0ZXNDYWNoZSkge1xyXG4gICAgaWYgKHBhdGhJc0VtcHR5KG9wZXJhdGlvbi5wYXRoKSkge1xyXG4gICAgICAgIHJldHVybiBzeW5jVHJlZUFwcGx5T3BlcmF0aW9uRGVzY2VuZGFudHNIZWxwZXJfKG9wZXJhdGlvbiwgc3luY1BvaW50VHJlZSwgc2VydmVyQ2FjaGUsIHdyaXRlc0NhY2hlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHN5bmNQb2ludCA9IHN5bmNQb2ludFRyZWUuZ2V0KG5ld0VtcHR5UGF0aCgpKTtcclxuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGNhY2hlZCBzZXJ2ZXIgZGF0YSwgc2VlIGlmIHdlIGNhbiBnZXQgaXQgZnJvbSB0aGlzIFN5bmNQb2ludC5cclxuICAgICAgICBpZiAoc2VydmVyQ2FjaGUgPT0gbnVsbCAmJiBzeW5jUG9pbnQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzZXJ2ZXJDYWNoZSA9IHN5bmNQb2ludEdldENvbXBsZXRlU2VydmVyQ2FjaGUoc3luY1BvaW50LCBuZXdFbXB0eVBhdGgoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBldmVudHMgPSBbXTtcclxuICAgICAgICBjb25zdCBjaGlsZE5hbWUgPSBwYXRoR2V0RnJvbnQob3BlcmF0aW9uLnBhdGgpO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkT3BlcmF0aW9uID0gb3BlcmF0aW9uLm9wZXJhdGlvbkZvckNoaWxkKGNoaWxkTmFtZSk7XHJcbiAgICAgICAgY29uc3QgY2hpbGRUcmVlID0gc3luY1BvaW50VHJlZS5jaGlsZHJlbi5nZXQoY2hpbGROYW1lKTtcclxuICAgICAgICBpZiAoY2hpbGRUcmVlICYmIGNoaWxkT3BlcmF0aW9uKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkU2VydmVyQ2FjaGUgPSBzZXJ2ZXJDYWNoZVxyXG4gICAgICAgICAgICAgICAgPyBzZXJ2ZXJDYWNoZS5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUpXHJcbiAgICAgICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkV3JpdGVzQ2FjaGUgPSB3cml0ZVRyZWVSZWZDaGlsZCh3cml0ZXNDYWNoZSwgY2hpbGROYW1lKTtcclxuICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChzeW5jVHJlZUFwcGx5T3BlcmF0aW9uSGVscGVyXyhjaGlsZE9wZXJhdGlvbiwgY2hpbGRUcmVlLCBjaGlsZFNlcnZlckNhY2hlLCBjaGlsZFdyaXRlc0NhY2hlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzeW5jUG9pbnQpIHtcclxuICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChzeW5jUG9pbnRBcHBseU9wZXJhdGlvbihzeW5jUG9pbnQsIG9wZXJhdGlvbiwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBldmVudHM7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlY3Vyc2l2ZSBoZWxwZXIgZm9yIGFwcGx5T3BlcmF0aW9uVG9TeW5jUG9pbnRzX1xyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVBcHBseU9wZXJhdGlvbkRlc2NlbmRhbnRzSGVscGVyXyhvcGVyYXRpb24sIHN5bmNQb2ludFRyZWUsIHNlcnZlckNhY2hlLCB3cml0ZXNDYWNoZSkge1xyXG4gICAgY29uc3Qgc3luY1BvaW50ID0gc3luY1BvaW50VHJlZS5nZXQobmV3RW1wdHlQYXRoKCkpO1xyXG4gICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBjYWNoZWQgc2VydmVyIGRhdGEsIHNlZSBpZiB3ZSBjYW4gZ2V0IGl0IGZyb20gdGhpcyBTeW5jUG9pbnQuXHJcbiAgICBpZiAoc2VydmVyQ2FjaGUgPT0gbnVsbCAmJiBzeW5jUG9pbnQgIT0gbnVsbCkge1xyXG4gICAgICAgIHNlcnZlckNhY2hlID0gc3luY1BvaW50R2V0Q29tcGxldGVTZXJ2ZXJDYWNoZShzeW5jUG9pbnQsIG5ld0VtcHR5UGF0aCgpKTtcclxuICAgIH1cclxuICAgIGxldCBldmVudHMgPSBbXTtcclxuICAgIHN5bmNQb2ludFRyZWUuY2hpbGRyZW4uaW5vcmRlclRyYXZlcnNhbCgoY2hpbGROYW1lLCBjaGlsZFRyZWUpID0+IHtcclxuICAgICAgICBjb25zdCBjaGlsZFNlcnZlckNhY2hlID0gc2VydmVyQ2FjaGVcclxuICAgICAgICAgICAgPyBzZXJ2ZXJDYWNoZS5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUpXHJcbiAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICBjb25zdCBjaGlsZFdyaXRlc0NhY2hlID0gd3JpdGVUcmVlUmVmQ2hpbGQod3JpdGVzQ2FjaGUsIGNoaWxkTmFtZSk7XHJcbiAgICAgICAgY29uc3QgY2hpbGRPcGVyYXRpb24gPSBvcGVyYXRpb24ub3BlcmF0aW9uRm9yQ2hpbGQoY2hpbGROYW1lKTtcclxuICAgICAgICBpZiAoY2hpbGRPcGVyYXRpb24pIHtcclxuICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChzeW5jVHJlZUFwcGx5T3BlcmF0aW9uRGVzY2VuZGFudHNIZWxwZXJfKGNoaWxkT3BlcmF0aW9uLCBjaGlsZFRyZWUsIGNoaWxkU2VydmVyQ2FjaGUsIGNoaWxkV3JpdGVzQ2FjaGUpKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIGlmIChzeW5jUG9pbnQpIHtcclxuICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHN5bmNQb2ludEFwcGx5T3BlcmF0aW9uKHN5bmNQb2ludCwgb3BlcmF0aW9uLCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGUpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBldmVudHM7XHJcbn1cclxuZnVuY3Rpb24gc3luY1RyZWVDcmVhdGVMaXN0ZW5lckZvclZpZXdfKHN5bmNUcmVlLCB2aWV3KSB7XHJcbiAgICBjb25zdCBxdWVyeSA9IHZpZXcucXVlcnk7XHJcbiAgICBjb25zdCB0YWcgPSBzeW5jVHJlZVRhZ0ZvclF1ZXJ5KHN5bmNUcmVlLCBxdWVyeSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGhhc2hGbjogKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjYWNoZSA9IHZpZXdHZXRTZXJ2ZXJDYWNoZSh2aWV3KSB8fCBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlLmhhc2goKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQ29tcGxldGU6IChzdGF0dXMpID0+IHtcclxuICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ29rJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzeW5jVHJlZUFwcGx5VGFnZ2VkTGlzdGVuQ29tcGxldGUoc3luY1RyZWUsIHF1ZXJ5Ll9wYXRoLCB0YWcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN5bmNUcmVlQXBwbHlMaXN0ZW5Db21wbGV0ZShzeW5jVHJlZSwgcXVlcnkuX3BhdGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgYSBsaXN0ZW4gZmFpbGVkLCBraWxsIGFsbCBvZiB0aGUgbGlzdGVuZXJzIGhlcmUsIG5vdCBqdXN0IHRoZSBvbmUgdGhhdCB0cmlnZ2VyZWQgdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IG5lZWQgdG8gYmUgc2NvcGVkIHRvIGp1c3QgdGhpcyBsaXN0ZW5lciBpZiB3ZSBjaGFuZ2UgcGVybWlzc2lvbnMgb24gZmlsdGVyZWQgY2hpbGRyZW5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gZXJyb3JGb3JTZXJ2ZXJDb2RlKHN0YXR1cywgcXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bmNUcmVlUmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24oc3luY1RyZWUsIHF1ZXJ5LCBcclxuICAgICAgICAgICAgICAgIC8qZXZlbnRSZWdpc3RyYXRpb24qLyBudWxsLCBlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm4gdGhlIHRhZyBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIHF1ZXJ5LlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVUYWdGb3JRdWVyeShzeW5jVHJlZSwgcXVlcnkpIHtcclxuICAgIGNvbnN0IHF1ZXJ5S2V5ID0gc3luY1RyZWVNYWtlUXVlcnlLZXlfKHF1ZXJ5KTtcclxuICAgIHJldHVybiBzeW5jVHJlZS5xdWVyeVRvVGFnTWFwLmdldChxdWVyeUtleSk7XHJcbn1cclxuLyoqXHJcbiAqIEdpdmVuIGEgcXVlcnksIGNvbXB1dGVzIGEgXCJxdWVyeUtleVwiIHN1aXRhYmxlIGZvciB1c2UgaW4gb3VyIHF1ZXJ5VG9UYWdNYXBfLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVNYWtlUXVlcnlLZXlfKHF1ZXJ5KSB7XHJcbiAgICByZXR1cm4gcXVlcnkuX3BhdGgudG9TdHJpbmcoKSArICckJyArIHF1ZXJ5Ll9xdWVyeUlkZW50aWZpZXI7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybiB0aGUgcXVlcnkgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiB0YWcsIGlmIHdlIGhhdmUgb25lXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZVF1ZXJ5S2V5Rm9yVGFnXyhzeW5jVHJlZSwgdGFnKSB7XHJcbiAgICByZXR1cm4gc3luY1RyZWUudGFnVG9RdWVyeU1hcC5nZXQodGFnKTtcclxufVxyXG4vKipcclxuICogR2l2ZW4gYSBxdWVyeUtleSAoY3JlYXRlZCBieSBtYWtlUXVlcnlLZXkpLCBwYXJzZSBpdCBiYWNrIGludG8gYSBwYXRoIGFuZCBxdWVyeUlkLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVQYXJzZVF1ZXJ5S2V5XyhxdWVyeUtleSkge1xyXG4gICAgY29uc3Qgc3BsaXRJbmRleCA9IHF1ZXJ5S2V5LmluZGV4T2YoJyQnKTtcclxuICAgIGFzc2VydChzcGxpdEluZGV4ICE9PSAtMSAmJiBzcGxpdEluZGV4IDwgcXVlcnlLZXkubGVuZ3RoIC0gMSwgJ0JhZCBxdWVyeUtleS4nKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcXVlcnlJZDogcXVlcnlLZXkuc3Vic3RyKHNwbGl0SW5kZXggKyAxKSxcclxuICAgICAgICBwYXRoOiBuZXcgUGF0aChxdWVyeUtleS5zdWJzdHIoMCwgc3BsaXRJbmRleCkpXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBBIGhlbHBlciBtZXRob2QgdG8gYXBwbHkgdGFnZ2VkIG9wZXJhdGlvbnNcclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQXBwbHlUYWdnZWRPcGVyYXRpb25fKHN5bmNUcmVlLCBxdWVyeVBhdGgsIG9wZXJhdGlvbikge1xyXG4gICAgY29uc3Qgc3luY1BvaW50ID0gc3luY1RyZWUuc3luY1BvaW50VHJlZV8uZ2V0KHF1ZXJ5UGF0aCk7XHJcbiAgICBhc3NlcnQoc3luY1BvaW50LCBcIk1pc3Npbmcgc3luYyBwb2ludCBmb3IgcXVlcnkgdGFnIHRoYXQgd2UncmUgdHJhY2tpbmdcIik7XHJcbiAgICBjb25zdCB3cml0ZXNDYWNoZSA9IHdyaXRlVHJlZUNoaWxkV3JpdGVzKHN5bmNUcmVlLnBlbmRpbmdXcml0ZVRyZWVfLCBxdWVyeVBhdGgpO1xyXG4gICAgcmV0dXJuIHN5bmNQb2ludEFwcGx5T3BlcmF0aW9uKHN5bmNQb2ludCwgb3BlcmF0aW9uLCB3cml0ZXNDYWNoZSwgbnVsbCk7XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgY29sbGFwc2VzIG11bHRpcGxlIHVuZmlsdGVyZWQgdmlld3MgaW50byBhIHNpbmdsZSB2aWV3LCBzaW5jZSB3ZSBvbmx5IG5lZWQgYSBzaW5nbGVcclxuICogbGlzdGVuZXIgZm9yIHRoZW0uXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZUNvbGxlY3REaXN0aW5jdFZpZXdzRm9yU3ViVHJlZV8oc3VidHJlZSkge1xyXG4gICAgcmV0dXJuIHN1YnRyZWUuZm9sZCgocmVsYXRpdmVQYXRoLCBtYXliZUNoaWxkU3luY1BvaW50LCBjaGlsZE1hcCkgPT4ge1xyXG4gICAgICAgIGlmIChtYXliZUNoaWxkU3luY1BvaW50ICYmIHN5bmNQb2ludEhhc0NvbXBsZXRlVmlldyhtYXliZUNoaWxkU3luY1BvaW50KSkge1xyXG4gICAgICAgICAgICBjb25zdCBjb21wbGV0ZVZpZXcgPSBzeW5jUG9pbnRHZXRDb21wbGV0ZVZpZXcobWF5YmVDaGlsZFN5bmNQb2ludCk7XHJcbiAgICAgICAgICAgIHJldHVybiBbY29tcGxldGVWaWV3XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE5vIGNvbXBsZXRlIHZpZXcgaGVyZSwgZmxhdHRlbiBhbnkgZGVlcGVyIGxpc3RlbnMgaW50byBhbiBhcnJheVxyXG4gICAgICAgICAgICBsZXQgdmlld3MgPSBbXTtcclxuICAgICAgICAgICAgaWYgKG1heWJlQ2hpbGRTeW5jUG9pbnQpIHtcclxuICAgICAgICAgICAgICAgIHZpZXdzID0gc3luY1BvaW50R2V0UXVlcnlWaWV3cyhtYXliZUNoaWxkU3luY1BvaW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlYWNoKGNoaWxkTWFwLCAoX2tleSwgY2hpbGRWaWV3cykgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmlld3MgPSB2aWV3cy5jb25jYXQoY2hpbGRWaWV3cyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdmlld3M7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIE5vcm1hbGl6ZXMgYSBxdWVyeSB0byBhIHF1ZXJ5IHdlIHNlbmQgdGhlIHNlcnZlciBmb3IgbGlzdGVuaW5nXHJcbiAqXHJcbiAqIEByZXR1cm5zIFRoZSBub3JtYWxpemVkIHF1ZXJ5XHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZVF1ZXJ5Rm9yTGlzdGVuaW5nXyhxdWVyeSkge1xyXG4gICAgaWYgKHF1ZXJ5Ll9xdWVyeVBhcmFtcy5sb2Fkc0FsbERhdGEoKSAmJiAhcXVlcnkuX3F1ZXJ5UGFyYW1zLmlzRGVmYXVsdCgpKSB7XHJcbiAgICAgICAgLy8gV2UgdHJlYXQgcXVlcmllcyB0aGF0IGxvYWQgYWxsIGRhdGEgYXMgZGVmYXVsdCBxdWVyaWVzXHJcbiAgICAgICAgLy8gQ2FzdCBpcyBuZWNlc3NhcnkgYmVjYXVzZSByZWYoKSB0ZWNobmljYWxseSByZXR1cm5zIEZpcmViYXNlIHdoaWNoIGlzIGFjdHVhbGx5IGZiLmFwaS5GaXJlYmFzZSB3aGljaCBpbmhlcml0c1xyXG4gICAgICAgIC8vIGZyb20gUXVlcnlcclxuICAgICAgICByZXR1cm4gbmV3IChzeW5jVHJlZUdldFJlZmVyZW5jZUNvbnN0cnVjdG9yKCkpKHF1ZXJ5Ll9yZXBvLCBxdWVyeS5fcGF0aCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gcXVlcnk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc3luY1RyZWVSZW1vdmVUYWdzXyhzeW5jVHJlZSwgcXVlcmllcykge1xyXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBxdWVyaWVzLmxlbmd0aDsgKytqKSB7XHJcbiAgICAgICAgY29uc3QgcmVtb3ZlZFF1ZXJ5ID0gcXVlcmllc1tqXTtcclxuICAgICAgICBpZiAoIXJlbW92ZWRRdWVyeS5fcXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCkpIHtcclxuICAgICAgICAgICAgLy8gV2Ugc2hvdWxkIGhhdmUgYSB0YWcgZm9yIHRoaXNcclxuICAgICAgICAgICAgY29uc3QgcmVtb3ZlZFF1ZXJ5S2V5ID0gc3luY1RyZWVNYWtlUXVlcnlLZXlfKHJlbW92ZWRRdWVyeSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWRRdWVyeVRhZyA9IHN5bmNUcmVlLnF1ZXJ5VG9UYWdNYXAuZ2V0KHJlbW92ZWRRdWVyeUtleSk7XHJcbiAgICAgICAgICAgIHN5bmNUcmVlLnF1ZXJ5VG9UYWdNYXAuZGVsZXRlKHJlbW92ZWRRdWVyeUtleSk7XHJcbiAgICAgICAgICAgIHN5bmNUcmVlLnRhZ1RvUXVlcnlNYXAuZGVsZXRlKHJlbW92ZWRRdWVyeVRhZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBTdGF0aWMgYWNjZXNzb3IgZm9yIHF1ZXJ5IHRhZ3MuXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZUdldE5leHRRdWVyeVRhZ18oKSB7XHJcbiAgICByZXR1cm4gc3luY1RyZWVOZXh0UXVlcnlUYWdfKys7XHJcbn1cclxuLyoqXHJcbiAqIEZvciBhIGdpdmVuIG5ldyBsaXN0ZW4sIG1hbmFnZSB0aGUgZGUtZHVwbGljYXRpb24gb2Ygb3V0c3RhbmRpbmcgc3Vic2NyaXB0aW9ucy5cclxuICpcclxuICogQHJldHVybnMgVGhpcyBtZXRob2QgY2FuIHJldHVybiBldmVudHMgdG8gc3VwcG9ydCBzeW5jaHJvbm91cyBkYXRhIHNvdXJjZXNcclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlU2V0dXBMaXN0ZW5lcl8oc3luY1RyZWUsIHF1ZXJ5LCB2aWV3KSB7XHJcbiAgICBjb25zdCBwYXRoID0gcXVlcnkuX3BhdGg7XHJcbiAgICBjb25zdCB0YWcgPSBzeW5jVHJlZVRhZ0ZvclF1ZXJ5KHN5bmNUcmVlLCBxdWVyeSk7XHJcbiAgICBjb25zdCBsaXN0ZW5lciA9IHN5bmNUcmVlQ3JlYXRlTGlzdGVuZXJGb3JWaWV3XyhzeW5jVHJlZSwgdmlldyk7XHJcbiAgICBjb25zdCBldmVudHMgPSBzeW5jVHJlZS5saXN0ZW5Qcm92aWRlcl8uc3RhcnRMaXN0ZW5pbmcoc3luY1RyZWVRdWVyeUZvckxpc3RlbmluZ18ocXVlcnkpLCB0YWcsIGxpc3RlbmVyLmhhc2hGbiwgbGlzdGVuZXIub25Db21wbGV0ZSk7XHJcbiAgICBjb25zdCBzdWJ0cmVlID0gc3luY1RyZWUuc3luY1BvaW50VHJlZV8uc3VidHJlZShwYXRoKTtcclxuICAgIC8vIFRoZSByb290IG9mIHRoaXMgc3VidHJlZSBoYXMgb3VyIHF1ZXJ5LiBXZSdyZSBoZXJlIGJlY2F1c2Ugd2UgZGVmaW5pdGVseSBuZWVkIHRvIHNlbmQgYSBsaXN0ZW4gZm9yIHRoYXQsIGJ1dCB3ZVxyXG4gICAgLy8gbWF5IG5lZWQgdG8gc2hhZG93IG90aGVyIGxpc3RlbnMgYXMgd2VsbC5cclxuICAgIGlmICh0YWcpIHtcclxuICAgICAgICBhc3NlcnQoIXN5bmNQb2ludEhhc0NvbXBsZXRlVmlldyhzdWJ0cmVlLnZhbHVlKSwgXCJJZiB3ZSdyZSBhZGRpbmcgYSBxdWVyeSwgaXQgc2hvdWxkbid0IGJlIHNoYWRvd2VkXCIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gU2hhZG93IGV2ZXJ5dGhpbmcgYXQgb3IgYmVsb3cgdGhpcyBsb2NhdGlvbiwgdGhpcyBpcyBhIGRlZmF1bHQgbGlzdGVuZXIuXHJcbiAgICAgICAgY29uc3QgcXVlcmllc1RvU3RvcCA9IHN1YnRyZWUuZm9sZCgocmVsYXRpdmVQYXRoLCBtYXliZUNoaWxkU3luY1BvaW50LCBjaGlsZE1hcCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXBhdGhJc0VtcHR5KHJlbGF0aXZlUGF0aCkgJiZcclxuICAgICAgICAgICAgICAgIG1heWJlQ2hpbGRTeW5jUG9pbnQgJiZcclxuICAgICAgICAgICAgICAgIHN5bmNQb2ludEhhc0NvbXBsZXRlVmlldyhtYXliZUNoaWxkU3luY1BvaW50KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtzeW5jUG9pbnRHZXRDb21wbGV0ZVZpZXcobWF5YmVDaGlsZFN5bmNQb2ludCkucXVlcnldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTm8gZGVmYXVsdCBsaXN0ZW5lciBoZXJlLCBmbGF0dGVuIGFueSBkZWVwZXIgcXVlcmllcyBpbnRvIGFuIGFycmF5XHJcbiAgICAgICAgICAgICAgICBsZXQgcXVlcmllcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1heWJlQ2hpbGRTeW5jUG9pbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBxdWVyaWVzID0gcXVlcmllcy5jb25jYXQoc3luY1BvaW50R2V0UXVlcnlWaWV3cyhtYXliZUNoaWxkU3luY1BvaW50KS5tYXAodmlldyA9PiB2aWV3LnF1ZXJ5KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlYWNoKGNoaWxkTWFwLCAoX2tleSwgY2hpbGRRdWVyaWVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVlcmllcyA9IHF1ZXJpZXMuY29uY2F0KGNoaWxkUXVlcmllcyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBxdWVyaWVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWVyaWVzVG9TdG9wLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5VG9TdG9wID0gcXVlcmllc1RvU3RvcFtpXTtcclxuICAgICAgICAgICAgc3luY1RyZWUubGlzdGVuUHJvdmlkZXJfLnN0b3BMaXN0ZW5pbmcoc3luY1RyZWVRdWVyeUZvckxpc3RlbmluZ18ocXVlcnlUb1N0b3ApLCBzeW5jVHJlZVRhZ0ZvclF1ZXJ5KHN5bmNUcmVlLCBxdWVyeVRvU3RvcCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBldmVudHM7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgRXhpc3RpbmdWYWx1ZVByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG5vZGVfKSB7XHJcbiAgICAgICAgdGhpcy5ub2RlXyA9IG5vZGVfO1xyXG4gICAgfVxyXG4gICAgZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLm5vZGVfLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFeGlzdGluZ1ZhbHVlUHJvdmlkZXIoY2hpbGQpO1xyXG4gICAgfVxyXG4gICAgbm9kZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlXztcclxuICAgIH1cclxufVxyXG5jbGFzcyBEZWZlcnJlZFZhbHVlUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3Ioc3luY1RyZWUsIHBhdGgpIHtcclxuICAgICAgICB0aGlzLnN5bmNUcmVlXyA9IHN5bmNUcmVlO1xyXG4gICAgICAgIHRoaXMucGF0aF8gPSBwYXRoO1xyXG4gICAgfVxyXG4gICAgZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGRQYXRoID0gcGF0aENoaWxkKHRoaXMucGF0aF8sIGNoaWxkTmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEZWZlcnJlZFZhbHVlUHJvdmlkZXIodGhpcy5zeW5jVHJlZV8sIGNoaWxkUGF0aCk7XHJcbiAgICB9XHJcbiAgICBub2RlKCkge1xyXG4gICAgICAgIHJldHVybiBzeW5jVHJlZUNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUodGhpcy5zeW5jVHJlZV8sIHRoaXMucGF0aF8pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBHZW5lcmF0ZSBwbGFjZWhvbGRlcnMgZm9yIGRlZmVycmVkIHZhbHVlcy5cclxuICovXHJcbmNvbnN0IGdlbmVyYXRlV2l0aFZhbHVlcyA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcclxuICAgIHZhbHVlcyA9IHZhbHVlcyB8fCB7fTtcclxuICAgIHZhbHVlc1sndGltZXN0YW1wJ10gPSB2YWx1ZXNbJ3RpbWVzdGFtcCddIHx8IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgcmV0dXJuIHZhbHVlcztcclxufTtcclxuLyoqXHJcbiAqIFZhbHVlIHRvIHVzZSB3aGVuIGZpcmluZyBsb2NhbCBldmVudHMuIFdoZW4gd3JpdGluZyBzZXJ2ZXIgdmFsdWVzLCBmaXJlXHJcbiAqIGxvY2FsIGV2ZW50cyB3aXRoIGFuIGFwcHJveGltYXRlIHZhbHVlLCBvdGhlcndpc2UgcmV0dXJuIHZhbHVlIGFzLWlzLlxyXG4gKi9cclxuY29uc3QgcmVzb2x2ZURlZmVycmVkTGVhZlZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBleGlzdGluZ1ZhbCwgc2VydmVyVmFsdWVzKSB7XHJcbiAgICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBhc3NlcnQoJy5zdicgaW4gdmFsdWUsICdVbmV4cGVjdGVkIGxlYWYgbm9kZSBvciBwcmlvcml0eSBjb250ZW50cycpO1xyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZVsnLnN2J10gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc29sdmVTY2FsYXJEZWZlcnJlZFZhbHVlKHZhbHVlWycuc3YnXSwgZXhpc3RpbmdWYWwsIHNlcnZlclZhbHVlcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWVbJy5zdiddID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIHJldHVybiByZXNvbHZlQ29tcGxleERlZmVycmVkVmFsdWUodmFsdWVbJy5zdiddLCBleGlzdGluZ1ZhbCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhc3NlcnQoZmFsc2UsICdVbmV4cGVjdGVkIHNlcnZlciB2YWx1ZTogJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlLCBudWxsLCAyKSk7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IHJlc29sdmVTY2FsYXJEZWZlcnJlZFZhbHVlID0gZnVuY3Rpb24gKG9wLCBleGlzdGluZywgc2VydmVyVmFsdWVzKSB7XHJcbiAgICBzd2l0Y2ggKG9wKSB7XHJcbiAgICAgICAgY2FzZSAndGltZXN0YW1wJzpcclxuICAgICAgICAgICAgcmV0dXJuIHNlcnZlclZhbHVlc1sndGltZXN0YW1wJ107XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCAnVW5leHBlY3RlZCBzZXJ2ZXIgdmFsdWU6ICcgKyBvcCk7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IHJlc29sdmVDb21wbGV4RGVmZXJyZWRWYWx1ZSA9IGZ1bmN0aW9uIChvcCwgZXhpc3RpbmcsIHVudXNlZCkge1xyXG4gICAgaWYgKCFvcC5oYXNPd25Qcm9wZXJ0eSgnaW5jcmVtZW50JykpIHtcclxuICAgICAgICBhc3NlcnQoZmFsc2UsICdVbmV4cGVjdGVkIHNlcnZlciB2YWx1ZTogJyArIEpTT04uc3RyaW5naWZ5KG9wLCBudWxsLCAyKSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBkZWx0YSA9IG9wWydpbmNyZW1lbnQnXTtcclxuICAgIGlmICh0eXBlb2YgZGVsdGEgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCAnVW5leHBlY3RlZCBpbmNyZW1lbnQgdmFsdWU6ICcgKyBkZWx0YSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBleGlzdGluZ05vZGUgPSBleGlzdGluZy5ub2RlKCk7XHJcbiAgICBhc3NlcnQoZXhpc3RpbmdOb2RlICE9PSBudWxsICYmIHR5cGVvZiBleGlzdGluZ05vZGUgIT09ICd1bmRlZmluZWQnLCAnRXhwZWN0ZWQgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUgZm9yIG51bGxzJyk7XHJcbiAgICAvLyBJbmNyZW1lbnRpbmcgYSBub24tbnVtYmVyIHNldHMgdGhlIHZhbHVlIHRvIHRoZSBpbmNyZW1lbnRlZCBhbW91bnRcclxuICAgIGlmICghZXhpc3RpbmdOb2RlLmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgIHJldHVybiBkZWx0YTtcclxuICAgIH1cclxuICAgIGNvbnN0IGxlYWYgPSBleGlzdGluZ05vZGU7XHJcbiAgICBjb25zdCBleGlzdGluZ1ZhbCA9IGxlYWYuZ2V0VmFsdWUoKTtcclxuICAgIGlmICh0eXBlb2YgZXhpc3RpbmdWYWwgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlbHRhO1xyXG4gICAgfVxyXG4gICAgLy8gTm8gbmVlZCB0byBkbyBvdmVyL3VuZGVyZmxvdyBhcml0aG1ldGljIGhlcmUgYmVjYXVzZSBKUyBvbmx5IGhhbmRsZXMgZmxvYXRzIHVuZGVyIHRoZSBjb3ZlcnNcclxuICAgIHJldHVybiBleGlzdGluZ1ZhbCArIGRlbHRhO1xyXG59O1xyXG4vKipcclxuICogUmVjdXJzaXZlbHkgcmVwbGFjZSBhbGwgZGVmZXJyZWQgdmFsdWVzIGFuZCBwcmlvcml0aWVzIGluIHRoZSB0cmVlIHdpdGggdGhlXHJcbiAqIHNwZWNpZmllZCBnZW5lcmF0ZWQgcmVwbGFjZW1lbnQgdmFsdWVzLlxyXG4gKiBAcGFyYW0gcGF0aCAtIHBhdGggdG8gd2hpY2ggd3JpdGUgaXMgcmVsYXRpdmVcclxuICogQHBhcmFtIG5vZGUgLSBuZXcgZGF0YSB3cml0dGVuIGF0IHBhdGhcclxuICogQHBhcmFtIHN5bmNUcmVlIC0gY3VycmVudCBkYXRhXHJcbiAqL1xyXG5jb25zdCByZXNvbHZlRGVmZXJyZWRWYWx1ZVRyZWUgPSBmdW5jdGlvbiAocGF0aCwgbm9kZSwgc3luY1RyZWUsIHNlcnZlclZhbHVlcykge1xyXG4gICAgcmV0dXJuIHJlc29sdmVEZWZlcnJlZFZhbHVlKG5vZGUsIG5ldyBEZWZlcnJlZFZhbHVlUHJvdmlkZXIoc3luY1RyZWUsIHBhdGgpLCBzZXJ2ZXJWYWx1ZXMpO1xyXG59O1xyXG4vKipcclxuICogUmVjdXJzaXZlbHkgcmVwbGFjZSBhbGwgZGVmZXJyZWQgdmFsdWVzIGFuZCBwcmlvcml0aWVzIGluIHRoZSBub2RlIHdpdGggdGhlXHJcbiAqIHNwZWNpZmllZCBnZW5lcmF0ZWQgcmVwbGFjZW1lbnQgdmFsdWVzLiAgSWYgdGhlcmUgYXJlIG5vIHNlcnZlciB2YWx1ZXMgaW4gdGhlIG5vZGUsXHJcbiAqIGl0J2xsIGJlIHJldHVybmVkIGFzLWlzLlxyXG4gKi9cclxuY29uc3QgcmVzb2x2ZURlZmVycmVkVmFsdWVTbmFwc2hvdCA9IGZ1bmN0aW9uIChub2RlLCBleGlzdGluZywgc2VydmVyVmFsdWVzKSB7XHJcbiAgICByZXR1cm4gcmVzb2x2ZURlZmVycmVkVmFsdWUobm9kZSwgbmV3IEV4aXN0aW5nVmFsdWVQcm92aWRlcihleGlzdGluZyksIHNlcnZlclZhbHVlcyk7XHJcbn07XHJcbmZ1bmN0aW9uIHJlc29sdmVEZWZlcnJlZFZhbHVlKG5vZGUsIGV4aXN0aW5nVmFsLCBzZXJ2ZXJWYWx1ZXMpIHtcclxuICAgIGNvbnN0IHJhd1ByaSA9IG5vZGUuZ2V0UHJpb3JpdHkoKS52YWwoKTtcclxuICAgIGNvbnN0IHByaW9yaXR5ID0gcmVzb2x2ZURlZmVycmVkTGVhZlZhbHVlKHJhd1ByaSwgZXhpc3RpbmdWYWwuZ2V0SW1tZWRpYXRlQ2hpbGQoJy5wcmlvcml0eScpLCBzZXJ2ZXJWYWx1ZXMpO1xyXG4gICAgbGV0IG5ld05vZGU7XHJcbiAgICBpZiAobm9kZS5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICBjb25zdCBsZWFmTm9kZSA9IG5vZGU7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSByZXNvbHZlRGVmZXJyZWRMZWFmVmFsdWUobGVhZk5vZGUuZ2V0VmFsdWUoKSwgZXhpc3RpbmdWYWwsIHNlcnZlclZhbHVlcyk7XHJcbiAgICAgICAgaWYgKHZhbHVlICE9PSBsZWFmTm9kZS5nZXRWYWx1ZSgpIHx8XHJcbiAgICAgICAgICAgIHByaW9yaXR5ICE9PSBsZWFmTm9kZS5nZXRQcmlvcml0eSgpLnZhbCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGVhZk5vZGUodmFsdWUsIG5vZGVGcm9tSlNPTihwcmlvcml0eSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGRyZW5Ob2RlID0gbm9kZTtcclxuICAgICAgICBuZXdOb2RlID0gY2hpbGRyZW5Ob2RlO1xyXG4gICAgICAgIGlmIChwcmlvcml0eSAhPT0gY2hpbGRyZW5Ob2RlLmdldFByaW9yaXR5KCkudmFsKCkpIHtcclxuICAgICAgICAgICAgbmV3Tm9kZSA9IG5ld05vZGUudXBkYXRlUHJpb3JpdHkobmV3IExlYWZOb2RlKHByaW9yaXR5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNoaWxkcmVuTm9kZS5mb3JFYWNoQ2hpbGQoUFJJT1JJVFlfSU5ERVgsIChjaGlsZE5hbWUsIGNoaWxkTm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdDaGlsZE5vZGUgPSByZXNvbHZlRGVmZXJyZWRWYWx1ZShjaGlsZE5vZGUsIGV4aXN0aW5nVmFsLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSksIHNlcnZlclZhbHVlcyk7XHJcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZE5vZGUgIT09IGNoaWxkTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgbmV3Tm9kZSA9IG5ld05vZGUudXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lLCBuZXdDaGlsZE5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5ld05vZGU7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEEgbGlnaHQtd2VpZ2h0IHRyZWUsIHRyYXZlcnNhYmxlIGJ5IHBhdGguICBOb2RlcyBjYW4gaGF2ZSBib3RoIHZhbHVlcyBhbmQgY2hpbGRyZW4uXHJcbiAqIE5vZGVzIGFyZSBub3QgZW51bWVyYXRlZCAoYnkgZm9yRWFjaENoaWxkKSB1bmxlc3MgdGhleSBoYXZlIGEgdmFsdWUgb3Igbm9uLWVtcHR5XHJcbiAqIGNoaWxkcmVuLlxyXG4gKi9cclxuY2xhc3MgVHJlZSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBuYW1lIC0gT3B0aW9uYWwgbmFtZSBvZiB0aGUgbm9kZS5cclxuICAgICAqIEBwYXJhbSBwYXJlbnQgLSBPcHRpb25hbCBwYXJlbnQgbm9kZS5cclxuICAgICAqIEBwYXJhbSBub2RlIC0gT3B0aW9uYWwgbm9kZSB0byB3cmFwLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihuYW1lID0gJycsIHBhcmVudCA9IG51bGwsIG5vZGUgPSB7IGNoaWxkcmVuOiB7fSwgY2hpbGRDb3VudDogMCB9KSB7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3ViLVRyZWUgZm9yIHRoZSBnaXZlbiBwYXRoLlxyXG4gKlxyXG4gKiBAcGFyYW0gcGF0aE9iaiAtIFBhdGggdG8gbG9vayB1cC5cclxuICogQHJldHVybnMgVHJlZSBmb3IgcGF0aC5cclxuICovXHJcbmZ1bmN0aW9uIHRyZWVTdWJUcmVlKHRyZWUsIHBhdGhPYmopIHtcclxuICAgIC8vIFRPRE86IFJlcXVpcmUgcGF0aE9iaiB0byBiZSBQYXRoP1xyXG4gICAgbGV0IHBhdGggPSBwYXRoT2JqIGluc3RhbmNlb2YgUGF0aCA/IHBhdGhPYmogOiBuZXcgUGF0aChwYXRoT2JqKTtcclxuICAgIGxldCBjaGlsZCA9IHRyZWUsIG5leHQgPSBwYXRoR2V0RnJvbnQocGF0aCk7XHJcbiAgICB3aGlsZSAobmV4dCAhPT0gbnVsbCkge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IHNhZmVHZXQoY2hpbGQubm9kZS5jaGlsZHJlbiwgbmV4dCkgfHwge1xyXG4gICAgICAgICAgICBjaGlsZHJlbjoge30sXHJcbiAgICAgICAgICAgIGNoaWxkQ291bnQ6IDBcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNoaWxkID0gbmV3IFRyZWUobmV4dCwgY2hpbGQsIGNoaWxkTm9kZSk7XHJcbiAgICAgICAgcGF0aCA9IHBhdGhQb3BGcm9udChwYXRoKTtcclxuICAgICAgICBuZXh0ID0gcGF0aEdldEZyb250KHBhdGgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNoaWxkO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHRyZWUgbm9kZS5cclxuICpcclxuICogQHJldHVybnMgVGhlIGRhdGEgb3IgbnVsbCBpZiBubyBkYXRhIGV4aXN0cy5cclxuICovXHJcbmZ1bmN0aW9uIHRyZWVHZXRWYWx1ZSh0cmVlKSB7XHJcbiAgICByZXR1cm4gdHJlZS5ub2RlLnZhbHVlO1xyXG59XHJcbi8qKlxyXG4gKiBTZXRzIGRhdGEgdG8gdGhpcyB0cmVlIG5vZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIHNldC5cclxuICovXHJcbmZ1bmN0aW9uIHRyZWVTZXRWYWx1ZSh0cmVlLCB2YWx1ZSkge1xyXG4gICAgdHJlZS5ub2RlLnZhbHVlID0gdmFsdWU7XHJcbiAgICB0cmVlVXBkYXRlUGFyZW50cyh0cmVlKTtcclxufVxyXG4vKipcclxuICogQHJldHVybnMgV2hldGhlciB0aGUgdHJlZSBoYXMgYW55IGNoaWxkcmVuLlxyXG4gKi9cclxuZnVuY3Rpb24gdHJlZUhhc0NoaWxkcmVuKHRyZWUpIHtcclxuICAgIHJldHVybiB0cmVlLm5vZGUuY2hpbGRDb3VudCA+IDA7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIFdoZXRoZSBydGhlIHRyZWUgaXMgZW1wdHkgKG5vIHZhbHVlIG9yIGNoaWxkcmVuKS5cclxuICovXHJcbmZ1bmN0aW9uIHRyZWVJc0VtcHR5KHRyZWUpIHtcclxuICAgIHJldHVybiB0cmVlR2V0VmFsdWUodHJlZSkgPT09IHVuZGVmaW5lZCAmJiAhdHJlZUhhc0NoaWxkcmVuKHRyZWUpO1xyXG59XHJcbi8qKlxyXG4gKiBDYWxscyBhY3Rpb24gZm9yIGVhY2ggY2hpbGQgb2YgdGhpcyB0cmVlIG5vZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBhY3Rpb24gLSBBY3Rpb24gdG8gYmUgY2FsbGVkIGZvciBlYWNoIGNoaWxkLlxyXG4gKi9cclxuZnVuY3Rpb24gdHJlZUZvckVhY2hDaGlsZCh0cmVlLCBhY3Rpb24pIHtcclxuICAgIGVhY2godHJlZS5ub2RlLmNoaWxkcmVuLCAoY2hpbGQsIGNoaWxkVHJlZSkgPT4ge1xyXG4gICAgICAgIGFjdGlvbihuZXcgVHJlZShjaGlsZCwgdHJlZSwgY2hpbGRUcmVlKSk7XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogRG9lcyBhIGRlcHRoLWZpcnN0IHRyYXZlcnNhbCBvZiB0aGlzIG5vZGUncyBkZXNjZW5kYW50cywgY2FsbGluZyBhY3Rpb24gZm9yIGVhY2ggb25lLlxyXG4gKlxyXG4gKiBAcGFyYW0gYWN0aW9uIC0gQWN0aW9uIHRvIGJlIGNhbGxlZCBmb3IgZWFjaCBjaGlsZC5cclxuICogQHBhcmFtIGluY2x1ZGVTZWxmIC0gV2hldGhlciB0byBjYWxsIGFjdGlvbiBvbiB0aGlzIG5vZGUgYXMgd2VsbC4gRGVmYXVsdHMgdG9cclxuICogICBmYWxzZS5cclxuICogQHBhcmFtIGNoaWxkcmVuRmlyc3QgLSBXaGV0aGVyIHRvIGNhbGwgYWN0aW9uIG9uIGNoaWxkcmVuIGJlZm9yZSBjYWxsaW5nIGl0IG9uXHJcbiAqICAgcGFyZW50LlxyXG4gKi9cclxuZnVuY3Rpb24gdHJlZUZvckVhY2hEZXNjZW5kYW50KHRyZWUsIGFjdGlvbiwgaW5jbHVkZVNlbGYsIGNoaWxkcmVuRmlyc3QpIHtcclxuICAgIGlmIChpbmNsdWRlU2VsZiAmJiAhY2hpbGRyZW5GaXJzdCkge1xyXG4gICAgICAgIGFjdGlvbih0cmVlKTtcclxuICAgIH1cclxuICAgIHRyZWVGb3JFYWNoQ2hpbGQodHJlZSwgY2hpbGQgPT4ge1xyXG4gICAgICAgIHRyZWVGb3JFYWNoRGVzY2VuZGFudChjaGlsZCwgYWN0aW9uLCB0cnVlLCBjaGlsZHJlbkZpcnN0KTtcclxuICAgIH0pO1xyXG4gICAgaWYgKGluY2x1ZGVTZWxmICYmIGNoaWxkcmVuRmlyc3QpIHtcclxuICAgICAgICBhY3Rpb24odHJlZSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENhbGxzIGFjdGlvbiBvbiBlYWNoIGFuY2VzdG9yIG5vZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBhY3Rpb24gLSBBY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGVhY2ggcGFyZW50OyByZXR1cm5cclxuICogICB0cnVlIHRvIGFib3J0LlxyXG4gKiBAcGFyYW0gaW5jbHVkZVNlbGYgLSBXaGV0aGVyIHRvIGNhbGwgYWN0aW9uIG9uIHRoaXMgbm9kZSBhcyB3ZWxsLlxyXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBhY3Rpb24gY2FsbGJhY2sgcmV0dXJuZWQgdHJ1ZS5cclxuICovXHJcbmZ1bmN0aW9uIHRyZWVGb3JFYWNoQW5jZXN0b3IodHJlZSwgYWN0aW9uLCBpbmNsdWRlU2VsZikge1xyXG4gICAgbGV0IG5vZGUgPSBpbmNsdWRlU2VsZiA/IHRyZWUgOiB0cmVlLnBhcmVudDtcclxuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XHJcbiAgICAgICAgaWYgKGFjdGlvbihub2RlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyBUaGUgcGF0aCBvZiB0aGlzIHRyZWUgbm9kZSwgYXMgYSBQYXRoLlxyXG4gKi9cclxuZnVuY3Rpb24gdHJlZUdldFBhdGgodHJlZSkge1xyXG4gICAgcmV0dXJuIG5ldyBQYXRoKHRyZWUucGFyZW50ID09PSBudWxsXHJcbiAgICAgICAgPyB0cmVlLm5hbWVcclxuICAgICAgICA6IHRyZWVHZXRQYXRoKHRyZWUucGFyZW50KSArICcvJyArIHRyZWUubmFtZSk7XHJcbn1cclxuLyoqXHJcbiAqIEFkZHMgb3IgcmVtb3ZlcyB0aGlzIGNoaWxkIGZyb20gaXRzIHBhcmVudCBiYXNlZCBvbiB3aGV0aGVyIGl0J3MgZW1wdHkgb3Igbm90LlxyXG4gKi9cclxuZnVuY3Rpb24gdHJlZVVwZGF0ZVBhcmVudHModHJlZSkge1xyXG4gICAgaWYgKHRyZWUucGFyZW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgdHJlZVVwZGF0ZUNoaWxkKHRyZWUucGFyZW50LCB0cmVlLm5hbWUsIHRyZWUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBZGRzIG9yIHJlbW92ZXMgdGhlIHBhc3NlZCBjaGlsZCB0byB0aGlzIHRyZWUgbm9kZSwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgaXQncyBlbXB0eS5cclxuICpcclxuICogQHBhcmFtIGNoaWxkTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBjaGlsZCB0byB1cGRhdGUuXHJcbiAqIEBwYXJhbSBjaGlsZCAtIFRoZSBjaGlsZCB0byB1cGRhdGUuXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmVlVXBkYXRlQ2hpbGQodHJlZSwgY2hpbGROYW1lLCBjaGlsZCkge1xyXG4gICAgY29uc3QgY2hpbGRFbXB0eSA9IHRyZWVJc0VtcHR5KGNoaWxkKTtcclxuICAgIGNvbnN0IGNoaWxkRXhpc3RzID0gY29udGFpbnModHJlZS5ub2RlLmNoaWxkcmVuLCBjaGlsZE5hbWUpO1xyXG4gICAgaWYgKGNoaWxkRW1wdHkgJiYgY2hpbGRFeGlzdHMpIHtcclxuICAgICAgICBkZWxldGUgdHJlZS5ub2RlLmNoaWxkcmVuW2NoaWxkTmFtZV07XHJcbiAgICAgICAgdHJlZS5ub2RlLmNoaWxkQ291bnQtLTtcclxuICAgICAgICB0cmVlVXBkYXRlUGFyZW50cyh0cmVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCFjaGlsZEVtcHR5ICYmICFjaGlsZEV4aXN0cykge1xyXG4gICAgICAgIHRyZWUubm9kZS5jaGlsZHJlbltjaGlsZE5hbWVdID0gY2hpbGQubm9kZTtcclxuICAgICAgICB0cmVlLm5vZGUuY2hpbGRDb3VudCsrO1xyXG4gICAgICAgIHRyZWVVcGRhdGVQYXJlbnRzKHRyZWUpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUcnVlIGZvciBpbnZhbGlkIEZpcmViYXNlIGtleXNcclxuICovXHJcbmNvbnN0IElOVkFMSURfS0VZX1JFR0VYXyA9IC9bXFxbXFxdLiMkXFwvXFx1MDAwMC1cXHUwMDFGXFx1MDA3Rl0vO1xyXG4vKipcclxuICogVHJ1ZSBmb3IgaW52YWxpZCBGaXJlYmFzZSBwYXRocy5cclxuICogQWxsb3dzICcvJyBpbiBwYXRocy5cclxuICovXHJcbmNvbnN0IElOVkFMSURfUEFUSF9SRUdFWF8gPSAvW1xcW1xcXS4jJFxcdTAwMDAtXFx1MDAxRlxcdTAwN0ZdLztcclxuLyoqXHJcbiAqIE1heGltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8gYWxsb3cgaW4gbGVhZiB2YWx1ZVxyXG4gKi9cclxuY29uc3QgTUFYX0xFQUZfU0laRV8gPSAxMCAqIDEwMjQgKiAxMDI0O1xyXG5jb25zdCBpc1ZhbGlkS2V5ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgcmV0dXJuICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiBrZXkubGVuZ3RoICE9PSAwICYmICFJTlZBTElEX0tFWV9SRUdFWF8udGVzdChrZXkpKTtcclxufTtcclxuY29uc3QgaXNWYWxpZFBhdGhTdHJpbmcgPSBmdW5jdGlvbiAocGF0aFN0cmluZykge1xyXG4gICAgcmV0dXJuICh0eXBlb2YgcGF0aFN0cmluZyA9PT0gJ3N0cmluZycgJiZcclxuICAgICAgICBwYXRoU3RyaW5nLmxlbmd0aCAhPT0gMCAmJlxyXG4gICAgICAgICFJTlZBTElEX1BBVEhfUkVHRVhfLnRlc3QocGF0aFN0cmluZykpO1xyXG59O1xyXG5jb25zdCBpc1ZhbGlkUm9vdFBhdGhTdHJpbmcgPSBmdW5jdGlvbiAocGF0aFN0cmluZykge1xyXG4gICAgaWYgKHBhdGhTdHJpbmcpIHtcclxuICAgICAgICAvLyBBbGxvdyAnLy5pbmZvLycgYXQgdGhlIGJlZ2lubmluZy5cclxuICAgICAgICBwYXRoU3RyaW5nID0gcGF0aFN0cmluZy5yZXBsYWNlKC9eXFwvKlxcLmluZm8oXFwvfCQpLywgJy8nKTtcclxuICAgIH1cclxuICAgIHJldHVybiBpc1ZhbGlkUGF0aFN0cmluZyhwYXRoU3RyaW5nKTtcclxufTtcclxuY29uc3QgaXNWYWxpZFByaW9yaXR5ID0gZnVuY3Rpb24gKHByaW9yaXR5KSB7XHJcbiAgICByZXR1cm4gKHByaW9yaXR5ID09PSBudWxsIHx8XHJcbiAgICAgICAgdHlwZW9mIHByaW9yaXR5ID09PSAnc3RyaW5nJyB8fFxyXG4gICAgICAgICh0eXBlb2YgcHJpb3JpdHkgPT09ICdudW1iZXInICYmICFpc0ludmFsaWRKU09OTnVtYmVyKHByaW9yaXR5KSkgfHxcclxuICAgICAgICAocHJpb3JpdHkgJiZcclxuICAgICAgICAgICAgdHlwZW9mIHByaW9yaXR5ID09PSAnb2JqZWN0JyAmJlxyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICBjb250YWlucyhwcmlvcml0eSwgJy5zdicpKSk7XHJcbn07XHJcbi8qKlxyXG4gKiBQcmUtdmFsaWRhdGUgYSBkYXR1bSBwYXNzZWQgYXMgYW4gYXJndW1lbnQgdG8gRmlyZWJhc2UgZnVuY3Rpb24uXHJcbiAqL1xyXG5jb25zdCB2YWxpZGF0ZUZpcmViYXNlRGF0YUFyZyA9IGZ1bmN0aW9uIChmbk5hbWUsIHZhbHVlLCBwYXRoLCBvcHRpb25hbCkge1xyXG4gICAgaWYgKG9wdGlvbmFsICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YWxpZGF0ZUZpcmViYXNlRGF0YShlcnJvclByZWZpeChmbk5hbWUsICd2YWx1ZScpLCB2YWx1ZSwgcGF0aCk7XHJcbn07XHJcbi8qKlxyXG4gKiBWYWxpZGF0ZSBhIGRhdGEgb2JqZWN0IGNsaWVudC1zaWRlIGJlZm9yZSBzZW5kaW5nIHRvIHNlcnZlci5cclxuICovXHJcbmNvbnN0IHZhbGlkYXRlRmlyZWJhc2VEYXRhID0gZnVuY3Rpb24gKGVycm9yUHJlZml4LCBkYXRhLCBwYXRoXykge1xyXG4gICAgY29uc3QgcGF0aCA9IHBhdGhfIGluc3RhbmNlb2YgUGF0aCA/IG5ldyBWYWxpZGF0aW9uUGF0aChwYXRoXywgZXJyb3JQcmVmaXgpIDogcGF0aF87XHJcbiAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4ICsgJ2NvbnRhaW5zIHVuZGVmaW5lZCAnICsgdmFsaWRhdGlvblBhdGhUb0Vycm9yU3RyaW5nKHBhdGgpKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeCArXHJcbiAgICAgICAgICAgICdjb250YWlucyBhIGZ1bmN0aW9uICcgK1xyXG4gICAgICAgICAgICB2YWxpZGF0aW9uUGF0aFRvRXJyb3JTdHJpbmcocGF0aCkgK1xyXG4gICAgICAgICAgICAnIHdpdGggY29udGVudHMgPSAnICtcclxuICAgICAgICAgICAgZGF0YS50b1N0cmluZygpKTtcclxuICAgIH1cclxuICAgIGlmIChpc0ludmFsaWRKU09OTnVtYmVyKGRhdGEpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4ICtcclxuICAgICAgICAgICAgJ2NvbnRhaW5zICcgK1xyXG4gICAgICAgICAgICBkYXRhLnRvU3RyaW5nKCkgK1xyXG4gICAgICAgICAgICAnICcgK1xyXG4gICAgICAgICAgICB2YWxpZGF0aW9uUGF0aFRvRXJyb3JTdHJpbmcocGF0aCkpO1xyXG4gICAgfVxyXG4gICAgLy8gQ2hlY2sgbWF4IGxlYWYgc2l6ZSwgYnV0IHRyeSB0byBhdm9pZCB0aGUgdXRmOCBjb252ZXJzaW9uIGlmIHdlIGNhbi5cclxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgJiZcclxuICAgICAgICBkYXRhLmxlbmd0aCA+IE1BWF9MRUFGX1NJWkVfIC8gMyAmJlxyXG4gICAgICAgIHN0cmluZ0xlbmd0aChkYXRhKSA+IE1BWF9MRUFGX1NJWkVfKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4ICtcclxuICAgICAgICAgICAgJ2NvbnRhaW5zIGEgc3RyaW5nIGdyZWF0ZXIgdGhhbiAnICtcclxuICAgICAgICAgICAgTUFYX0xFQUZfU0laRV8gK1xyXG4gICAgICAgICAgICAnIHV0ZjggYnl0ZXMgJyArXHJcbiAgICAgICAgICAgIHZhbGlkYXRpb25QYXRoVG9FcnJvclN0cmluZyhwYXRoKSArXHJcbiAgICAgICAgICAgIFwiICgnXCIgK1xyXG4gICAgICAgICAgICBkYXRhLnN1YnN0cmluZygwLCA1MCkgK1xyXG4gICAgICAgICAgICBcIi4uLicpXCIpO1xyXG4gICAgfVxyXG4gICAgLy8gVE9ETyA9IFBlcmYgPSBDb25zaWRlciBjb21iaW5pbmcgdGhlIHJlY3Vyc2l2ZSB2YWxpZGF0aW9uIG9mIGtleXMgaW50byBOb2RlRnJvbUpTT05cclxuICAgIC8vIHRvIHNhdmUgZXh0cmEgd2Fsa2luZyBvZiBsYXJnZSBvYmplY3RzLlxyXG4gICAgaWYgKGRhdGEgJiYgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgbGV0IGhhc0RvdFZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IGhhc0FjdHVhbENoaWxkID0gZmFsc2U7XHJcbiAgICAgICAgZWFjaChkYXRhLCAoa2V5LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnLnZhbHVlJykge1xyXG4gICAgICAgICAgICAgICAgaGFzRG90VmFsdWUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJy5wcmlvcml0eScgJiYga2V5ICE9PSAnLnN2Jykge1xyXG4gICAgICAgICAgICAgICAgaGFzQWN0dWFsQ2hpbGQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkS2V5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXggK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnIGNvbnRhaW5zIGFuIGludmFsaWQga2V5ICgnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5ICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJykgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25QYXRoVG9FcnJvclN0cmluZyhwYXRoKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICcuICBLZXlzIG11c3QgYmUgbm9uLWVtcHR5IHN0cmluZ3MgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdhbmQgY2FuXFwndCBjb250YWluIFwiLlwiLCBcIiNcIiwgXCIkXCIsIFwiL1wiLCBcIltcIiwgb3IgXCJdXCInKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YWxpZGF0aW9uUGF0aFB1c2gocGF0aCwga2V5KTtcclxuICAgICAgICAgICAgdmFsaWRhdGVGaXJlYmFzZURhdGEoZXJyb3JQcmVmaXgsIHZhbHVlLCBwYXRoKTtcclxuICAgICAgICAgICAgdmFsaWRhdGlvblBhdGhQb3AocGF0aCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGhhc0RvdFZhbHVlICYmIGhhc0FjdHVhbENoaWxkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeCArXHJcbiAgICAgICAgICAgICAgICAnIGNvbnRhaW5zIFwiLnZhbHVlXCIgY2hpbGQgJyArXHJcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUGF0aFRvRXJyb3JTdHJpbmcocGF0aCkgK1xyXG4gICAgICAgICAgICAgICAgJyBpbiBhZGRpdGlvbiB0byBhY3R1YWwgY2hpbGRyZW4uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogUHJlLXZhbGlkYXRlIHBhdGhzIHBhc3NlZCBpbiB0aGUgZmlyZWJhc2UgZnVuY3Rpb24uXHJcbiAqL1xyXG5jb25zdCB2YWxpZGF0ZUZpcmViYXNlTWVyZ2VQYXRocyA9IGZ1bmN0aW9uIChlcnJvclByZWZpeCwgbWVyZ2VQYXRocykge1xyXG4gICAgbGV0IGksIGN1clBhdGg7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbWVyZ2VQYXRocy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGN1clBhdGggPSBtZXJnZVBhdGhzW2ldO1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBwYXRoU2xpY2UoY3VyUGF0aCk7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIGlmIChrZXlzW2pdID09PSAnLnByaW9yaXR5JyAmJiBqID09PSBrZXlzLmxlbmd0aCAtIDEpIDtcclxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzVmFsaWRLZXkoa2V5c1tqXSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeCArXHJcbiAgICAgICAgICAgICAgICAgICAgJ2NvbnRhaW5zIGFuIGludmFsaWQga2V5ICgnICtcclxuICAgICAgICAgICAgICAgICAgICBrZXlzW2pdICtcclxuICAgICAgICAgICAgICAgICAgICAnKSBpbiBwYXRoICcgK1xyXG4gICAgICAgICAgICAgICAgICAgIGN1clBhdGgudG9TdHJpbmcoKSArXHJcbiAgICAgICAgICAgICAgICAgICAgJy4gS2V5cyBtdXN0IGJlIG5vbi1lbXB0eSBzdHJpbmdzICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdhbmQgY2FuXFwndCBjb250YWluIFwiLlwiLCBcIiNcIiwgXCIkXCIsIFwiL1wiLCBcIltcIiwgb3IgXCJdXCInKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIENoZWNrIHRoYXQgdXBkYXRlIGtleXMgYXJlIG5vdCBkZXNjZW5kYW50cyBvZiBlYWNoIG90aGVyLlxyXG4gICAgLy8gV2UgcmVseSBvbiB0aGUgcHJvcGVydHkgdGhhdCBzb3J0aW5nIGd1YXJhbnRlZXMgdGhhdCBhbmNlc3RvcnMgY29tZVxyXG4gICAgLy8gcmlnaHQgYmVmb3JlIGRlc2NlbmRhbnRzLlxyXG4gICAgbWVyZ2VQYXRocy5zb3J0KHBhdGhDb21wYXJlKTtcclxuICAgIGxldCBwcmV2UGF0aCA9IG51bGw7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbWVyZ2VQYXRocy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGN1clBhdGggPSBtZXJnZVBhdGhzW2ldO1xyXG4gICAgICAgIGlmIChwcmV2UGF0aCAhPT0gbnVsbCAmJiBwYXRoQ29udGFpbnMocHJldlBhdGgsIGN1clBhdGgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeCArXHJcbiAgICAgICAgICAgICAgICAnY29udGFpbnMgYSBwYXRoICcgK1xyXG4gICAgICAgICAgICAgICAgcHJldlBhdGgudG9TdHJpbmcoKSArXHJcbiAgICAgICAgICAgICAgICAnIHRoYXQgaXMgYW5jZXN0b3Igb2YgYW5vdGhlciBwYXRoICcgK1xyXG4gICAgICAgICAgICAgICAgY3VyUGF0aC50b1N0cmluZygpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJldlBhdGggPSBjdXJQYXRoO1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogcHJlLXZhbGlkYXRlIGFuIG9iamVjdCBwYXNzZWQgYXMgYW4gYXJndW1lbnQgdG8gZmlyZWJhc2UgZnVuY3Rpb24gKFxyXG4gKiBtdXN0IGJlIGFuIG9iamVjdCAtIGUuZy4gZm9yIGZpcmViYXNlLnVwZGF0ZSgpKS5cclxuICovXHJcbmNvbnN0IHZhbGlkYXRlRmlyZWJhc2VNZXJnZURhdGFBcmcgPSBmdW5jdGlvbiAoZm5OYW1lLCBkYXRhLCBwYXRoLCBvcHRpb25hbCkge1xyXG4gICAgaWYgKG9wdGlvbmFsICYmIGRhdGEgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IGVycm9yUHJlZml4JDEgPSBlcnJvclByZWZpeChmbk5hbWUsICd2YWx1ZXMnKTtcclxuICAgIGlmICghKGRhdGEgJiYgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSB8fCBBcnJheS5pc0FycmF5KGRhdGEpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4JDEgKyAnIG11c3QgYmUgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNoaWxkcmVuIHRvIHJlcGxhY2UuJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBtZXJnZVBhdGhzID0gW107XHJcbiAgICBlYWNoKGRhdGEsIChrZXksIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY3VyUGF0aCA9IG5ldyBQYXRoKGtleSk7XHJcbiAgICAgICAgdmFsaWRhdGVGaXJlYmFzZURhdGEoZXJyb3JQcmVmaXgkMSwgdmFsdWUsIHBhdGhDaGlsZChwYXRoLCBjdXJQYXRoKSk7XHJcbiAgICAgICAgaWYgKHBhdGhHZXRCYWNrKGN1clBhdGgpID09PSAnLnByaW9yaXR5Jykge1xyXG4gICAgICAgICAgICBpZiAoIWlzVmFsaWRQcmlvcml0eSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeCQxICtcclxuICAgICAgICAgICAgICAgICAgICBcImNvbnRhaW5zIGFuIGludmFsaWQgdmFsdWUgZm9yICdcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgY3VyUGF0aC50b1N0cmluZygpICtcclxuICAgICAgICAgICAgICAgICAgICBcIicsIHdoaWNoIG11c3QgYmUgYSB2YWxpZCBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgJ0ZpcmViYXNlIHByaW9yaXR5IChhIHN0cmluZywgZmluaXRlIG51bWJlciwgc2VydmVyIHZhbHVlLCBvciBudWxsKS4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBtZXJnZVBhdGhzLnB1c2goY3VyUGF0aCk7XHJcbiAgICB9KTtcclxuICAgIHZhbGlkYXRlRmlyZWJhc2VNZXJnZVBhdGhzKGVycm9yUHJlZml4JDEsIG1lcmdlUGF0aHMpO1xyXG59O1xyXG5jb25zdCB2YWxpZGF0ZVByaW9yaXR5ID0gZnVuY3Rpb24gKGZuTmFtZSwgcHJpb3JpdHksIG9wdGlvbmFsKSB7XHJcbiAgICBpZiAob3B0aW9uYWwgJiYgcHJpb3JpdHkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChpc0ludmFsaWRKU09OTnVtYmVyKHByaW9yaXR5KSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeChmbk5hbWUsICdwcmlvcml0eScpICtcclxuICAgICAgICAgICAgJ2lzICcgK1xyXG4gICAgICAgICAgICBwcmlvcml0eS50b1N0cmluZygpICtcclxuICAgICAgICAgICAgJywgYnV0IG11c3QgYmUgYSB2YWxpZCBGaXJlYmFzZSBwcmlvcml0eSAoYSBzdHJpbmcsIGZpbml0ZSBudW1iZXIsICcgK1xyXG4gICAgICAgICAgICAnc2VydmVyIHZhbHVlLCBvciBudWxsKS4nKTtcclxuICAgIH1cclxuICAgIC8vIFNwZWNpYWwgY2FzZSB0byBhbGxvdyBpbXBvcnRpbmcgZGF0YSB3aXRoIGEgLnN2LlxyXG4gICAgaWYgKCFpc1ZhbGlkUHJpb3JpdHkocHJpb3JpdHkpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4KGZuTmFtZSwgJ3ByaW9yaXR5JykgK1xyXG4gICAgICAgICAgICAnbXVzdCBiZSBhIHZhbGlkIEZpcmViYXNlIHByaW9yaXR5ICcgK1xyXG4gICAgICAgICAgICAnKGEgc3RyaW5nLCBmaW5pdGUgbnVtYmVyLCBzZXJ2ZXIgdmFsdWUsIG9yIG51bGwpLicpO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCB2YWxpZGF0ZUtleSA9IGZ1bmN0aW9uIChmbk5hbWUsIGFyZ3VtZW50TmFtZSwga2V5LCBvcHRpb25hbCkge1xyXG4gICAgaWYgKG9wdGlvbmFsICYmIGtleSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc1ZhbGlkS2V5KGtleSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE5hbWUpICtcclxuICAgICAgICAgICAgJ3dhcyBhbiBpbnZhbGlkIGtleSA9IFwiJyArXHJcbiAgICAgICAgICAgIGtleSArXHJcbiAgICAgICAgICAgICdcIi4gIEZpcmViYXNlIGtleXMgbXVzdCBiZSBub24tZW1wdHkgc3RyaW5ncyBhbmQgJyArXHJcbiAgICAgICAgICAgICdjYW5cXCd0IGNvbnRhaW4gXCIuXCIsIFwiI1wiLCBcIiRcIiwgXCIvXCIsIFwiW1wiLCBvciBcIl1cIikuJyk7XHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNvbnN0IHZhbGlkYXRlUGF0aFN0cmluZyA9IGZ1bmN0aW9uIChmbk5hbWUsIGFyZ3VtZW50TmFtZSwgcGF0aFN0cmluZywgb3B0aW9uYWwpIHtcclxuICAgIGlmIChvcHRpb25hbCAmJiBwYXRoU3RyaW5nID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzVmFsaWRQYXRoU3RyaW5nKHBhdGhTdHJpbmcpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4KGZuTmFtZSwgYXJndW1lbnROYW1lKSArXHJcbiAgICAgICAgICAgICd3YXMgYW4gaW52YWxpZCBwYXRoID0gXCInICtcclxuICAgICAgICAgICAgcGF0aFN0cmluZyArXHJcbiAgICAgICAgICAgICdcIi4gUGF0aHMgbXVzdCBiZSBub24tZW1wdHkgc3RyaW5ncyBhbmQgJyArXHJcbiAgICAgICAgICAgICdjYW5cXCd0IGNvbnRhaW4gXCIuXCIsIFwiI1wiLCBcIiRcIiwgXCJbXCIsIG9yIFwiXVwiJyk7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IHZhbGlkYXRlUm9vdFBhdGhTdHJpbmcgPSBmdW5jdGlvbiAoZm5OYW1lLCBhcmd1bWVudE5hbWUsIHBhdGhTdHJpbmcsIG9wdGlvbmFsKSB7XHJcbiAgICBpZiAocGF0aFN0cmluZykge1xyXG4gICAgICAgIC8vIEFsbG93ICcvLmluZm8vJyBhdCB0aGUgYmVnaW5uaW5nLlxyXG4gICAgICAgIHBhdGhTdHJpbmcgPSBwYXRoU3RyaW5nLnJlcGxhY2UoL15cXC8qXFwuaW5mbyhcXC98JCkvLCAnLycpO1xyXG4gICAgfVxyXG4gICAgdmFsaWRhdGVQYXRoU3RyaW5nKGZuTmFtZSwgYXJndW1lbnROYW1lLCBwYXRoU3RyaW5nLCBvcHRpb25hbCk7XHJcbn07XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNvbnN0IHZhbGlkYXRlV3JpdGFibGVQYXRoID0gZnVuY3Rpb24gKGZuTmFtZSwgcGF0aCkge1xyXG4gICAgaWYgKHBhdGhHZXRGcm9udChwYXRoKSA9PT0gJy5pbmZvJykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihmbk5hbWUgKyBcIiBmYWlsZWQgPSBDYW4ndCBtb2RpZnkgZGF0YSB1bmRlciAvLmluZm8vXCIpO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCB2YWxpZGF0ZVVybCA9IGZ1bmN0aW9uIChmbk5hbWUsIHBhcnNlZFVybCkge1xyXG4gICAgLy8gVE9ETyA9IFZhbGlkYXRlIHNlcnZlciBiZXR0ZXIuXHJcbiAgICBjb25zdCBwYXRoU3RyaW5nID0gcGFyc2VkVXJsLnBhdGgudG9TdHJpbmcoKTtcclxuICAgIGlmICghKHR5cGVvZiBwYXJzZWRVcmwucmVwb0luZm8uaG9zdCA9PT0gJ3N0cmluZycpIHx8XHJcbiAgICAgICAgcGFyc2VkVXJsLnJlcG9JbmZvLmhvc3QubGVuZ3RoID09PSAwIHx8XHJcbiAgICAgICAgKCFpc1ZhbGlkS2V5KHBhcnNlZFVybC5yZXBvSW5mby5uYW1lc3BhY2UpICYmXHJcbiAgICAgICAgICAgIHBhcnNlZFVybC5yZXBvSW5mby5ob3N0LnNwbGl0KCc6JylbMF0gIT09ICdsb2NhbGhvc3QnKSB8fFxyXG4gICAgICAgIChwYXRoU3RyaW5nLmxlbmd0aCAhPT0gMCAmJiAhaXNWYWxpZFJvb3RQYXRoU3RyaW5nKHBhdGhTdHJpbmcpKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeChmbk5hbWUsICd1cmwnKSArXHJcbiAgICAgICAgICAgICdtdXN0IGJlIGEgdmFsaWQgZmlyZWJhc2UgVVJMIGFuZCAnICtcclxuICAgICAgICAgICAgJ3RoZSBwYXRoIGNhblxcJ3QgY29udGFpbiBcIi5cIiwgXCIjXCIsIFwiJFwiLCBcIltcIiwgb3IgXCJdXCIuJyk7XHJcbiAgICB9XHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUaGUgZXZlbnQgcXVldWUgc2VydmVzIGEgZmV3IHB1cnBvc2VzOlxyXG4gKiAxLiBJdCBlbnN1cmVzIHdlIG1haW50YWluIGV2ZW50IG9yZGVyIGluIHRoZSBmYWNlIG9mIGV2ZW50IGNhbGxiYWNrcyBkb2luZyBvcGVyYXRpb25zIHRoYXQgcmVzdWx0IGluIG1vcmVcclxuICogICAgZXZlbnRzIGJlaW5nIHF1ZXVlZC5cclxuICogMi4gcmFpc2VRdWV1ZWRFdmVudHMoKSBoYW5kbGVzIGJlaW5nIGNhbGxlZCByZWVudHJhbnRseSBuaWNlbHkuICBUaGF0IGlzLCBpZiBpbiB0aGUgY291cnNlIG9mIHJhaXNpbmcgZXZlbnRzLFxyXG4gKiAgICByYWlzZVF1ZXVlZEV2ZW50cygpIGlzIGNhbGxlZCBhZ2FpbiwgdGhlIFwiaW5uZXJcIiBjYWxsIHdpbGwgcGljayB1cCByYWlzaW5nIGV2ZW50cyB3aGVyZSB0aGUgXCJvdXRlclwiIGNhbGxcclxuICogICAgbGVmdCBvZmYsIGVuc3VyaW5nIHRoYXQgdGhlIGV2ZW50cyBhcmUgc3RpbGwgcmFpc2VkIHN5bmNocm9ub3VzbHkgYW5kIGluIG9yZGVyLlxyXG4gKiAzLiBZb3UgY2FuIHVzZSByYWlzZUV2ZW50c0F0UGF0aCBhbmQgcmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aCB0byBlbnN1cmUgb25seSByZWxldmFudCBwcmV2aW91c2x5LXF1ZXVlZFxyXG4gKiAgICBldmVudHMgYXJlIHJhaXNlZCBzeW5jaHJvbm91c2x5LlxyXG4gKlxyXG4gKiBOT1RFOiBUaGlzIGNhbiBhbGwgZ28gYXdheSBpZi93aGVuIHdlIG1vdmUgdG8gYXN5bmMgZXZlbnRzLlxyXG4gKlxyXG4gKi9cclxuY2xhc3MgRXZlbnRRdWV1ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmV2ZW50TGlzdHNfID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVHJhY2tzIHJlY3Vyc2lvbiBkZXB0aCBvZiByYWlzZVF1ZXVlZEV2ZW50c18sIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5yZWN1cnNpb25EZXB0aF8gPSAwO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gZXZlbnREYXRhTGlzdCAtIFRoZSBuZXcgZXZlbnRzIHRvIHF1ZXVlLlxyXG4gKi9cclxuZnVuY3Rpb24gZXZlbnRRdWV1ZVF1ZXVlRXZlbnRzKGV2ZW50UXVldWUsIGV2ZW50RGF0YUxpc3QpIHtcclxuICAgIC8vIFdlIGdyb3VwIGV2ZW50cyBieSBwYXRoLCBzdG9yaW5nIHRoZW0gaW4gYSBzaW5nbGUgRXZlbnRMaXN0LCB0byBtYWtlIGl0IGVhc2llciB0byBza2lwIG92ZXIgdGhlbSBxdWlja2x5LlxyXG4gICAgbGV0IGN1cnJMaXN0ID0gbnVsbDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnREYXRhTGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBldmVudERhdGFMaXN0W2ldO1xyXG4gICAgICAgIGNvbnN0IHBhdGggPSBkYXRhLmdldFBhdGgoKTtcclxuICAgICAgICBpZiAoY3Vyckxpc3QgIT09IG51bGwgJiYgIXBhdGhFcXVhbHMocGF0aCwgY3Vyckxpc3QucGF0aCkpIHtcclxuICAgICAgICAgICAgZXZlbnRRdWV1ZS5ldmVudExpc3RzXy5wdXNoKGN1cnJMaXN0KTtcclxuICAgICAgICAgICAgY3Vyckxpc3QgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY3Vyckxpc3QgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgY3Vyckxpc3QgPSB7IGV2ZW50czogW10sIHBhdGggfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3Vyckxpc3QuZXZlbnRzLnB1c2goZGF0YSk7XHJcbiAgICB9XHJcbiAgICBpZiAoY3Vyckxpc3QpIHtcclxuICAgICAgICBldmVudFF1ZXVlLmV2ZW50TGlzdHNfLnB1c2goY3Vyckxpc3QpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBRdWV1ZXMgdGhlIHNwZWNpZmllZCBldmVudHMgYW5kIHN5bmNocm9ub3VzbHkgcmFpc2VzIGFsbCBldmVudHMgKGluY2x1ZGluZyBwcmV2aW91c2x5IHF1ZXVlZCBvbmVzKVxyXG4gKiBmb3IgdGhlIHNwZWNpZmllZCBwYXRoLlxyXG4gKlxyXG4gKiBJdCBpcyBhc3N1bWVkIHRoYXQgdGhlIG5ldyBldmVudHMgYXJlIGFsbCBmb3IgdGhlIHNwZWNpZmllZCBwYXRoLlxyXG4gKlxyXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHRvIHJhaXNlIGV2ZW50cyBmb3IuXHJcbiAqIEBwYXJhbSBldmVudERhdGFMaXN0IC0gVGhlIG5ldyBldmVudHMgdG8gcmFpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBldmVudFF1ZXVlUmFpc2VFdmVudHNBdFBhdGgoZXZlbnRRdWV1ZSwgcGF0aCwgZXZlbnREYXRhTGlzdCkge1xyXG4gICAgZXZlbnRRdWV1ZVF1ZXVlRXZlbnRzKGV2ZW50UXVldWUsIGV2ZW50RGF0YUxpc3QpO1xyXG4gICAgZXZlbnRRdWV1ZVJhaXNlUXVldWVkRXZlbnRzTWF0Y2hpbmdQcmVkaWNhdGUoZXZlbnRRdWV1ZSwgZXZlbnRQYXRoID0+IHBhdGhFcXVhbHMoZXZlbnRQYXRoLCBwYXRoKSk7XHJcbn1cclxuLyoqXHJcbiAqIFF1ZXVlcyB0aGUgc3BlY2lmaWVkIGV2ZW50cyBhbmQgc3luY2hyb25vdXNseSByYWlzZXMgYWxsIGV2ZW50cyAoaW5jbHVkaW5nIHByZXZpb3VzbHkgcXVldWVkIG9uZXMpIGZvclxyXG4gKiBsb2NhdGlvbnMgcmVsYXRlZCB0byB0aGUgc3BlY2lmaWVkIGNoYW5nZSBwYXRoIChpLmUuIGFsbCBhbmNlc3RvcnMgYW5kIGRlc2NlbmRhbnRzKS5cclxuICpcclxuICogSXQgaXMgYXNzdW1lZCB0aGF0IHRoZSBuZXcgZXZlbnRzIGFyZSBhbGwgcmVsYXRlZCAoYW5jZXN0b3Igb3IgZGVzY2VuZGFudCkgdG8gdGhlIHNwZWNpZmllZCBwYXRoLlxyXG4gKlxyXG4gKiBAcGFyYW0gY2hhbmdlZFBhdGggLSBUaGUgcGF0aCB0byByYWlzZSBldmVudHMgZm9yLlxyXG4gKiBAcGFyYW0gZXZlbnREYXRhTGlzdCAtIFRoZSBldmVudHMgdG8gcmFpc2VcclxuICovXHJcbmZ1bmN0aW9uIGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKGV2ZW50UXVldWUsIGNoYW5nZWRQYXRoLCBldmVudERhdGFMaXN0KSB7XHJcbiAgICBldmVudFF1ZXVlUXVldWVFdmVudHMoZXZlbnRRdWV1ZSwgZXZlbnREYXRhTGlzdCk7XHJcbiAgICBldmVudFF1ZXVlUmFpc2VRdWV1ZWRFdmVudHNNYXRjaGluZ1ByZWRpY2F0ZShldmVudFF1ZXVlLCBldmVudFBhdGggPT4gcGF0aENvbnRhaW5zKGV2ZW50UGF0aCwgY2hhbmdlZFBhdGgpIHx8XHJcbiAgICAgICAgcGF0aENvbnRhaW5zKGNoYW5nZWRQYXRoLCBldmVudFBhdGgpKTtcclxufVxyXG5mdW5jdGlvbiBldmVudFF1ZXVlUmFpc2VRdWV1ZWRFdmVudHNNYXRjaGluZ1ByZWRpY2F0ZShldmVudFF1ZXVlLCBwcmVkaWNhdGUpIHtcclxuICAgIGV2ZW50UXVldWUucmVjdXJzaW9uRGVwdGhfKys7XHJcbiAgICBsZXQgc2VudEFsbCA9IHRydWU7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50UXVldWUuZXZlbnRMaXN0c18ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBldmVudExpc3QgPSBldmVudFF1ZXVlLmV2ZW50TGlzdHNfW2ldO1xyXG4gICAgICAgIGlmIChldmVudExpc3QpIHtcclxuICAgICAgICAgICAgY29uc3QgZXZlbnRQYXRoID0gZXZlbnRMaXN0LnBhdGg7XHJcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoZXZlbnRQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnRMaXN0UmFpc2UoZXZlbnRRdWV1ZS5ldmVudExpc3RzX1tpXSk7XHJcbiAgICAgICAgICAgICAgICBldmVudFF1ZXVlLmV2ZW50TGlzdHNfW2ldID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNlbnRBbGwgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChzZW50QWxsKSB7XHJcbiAgICAgICAgZXZlbnRRdWV1ZS5ldmVudExpc3RzXyA9IFtdO1xyXG4gICAgfVxyXG4gICAgZXZlbnRRdWV1ZS5yZWN1cnNpb25EZXB0aF8tLTtcclxufVxyXG4vKipcclxuICogSXRlcmF0ZXMgdGhyb3VnaCB0aGUgbGlzdCBhbmQgcmFpc2VzIGVhY2ggZXZlbnRcclxuICovXHJcbmZ1bmN0aW9uIGV2ZW50TGlzdFJhaXNlKGV2ZW50TGlzdCkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudExpc3QuZXZlbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgZXZlbnREYXRhID0gZXZlbnRMaXN0LmV2ZW50c1tpXTtcclxuICAgICAgICBpZiAoZXZlbnREYXRhICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGV2ZW50TGlzdC5ldmVudHNbaV0gPSBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBldmVudEZuID0gZXZlbnREYXRhLmdldEV2ZW50UnVubmVyKCk7XHJcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIHtcclxuICAgICAgICAgICAgICAgIGxvZygnZXZlbnQ6ICcgKyBldmVudERhdGEudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZXhjZXB0aW9uR3VhcmQoZXZlbnRGbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IElOVEVSUlVQVF9SRUFTT04gPSAncmVwb19pbnRlcnJ1cHQnO1xyXG4vKipcclxuICogSWYgYSB0cmFuc2FjdGlvbiBkb2VzIG5vdCBzdWNjZWVkIGFmdGVyIDI1IHJldHJpZXMsIHdlIGFib3J0IGl0LiBBbW9uZyBvdGhlclxyXG4gKiB0aGluZ3MgdGhpcyBlbnN1cmUgdGhhdCBpZiB0aGVyZSdzIGV2ZXIgYSBidWcgY2F1c2luZyBhIG1pc21hdGNoIGJldHdlZW5cclxuICogY2xpZW50IC8gc2VydmVyIGhhc2hlcyBmb3Igc29tZSBkYXRhLCB3ZSB3b24ndCByZXRyeSBpbmRlZmluaXRlbHkuXHJcbiAqL1xyXG5jb25zdCBNQVhfVFJBTlNBQ1RJT05fUkVUUklFUyA9IDI1O1xyXG4vKipcclxuICogQSBjb25uZWN0aW9uIHRvIGEgc2luZ2xlIGRhdGEgcmVwb3NpdG9yeS5cclxuICovXHJcbmNsYXNzIFJlcG8ge1xyXG4gICAgY29uc3RydWN0b3IocmVwb0luZm9fLCBmb3JjZVJlc3RDbGllbnRfLCBhdXRoVG9rZW5Qcm92aWRlcl8sIGFwcENoZWNrUHJvdmlkZXJfKSB7XHJcbiAgICAgICAgdGhpcy5yZXBvSW5mb18gPSByZXBvSW5mb187XHJcbiAgICAgICAgdGhpcy5mb3JjZVJlc3RDbGllbnRfID0gZm9yY2VSZXN0Q2xpZW50XztcclxuICAgICAgICB0aGlzLmF1dGhUb2tlblByb3ZpZGVyXyA9IGF1dGhUb2tlblByb3ZpZGVyXztcclxuICAgICAgICB0aGlzLmFwcENoZWNrUHJvdmlkZXJfID0gYXBwQ2hlY2tQcm92aWRlcl87XHJcbiAgICAgICAgdGhpcy5kYXRhVXBkYXRlQ291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMuc3RhdHNMaXN0ZW5lcl8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZV8gPSBuZXcgRXZlbnRRdWV1ZSgpO1xyXG4gICAgICAgIHRoaXMubmV4dFdyaXRlSWRfID0gMTtcclxuICAgICAgICB0aGlzLmludGVyY2VwdFNlcnZlckRhdGFDYWxsYmFja18gPSBudWxsO1xyXG4gICAgICAgIC8qKiBBIGxpc3Qgb2YgZGF0YSBwaWVjZXMgYW5kIHBhdGhzIHRvIGJlIHNldCB3aGVuIHRoaXMgY2xpZW50IGRpc2Nvbm5lY3RzLiAqL1xyXG4gICAgICAgIHRoaXMub25EaXNjb25uZWN0XyA9IG5ld1NwYXJzZVNuYXBzaG90VHJlZSgpO1xyXG4gICAgICAgIC8qKiBTdG9yZXMgcXVldWVzIG9mIG91dHN0YW5kaW5nIHRyYW5zYWN0aW9ucyBmb3IgRmlyZWJhc2UgbG9jYXRpb25zLiAqL1xyXG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb25RdWV1ZVRyZWVfID0gbmV3IFRyZWUoKTtcclxuICAgICAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCBiZSBAcHJpdmF0ZSBidXQgaXQncyB1c2VkIGJ5IHRlc3RfYWNjZXNzLmpzIGFuZCBpbnRlcm5hbC5qc1xyXG4gICAgICAgIHRoaXMucGVyc2lzdGVudENvbm5lY3Rpb25fID0gbnVsbDtcclxuICAgICAgICAvLyBUaGlzIGtleSBpcyBpbnRlbnRpb25hbGx5IG5vdCB1cGRhdGVkIGlmIFJlcG9JbmZvIGlzIGxhdGVyIGNoYW5nZWQgb3IgcmVwbGFjZWRcclxuICAgICAgICB0aGlzLmtleSA9IHRoaXMucmVwb0luZm9fLnRvVVJMU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRoZSBVUkwgY29ycmVzcG9uZGluZyB0byB0aGUgcm9vdCBvZiB0aGlzIEZpcmViYXNlLlxyXG4gICAgICovXHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gKCh0aGlzLnJlcG9JbmZvXy5zZWN1cmUgPyAnaHR0cHM6Ly8nIDogJ2h0dHA6Ly8nKSArIHRoaXMucmVwb0luZm9fLmhvc3QpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlcG9TdGFydChyZXBvLCBhcHBJZCwgYXV0aE92ZXJyaWRlKSB7XHJcbiAgICByZXBvLnN0YXRzXyA9IHN0YXRzTWFuYWdlckdldENvbGxlY3Rpb24ocmVwby5yZXBvSW5mb18pO1xyXG4gICAgaWYgKHJlcG8uZm9yY2VSZXN0Q2xpZW50XyB8fCBiZWluZ0NyYXdsZWQoKSkge1xyXG4gICAgICAgIHJlcG8uc2VydmVyXyA9IG5ldyBSZWFkb25seVJlc3RDbGllbnQocmVwby5yZXBvSW5mb18sIChwYXRoU3RyaW5nLCBkYXRhLCBpc01lcmdlLCB0YWcpID0+IHtcclxuICAgICAgICAgICAgcmVwb09uRGF0YVVwZGF0ZShyZXBvLCBwYXRoU3RyaW5nLCBkYXRhLCBpc01lcmdlLCB0YWcpO1xyXG4gICAgICAgIH0sIHJlcG8uYXV0aFRva2VuUHJvdmlkZXJfLCByZXBvLmFwcENoZWNrUHJvdmlkZXJfKTtcclxuICAgICAgICAvLyBNaW5vciBoYWNrOiBGaXJlIG9uQ29ubmVjdCBpbW1lZGlhdGVseSwgc2luY2UgdGhlcmUncyBubyBhY3R1YWwgY29ubmVjdGlvbi5cclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHJlcG9PbkNvbm5lY3RTdGF0dXMocmVwbywgLyogY29ubmVjdFN0YXR1cz0gKi8gdHJ1ZSksIDApO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gVmFsaWRhdGUgYXV0aE92ZXJyaWRlXHJcbiAgICAgICAgaWYgKHR5cGVvZiBhdXRoT3ZlcnJpZGUgIT09ICd1bmRlZmluZWQnICYmIGF1dGhPdmVycmlkZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGF1dGhPdmVycmlkZSAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBvYmplY3RzIGFyZSBzdXBwb3J0ZWQgZm9yIG9wdGlvbiBkYXRhYmFzZUF1dGhWYXJpYWJsZU92ZXJyaWRlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShhdXRoT3ZlcnJpZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXV0aE92ZXJyaWRlIHByb3ZpZGVkOiAnICsgZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmVwby5wZXJzaXN0ZW50Q29ubmVjdGlvbl8gPSBuZXcgUGVyc2lzdGVudENvbm5lY3Rpb24ocmVwby5yZXBvSW5mb18sIGFwcElkLCAocGF0aFN0cmluZywgZGF0YSwgaXNNZXJnZSwgdGFnKSA9PiB7XHJcbiAgICAgICAgICAgIHJlcG9PbkRhdGFVcGRhdGUocmVwbywgcGF0aFN0cmluZywgZGF0YSwgaXNNZXJnZSwgdGFnKTtcclxuICAgICAgICB9LCAoY29ubmVjdFN0YXR1cykgPT4ge1xyXG4gICAgICAgICAgICByZXBvT25Db25uZWN0U3RhdHVzKHJlcG8sIGNvbm5lY3RTdGF0dXMpO1xyXG4gICAgICAgIH0sICh1cGRhdGVzKSA9PiB7XHJcbiAgICAgICAgICAgIHJlcG9PblNlcnZlckluZm9VcGRhdGUocmVwbywgdXBkYXRlcyk7XHJcbiAgICAgICAgfSwgcmVwby5hdXRoVG9rZW5Qcm92aWRlcl8sIHJlcG8uYXBwQ2hlY2tQcm92aWRlcl8sIGF1dGhPdmVycmlkZSk7XHJcbiAgICAgICAgcmVwby5zZXJ2ZXJfID0gcmVwby5wZXJzaXN0ZW50Q29ubmVjdGlvbl87XHJcbiAgICB9XHJcbiAgICByZXBvLmF1dGhUb2tlblByb3ZpZGVyXy5hZGRUb2tlbkNoYW5nZUxpc3RlbmVyKHRva2VuID0+IHtcclxuICAgICAgICByZXBvLnNlcnZlcl8ucmVmcmVzaEF1dGhUb2tlbih0b2tlbik7XHJcbiAgICB9KTtcclxuICAgIHJlcG8uYXBwQ2hlY2tQcm92aWRlcl8uYWRkVG9rZW5DaGFuZ2VMaXN0ZW5lcihyZXN1bHQgPT4ge1xyXG4gICAgICAgIHJlcG8uc2VydmVyXy5yZWZyZXNoQXBwQ2hlY2tUb2tlbihyZXN1bHQudG9rZW4pO1xyXG4gICAgfSk7XHJcbiAgICAvLyBJbiB0aGUgY2FzZSBvZiBtdWx0aXBsZSBSZXBvcyBmb3IgdGhlIHNhbWUgcmVwb0luZm8gKGkuZS4gdGhlcmUgYXJlIG11bHRpcGxlIEZpcmViYXNlLkNvbnRleHRzIGJlaW5nIHVzZWQpLFxyXG4gICAgLy8gd2Ugb25seSB3YW50IHRvIGNyZWF0ZSBvbmUgU3RhdHNSZXBvcnRlci4gIEFzIHN1Y2gsIHdlJ2xsIHJlcG9ydCBzdGF0cyBvdmVyIHRoZSBmaXJzdCBSZXBvIGNyZWF0ZWQuXHJcbiAgICByZXBvLnN0YXRzUmVwb3J0ZXJfID0gc3RhdHNNYW5hZ2VyR2V0T3JDcmVhdGVSZXBvcnRlcihyZXBvLnJlcG9JbmZvXywgKCkgPT4gbmV3IFN0YXRzUmVwb3J0ZXIocmVwby5zdGF0c18sIHJlcG8uc2VydmVyXykpO1xyXG4gICAgLy8gVXNlZCBmb3IgLmluZm8uXHJcbiAgICByZXBvLmluZm9EYXRhXyA9IG5ldyBTbmFwc2hvdEhvbGRlcigpO1xyXG4gICAgcmVwby5pbmZvU3luY1RyZWVfID0gbmV3IFN5bmNUcmVlKHtcclxuICAgICAgICBzdGFydExpc3RlbmluZzogKHF1ZXJ5LCB0YWcsIGN1cnJlbnRIYXNoRm4sIG9uQ29tcGxldGUpID0+IHtcclxuICAgICAgICAgICAgbGV0IGluZm9FdmVudHMgPSBbXTtcclxuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHJlcG8uaW5mb0RhdGFfLmdldE5vZGUocXVlcnkuX3BhdGgpO1xyXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHBvc3NpYmx5IGEgaGFjaywgYnV0IHdlIGhhdmUgZGlmZmVyZW50IHNlbWFudGljcyBmb3IgLmluZm8gZW5kcG9pbnRzLiBXZSBkb24ndCByYWlzZSBudWxsIGV2ZW50c1xyXG4gICAgICAgICAgICAvLyBvbiBpbml0aWFsIGRhdGEuLi5cclxuICAgICAgICAgICAgaWYgKCFub2RlLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgaW5mb0V2ZW50cyA9IHN5bmNUcmVlQXBwbHlTZXJ2ZXJPdmVyd3JpdGUocmVwby5pbmZvU3luY1RyZWVfLCBxdWVyeS5fcGF0aCwgbm9kZSk7XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBvbkNvbXBsZXRlKCdvaycpO1xyXG4gICAgICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGluZm9FdmVudHM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdG9wTGlzdGVuaW5nOiAoKSA9PiB7IH1cclxuICAgIH0pO1xyXG4gICAgcmVwb1VwZGF0ZUluZm8ocmVwbywgJ2Nvbm5lY3RlZCcsIGZhbHNlKTtcclxuICAgIHJlcG8uc2VydmVyU3luY1RyZWVfID0gbmV3IFN5bmNUcmVlKHtcclxuICAgICAgICBzdGFydExpc3RlbmluZzogKHF1ZXJ5LCB0YWcsIGN1cnJlbnRIYXNoRm4sIG9uQ29tcGxldGUpID0+IHtcclxuICAgICAgICAgICAgcmVwby5zZXJ2ZXJfLmxpc3RlbihxdWVyeSwgY3VycmVudEhhc2hGbiwgdGFnLCAoc3RhdHVzLCBkYXRhKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudHMgPSBvbkNvbXBsZXRlKHN0YXR1cywgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICBldmVudFF1ZXVlUmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChyZXBvLmV2ZW50UXVldWVfLCBxdWVyeS5fcGF0aCwgZXZlbnRzKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIE5vIHN5bmNocm9ub3VzIGV2ZW50cyBmb3IgbmV0d29yay1iYWNrZWQgc3luYyB0cmVlc1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdG9wTGlzdGVuaW5nOiAocXVlcnksIHRhZykgPT4ge1xyXG4gICAgICAgICAgICByZXBvLnNlcnZlcl8udW5saXN0ZW4ocXVlcnksIHRhZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcywgdGFraW5nIHRoZSBzZXJ2ZXIgb2Zmc2V0IGludG8gYWNjb3VudCBpZiB3ZSBoYXZlIG9uZS5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9TZXJ2ZXJUaW1lKHJlcG8pIHtcclxuICAgIGNvbnN0IG9mZnNldE5vZGUgPSByZXBvLmluZm9EYXRhXy5nZXROb2RlKG5ldyBQYXRoKCcuaW5mby9zZXJ2ZXJUaW1lT2Zmc2V0JykpO1xyXG4gICAgY29uc3Qgb2Zmc2V0ID0gb2Zmc2V0Tm9kZS52YWwoKSB8fCAwO1xyXG4gICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgb2Zmc2V0O1xyXG59XHJcbi8qKlxyXG4gKiBHZW5lcmF0ZSBTZXJ2ZXJWYWx1ZXMgdXNpbmcgc29tZSB2YXJpYWJsZXMgZnJvbSB0aGUgcmVwbyBvYmplY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvR2VuZXJhdGVTZXJ2ZXJWYWx1ZXMocmVwbykge1xyXG4gICAgcmV0dXJuIGdlbmVyYXRlV2l0aFZhbHVlcyh7XHJcbiAgICAgICAgdGltZXN0YW1wOiByZXBvU2VydmVyVGltZShyZXBvKVxyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIENhbGxlZCBieSByZWFsdGltZSB3aGVuIHdlIGdldCBuZXcgbWVzc2FnZXMgZnJvbSB0aGUgc2VydmVyLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb09uRGF0YVVwZGF0ZShyZXBvLCBwYXRoU3RyaW5nLCBkYXRhLCBpc01lcmdlLCB0YWcpIHtcclxuICAgIC8vIEZvciB0ZXN0aW5nLlxyXG4gICAgcmVwby5kYXRhVXBkYXRlQ291bnQrKztcclxuICAgIGNvbnN0IHBhdGggPSBuZXcgUGF0aChwYXRoU3RyaW5nKTtcclxuICAgIGRhdGEgPSByZXBvLmludGVyY2VwdFNlcnZlckRhdGFDYWxsYmFja19cclxuICAgICAgICA/IHJlcG8uaW50ZXJjZXB0U2VydmVyRGF0YUNhbGxiYWNrXyhwYXRoU3RyaW5nLCBkYXRhKVxyXG4gICAgICAgIDogZGF0YTtcclxuICAgIGxldCBldmVudHMgPSBbXTtcclxuICAgIGlmICh0YWcpIHtcclxuICAgICAgICBpZiAoaXNNZXJnZSkge1xyXG4gICAgICAgICAgICBjb25zdCB0YWdnZWRDaGlsZHJlbiA9IG1hcChkYXRhLCAocmF3KSA9PiBub2RlRnJvbUpTT04ocmF3KSk7XHJcbiAgICAgICAgICAgIGV2ZW50cyA9IHN5bmNUcmVlQXBwbHlUYWdnZWRRdWVyeU1lcmdlKHJlcG8uc2VydmVyU3luY1RyZWVfLCBwYXRoLCB0YWdnZWRDaGlsZHJlbiwgdGFnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhZ2dlZFNuYXAgPSBub2RlRnJvbUpTT04oZGF0YSk7XHJcbiAgICAgICAgICAgIGV2ZW50cyA9IHN5bmNUcmVlQXBwbHlUYWdnZWRRdWVyeU92ZXJ3cml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcGF0aCwgdGFnZ2VkU25hcCwgdGFnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc01lcmdlKSB7XHJcbiAgICAgICAgY29uc3QgY2hhbmdlZENoaWxkcmVuID0gbWFwKGRhdGEsIChyYXcpID0+IG5vZGVGcm9tSlNPTihyYXcpKTtcclxuICAgICAgICBldmVudHMgPSBzeW5jVHJlZUFwcGx5U2VydmVyTWVyZ2UocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHBhdGgsIGNoYW5nZWRDaGlsZHJlbik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBzbmFwID0gbm9kZUZyb21KU09OKGRhdGEpO1xyXG4gICAgICAgIGV2ZW50cyA9IHN5bmNUcmVlQXBwbHlTZXJ2ZXJPdmVyd3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHBhdGgsIHNuYXApO1xyXG4gICAgfVxyXG4gICAgbGV0IGFmZmVjdGVkUGF0aCA9IHBhdGg7XHJcbiAgICBpZiAoZXZlbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAvLyBTaW5jZSB3ZSBoYXZlIGEgbGlzdGVuZXIgb3V0c3RhbmRpbmcgZm9yIGVhY2ggdHJhbnNhY3Rpb24sIHJlY2VpdmluZyBhbnkgZXZlbnRzXHJcbiAgICAgICAgLy8gaXMgYSBwcm94eSBmb3Igc29tZSBjaGFuZ2UgaGF2aW5nIG9jY3VycmVkLlxyXG4gICAgICAgIGFmZmVjdGVkUGF0aCA9IHJlcG9SZXJ1blRyYW5zYWN0aW9ucyhyZXBvLCBwYXRoKTtcclxuICAgIH1cclxuICAgIGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIGFmZmVjdGVkUGF0aCwgZXZlbnRzKTtcclxufVxyXG5mdW5jdGlvbiByZXBvT25Db25uZWN0U3RhdHVzKHJlcG8sIGNvbm5lY3RTdGF0dXMpIHtcclxuICAgIHJlcG9VcGRhdGVJbmZvKHJlcG8sICdjb25uZWN0ZWQnLCBjb25uZWN0U3RhdHVzKTtcclxuICAgIGlmIChjb25uZWN0U3RhdHVzID09PSBmYWxzZSkge1xyXG4gICAgICAgIHJlcG9SdW5PbkRpc2Nvbm5lY3RFdmVudHMocmVwbyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVwb09uU2VydmVySW5mb1VwZGF0ZShyZXBvLCB1cGRhdGVzKSB7XHJcbiAgICBlYWNoKHVwZGF0ZXMsIChrZXksIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgcmVwb1VwZGF0ZUluZm8ocmVwbywga2V5LCB2YWx1ZSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiByZXBvVXBkYXRlSW5mbyhyZXBvLCBwYXRoU3RyaW5nLCB2YWx1ZSkge1xyXG4gICAgY29uc3QgcGF0aCA9IG5ldyBQYXRoKCcvLmluZm8vJyArIHBhdGhTdHJpbmcpO1xyXG4gICAgY29uc3QgbmV3Tm9kZSA9IG5vZGVGcm9tSlNPTih2YWx1ZSk7XHJcbiAgICByZXBvLmluZm9EYXRhXy51cGRhdGVTbmFwc2hvdChwYXRoLCBuZXdOb2RlKTtcclxuICAgIGNvbnN0IGV2ZW50cyA9IHN5bmNUcmVlQXBwbHlTZXJ2ZXJPdmVyd3JpdGUocmVwby5pbmZvU3luY1RyZWVfLCBwYXRoLCBuZXdOb2RlKTtcclxuICAgIGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIHBhdGgsIGV2ZW50cyk7XHJcbn1cclxuZnVuY3Rpb24gcmVwb0dldE5leHRXcml0ZUlkKHJlcG8pIHtcclxuICAgIHJldHVybiByZXBvLm5leHRXcml0ZUlkXysrO1xyXG59XHJcbi8qKlxyXG4gKiBUaGUgcHVycG9zZSBvZiBgZ2V0VmFsdWVgIGlzIHRvIHJldHVybiB0aGUgbGF0ZXN0IGtub3duIHZhbHVlXHJcbiAqIHNhdGlzZnlpbmcgYHF1ZXJ5YC5cclxuICpcclxuICogVGhpcyBtZXRob2Qgd2lsbCBmaXJzdCBjaGVjayBmb3IgaW4tbWVtb3J5IGNhY2hlZCB2YWx1ZXNcclxuICogYmVsb25naW5nIHRvIGFjdGl2ZSBsaXN0ZW5lcnMuIElmIHRoZXkgYXJlIGZvdW5kLCBzdWNoIHZhbHVlc1xyXG4gKiBhcmUgY29uc2lkZXJlZCB0byBiZSB0aGUgbW9zdCB1cC10by1kYXRlLlxyXG4gKlxyXG4gKiBJZiB0aGUgY2xpZW50IGlzIG5vdCBjb25uZWN0ZWQsIHRoaXMgbWV0aG9kIHdpbGwgd2FpdCB1bnRpbCB0aGVcclxuICogIHJlcG8gaGFzIGVzdGFibGlzaGVkIGEgY29ubmVjdGlvbiBhbmQgdGhlbiByZXF1ZXN0IHRoZSB2YWx1ZSBmb3IgYHF1ZXJ5YC5cclxuICogSWYgdGhlIGNsaWVudCBpcyBub3QgYWJsZSB0byByZXRyaWV2ZSB0aGUgcXVlcnkgcmVzdWx0IGZvciBhbm90aGVyIHJlYXNvbixcclxuICogaXQgcmVwb3J0cyBhbiBlcnJvci5cclxuICpcclxuICogQHBhcmFtIHF1ZXJ5IC0gVGhlIHF1ZXJ5IHRvIHN1cmZhY2UgYSB2YWx1ZSBmb3IuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvR2V0VmFsdWUocmVwbywgcXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uKSB7XHJcbiAgICAvLyBPbmx5IGFjdGl2ZSBxdWVyaWVzIGFyZSBjYWNoZWQuIFRoZXJlIGlzIG5vIHBlcnNpc3RlZCBjYWNoZS5cclxuICAgIGNvbnN0IGNhY2hlZCA9IHN5bmNUcmVlR2V0U2VydmVyVmFsdWUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHF1ZXJ5KTtcclxuICAgIGlmIChjYWNoZWQgIT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2FjaGVkKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXBvLnNlcnZlcl8uZ2V0KHF1ZXJ5KS50aGVuKHBheWxvYWQgPT4ge1xyXG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2RlRnJvbUpTT04ocGF5bG9hZCkud2l0aEluZGV4KHF1ZXJ5Ll9xdWVyeVBhcmFtcy5nZXRJbmRleCgpKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCZWxvdyB3ZSBzaW11bGF0ZSB0aGUgYWN0aW9ucyBvZiBhbiBgb25seU9uY2VgIGBvblZhbHVlKClgIGV2ZW50IHdoZXJlOlxyXG4gICAgICAgICAqIEFkZCBhbiBldmVudCByZWdpc3RyYXRpb24sXHJcbiAgICAgICAgICogVXBkYXRlIGRhdGEgYXQgdGhlIHBhdGgsXHJcbiAgICAgICAgICogUmFpc2UgYW55IGV2ZW50cyxcclxuICAgICAgICAgKiBDbGVhbnVwIHRoZSBTeW5jVHJlZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN5bmNUcmVlQWRkRXZlbnRSZWdpc3RyYXRpb24ocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbiwgdHJ1ZSk7XHJcbiAgICAgICAgbGV0IGV2ZW50cztcclxuICAgICAgICBpZiAocXVlcnkuX3F1ZXJ5UGFyYW1zLmxvYWRzQWxsRGF0YSgpKSB7XHJcbiAgICAgICAgICAgIGV2ZW50cyA9IHN5bmNUcmVlQXBwbHlTZXJ2ZXJPdmVyd3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHF1ZXJ5Ll9wYXRoLCBub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHN5bmNUcmVlVGFnRm9yUXVlcnkocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHF1ZXJ5KTtcclxuICAgICAgICAgICAgZXZlbnRzID0gc3luY1RyZWVBcHBseVRhZ2dlZFF1ZXJ5T3ZlcndyaXRlKHJlcG8uc2VydmVyU3luY1RyZWVfLCBxdWVyeS5fcGF0aCwgbm9kZSwgdGFnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBXZSBuZWVkIHRvIHJhaXNlIGV2ZW50cyBpbiB0aGUgc2NlbmFyaW8gd2hlcmUgYGdldCgpYCBpcyBjYWxsZWQgYXQgYSBwYXJlbnQgcGF0aCwgYW5kXHJcbiAgICAgICAgICogd2hpbGUgdGhlIGBnZXQoKWAgaXMgcGVuZGluZywgYG9uVmFsdWVgIGlzIGNhbGxlZCBhdCBhIGNoaWxkIGxvY2F0aW9uLiBXaGlsZSBnZXQoKSBpcyB3YWl0aW5nXHJcbiAgICAgICAgICogZm9yIHRoZSBkYXRhLCBgb25WYWx1ZWAgd2lsbCByZWdpc3RlciBhIG5ldyBldmVudC4gVGhlbiwgZ2V0KCkgd2lsbCBjb21lIGJhY2ssIGFuZCB1cGRhdGUgdGhlIHN5bmNUcmVlXHJcbiAgICAgICAgICogYW5kIGl0cyBjb3JyZXNwb25kaW5nIHNlcnZlckNhY2hlLCBpbmNsdWRpbmcgdGhlIGNoaWxkIGxvY2F0aW9uIHdoZXJlIGBvblZhbHVlYCBpcyBjYWxsZWQuIFRoZW4sXHJcbiAgICAgICAgICogYG9uVmFsdWVgIHdpbGwgcmVjZWl2ZSB0aGUgZXZlbnQgZnJvbSB0aGUgc2VydmVyLCBidXQgbG9vayBhdCB0aGUgc3luY1RyZWUgYW5kIHNlZSB0aGF0IHRoZSBkYXRhIHJlY2VpdmVkXHJcbiAgICAgICAgICogZnJvbSB0aGUgc2VydmVyIGlzIGFscmVhZHkgYXQgdGhlIFN5bmNQb2ludCwgYW5kIHNvIHRoZSBgb25WYWx1ZWAgY2FsbGJhY2sgd2lsbCBuZXZlciBnZXQgZmlyZWQuXHJcbiAgICAgICAgICogQ2FsbGluZyBgZXZlbnRRdWV1ZVJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgoKWAgaXMgdGhlIGNvcnJlY3Qgd2F5IHRvIHByb3BhZ2F0ZSB0aGUgZXZlbnRzIGFuZFxyXG4gICAgICAgICAqIGVuc3VyZSB0aGUgY29ycmVzcG9uZGluZyBjaGlsZCBldmVudHMgd2lsbCBnZXQgZmlyZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZXZlbnRRdWV1ZVJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgocmVwby5ldmVudFF1ZXVlXywgcXVlcnkuX3BhdGgsIGV2ZW50cyk7XHJcbiAgICAgICAgc3luY1RyZWVSZW1vdmVFdmVudFJlZ2lzdHJhdGlvbihyZXBvLnNlcnZlclN5bmNUcmVlXywgcXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uLCBudWxsLCB0cnVlKTtcclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH0sIGVyciA9PiB7XHJcbiAgICAgICAgcmVwb0xvZyhyZXBvLCAnZ2V0IGZvciBxdWVyeSAnICsgc3RyaW5naWZ5KHF1ZXJ5KSArICcgZmFpbGVkOiAnICsgZXJyKTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGVycikpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gcmVwb1NldFdpdGhQcmlvcml0eShyZXBvLCBwYXRoLCBuZXdWYWwsIG5ld1ByaW9yaXR5LCBvbkNvbXBsZXRlKSB7XHJcbiAgICByZXBvTG9nKHJlcG8sICdzZXQnLCB7XHJcbiAgICAgICAgcGF0aDogcGF0aC50b1N0cmluZygpLFxyXG4gICAgICAgIHZhbHVlOiBuZXdWYWwsXHJcbiAgICAgICAgcHJpb3JpdHk6IG5ld1ByaW9yaXR5XHJcbiAgICB9KTtcclxuICAgIC8vIFRPRE86IE9wdGltaXplIHRoaXMgYmVoYXZpb3IgdG8gZWl0aGVyIChhKSBzdG9yZSBmbGFnIHRvIHNraXAgcmVzb2x2aW5nIHdoZXJlIHBvc3NpYmxlIGFuZCAvIG9yXHJcbiAgICAvLyAoYikgc3RvcmUgdW5yZXNvbHZlZCBwYXRocyBvbiBKU09OIHBhcnNlXHJcbiAgICBjb25zdCBzZXJ2ZXJWYWx1ZXMgPSByZXBvR2VuZXJhdGVTZXJ2ZXJWYWx1ZXMocmVwbyk7XHJcbiAgICBjb25zdCBuZXdOb2RlVW5yZXNvbHZlZCA9IG5vZGVGcm9tSlNPTihuZXdWYWwsIG5ld1ByaW9yaXR5KTtcclxuICAgIGNvbnN0IGV4aXN0aW5nID0gc3luY1RyZWVDYWxjQ29tcGxldGVFdmVudENhY2hlKHJlcG8uc2VydmVyU3luY1RyZWVfLCBwYXRoKTtcclxuICAgIGNvbnN0IG5ld05vZGUgPSByZXNvbHZlRGVmZXJyZWRWYWx1ZVNuYXBzaG90KG5ld05vZGVVbnJlc29sdmVkLCBleGlzdGluZywgc2VydmVyVmFsdWVzKTtcclxuICAgIGNvbnN0IHdyaXRlSWQgPSByZXBvR2V0TmV4dFdyaXRlSWQocmVwbyk7XHJcbiAgICBjb25zdCBldmVudHMgPSBzeW5jVHJlZUFwcGx5VXNlck92ZXJ3cml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcGF0aCwgbmV3Tm9kZSwgd3JpdGVJZCwgdHJ1ZSk7XHJcbiAgICBldmVudFF1ZXVlUXVldWVFdmVudHMocmVwby5ldmVudFF1ZXVlXywgZXZlbnRzKTtcclxuICAgIHJlcG8uc2VydmVyXy5wdXQocGF0aC50b1N0cmluZygpLCBuZXdOb2RlVW5yZXNvbHZlZC52YWwoLypleHBvcnQ9Ki8gdHJ1ZSksIChzdGF0dXMsIGVycm9yUmVhc29uKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9IHN0YXR1cyA9PT0gJ29rJztcclxuICAgICAgICBpZiAoIXN1Y2Nlc3MpIHtcclxuICAgICAgICAgICAgd2Fybignc2V0IGF0ICcgKyBwYXRoICsgJyBmYWlsZWQ6ICcgKyBzdGF0dXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjbGVhckV2ZW50cyA9IHN5bmNUcmVlQWNrVXNlcldyaXRlKHJlcG8uc2VydmVyU3luY1RyZWVfLCB3cml0ZUlkLCAhc3VjY2Vzcyk7XHJcbiAgICAgICAgZXZlbnRRdWV1ZVJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgocmVwby5ldmVudFF1ZXVlXywgcGF0aCwgY2xlYXJFdmVudHMpO1xyXG4gICAgICAgIHJlcG9DYWxsT25Db21wbGV0ZUNhbGxiYWNrKHJlcG8sIG9uQ29tcGxldGUsIHN0YXR1cywgZXJyb3JSZWFzb24pO1xyXG4gICAgfSk7XHJcbiAgICBjb25zdCBhZmZlY3RlZFBhdGggPSByZXBvQWJvcnRUcmFuc2FjdGlvbnMocmVwbywgcGF0aCk7XHJcbiAgICByZXBvUmVydW5UcmFuc2FjdGlvbnMocmVwbywgYWZmZWN0ZWRQYXRoKTtcclxuICAgIC8vIFdlIHF1ZXVlZCB0aGUgZXZlbnRzIGFib3ZlLCBzbyBqdXN0IGZsdXNoIHRoZSBxdWV1ZSBoZXJlXHJcbiAgICBldmVudFF1ZXVlUmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChyZXBvLmV2ZW50UXVldWVfLCBhZmZlY3RlZFBhdGgsIFtdKTtcclxufVxyXG5mdW5jdGlvbiByZXBvVXBkYXRlKHJlcG8sIHBhdGgsIGNoaWxkcmVuVG9NZXJnZSwgb25Db21wbGV0ZSkge1xyXG4gICAgcmVwb0xvZyhyZXBvLCAndXBkYXRlJywgeyBwYXRoOiBwYXRoLnRvU3RyaW5nKCksIHZhbHVlOiBjaGlsZHJlblRvTWVyZ2UgfSk7XHJcbiAgICAvLyBTdGFydCB3aXRoIG91ciBleGlzdGluZyBkYXRhIGFuZCBtZXJnZSBlYWNoIGNoaWxkIGludG8gaXQuXHJcbiAgICBsZXQgZW1wdHkgPSB0cnVlO1xyXG4gICAgY29uc3Qgc2VydmVyVmFsdWVzID0gcmVwb0dlbmVyYXRlU2VydmVyVmFsdWVzKHJlcG8pO1xyXG4gICAgY29uc3QgY2hhbmdlZENoaWxkcmVuID0ge307XHJcbiAgICBlYWNoKGNoaWxkcmVuVG9NZXJnZSwgKGNoYW5nZWRLZXksIGNoYW5nZWRWYWx1ZSkgPT4ge1xyXG4gICAgICAgIGVtcHR5ID0gZmFsc2U7XHJcbiAgICAgICAgY2hhbmdlZENoaWxkcmVuW2NoYW5nZWRLZXldID0gcmVzb2x2ZURlZmVycmVkVmFsdWVUcmVlKHBhdGhDaGlsZChwYXRoLCBjaGFuZ2VkS2V5KSwgbm9kZUZyb21KU09OKGNoYW5nZWRWYWx1ZSksIHJlcG8uc2VydmVyU3luY1RyZWVfLCBzZXJ2ZXJWYWx1ZXMpO1xyXG4gICAgfSk7XHJcbiAgICBpZiAoIWVtcHR5KSB7XHJcbiAgICAgICAgY29uc3Qgd3JpdGVJZCA9IHJlcG9HZXROZXh0V3JpdGVJZChyZXBvKTtcclxuICAgICAgICBjb25zdCBldmVudHMgPSBzeW5jVHJlZUFwcGx5VXNlck1lcmdlKHJlcG8uc2VydmVyU3luY1RyZWVfLCBwYXRoLCBjaGFuZ2VkQ2hpbGRyZW4sIHdyaXRlSWQpO1xyXG4gICAgICAgIGV2ZW50UXVldWVRdWV1ZUV2ZW50cyhyZXBvLmV2ZW50UXVldWVfLCBldmVudHMpO1xyXG4gICAgICAgIHJlcG8uc2VydmVyXy5tZXJnZShwYXRoLnRvU3RyaW5nKCksIGNoaWxkcmVuVG9NZXJnZSwgKHN0YXR1cywgZXJyb3JSZWFzb24pID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc3VjY2VzcyA9IHN0YXR1cyA9PT0gJ29rJztcclxuICAgICAgICAgICAgaWYgKCFzdWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKCd1cGRhdGUgYXQgJyArIHBhdGggKyAnIGZhaWxlZDogJyArIHN0YXR1cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgY2xlYXJFdmVudHMgPSBzeW5jVHJlZUFja1VzZXJXcml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgd3JpdGVJZCwgIXN1Y2Nlc3MpO1xyXG4gICAgICAgICAgICBjb25zdCBhZmZlY3RlZFBhdGggPSBjbGVhckV2ZW50cy5sZW5ndGggPiAwID8gcmVwb1JlcnVuVHJhbnNhY3Rpb25zKHJlcG8sIHBhdGgpIDogcGF0aDtcclxuICAgICAgICAgICAgZXZlbnRRdWV1ZVJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgocmVwby5ldmVudFF1ZXVlXywgYWZmZWN0ZWRQYXRoLCBjbGVhckV2ZW50cyk7XHJcbiAgICAgICAgICAgIHJlcG9DYWxsT25Db21wbGV0ZUNhbGxiYWNrKHJlcG8sIG9uQ29tcGxldGUsIHN0YXR1cywgZXJyb3JSZWFzb24pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGVhY2goY2hpbGRyZW5Ub01lcmdlLCAoY2hhbmdlZFBhdGgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYWZmZWN0ZWRQYXRoID0gcmVwb0Fib3J0VHJhbnNhY3Rpb25zKHJlcG8sIHBhdGhDaGlsZChwYXRoLCBjaGFuZ2VkUGF0aCkpO1xyXG4gICAgICAgICAgICByZXBvUmVydW5UcmFuc2FjdGlvbnMocmVwbywgYWZmZWN0ZWRQYXRoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBXZSBxdWV1ZWQgdGhlIGV2ZW50cyBhYm92ZSwgc28ganVzdCBmbHVzaCB0aGUgcXVldWUgaGVyZVxyXG4gICAgICAgIGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIHBhdGgsIFtdKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxvZyhcInVwZGF0ZSgpIGNhbGxlZCB3aXRoIGVtcHR5IGRhdGEuICBEb24ndCBkbyBhbnl0aGluZy5cIik7XHJcbiAgICAgICAgcmVwb0NhbGxPbkNvbXBsZXRlQ2FsbGJhY2socmVwbywgb25Db21wbGV0ZSwgJ29rJywgdW5kZWZpbmVkKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQXBwbGllcyBhbGwgb2YgdGhlIGNoYW5nZXMgc3RvcmVkIHVwIGluIHRoZSBvbkRpc2Nvbm5lY3RfIHRyZWUuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvUnVuT25EaXNjb25uZWN0RXZlbnRzKHJlcG8pIHtcclxuICAgIHJlcG9Mb2cocmVwbywgJ29uRGlzY29ubmVjdEV2ZW50cycpO1xyXG4gICAgY29uc3Qgc2VydmVyVmFsdWVzID0gcmVwb0dlbmVyYXRlU2VydmVyVmFsdWVzKHJlcG8pO1xyXG4gICAgY29uc3QgcmVzb2x2ZWRPbkRpc2Nvbm5lY3RUcmVlID0gbmV3U3BhcnNlU25hcHNob3RUcmVlKCk7XHJcbiAgICBzcGFyc2VTbmFwc2hvdFRyZWVGb3JFYWNoVHJlZShyZXBvLm9uRGlzY29ubmVjdF8sIG5ld0VtcHR5UGF0aCgpLCAocGF0aCwgbm9kZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZURlZmVycmVkVmFsdWVUcmVlKHBhdGgsIG5vZGUsIHJlcG8uc2VydmVyU3luY1RyZWVfLCBzZXJ2ZXJWYWx1ZXMpO1xyXG4gICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZVJlbWVtYmVyKHJlc29sdmVkT25EaXNjb25uZWN0VHJlZSwgcGF0aCwgcmVzb2x2ZWQpO1xyXG4gICAgfSk7XHJcbiAgICBsZXQgZXZlbnRzID0gW107XHJcbiAgICBzcGFyc2VTbmFwc2hvdFRyZWVGb3JFYWNoVHJlZShyZXNvbHZlZE9uRGlzY29ubmVjdFRyZWUsIG5ld0VtcHR5UGF0aCgpLCAocGF0aCwgc25hcCkgPT4ge1xyXG4gICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoc3luY1RyZWVBcHBseVNlcnZlck92ZXJ3cml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcGF0aCwgc25hcCkpO1xyXG4gICAgICAgIGNvbnN0IGFmZmVjdGVkUGF0aCA9IHJlcG9BYm9ydFRyYW5zYWN0aW9ucyhyZXBvLCBwYXRoKTtcclxuICAgICAgICByZXBvUmVydW5UcmFuc2FjdGlvbnMocmVwbywgYWZmZWN0ZWRQYXRoKTtcclxuICAgIH0pO1xyXG4gICAgcmVwby5vbkRpc2Nvbm5lY3RfID0gbmV3U3BhcnNlU25hcHNob3RUcmVlKCk7XHJcbiAgICBldmVudFF1ZXVlUmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChyZXBvLmV2ZW50UXVldWVfLCBuZXdFbXB0eVBhdGgoKSwgZXZlbnRzKTtcclxufVxyXG5mdW5jdGlvbiByZXBvT25EaXNjb25uZWN0Q2FuY2VsKHJlcG8sIHBhdGgsIG9uQ29tcGxldGUpIHtcclxuICAgIHJlcG8uc2VydmVyXy5vbkRpc2Nvbm5lY3RDYW5jZWwocGF0aC50b1N0cmluZygpLCAoc3RhdHVzLCBlcnJvclJlYXNvbikgPT4ge1xyXG4gICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcclxuICAgICAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlRm9yZ2V0KHJlcG8ub25EaXNjb25uZWN0XywgcGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlcG9DYWxsT25Db21wbGV0ZUNhbGxiYWNrKHJlcG8sIG9uQ29tcGxldGUsIHN0YXR1cywgZXJyb3JSZWFzb24pO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gcmVwb09uRGlzY29ubmVjdFNldChyZXBvLCBwYXRoLCB2YWx1ZSwgb25Db21wbGV0ZSkge1xyXG4gICAgY29uc3QgbmV3Tm9kZSA9IG5vZGVGcm9tSlNPTih2YWx1ZSk7XHJcbiAgICByZXBvLnNlcnZlcl8ub25EaXNjb25uZWN0UHV0KHBhdGgudG9TdHJpbmcoKSwgbmV3Tm9kZS52YWwoLypleHBvcnQ9Ki8gdHJ1ZSksIChzdGF0dXMsIGVycm9yUmVhc29uKSA9PiB7XHJcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ29rJykge1xyXG4gICAgICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWVSZW1lbWJlcihyZXBvLm9uRGlzY29ubmVjdF8sIHBhdGgsIG5ld05vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXBvQ2FsbE9uQ29tcGxldGVDYWxsYmFjayhyZXBvLCBvbkNvbXBsZXRlLCBzdGF0dXMsIGVycm9yUmVhc29uKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHJlcG9PbkRpc2Nvbm5lY3RTZXRXaXRoUHJpb3JpdHkocmVwbywgcGF0aCwgdmFsdWUsIHByaW9yaXR5LCBvbkNvbXBsZXRlKSB7XHJcbiAgICBjb25zdCBuZXdOb2RlID0gbm9kZUZyb21KU09OKHZhbHVlLCBwcmlvcml0eSk7XHJcbiAgICByZXBvLnNlcnZlcl8ub25EaXNjb25uZWN0UHV0KHBhdGgudG9TdHJpbmcoKSwgbmV3Tm9kZS52YWwoLypleHBvcnQ9Ki8gdHJ1ZSksIChzdGF0dXMsIGVycm9yUmVhc29uKSA9PiB7XHJcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ29rJykge1xyXG4gICAgICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWVSZW1lbWJlcihyZXBvLm9uRGlzY29ubmVjdF8sIHBhdGgsIG5ld05vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXBvQ2FsbE9uQ29tcGxldGVDYWxsYmFjayhyZXBvLCBvbkNvbXBsZXRlLCBzdGF0dXMsIGVycm9yUmVhc29uKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHJlcG9PbkRpc2Nvbm5lY3RVcGRhdGUocmVwbywgcGF0aCwgY2hpbGRyZW5Ub01lcmdlLCBvbkNvbXBsZXRlKSB7XHJcbiAgICBpZiAoaXNFbXB0eShjaGlsZHJlblRvTWVyZ2UpKSB7XHJcbiAgICAgICAgbG9nKFwib25EaXNjb25uZWN0KCkudXBkYXRlKCkgY2FsbGVkIHdpdGggZW1wdHkgZGF0YS4gIERvbid0IGRvIGFueXRoaW5nLlwiKTtcclxuICAgICAgICByZXBvQ2FsbE9uQ29tcGxldGVDYWxsYmFjayhyZXBvLCBvbkNvbXBsZXRlLCAnb2snLCB1bmRlZmluZWQpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHJlcG8uc2VydmVyXy5vbkRpc2Nvbm5lY3RNZXJnZShwYXRoLnRvU3RyaW5nKCksIGNoaWxkcmVuVG9NZXJnZSwgKHN0YXR1cywgZXJyb3JSZWFzb24pID0+IHtcclxuICAgICAgICBpZiAoc3RhdHVzID09PSAnb2snKSB7XHJcbiAgICAgICAgICAgIGVhY2goY2hpbGRyZW5Ub01lcmdlLCAoY2hpbGROYW1lLCBjaGlsZE5vZGUpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0NoaWxkTm9kZSA9IG5vZGVGcm9tSlNPTihjaGlsZE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlUmVtZW1iZXIocmVwby5vbkRpc2Nvbm5lY3RfLCBwYXRoQ2hpbGQocGF0aCwgY2hpbGROYW1lKSwgbmV3Q2hpbGROb2RlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlcG9DYWxsT25Db21wbGV0ZUNhbGxiYWNrKHJlcG8sIG9uQ29tcGxldGUsIHN0YXR1cywgZXJyb3JSZWFzb24pO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gcmVwb0FkZEV2ZW50Q2FsbGJhY2tGb3JRdWVyeShyZXBvLCBxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24pIHtcclxuICAgIGxldCBldmVudHM7XHJcbiAgICBpZiAocGF0aEdldEZyb250KHF1ZXJ5Ll9wYXRoKSA9PT0gJy5pbmZvJykge1xyXG4gICAgICAgIGV2ZW50cyA9IHN5bmNUcmVlQWRkRXZlbnRSZWdpc3RyYXRpb24ocmVwby5pbmZvU3luY1RyZWVfLCBxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZXZlbnRzID0gc3luY1RyZWVBZGRFdmVudFJlZ2lzdHJhdGlvbihyZXBvLnNlcnZlclN5bmNUcmVlXywgcXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uKTtcclxuICAgIH1cclxuICAgIGV2ZW50UXVldWVSYWlzZUV2ZW50c0F0UGF0aChyZXBvLmV2ZW50UXVldWVfLCBxdWVyeS5fcGF0aCwgZXZlbnRzKTtcclxufVxyXG5mdW5jdGlvbiByZXBvUmVtb3ZlRXZlbnRDYWxsYmFja0ZvclF1ZXJ5KHJlcG8sIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbikge1xyXG4gICAgLy8gVGhlc2UgYXJlIGd1YXJhbnRlZWQgbm90IHRvIHJhaXNlIGV2ZW50cywgc2luY2Ugd2UncmUgbm90IHBhc3NpbmcgaW4gYSBjYW5jZWxFcnJvci4gSG93ZXZlciwgd2UgY2FuIGZ1dHVyZS1wcm9vZlxyXG4gICAgLy8gYSBsaXR0bGUgYml0IGJ5IGhhbmRsaW5nIHRoZSByZXR1cm4gdmFsdWVzIGFueXdheXMuXHJcbiAgICBsZXQgZXZlbnRzO1xyXG4gICAgaWYgKHBhdGhHZXRGcm9udChxdWVyeS5fcGF0aCkgPT09ICcuaW5mbycpIHtcclxuICAgICAgICBldmVudHMgPSBzeW5jVHJlZVJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKHJlcG8uaW5mb1N5bmNUcmVlXywgcXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGV2ZW50cyA9IHN5bmNUcmVlUmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24ocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbik7XHJcbiAgICB9XHJcbiAgICBldmVudFF1ZXVlUmFpc2VFdmVudHNBdFBhdGgocmVwby5ldmVudFF1ZXVlXywgcXVlcnkuX3BhdGgsIGV2ZW50cyk7XHJcbn1cclxuZnVuY3Rpb24gcmVwb0ludGVycnVwdChyZXBvKSB7XHJcbiAgICBpZiAocmVwby5wZXJzaXN0ZW50Q29ubmVjdGlvbl8pIHtcclxuICAgICAgICByZXBvLnBlcnNpc3RlbnRDb25uZWN0aW9uXy5pbnRlcnJ1cHQoSU5URVJSVVBUX1JFQVNPTik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVwb1Jlc3VtZShyZXBvKSB7XHJcbiAgICBpZiAocmVwby5wZXJzaXN0ZW50Q29ubmVjdGlvbl8pIHtcclxuICAgICAgICByZXBvLnBlcnNpc3RlbnRDb25uZWN0aW9uXy5yZXN1bWUoSU5URVJSVVBUX1JFQVNPTik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVwb0xvZyhyZXBvLCAuLi52YXJBcmdzKSB7XHJcbiAgICBsZXQgcHJlZml4ID0gJyc7XHJcbiAgICBpZiAocmVwby5wZXJzaXN0ZW50Q29ubmVjdGlvbl8pIHtcclxuICAgICAgICBwcmVmaXggPSByZXBvLnBlcnNpc3RlbnRDb25uZWN0aW9uXy5pZCArICc6JztcclxuICAgIH1cclxuICAgIGxvZyhwcmVmaXgsIC4uLnZhckFyZ3MpO1xyXG59XHJcbmZ1bmN0aW9uIHJlcG9DYWxsT25Db21wbGV0ZUNhbGxiYWNrKHJlcG8sIGNhbGxiYWNrLCBzdGF0dXMsIGVycm9yUmVhc29uKSB7XHJcbiAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICBleGNlcHRpb25HdWFyZCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IChzdGF0dXMgfHwgJ2Vycm9yJykudG9VcHBlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlID0gY29kZTtcclxuICAgICAgICAgICAgICAgIGlmIChlcnJvclJlYXNvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gJzogJyArIGVycm9yUmVhc29uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICAgICAgZXJyb3IuY29kZSA9IGNvZGU7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyB0cmFuc2FjdGlvbiwgYWRkcyBpdCB0byB0aGUgdHJhbnNhY3Rpb25zIHdlJ3JlIHRyYWNraW5nLCBhbmRcclxuICogc2VuZHMgaXQgdG8gdGhlIHNlcnZlciBpZiBwb3NzaWJsZS5cclxuICpcclxuICogQHBhcmFtIHBhdGggLSBQYXRoIGF0IHdoaWNoIHRvIGRvIHRyYW5zYWN0aW9uLlxyXG4gKiBAcGFyYW0gdHJhbnNhY3Rpb25VcGRhdGUgLSBVcGRhdGUgY2FsbGJhY2suXHJcbiAqIEBwYXJhbSBvbkNvbXBsZXRlIC0gQ29tcGxldGlvbiBjYWxsYmFjay5cclxuICogQHBhcmFtIHVud2F0Y2hlciAtIEZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgdHJhbnNhY3Rpb24gbm8gbG9uZ2VyXHJcbiAqIG5lZWQgZGF0YSB1cGRhdGVzIGZvciBgcGF0aGAuXHJcbiAqIEBwYXJhbSBhcHBseUxvY2FsbHkgLSBXaGV0aGVyIG9yIG5vdCB0byBtYWtlIGludGVybWVkaWF0ZSByZXN1bHRzIHZpc2libGVcclxuICovXHJcbmZ1bmN0aW9uIHJlcG9TdGFydFRyYW5zYWN0aW9uKHJlcG8sIHBhdGgsIHRyYW5zYWN0aW9uVXBkYXRlLCBvbkNvbXBsZXRlLCB1bndhdGNoZXIsIGFwcGx5TG9jYWxseSkge1xyXG4gICAgcmVwb0xvZyhyZXBvLCAndHJhbnNhY3Rpb24gb24gJyArIHBhdGgpO1xyXG4gICAgLy8gSW5pdGlhbGl6ZSB0cmFuc2FjdGlvbi5cclxuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0ge1xyXG4gICAgICAgIHBhdGgsXHJcbiAgICAgICAgdXBkYXRlOiB0cmFuc2FjdGlvblVwZGF0ZSxcclxuICAgICAgICBvbkNvbXBsZXRlLFxyXG4gICAgICAgIC8vIE9uZSBvZiBUcmFuc2FjdGlvblN0YXR1cyBlbnVtcy5cclxuICAgICAgICBzdGF0dXM6IG51bGwsXHJcbiAgICAgICAgLy8gVXNlZCB3aGVuIGNvbWJpbmluZyB0cmFuc2FjdGlvbnMgYXQgZGlmZmVyZW50IGxvY2F0aW9ucyB0byBmaWd1cmUgb3V0XHJcbiAgICAgICAgLy8gd2hpY2ggb25lIGdvZXMgZmlyc3QuXHJcbiAgICAgICAgb3JkZXI6IExVSURHZW5lcmF0b3IoKSxcclxuICAgICAgICAvLyBXaGV0aGVyIHRvIHJhaXNlIGxvY2FsIGV2ZW50cyBmb3IgdGhpcyB0cmFuc2FjdGlvbi5cclxuICAgICAgICBhcHBseUxvY2FsbHksXHJcbiAgICAgICAgLy8gQ291bnQgb2YgaG93IG1hbnkgdGltZXMgd2UndmUgcmV0cmllZCB0aGUgdHJhbnNhY3Rpb24uXHJcbiAgICAgICAgcmV0cnlDb3VudDogMCxcclxuICAgICAgICAvLyBGdW5jdGlvbiB0byBjYWxsIHRvIGNsZWFuIHVwIG91ciAub24oKSBsaXN0ZW5lci5cclxuICAgICAgICB1bndhdGNoZXIsXHJcbiAgICAgICAgLy8gU3RvcmVzIHdoeSBhIHRyYW5zYWN0aW9uIHdhcyBhYm9ydGVkLlxyXG4gICAgICAgIGFib3J0UmVhc29uOiBudWxsLFxyXG4gICAgICAgIGN1cnJlbnRXcml0ZUlkOiBudWxsLFxyXG4gICAgICAgIGN1cnJlbnRJbnB1dFNuYXBzaG90OiBudWxsLFxyXG4gICAgICAgIGN1cnJlbnRPdXRwdXRTbmFwc2hvdFJhdzogbnVsbCxcclxuICAgICAgICBjdXJyZW50T3V0cHV0U25hcHNob3RSZXNvbHZlZDogbnVsbFxyXG4gICAgfTtcclxuICAgIC8vIFJ1biB0cmFuc2FjdGlvbiBpbml0aWFsbHkuXHJcbiAgICBjb25zdCBjdXJyZW50U3RhdGUgPSByZXBvR2V0TGF0ZXN0U3RhdGUocmVwbywgcGF0aCwgdW5kZWZpbmVkKTtcclxuICAgIHRyYW5zYWN0aW9uLmN1cnJlbnRJbnB1dFNuYXBzaG90ID0gY3VycmVudFN0YXRlO1xyXG4gICAgY29uc3QgbmV3VmFsID0gdHJhbnNhY3Rpb24udXBkYXRlKGN1cnJlbnRTdGF0ZS52YWwoKSk7XHJcbiAgICBpZiAobmV3VmFsID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAvLyBBYm9ydCB0cmFuc2FjdGlvbi5cclxuICAgICAgICB0cmFuc2FjdGlvbi51bndhdGNoZXIoKTtcclxuICAgICAgICB0cmFuc2FjdGlvbi5jdXJyZW50T3V0cHV0U25hcHNob3RSYXcgPSBudWxsO1xyXG4gICAgICAgIHRyYW5zYWN0aW9uLmN1cnJlbnRPdXRwdXRTbmFwc2hvdFJlc29sdmVkID0gbnVsbDtcclxuICAgICAgICBpZiAodHJhbnNhY3Rpb24ub25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5vbkNvbXBsZXRlKG51bGwsIGZhbHNlLCB0cmFuc2FjdGlvbi5jdXJyZW50SW5wdXRTbmFwc2hvdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFsaWRhdGVGaXJlYmFzZURhdGEoJ3RyYW5zYWN0aW9uIGZhaWxlZDogRGF0YSByZXR1cm5lZCAnLCBuZXdWYWwsIHRyYW5zYWN0aW9uLnBhdGgpO1xyXG4gICAgICAgIC8vIE1hcmsgYXMgcnVuIGFuZCBhZGQgdG8gb3VyIHF1ZXVlLlxyXG4gICAgICAgIHRyYW5zYWN0aW9uLnN0YXR1cyA9IDAgLyogVHJhbnNhY3Rpb25TdGF0dXMuUlVOICovO1xyXG4gICAgICAgIGNvbnN0IHF1ZXVlTm9kZSA9IHRyZWVTdWJUcmVlKHJlcG8udHJhbnNhY3Rpb25RdWV1ZVRyZWVfLCBwYXRoKTtcclxuICAgICAgICBjb25zdCBub2RlUXVldWUgPSB0cmVlR2V0VmFsdWUocXVldWVOb2RlKSB8fCBbXTtcclxuICAgICAgICBub2RlUXVldWUucHVzaCh0cmFuc2FjdGlvbik7XHJcbiAgICAgICAgdHJlZVNldFZhbHVlKHF1ZXVlTm9kZSwgbm9kZVF1ZXVlKTtcclxuICAgICAgICAvLyBVcGRhdGUgdmlzaWJsZURhdGEgYW5kIHJhaXNlIGV2ZW50c1xyXG4gICAgICAgIC8vIE5vdGU6IFdlIGludGVudGlvbmFsbHkgcmFpc2UgZXZlbnRzIGFmdGVyIHVwZGF0aW5nIGFsbCBvZiBvdXJcclxuICAgICAgICAvLyB0cmFuc2FjdGlvbiBzdGF0ZSwgc2luY2UgdGhlIHVzZXIgY291bGQgc3RhcnQgbmV3IHRyYW5zYWN0aW9ucyBmcm9tIHRoZVxyXG4gICAgICAgIC8vIGV2ZW50IGNhbGxiYWNrcy5cclxuICAgICAgICBsZXQgcHJpb3JpdHlGb3JOb2RlO1xyXG4gICAgICAgIGlmICh0eXBlb2YgbmV3VmFsID09PSAnb2JqZWN0JyAmJlxyXG4gICAgICAgICAgICBuZXdWYWwgIT09IG51bGwgJiZcclxuICAgICAgICAgICAgY29udGFpbnMobmV3VmFsLCAnLnByaW9yaXR5JykpIHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgcHJpb3JpdHlGb3JOb2RlID0gc2FmZUdldChuZXdWYWwsICcucHJpb3JpdHknKTtcclxuICAgICAgICAgICAgYXNzZXJ0KGlzVmFsaWRQcmlvcml0eShwcmlvcml0eUZvck5vZGUpLCAnSW52YWxpZCBwcmlvcml0eSByZXR1cm5lZCBieSB0cmFuc2FjdGlvbi4gJyArXHJcbiAgICAgICAgICAgICAgICAnUHJpb3JpdHkgbXVzdCBiZSBhIHZhbGlkIHN0cmluZywgZmluaXRlIG51bWJlciwgc2VydmVyIHZhbHVlLCBvciBudWxsLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudE5vZGUgPSBzeW5jVHJlZUNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHBhdGgpIHx8XHJcbiAgICAgICAgICAgICAgICBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgICAgICAgICAgcHJpb3JpdHlGb3JOb2RlID0gY3VycmVudE5vZGUuZ2V0UHJpb3JpdHkoKS52YWwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2VydmVyVmFsdWVzID0gcmVwb0dlbmVyYXRlU2VydmVyVmFsdWVzKHJlcG8pO1xyXG4gICAgICAgIGNvbnN0IG5ld05vZGVVbnJlc29sdmVkID0gbm9kZUZyb21KU09OKG5ld1ZhbCwgcHJpb3JpdHlGb3JOb2RlKTtcclxuICAgICAgICBjb25zdCBuZXdOb2RlID0gcmVzb2x2ZURlZmVycmVkVmFsdWVTbmFwc2hvdChuZXdOb2RlVW5yZXNvbHZlZCwgY3VycmVudFN0YXRlLCBzZXJ2ZXJWYWx1ZXMpO1xyXG4gICAgICAgIHRyYW5zYWN0aW9uLmN1cnJlbnRPdXRwdXRTbmFwc2hvdFJhdyA9IG5ld05vZGVVbnJlc29sdmVkO1xyXG4gICAgICAgIHRyYW5zYWN0aW9uLmN1cnJlbnRPdXRwdXRTbmFwc2hvdFJlc29sdmVkID0gbmV3Tm9kZTtcclxuICAgICAgICB0cmFuc2FjdGlvbi5jdXJyZW50V3JpdGVJZCA9IHJlcG9HZXROZXh0V3JpdGVJZChyZXBvKTtcclxuICAgICAgICBjb25zdCBldmVudHMgPSBzeW5jVHJlZUFwcGx5VXNlck92ZXJ3cml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcGF0aCwgbmV3Tm9kZSwgdHJhbnNhY3Rpb24uY3VycmVudFdyaXRlSWQsIHRyYW5zYWN0aW9uLmFwcGx5TG9jYWxseSk7XHJcbiAgICAgICAgZXZlbnRRdWV1ZVJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgocmVwby5ldmVudFF1ZXVlXywgcGF0aCwgZXZlbnRzKTtcclxuICAgICAgICByZXBvU2VuZFJlYWR5VHJhbnNhY3Rpb25zKHJlcG8sIHJlcG8udHJhbnNhY3Rpb25RdWV1ZVRyZWVfKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQHBhcmFtIGV4Y2x1ZGVTZXRzIC0gQSBzcGVjaWZpYyBzZXQgdG8gZXhjbHVkZVxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb0dldExhdGVzdFN0YXRlKHJlcG8sIHBhdGgsIGV4Y2x1ZGVTZXRzKSB7XHJcbiAgICByZXR1cm4gKHN5bmNUcmVlQ2FsY0NvbXBsZXRlRXZlbnRDYWNoZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcGF0aCwgZXhjbHVkZVNldHMpIHx8XHJcbiAgICAgICAgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUpO1xyXG59XHJcbi8qKlxyXG4gKiBTZW5kcyBhbnkgYWxyZWFkeS1ydW4gdHJhbnNhY3Rpb25zIHRoYXQgYXJlbid0IHdhaXRpbmcgZm9yIG91dHN0YW5kaW5nXHJcbiAqIHRyYW5zYWN0aW9ucyB0byBjb21wbGV0ZS5cclxuICpcclxuICogRXh0ZXJuYWxseSBpdCdzIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50cywgYnV0IGl0IGNhbGxzIGl0c2VsZiByZWN1cnNpdmVseVxyXG4gKiB3aXRoIGEgcGFydGljdWxhciB0cmFuc2FjdGlvblF1ZXVlVHJlZSBub2RlIHRvIHJlY3Vyc2UgdGhyb3VnaCB0aGUgdHJlZS5cclxuICpcclxuICogQHBhcmFtIG5vZGUgLSB0cmFuc2FjdGlvblF1ZXVlVHJlZSBub2RlIHRvIHN0YXJ0IGF0LlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb1NlbmRSZWFkeVRyYW5zYWN0aW9ucyhyZXBvLCBub2RlID0gcmVwby50cmFuc2FjdGlvblF1ZXVlVHJlZV8pIHtcclxuICAgIC8vIEJlZm9yZSByZWN1cnNpbmcsIG1ha2Ugc3VyZSBhbnkgY29tcGxldGVkIHRyYW5zYWN0aW9ucyBhcmUgcmVtb3ZlZC5cclxuICAgIGlmICghbm9kZSkge1xyXG4gICAgICAgIHJlcG9QcnVuZUNvbXBsZXRlZFRyYW5zYWN0aW9uc0JlbG93Tm9kZShyZXBvLCBub2RlKTtcclxuICAgIH1cclxuICAgIGlmICh0cmVlR2V0VmFsdWUobm9kZSkpIHtcclxuICAgICAgICBjb25zdCBxdWV1ZSA9IHJlcG9CdWlsZFRyYW5zYWN0aW9uUXVldWUocmVwbywgbm9kZSk7XHJcbiAgICAgICAgYXNzZXJ0KHF1ZXVlLmxlbmd0aCA+IDAsICdTZW5kaW5nIHplcm8gbGVuZ3RoIHRyYW5zYWN0aW9uIHF1ZXVlJyk7XHJcbiAgICAgICAgY29uc3QgYWxsUnVuID0gcXVldWUuZXZlcnkoKHRyYW5zYWN0aW9uKSA9PiB0cmFuc2FjdGlvbi5zdGF0dXMgPT09IDAgLyogVHJhbnNhY3Rpb25TdGF0dXMuUlVOICovKTtcclxuICAgICAgICAvLyBJZiB0aGV5J3JlIGFsbCBydW4gKGFuZCBub3Qgc2VudCksIHdlIGNhbiBzZW5kIHRoZW0uICBFbHNlLCB3ZSBtdXN0IHdhaXQuXHJcbiAgICAgICAgaWYgKGFsbFJ1bikge1xyXG4gICAgICAgICAgICByZXBvU2VuZFRyYW5zYWN0aW9uUXVldWUocmVwbywgdHJlZUdldFBhdGgobm9kZSksIHF1ZXVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0cmVlSGFzQ2hpbGRyZW4obm9kZSkpIHtcclxuICAgICAgICB0cmVlRm9yRWFjaENoaWxkKG5vZGUsIGNoaWxkTm9kZSA9PiB7XHJcbiAgICAgICAgICAgIHJlcG9TZW5kUmVhZHlUcmFuc2FjdGlvbnMocmVwbywgY2hpbGROb2RlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogR2l2ZW4gYSBsaXN0IG9mIHJ1biB0cmFuc2FjdGlvbnMsIHNlbmQgdGhlbSB0byB0aGUgc2VydmVyIGFuZCB0aGVuIGhhbmRsZVxyXG4gKiB0aGUgcmVzdWx0IChzdWNjZXNzIG9yIGZhaWx1cmUpLlxyXG4gKlxyXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBsb2NhdGlvbiBvZiB0aGUgcXVldWUuXHJcbiAqIEBwYXJhbSBxdWV1ZSAtIFF1ZXVlIG9mIHRyYW5zYWN0aW9ucyB1bmRlciB0aGUgc3BlY2lmaWVkIGxvY2F0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb1NlbmRUcmFuc2FjdGlvblF1ZXVlKHJlcG8sIHBhdGgsIHF1ZXVlKSB7XHJcbiAgICAvLyBNYXJrIHRyYW5zYWN0aW9ucyBhcyBzZW50IGFuZCBpbmNyZW1lbnQgcmV0cnkgY291bnQhXHJcbiAgICBjb25zdCBzZXRzVG9JZ25vcmUgPSBxdWV1ZS5tYXAodHhuID0+IHtcclxuICAgICAgICByZXR1cm4gdHhuLmN1cnJlbnRXcml0ZUlkO1xyXG4gICAgfSk7XHJcbiAgICBjb25zdCBsYXRlc3RTdGF0ZSA9IHJlcG9HZXRMYXRlc3RTdGF0ZShyZXBvLCBwYXRoLCBzZXRzVG9JZ25vcmUpO1xyXG4gICAgbGV0IHNuYXBUb1NlbmQgPSBsYXRlc3RTdGF0ZTtcclxuICAgIGNvbnN0IGxhdGVzdEhhc2ggPSBsYXRlc3RTdGF0ZS5oYXNoKCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgdHhuID0gcXVldWVbaV07XHJcbiAgICAgICAgYXNzZXJ0KHR4bi5zdGF0dXMgPT09IDAgLyogVHJhbnNhY3Rpb25TdGF0dXMuUlVOICovLCAndHJ5VG9TZW5kVHJhbnNhY3Rpb25RdWV1ZV86IGl0ZW1zIGluIHF1ZXVlIHNob3VsZCBhbGwgYmUgcnVuLicpO1xyXG4gICAgICAgIHR4bi5zdGF0dXMgPSAxIC8qIFRyYW5zYWN0aW9uU3RhdHVzLlNFTlQgKi87XHJcbiAgICAgICAgdHhuLnJldHJ5Q291bnQrKztcclxuICAgICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBuZXdSZWxhdGl2ZVBhdGgocGF0aCwgdHhuLnBhdGgpO1xyXG4gICAgICAgIC8vIElmIHdlJ3ZlIGdvdHRlbiB0byB0aGlzIHBvaW50LCB0aGUgb3V0cHV0IHNuYXBzaG90IG11c3QgYmUgZGVmaW5lZC5cclxuICAgICAgICBzbmFwVG9TZW5kID0gc25hcFRvU2VuZC51cGRhdGVDaGlsZChyZWxhdGl2ZVBhdGggLyoqIEB0eXBlIHshTm9kZX0gKi8sIHR4bi5jdXJyZW50T3V0cHV0U25hcHNob3RSYXcpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGF0YVRvU2VuZCA9IHNuYXBUb1NlbmQudmFsKHRydWUpO1xyXG4gICAgY29uc3QgcGF0aFRvU2VuZCA9IHBhdGg7XHJcbiAgICAvLyBTZW5kIHRoZSBwdXQuXHJcbiAgICByZXBvLnNlcnZlcl8ucHV0KHBhdGhUb1NlbmQudG9TdHJpbmcoKSwgZGF0YVRvU2VuZCwgKHN0YXR1cykgPT4ge1xyXG4gICAgICAgIHJlcG9Mb2cocmVwbywgJ3RyYW5zYWN0aW9uIHB1dCByZXNwb25zZScsIHtcclxuICAgICAgICAgICAgcGF0aDogcGF0aFRvU2VuZC50b1N0cmluZygpLFxyXG4gICAgICAgICAgICBzdGF0dXNcclxuICAgICAgICB9KTtcclxuICAgICAgICBsZXQgZXZlbnRzID0gW107XHJcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ29rJykge1xyXG4gICAgICAgICAgICAvLyBRdWV1ZSB1cCB0aGUgY2FsbGJhY2tzIGFuZCBmaXJlIHRoZW0gYWZ0ZXIgY2xlYW5pbmcgdXAgYWxsIG9mIG91clxyXG4gICAgICAgICAgICAvLyB0cmFuc2FjdGlvbiBzdGF0ZSwgc2luY2UgdGhlIGNhbGxiYWNrIGNvdWxkIHRyaWdnZXIgbW9yZVxyXG4gICAgICAgICAgICAvLyB0cmFuc2FjdGlvbnMgb3Igc2V0cy5cclxuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHF1ZXVlW2ldLnN0YXR1cyA9IDIgLyogVHJhbnNhY3Rpb25TdGF0dXMuQ09NUExFVEVEICovO1xyXG4gICAgICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChzeW5jVHJlZUFja1VzZXJXcml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcXVldWVbaV0uY3VycmVudFdyaXRlSWQpKTtcclxuICAgICAgICAgICAgICAgIGlmIChxdWV1ZVtpXS5vbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmV2ZXIgdW5zZXQgdGhlIG91dHB1dCBzbmFwc2hvdCwgYW5kIGdpdmVuIHRoYXQgdGhpc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRyYW5zYWN0aW9uIGlzIGNvbXBsZXRlLCBpdCBzaG91bGQgYmUgc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLnB1c2goKCkgPT4gcXVldWVbaV0ub25Db21wbGV0ZShudWxsLCB0cnVlLCBxdWV1ZVtpXS5jdXJyZW50T3V0cHV0U25hcHNob3RSZXNvbHZlZCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcXVldWVbaV0udW53YXRjaGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gTm93IHJlbW92ZSB0aGUgY29tcGxldGVkIHRyYW5zYWN0aW9ucy5cclxuICAgICAgICAgICAgcmVwb1BydW5lQ29tcGxldGVkVHJhbnNhY3Rpb25zQmVsb3dOb2RlKHJlcG8sIHRyZWVTdWJUcmVlKHJlcG8udHJhbnNhY3Rpb25RdWV1ZVRyZWVfLCBwYXRoKSk7XHJcbiAgICAgICAgICAgIC8vIFRoZXJlIG1heSBiZSBwZW5kaW5nIHRyYW5zYWN0aW9ucyB0aGF0IHdlIGNhbiBub3cgc2VuZC5cclxuICAgICAgICAgICAgcmVwb1NlbmRSZWFkeVRyYW5zYWN0aW9ucyhyZXBvLCByZXBvLnRyYW5zYWN0aW9uUXVldWVUcmVlXyk7XHJcbiAgICAgICAgICAgIGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIHBhdGgsIGV2ZW50cyk7XHJcbiAgICAgICAgICAgIC8vIEZpbmFsbHksIHRyaWdnZXIgb25Db21wbGV0ZSBjYWxsYmFja3MuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBleGNlcHRpb25HdWFyZChjYWxsYmFja3NbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB0cmFuc2FjdGlvbnMgYXJlIG5vIGxvbmdlciBzZW50LiAgVXBkYXRlIHRoZWlyIHN0YXR1cyBhcHByb3ByaWF0ZWx5LlxyXG4gICAgICAgICAgICBpZiAoc3RhdHVzID09PSAnZGF0YXN0YWxlJykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChxdWV1ZVtpXS5zdGF0dXMgPT09IDMgLyogVHJhbnNhY3Rpb25TdGF0dXMuU0VOVF9ORUVEU19BQk9SVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZVtpXS5zdGF0dXMgPSA0IC8qIFRyYW5zYWN0aW9uU3RhdHVzLk5FRURTX0FCT1JUICovO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVbaV0uc3RhdHVzID0gMCAvKiBUcmFuc2FjdGlvblN0YXR1cy5SVU4gKi87XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgd2FybigndHJhbnNhY3Rpb24gYXQgJyArIHBhdGhUb1NlbmQudG9TdHJpbmcoKSArICcgZmFpbGVkOiAnICsgc3RhdHVzKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBxdWV1ZVtpXS5zdGF0dXMgPSA0IC8qIFRyYW5zYWN0aW9uU3RhdHVzLk5FRURTX0FCT1JUICovO1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlW2ldLmFib3J0UmVhc29uID0gc3RhdHVzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlcG9SZXJ1blRyYW5zYWN0aW9ucyhyZXBvLCBwYXRoKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBsYXRlc3RIYXNoKTtcclxufVxyXG4vKipcclxuICogRmluZHMgYWxsIHRyYW5zYWN0aW9ucyBkZXBlbmRlbnQgb24gdGhlIGRhdGEgYXQgY2hhbmdlZFBhdGggYW5kIHJlcnVucyB0aGVtLlxyXG4gKlxyXG4gKiBTaG91bGQgYmUgY2FsbGVkIGFueSB0aW1lIGNhY2hlZCBkYXRhIGNoYW5nZXMuXHJcbiAqXHJcbiAqIFJldHVybiB0aGUgaGlnaGVzdCBwYXRoIHRoYXQgd2FzIGFmZmVjdGVkIGJ5IHJlcnVubmluZyB0cmFuc2FjdGlvbnMuIFRoaXNcclxuICogaXMgdGhlIHBhdGggYXQgd2hpY2ggZXZlbnRzIG5lZWQgdG8gYmUgcmFpc2VkIGZvci5cclxuICpcclxuICogQHBhcmFtIGNoYW5nZWRQYXRoIC0gVGhlIHBhdGggaW4gbWVyZ2VkRGF0YSB0aGF0IGNoYW5nZWQuXHJcbiAqIEByZXR1cm5zIFRoZSByb290bW9zdCBwYXRoIHRoYXQgd2FzIGFmZmVjdGVkIGJ5IHJlcnVubmluZyB0cmFuc2FjdGlvbnMuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvUmVydW5UcmFuc2FjdGlvbnMocmVwbywgY2hhbmdlZFBhdGgpIHtcclxuICAgIGNvbnN0IHJvb3RNb3N0VHJhbnNhY3Rpb25Ob2RlID0gcmVwb0dldEFuY2VzdG9yVHJhbnNhY3Rpb25Ob2RlKHJlcG8sIGNoYW5nZWRQYXRoKTtcclxuICAgIGNvbnN0IHBhdGggPSB0cmVlR2V0UGF0aChyb290TW9zdFRyYW5zYWN0aW9uTm9kZSk7XHJcbiAgICBjb25zdCBxdWV1ZSA9IHJlcG9CdWlsZFRyYW5zYWN0aW9uUXVldWUocmVwbywgcm9vdE1vc3RUcmFuc2FjdGlvbk5vZGUpO1xyXG4gICAgcmVwb1JlcnVuVHJhbnNhY3Rpb25RdWV1ZShyZXBvLCBxdWV1ZSwgcGF0aCk7XHJcbiAgICByZXR1cm4gcGF0aDtcclxufVxyXG4vKipcclxuICogRG9lcyBhbGwgdGhlIHdvcmsgb2YgcmVydW5uaW5nIHRyYW5zYWN0aW9ucyAoYXMgd2VsbCBhcyBjbGVhbnMgdXAgYWJvcnRlZFxyXG4gKiB0cmFuc2FjdGlvbnMgYW5kIHdoYXRub3QpLlxyXG4gKlxyXG4gKiBAcGFyYW0gcXVldWUgLSBUaGUgcXVldWUgb2YgdHJhbnNhY3Rpb25zIHRvIHJ1bi5cclxuICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0aGUgcXVldWUgaXMgZm9yLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb1JlcnVuVHJhbnNhY3Rpb25RdWV1ZShyZXBvLCBxdWV1ZSwgcGF0aCkge1xyXG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybjsgLy8gTm90aGluZyB0byBkbyFcclxuICAgIH1cclxuICAgIC8vIFF1ZXVlIHVwIHRoZSBjYWxsYmFja3MgYW5kIGZpcmUgdGhlbSBhZnRlciBjbGVhbmluZyB1cCBhbGwgb2Ygb3VyXHJcbiAgICAvLyB0cmFuc2FjdGlvbiBzdGF0ZSwgc2luY2UgdGhlIGNhbGxiYWNrIGNvdWxkIHRyaWdnZXIgbW9yZSB0cmFuc2FjdGlvbnMgb3JcclxuICAgIC8vIHNldHMuXHJcbiAgICBjb25zdCBjYWxsYmFja3MgPSBbXTtcclxuICAgIGxldCBldmVudHMgPSBbXTtcclxuICAgIC8vIElnbm9yZSBhbGwgb2YgdGhlIHNldHMgd2UncmUgZ29pbmcgdG8gcmUtcnVuLlxyXG4gICAgY29uc3QgdHhuc1RvUmVydW4gPSBxdWV1ZS5maWx0ZXIocSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHEuc3RhdHVzID09PSAwIC8qIFRyYW5zYWN0aW9uU3RhdHVzLlJVTiAqLztcclxuICAgIH0pO1xyXG4gICAgY29uc3Qgc2V0c1RvSWdub3JlID0gdHhuc1RvUmVydW4ubWFwKHEgPT4ge1xyXG4gICAgICAgIHJldHVybiBxLmN1cnJlbnRXcml0ZUlkO1xyXG4gICAgfSk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBxdWV1ZVtpXTtcclxuICAgICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBuZXdSZWxhdGl2ZVBhdGgocGF0aCwgdHJhbnNhY3Rpb24ucGF0aCk7XHJcbiAgICAgICAgbGV0IGFib3J0VHJhbnNhY3Rpb24gPSBmYWxzZSwgYWJvcnRSZWFzb247XHJcbiAgICAgICAgYXNzZXJ0KHJlbGF0aXZlUGF0aCAhPT0gbnVsbCwgJ3JlcnVuVHJhbnNhY3Rpb25zVW5kZXJOb2RlXzogcmVsYXRpdmVQYXRoIHNob3VsZCBub3QgYmUgbnVsbC4nKTtcclxuICAgICAgICBpZiAodHJhbnNhY3Rpb24uc3RhdHVzID09PSA0IC8qIFRyYW5zYWN0aW9uU3RhdHVzLk5FRURTX0FCT1JUICovKSB7XHJcbiAgICAgICAgICAgIGFib3J0VHJhbnNhY3Rpb24gPSB0cnVlO1xyXG4gICAgICAgICAgICBhYm9ydFJlYXNvbiA9IHRyYW5zYWN0aW9uLmFib3J0UmVhc29uO1xyXG4gICAgICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHN5bmNUcmVlQWNrVXNlcldyaXRlKHJlcG8uc2VydmVyU3luY1RyZWVfLCB0cmFuc2FjdGlvbi5jdXJyZW50V3JpdGVJZCwgdHJ1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0cmFuc2FjdGlvbi5zdGF0dXMgPT09IDAgLyogVHJhbnNhY3Rpb25TdGF0dXMuUlVOICovKSB7XHJcbiAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi5yZXRyeUNvdW50ID49IE1BWF9UUkFOU0FDVElPTl9SRVRSSUVTKSB7XHJcbiAgICAgICAgICAgICAgICBhYm9ydFRyYW5zYWN0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGFib3J0UmVhc29uID0gJ21heHJldHJ5JztcclxuICAgICAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoc3luY1RyZWVBY2tVc2VyV3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHRyYW5zYWN0aW9uLmN1cnJlbnRXcml0ZUlkLCB0cnVlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNvZGUgcmVydW5zIGEgdHJhbnNhY3Rpb25cclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnROb2RlID0gcmVwb0dldExhdGVzdFN0YXRlKHJlcG8sIHRyYW5zYWN0aW9uLnBhdGgsIHNldHNUb0lnbm9yZSk7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5jdXJyZW50SW5wdXRTbmFwc2hvdCA9IGN1cnJlbnROb2RlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RGF0YSA9IHF1ZXVlW2ldLnVwZGF0ZShjdXJyZW50Tm9kZS52YWwoKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3RGF0YSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVGaXJlYmFzZURhdGEoJ3RyYW5zYWN0aW9uIGZhaWxlZDogRGF0YSByZXR1cm5lZCAnLCBuZXdEYXRhLCB0cmFuc2FjdGlvbi5wYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3RGF0YU5vZGUgPSBub2RlRnJvbUpTT04obmV3RGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzRXhwbGljaXRQcmlvcml0eSA9IHR5cGVvZiBuZXdEYXRhID09PSAnb2JqZWN0JyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdEYXRhICE9IG51bGwgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbnMobmV3RGF0YSwgJy5wcmlvcml0eScpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaGFzRXhwbGljaXRQcmlvcml0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIHRoZSBvbGQgcHJpb3JpdHkgaWYgdGhlcmUgd2Fzbid0IGEgcHJpb3JpdHkgZXhwbGljaXRseSBzcGVjaWZpZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RhdGFOb2RlID0gbmV3RGF0YU5vZGUudXBkYXRlUHJpb3JpdHkoY3VycmVudE5vZGUuZ2V0UHJpb3JpdHkoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZFdyaXRlSWQgPSB0cmFuc2FjdGlvbi5jdXJyZW50V3JpdGVJZDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJWYWx1ZXMgPSByZXBvR2VuZXJhdGVTZXJ2ZXJWYWx1ZXMocmVwbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3Tm9kZVJlc29sdmVkID0gcmVzb2x2ZURlZmVycmVkVmFsdWVTbmFwc2hvdChuZXdEYXRhTm9kZSwgY3VycmVudE5vZGUsIHNlcnZlclZhbHVlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uY3VycmVudE91dHB1dFNuYXBzaG90UmF3ID0gbmV3RGF0YU5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uY3VycmVudE91dHB1dFNuYXBzaG90UmVzb2x2ZWQgPSBuZXdOb2RlUmVzb2x2ZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uY3VycmVudFdyaXRlSWQgPSByZXBvR2V0TmV4dFdyaXRlSWQocmVwbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTXV0YXRlcyBzZXRzVG9JZ25vcmUgaW4gcGxhY2VcclxuICAgICAgICAgICAgICAgICAgICBzZXRzVG9JZ25vcmUuc3BsaWNlKHNldHNUb0lnbm9yZS5pbmRleE9mKG9sZFdyaXRlSWQpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHN5bmNUcmVlQXBwbHlVc2VyT3ZlcndyaXRlKHJlcG8uc2VydmVyU3luY1RyZWVfLCB0cmFuc2FjdGlvbi5wYXRoLCBuZXdOb2RlUmVzb2x2ZWQsIHRyYW5zYWN0aW9uLmN1cnJlbnRXcml0ZUlkLCB0cmFuc2FjdGlvbi5hcHBseUxvY2FsbHkpKTtcclxuICAgICAgICAgICAgICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHN5bmNUcmVlQWNrVXNlcldyaXRlKHJlcG8uc2VydmVyU3luY1RyZWVfLCBvbGRXcml0ZUlkLCB0cnVlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBhYm9ydFRyYW5zYWN0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBhYm9ydFJlYXNvbiA9ICdub2RhdGEnO1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoc3luY1RyZWVBY2tVc2VyV3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHRyYW5zYWN0aW9uLmN1cnJlbnRXcml0ZUlkLCB0cnVlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZXZlbnRRdWV1ZVJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgocmVwby5ldmVudFF1ZXVlXywgcGF0aCwgZXZlbnRzKTtcclxuICAgICAgICBldmVudHMgPSBbXTtcclxuICAgICAgICBpZiAoYWJvcnRUcmFuc2FjdGlvbikge1xyXG4gICAgICAgICAgICAvLyBBYm9ydC5cclxuICAgICAgICAgICAgcXVldWVbaV0uc3RhdHVzID0gMiAvKiBUcmFuc2FjdGlvblN0YXR1cy5DT01QTEVURUQgKi87XHJcbiAgICAgICAgICAgIC8vIFJlbW92aW5nIGEgbGlzdGVuZXIgY2FuIHRyaWdnZXIgcHJ1bmluZyB3aGljaCBjYW4gbXVjayB3aXRoXHJcbiAgICAgICAgICAgIC8vIG1lcmdlZERhdGEvdmlzaWJsZURhdGEgKGFzIGl0IHBydW5lcyBkYXRhKS4gU28gZGVmZXIgdGhlIHVud2F0Y2hlclxyXG4gICAgICAgICAgICAvLyB1bnRpbCB3ZSdyZSBkb25lLlxyXG4gICAgICAgICAgICAoZnVuY3Rpb24gKHVud2F0Y2hlcikge1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCh1bndhdGNoZXIsIE1hdGguZmxvb3IoMCkpO1xyXG4gICAgICAgICAgICB9KShxdWV1ZVtpXS51bndhdGNoZXIpO1xyXG4gICAgICAgICAgICBpZiAocXVldWVbaV0ub25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFib3J0UmVhc29uID09PSAnbm9kYXRhJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5wdXNoKCgpID0+IHF1ZXVlW2ldLm9uQ29tcGxldGUobnVsbCwgZmFsc2UsIHF1ZXVlW2ldLmN1cnJlbnRJbnB1dFNuYXBzaG90KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3MucHVzaCgoKSA9PiBxdWV1ZVtpXS5vbkNvbXBsZXRlKG5ldyBFcnJvcihhYm9ydFJlYXNvbiksIGZhbHNlLCBudWxsKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBDbGVhbiB1cCBjb21wbGV0ZWQgdHJhbnNhY3Rpb25zLlxyXG4gICAgcmVwb1BydW5lQ29tcGxldGVkVHJhbnNhY3Rpb25zQmVsb3dOb2RlKHJlcG8sIHJlcG8udHJhbnNhY3Rpb25RdWV1ZVRyZWVfKTtcclxuICAgIC8vIE5vdyBmaXJlIGNhbGxiYWNrcywgbm93IHRoYXQgd2UncmUgaW4gYSBnb29kLCBrbm93biBzdGF0ZS5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgZXhjZXB0aW9uR3VhcmQoY2FsbGJhY2tzW2ldKTtcclxuICAgIH1cclxuICAgIC8vIFRyeSB0byBzZW5kIHRoZSB0cmFuc2FjdGlvbiByZXN1bHQgdG8gdGhlIHNlcnZlci5cclxuICAgIHJlcG9TZW5kUmVhZHlUcmFuc2FjdGlvbnMocmVwbywgcmVwby50cmFuc2FjdGlvblF1ZXVlVHJlZV8pO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSByb290bW9zdCBhbmNlc3RvciBub2RlIG9mIHRoZSBzcGVjaWZpZWQgcGF0aCB0aGF0IGhhcyBhIHBlbmRpbmdcclxuICogdHJhbnNhY3Rpb24gb24gaXQsIG9yIGp1c3QgcmV0dXJucyB0aGUgbm9kZSBmb3IgdGhlIGdpdmVuIHBhdGggaWYgdGhlcmUgYXJlXHJcbiAqIG5vIHBlbmRpbmcgdHJhbnNhY3Rpb25zIG9uIGFueSBhbmNlc3Rvci5cclxuICpcclxuICogQHBhcmFtIHBhdGggLSBUaGUgbG9jYXRpb24gdG8gc3RhcnQgYXQuXHJcbiAqIEByZXR1cm5zIFRoZSByb290bW9zdCBub2RlIHdpdGggYSB0cmFuc2FjdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9HZXRBbmNlc3RvclRyYW5zYWN0aW9uTm9kZShyZXBvLCBwYXRoKSB7XHJcbiAgICBsZXQgZnJvbnQ7XHJcbiAgICAvLyBTdGFydCBhdCB0aGUgcm9vdCBhbmQgd2FsayBkZWVwZXIgaW50byB0aGUgdHJlZSB0b3dhcmRzIHBhdGggdW50aWwgd2VcclxuICAgIC8vIGZpbmQgYSBub2RlIHdpdGggcGVuZGluZyB0cmFuc2FjdGlvbnMuXHJcbiAgICBsZXQgdHJhbnNhY3Rpb25Ob2RlID0gcmVwby50cmFuc2FjdGlvblF1ZXVlVHJlZV87XHJcbiAgICBmcm9udCA9IHBhdGhHZXRGcm9udChwYXRoKTtcclxuICAgIHdoaWxlIChmcm9udCAhPT0gbnVsbCAmJiB0cmVlR2V0VmFsdWUodHJhbnNhY3Rpb25Ob2RlKSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdHJhbnNhY3Rpb25Ob2RlID0gdHJlZVN1YlRyZWUodHJhbnNhY3Rpb25Ob2RlLCBmcm9udCk7XHJcbiAgICAgICAgcGF0aCA9IHBhdGhQb3BGcm9udChwYXRoKTtcclxuICAgICAgICBmcm9udCA9IHBhdGhHZXRGcm9udChwYXRoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cmFuc2FjdGlvbk5vZGU7XHJcbn1cclxuLyoqXHJcbiAqIEJ1aWxkcyB0aGUgcXVldWUgb2YgYWxsIHRyYW5zYWN0aW9ucyBhdCBvciBiZWxvdyB0aGUgc3BlY2lmaWVkXHJcbiAqIHRyYW5zYWN0aW9uTm9kZS5cclxuICpcclxuICogQHBhcmFtIHRyYW5zYWN0aW9uTm9kZVxyXG4gKiBAcmV0dXJucyBUaGUgZ2VuZXJhdGVkIHF1ZXVlLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb0J1aWxkVHJhbnNhY3Rpb25RdWV1ZShyZXBvLCB0cmFuc2FjdGlvbk5vZGUpIHtcclxuICAgIC8vIFdhbGsgYW55IGNoaWxkIHRyYW5zYWN0aW9uIHF1ZXVlcyBhbmQgYWdncmVnYXRlIHRoZW0gaW50byBhIHNpbmdsZSBxdWV1ZS5cclxuICAgIGNvbnN0IHRyYW5zYWN0aW9uUXVldWUgPSBbXTtcclxuICAgIHJlcG9BZ2dyZWdhdGVUcmFuc2FjdGlvblF1ZXVlc0Zvck5vZGUocmVwbywgdHJhbnNhY3Rpb25Ob2RlLCB0cmFuc2FjdGlvblF1ZXVlKTtcclxuICAgIC8vIFNvcnQgdGhlbSBieSB0aGUgb3JkZXIgdGhlIHRyYW5zYWN0aW9ucyB3ZXJlIGNyZWF0ZWQuXHJcbiAgICB0cmFuc2FjdGlvblF1ZXVlLnNvcnQoKGEsIGIpID0+IGEub3JkZXIgLSBiLm9yZGVyKTtcclxuICAgIHJldHVybiB0cmFuc2FjdGlvblF1ZXVlO1xyXG59XHJcbmZ1bmN0aW9uIHJlcG9BZ2dyZWdhdGVUcmFuc2FjdGlvblF1ZXVlc0Zvck5vZGUocmVwbywgbm9kZSwgcXVldWUpIHtcclxuICAgIGNvbnN0IG5vZGVRdWV1ZSA9IHRyZWVHZXRWYWx1ZShub2RlKTtcclxuICAgIGlmIChub2RlUXVldWUpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVRdWV1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBxdWV1ZS5wdXNoKG5vZGVRdWV1ZVtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdHJlZUZvckVhY2hDaGlsZChub2RlLCBjaGlsZCA9PiB7XHJcbiAgICAgICAgcmVwb0FnZ3JlZ2F0ZVRyYW5zYWN0aW9uUXVldWVzRm9yTm9kZShyZXBvLCBjaGlsZCwgcXVldWUpO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIFJlbW92ZSBDT01QTEVURUQgdHJhbnNhY3Rpb25zIGF0IG9yIGJlbG93IHRoaXMgbm9kZSBpbiB0aGUgdHJhbnNhY3Rpb25RdWV1ZVRyZWVfLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb1BydW5lQ29tcGxldGVkVHJhbnNhY3Rpb25zQmVsb3dOb2RlKHJlcG8sIG5vZGUpIHtcclxuICAgIGNvbnN0IHF1ZXVlID0gdHJlZUdldFZhbHVlKG5vZGUpO1xyXG4gICAgaWYgKHF1ZXVlKSB7XHJcbiAgICAgICAgbGV0IHRvID0gMDtcclxuICAgICAgICBmb3IgKGxldCBmcm9tID0gMDsgZnJvbSA8IHF1ZXVlLmxlbmd0aDsgZnJvbSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChxdWV1ZVtmcm9tXS5zdGF0dXMgIT09IDIgLyogVHJhbnNhY3Rpb25TdGF0dXMuQ09NUExFVEVEICovKSB7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZVt0b10gPSBxdWV1ZVtmcm9tXTtcclxuICAgICAgICAgICAgICAgIHRvKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcXVldWUubGVuZ3RoID0gdG87XHJcbiAgICAgICAgdHJlZVNldFZhbHVlKG5vZGUsIHF1ZXVlLmxlbmd0aCA+IDAgPyBxdWV1ZSA6IHVuZGVmaW5lZCk7XHJcbiAgICB9XHJcbiAgICB0cmVlRm9yRWFjaENoaWxkKG5vZGUsIGNoaWxkTm9kZSA9PiB7XHJcbiAgICAgICAgcmVwb1BydW5lQ29tcGxldGVkVHJhbnNhY3Rpb25zQmVsb3dOb2RlKHJlcG8sIGNoaWxkTm9kZSk7XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogQWJvcnRzIGFsbCB0cmFuc2FjdGlvbnMgb24gYW5jZXN0b3JzIG9yIGRlc2NlbmRhbnRzIG9mIHRoZSBzcGVjaWZpZWQgcGF0aC5cclxuICogQ2FsbGVkIHdoZW4gZG9pbmcgYSBzZXQoKSBvciB1cGRhdGUoKSBzaW5jZSB3ZSBjb25zaWRlciB0aGVtIGluY29tcGF0aWJsZVxyXG4gKiB3aXRoIHRyYW5zYWN0aW9ucy5cclxuICpcclxuICogQHBhcmFtIHBhdGggLSBQYXRoIGZvciB3aGljaCB3ZSB3YW50IHRvIGFib3J0IHJlbGF0ZWQgdHJhbnNhY3Rpb25zLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb0Fib3J0VHJhbnNhY3Rpb25zKHJlcG8sIHBhdGgpIHtcclxuICAgIGNvbnN0IGFmZmVjdGVkUGF0aCA9IHRyZWVHZXRQYXRoKHJlcG9HZXRBbmNlc3RvclRyYW5zYWN0aW9uTm9kZShyZXBvLCBwYXRoKSk7XHJcbiAgICBjb25zdCB0cmFuc2FjdGlvbk5vZGUgPSB0cmVlU3ViVHJlZShyZXBvLnRyYW5zYWN0aW9uUXVldWVUcmVlXywgcGF0aCk7XHJcbiAgICB0cmVlRm9yRWFjaEFuY2VzdG9yKHRyYW5zYWN0aW9uTm9kZSwgKG5vZGUpID0+IHtcclxuICAgICAgICByZXBvQWJvcnRUcmFuc2FjdGlvbnNPbk5vZGUocmVwbywgbm9kZSk7XHJcbiAgICB9KTtcclxuICAgIHJlcG9BYm9ydFRyYW5zYWN0aW9uc09uTm9kZShyZXBvLCB0cmFuc2FjdGlvbk5vZGUpO1xyXG4gICAgdHJlZUZvckVhY2hEZXNjZW5kYW50KHRyYW5zYWN0aW9uTm9kZSwgKG5vZGUpID0+IHtcclxuICAgICAgICByZXBvQWJvcnRUcmFuc2FjdGlvbnNPbk5vZGUocmVwbywgbm9kZSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBhZmZlY3RlZFBhdGg7XHJcbn1cclxuLyoqXHJcbiAqIEFib3J0IHRyYW5zYWN0aW9ucyBzdG9yZWQgaW4gdGhpcyB0cmFuc2FjdGlvbiBxdWV1ZSBub2RlLlxyXG4gKlxyXG4gKiBAcGFyYW0gbm9kZSAtIE5vZGUgdG8gYWJvcnQgdHJhbnNhY3Rpb25zIGZvci5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9BYm9ydFRyYW5zYWN0aW9uc09uTm9kZShyZXBvLCBub2RlKSB7XHJcbiAgICBjb25zdCBxdWV1ZSA9IHRyZWVHZXRWYWx1ZShub2RlKTtcclxuICAgIGlmIChxdWV1ZSkge1xyXG4gICAgICAgIC8vIFF1ZXVlIHVwIHRoZSBjYWxsYmFja3MgYW5kIGZpcmUgdGhlbSBhZnRlciBjbGVhbmluZyB1cCBhbGwgb2Ygb3VyXHJcbiAgICAgICAgLy8gdHJhbnNhY3Rpb24gc3RhdGUsIHNpbmNlIHRoZSBjYWxsYmFjayBjb3VsZCB0cmlnZ2VyIG1vcmUgdHJhbnNhY3Rpb25zXHJcbiAgICAgICAgLy8gb3Igc2V0cy5cclxuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSBbXTtcclxuICAgICAgICAvLyBHbyB0aHJvdWdoIHF1ZXVlLiAgQW55IGFscmVhZHktc2VudCB0cmFuc2FjdGlvbnMgbXVzdCBiZSBtYXJrZWQgZm9yXHJcbiAgICAgICAgLy8gYWJvcnQsIHdoaWxlIHRoZSB1bnNlbnQgb25lcyBjYW4gYmUgaW1tZWRpYXRlbHkgYWJvcnRlZCBhbmQgcmVtb3ZlZC5cclxuICAgICAgICBsZXQgZXZlbnRzID0gW107XHJcbiAgICAgICAgbGV0IGxhc3RTZW50ID0gLTE7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAocXVldWVbaV0uc3RhdHVzID09PSAzIC8qIFRyYW5zYWN0aW9uU3RhdHVzLlNFTlRfTkVFRFNfQUJPUlQgKi8pIDtcclxuICAgICAgICAgICAgZWxzZSBpZiAocXVldWVbaV0uc3RhdHVzID09PSAxIC8qIFRyYW5zYWN0aW9uU3RhdHVzLlNFTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgIGFzc2VydChsYXN0U2VudCA9PT0gaSAtIDEsICdBbGwgU0VOVCBpdGVtcyBzaG91bGQgYmUgYXQgYmVnaW5uaW5nIG9mIHF1ZXVlLicpO1xyXG4gICAgICAgICAgICAgICAgbGFzdFNlbnQgPSBpO1xyXG4gICAgICAgICAgICAgICAgLy8gTWFyayB0cmFuc2FjdGlvbiBmb3IgYWJvcnQgd2hlbiBpdCBjb21lcyBiYWNrLlxyXG4gICAgICAgICAgICAgICAgcXVldWVbaV0uc3RhdHVzID0gMyAvKiBUcmFuc2FjdGlvblN0YXR1cy5TRU5UX05FRURTX0FCT1JUICovO1xyXG4gICAgICAgICAgICAgICAgcXVldWVbaV0uYWJvcnRSZWFzb24gPSAnc2V0JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFzc2VydChxdWV1ZVtpXS5zdGF0dXMgPT09IDAgLyogVHJhbnNhY3Rpb25TdGF0dXMuUlVOICovLCAnVW5leHBlY3RlZCB0cmFuc2FjdGlvbiBzdGF0dXMgaW4gYWJvcnQnKTtcclxuICAgICAgICAgICAgICAgIC8vIFdlIGNhbiBhYm9ydCBpdCBpbW1lZGlhdGVseS5cclxuICAgICAgICAgICAgICAgIHF1ZXVlW2ldLnVud2F0Y2hlcigpO1xyXG4gICAgICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChzeW5jVHJlZUFja1VzZXJXcml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcXVldWVbaV0uY3VycmVudFdyaXRlSWQsIHRydWUpKTtcclxuICAgICAgICAgICAgICAgIGlmIChxdWV1ZVtpXS5vbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLnB1c2gocXVldWVbaV0ub25Db21wbGV0ZS5iaW5kKG51bGwsIG5ldyBFcnJvcignc2V0JyksIGZhbHNlLCBudWxsKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhc3RTZW50ID09PSAtMSkge1xyXG4gICAgICAgICAgICAvLyBXZSdyZSBub3Qgd2FpdGluZyBmb3IgYW55IHNlbnQgdHJhbnNhY3Rpb25zLiAgV2UgY2FuIGNsZWFyIHRoZSBxdWV1ZS5cclxuICAgICAgICAgICAgdHJlZVNldFZhbHVlKG5vZGUsIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHRyYW5zYWN0aW9ucyB3ZSBhYm9ydGVkLlxyXG4gICAgICAgICAgICBxdWV1ZS5sZW5ndGggPSBsYXN0U2VudCArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE5vdyBmaXJlIHRoZSBjYWxsYmFja3MuXHJcbiAgICAgICAgZXZlbnRRdWV1ZVJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgocmVwby5ldmVudFF1ZXVlXywgdHJlZUdldFBhdGgobm9kZSksIGV2ZW50cyk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZXhjZXB0aW9uR3VhcmQoY2FsbGJhY2tzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gZGVjb2RlUGF0aChwYXRoU3RyaW5nKSB7XHJcbiAgICBsZXQgcGF0aFN0cmluZ0RlY29kZWQgPSAnJztcclxuICAgIGNvbnN0IHBpZWNlcyA9IHBhdGhTdHJpbmcuc3BsaXQoJy8nKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGllY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKHBpZWNlc1tpXS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGxldCBwaWVjZSA9IHBpZWNlc1tpXTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHBpZWNlID0gZGVjb2RlVVJJQ29tcG9uZW50KHBpZWNlLnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XHJcbiAgICAgICAgICAgIHBhdGhTdHJpbmdEZWNvZGVkICs9ICcvJyArIHBpZWNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwYXRoU3RyaW5nRGVjb2RlZDtcclxufVxyXG4vKipcclxuICogQHJldHVybnMga2V5IHZhbHVlIGhhc2hcclxuICovXHJcbmZ1bmN0aW9uIGRlY29kZVF1ZXJ5KHF1ZXJ5U3RyaW5nKSB7XHJcbiAgICBjb25zdCByZXN1bHRzID0ge307XHJcbiAgICBpZiAocXVlcnlTdHJpbmcuY2hhckF0KDApID09PSAnPycpIHtcclxuICAgICAgICBxdWVyeVN0cmluZyA9IHF1ZXJ5U3RyaW5nLnN1YnN0cmluZygxKTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBxdWVyeVN0cmluZy5zcGxpdCgnJicpKSB7XHJcbiAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBrdiA9IHNlZ21lbnQuc3BsaXQoJz0nKTtcclxuICAgICAgICBpZiAoa3YubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHNbZGVjb2RlVVJJQ29tcG9uZW50KGt2WzBdKV0gPSBkZWNvZGVVUklDb21wb25lbnQoa3ZbMV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgd2FybihgSW52YWxpZCBxdWVyeSBzZWdtZW50ICcke3NlZ21lbnR9JyBpbiBxdWVyeSAnJHtxdWVyeVN0cmluZ30nYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdHM7XHJcbn1cclxuY29uc3QgcGFyc2VSZXBvSW5mbyA9IGZ1bmN0aW9uIChkYXRhVVJMLCBub2RlQWRtaW4pIHtcclxuICAgIGNvbnN0IHBhcnNlZFVybCA9IHBhcnNlRGF0YWJhc2VVUkwoZGF0YVVSTCksIG5hbWVzcGFjZSA9IHBhcnNlZFVybC5uYW1lc3BhY2U7XHJcbiAgICBpZiAocGFyc2VkVXJsLmRvbWFpbiA9PT0gJ2ZpcmViYXNlLmNvbScpIHtcclxuICAgICAgICBmYXRhbChwYXJzZWRVcmwuaG9zdCArXHJcbiAgICAgICAgICAgICcgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gJyArXHJcbiAgICAgICAgICAgICdQbGVhc2UgdXNlIDxZT1VSIEZJUkVCQVNFPi5maXJlYmFzZWlvLmNvbSBpbnN0ZWFkJyk7XHJcbiAgICB9XHJcbiAgICAvLyBDYXRjaCBjb21tb24gZXJyb3Igb2YgdW5pbml0aWFsaXplZCBuYW1lc3BhY2UgdmFsdWUuXHJcbiAgICBpZiAoKCFuYW1lc3BhY2UgfHwgbmFtZXNwYWNlID09PSAndW5kZWZpbmVkJykgJiZcclxuICAgICAgICBwYXJzZWRVcmwuZG9tYWluICE9PSAnbG9jYWxob3N0Jykge1xyXG4gICAgICAgIGZhdGFsKCdDYW5ub3QgcGFyc2UgRmlyZWJhc2UgdXJsLiBQbGVhc2UgdXNlIGh0dHBzOi8vPFlPVVIgRklSRUJBU0U+LmZpcmViYXNlaW8uY29tJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoIXBhcnNlZFVybC5zZWN1cmUpIHtcclxuICAgICAgICB3YXJuSWZQYWdlSXNTZWN1cmUoKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHdlYlNvY2tldE9ubHkgPSBwYXJzZWRVcmwuc2NoZW1lID09PSAnd3MnIHx8IHBhcnNlZFVybC5zY2hlbWUgPT09ICd3c3MnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXBvSW5mbzogbmV3IFJlcG9JbmZvKHBhcnNlZFVybC5ob3N0LCBwYXJzZWRVcmwuc2VjdXJlLCBuYW1lc3BhY2UsIHdlYlNvY2tldE9ubHksIG5vZGVBZG1pbiwgXHJcbiAgICAgICAgLypwZXJzaXN0ZW5jZUtleT0qLyAnJywgXHJcbiAgICAgICAgLyppbmNsdWRlTmFtZXNwYWNlSW5RdWVyeVBhcmFtcz0qLyBuYW1lc3BhY2UgIT09IHBhcnNlZFVybC5zdWJkb21haW4pLFxyXG4gICAgICAgIHBhdGg6IG5ldyBQYXRoKHBhcnNlZFVybC5wYXRoU3RyaW5nKVxyXG4gICAgfTtcclxufTtcclxuY29uc3QgcGFyc2VEYXRhYmFzZVVSTCA9IGZ1bmN0aW9uIChkYXRhVVJMKSB7XHJcbiAgICAvLyBEZWZhdWx0IHRvIGVtcHR5IHN0cmluZ3MgaW4gdGhlIGV2ZW50IG9mIGEgbWFsZm9ybWVkIHN0cmluZy5cclxuICAgIGxldCBob3N0ID0gJycsIGRvbWFpbiA9ICcnLCBzdWJkb21haW4gPSAnJywgcGF0aFN0cmluZyA9ICcnLCBuYW1lc3BhY2UgPSAnJztcclxuICAgIC8vIEFsd2F5cyBkZWZhdWx0IHRvIFNTTCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXHJcbiAgICBsZXQgc2VjdXJlID0gdHJ1ZSwgc2NoZW1lID0gJ2h0dHBzJywgcG9ydCA9IDQ0MztcclxuICAgIC8vIERvbid0IGRvIGFueSB2YWxpZGF0aW9uIGhlcmUuIFRoZSBjYWxsZXIgaXMgcmVzcG9uc2libGUgZm9yIHZhbGlkYXRpbmcgdGhlIHJlc3VsdCBvZiBwYXJzaW5nLlxyXG4gICAgaWYgKHR5cGVvZiBkYXRhVVJMID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIC8vIFBhcnNlIHNjaGVtZS5cclxuICAgICAgICBsZXQgY29sb25JbmQgPSBkYXRhVVJMLmluZGV4T2YoJy8vJyk7XHJcbiAgICAgICAgaWYgKGNvbG9uSW5kID49IDApIHtcclxuICAgICAgICAgICAgc2NoZW1lID0gZGF0YVVSTC5zdWJzdHJpbmcoMCwgY29sb25JbmQgLSAxKTtcclxuICAgICAgICAgICAgZGF0YVVSTCA9IGRhdGFVUkwuc3Vic3RyaW5nKGNvbG9uSW5kICsgMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFBhcnNlIGhvc3QsIHBhdGgsIGFuZCBxdWVyeSBzdHJpbmcuXHJcbiAgICAgICAgbGV0IHNsYXNoSW5kID0gZGF0YVVSTC5pbmRleE9mKCcvJyk7XHJcbiAgICAgICAgaWYgKHNsYXNoSW5kID09PSAtMSkge1xyXG4gICAgICAgICAgICBzbGFzaEluZCA9IGRhdGFVUkwubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgcXVlc3Rpb25NYXJrSW5kID0gZGF0YVVSTC5pbmRleE9mKCc/Jyk7XHJcbiAgICAgICAgaWYgKHF1ZXN0aW9uTWFya0luZCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgcXVlc3Rpb25NYXJrSW5kID0gZGF0YVVSTC5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhvc3QgPSBkYXRhVVJMLnN1YnN0cmluZygwLCBNYXRoLm1pbihzbGFzaEluZCwgcXVlc3Rpb25NYXJrSW5kKSk7XHJcbiAgICAgICAgaWYgKHNsYXNoSW5kIDwgcXVlc3Rpb25NYXJrSW5kKSB7XHJcbiAgICAgICAgICAgIC8vIEZvciBwYXRoU3RyaW5nLCBxdWVzdGlvbk1hcmtJbmQgd2lsbCBhbHdheXMgY29tZSBhZnRlciBzbGFzaEluZFxyXG4gICAgICAgICAgICBwYXRoU3RyaW5nID0gZGVjb2RlUGF0aChkYXRhVVJMLnN1YnN0cmluZyhzbGFzaEluZCwgcXVlc3Rpb25NYXJrSW5kKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gZGVjb2RlUXVlcnkoZGF0YVVSTC5zdWJzdHJpbmcoTWF0aC5taW4oZGF0YVVSTC5sZW5ndGgsIHF1ZXN0aW9uTWFya0luZCkpKTtcclxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcG9ydCwgdXNlIHNjaGVtZSBmb3IgZGV0ZXJtaW5pbmcgaWYgaXQncyBzZWN1cmUuXHJcbiAgICAgICAgY29sb25JbmQgPSBob3N0LmluZGV4T2YoJzonKTtcclxuICAgICAgICBpZiAoY29sb25JbmQgPj0gMCkge1xyXG4gICAgICAgICAgICBzZWN1cmUgPSBzY2hlbWUgPT09ICdodHRwcycgfHwgc2NoZW1lID09PSAnd3NzJztcclxuICAgICAgICAgICAgcG9ydCA9IHBhcnNlSW50KGhvc3Quc3Vic3RyaW5nKGNvbG9uSW5kICsgMSksIDEwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbG9uSW5kID0gaG9zdC5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGhvc3RXaXRob3V0UG9ydCA9IGhvc3Quc2xpY2UoMCwgY29sb25JbmQpO1xyXG4gICAgICAgIGlmIChob3N0V2l0aG91dFBvcnQudG9Mb3dlckNhc2UoKSA9PT0gJ2xvY2FsaG9zdCcpIHtcclxuICAgICAgICAgICAgZG9tYWluID0gJ2xvY2FsaG9zdCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGhvc3RXaXRob3V0UG9ydC5zcGxpdCgnLicpLmxlbmd0aCA8PSAyKSB7XHJcbiAgICAgICAgICAgIGRvbWFpbiA9IGhvc3RXaXRob3V0UG9ydDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEludGVycHJldCB0aGUgc3ViZG9tYWluIG9mIGEgMyBvciBtb3JlIGNvbXBvbmVudCBVUkwgYXMgdGhlIG5hbWVzcGFjZSBuYW1lLlxyXG4gICAgICAgICAgICBjb25zdCBkb3RJbmQgPSBob3N0LmluZGV4T2YoJy4nKTtcclxuICAgICAgICAgICAgc3ViZG9tYWluID0gaG9zdC5zdWJzdHJpbmcoMCwgZG90SW5kKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICBkb21haW4gPSBob3N0LnN1YnN0cmluZyhkb3RJbmQgKyAxKTtcclxuICAgICAgICAgICAgLy8gTm9ybWFsaXplIG5hbWVzcGFjZXMgdG8gbG93ZXJjYXNlIHRvIHNoYXJlIHN0b3JhZ2UgLyBjb25uZWN0aW9uLlxyXG4gICAgICAgICAgICBuYW1lc3BhY2UgPSBzdWJkb21haW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFsd2F5cyB0cmVhdCB0aGUgdmFsdWUgb2YgdGhlIGBuc2AgYXMgdGhlIG5hbWVzcGFjZSBuYW1lIGlmIGl0IGlzIHByZXNlbnQuXHJcbiAgICAgICAgaWYgKCducycgaW4gcXVlcnlQYXJhbXMpIHtcclxuICAgICAgICAgICAgbmFtZXNwYWNlID0gcXVlcnlQYXJhbXNbJ25zJ107XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBob3N0LFxyXG4gICAgICAgIHBvcnQsXHJcbiAgICAgICAgZG9tYWluLFxyXG4gICAgICAgIHN1YmRvbWFpbixcclxuICAgICAgICBzZWN1cmUsXHJcbiAgICAgICAgc2NoZW1lLFxyXG4gICAgICAgIHBhdGhTdHJpbmcsXHJcbiAgICAgICAgbmFtZXNwYWNlXHJcbiAgICB9O1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vLyBNb2RlbGVkIGFmdGVyIGJhc2U2NCB3ZWItc2FmZSBjaGFycywgYnV0IG9yZGVyZWQgYnkgQVNDSUkuXHJcbmNvbnN0IFBVU0hfQ0hBUlMgPSAnLTAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWl9hYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eic7XHJcbi8qKlxyXG4gKiBGYW5jeSBJRCBnZW5lcmF0b3IgdGhhdCBjcmVhdGVzIDIwLWNoYXJhY3RlciBzdHJpbmcgaWRlbnRpZmllcnMgd2l0aCB0aGVcclxuICogZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcbiAqXHJcbiAqIDEuIFRoZXkncmUgYmFzZWQgb24gdGltZXN0YW1wIHNvIHRoYXQgdGhleSBzb3J0ICphZnRlciogYW55IGV4aXN0aW5nIGlkcy5cclxuICogMi4gVGhleSBjb250YWluIDcyLWJpdHMgb2YgcmFuZG9tIGRhdGEgYWZ0ZXIgdGhlIHRpbWVzdGFtcCBzbyB0aGF0IElEcyB3b24ndFxyXG4gKiAgICBjb2xsaWRlIHdpdGggb3RoZXIgY2xpZW50cycgSURzLlxyXG4gKiAzLiBUaGV5IHNvcnQgKmxleGljb2dyYXBoaWNhbGx5KiAoc28gdGhlIHRpbWVzdGFtcCBpcyBjb252ZXJ0ZWQgdG8gY2hhcmFjdGVyc1xyXG4gKiAgICB0aGF0IHdpbGwgc29ydCBwcm9wZXJseSkuXHJcbiAqIDQuIFRoZXkncmUgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nLiBFdmVuIGlmIHlvdSBnZW5lcmF0ZSBtb3JlIHRoYW4gb25lIGluXHJcbiAqICAgIHRoZSBzYW1lIHRpbWVzdGFtcCwgdGhlIGxhdHRlciBvbmVzIHdpbGwgc29ydCBhZnRlciB0aGUgZm9ybWVyIG9uZXMuIFdlIGRvXHJcbiAqICAgIHRoaXMgYnkgdXNpbmcgdGhlIHByZXZpb3VzIHJhbmRvbSBiaXRzIGJ1dCBcImluY3JlbWVudGluZ1wiIHRoZW0gYnkgMSAob25seVxyXG4gKiAgICBpbiB0aGUgY2FzZSBvZiBhIHRpbWVzdGFtcCBjb2xsaXNpb24pLlxyXG4gKi9cclxuY29uc3QgbmV4dFB1c2hJZCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBUaW1lc3RhbXAgb2YgbGFzdCBwdXNoLCB1c2VkIHRvIHByZXZlbnQgbG9jYWwgY29sbGlzaW9ucyBpZiB5b3UgcHVzaCB0d2ljZVxyXG4gICAgLy8gaW4gb25lIG1zLlxyXG4gICAgbGV0IGxhc3RQdXNoVGltZSA9IDA7XHJcbiAgICAvLyBXZSBnZW5lcmF0ZSA3Mi1iaXRzIG9mIHJhbmRvbW5lc3Mgd2hpY2ggZ2V0IHR1cm5lZCBpbnRvIDEyIGNoYXJhY3RlcnMgYW5kXHJcbiAgICAvLyBhcHBlbmRlZCB0byB0aGUgdGltZXN0YW1wIHRvIHByZXZlbnQgY29sbGlzaW9ucyB3aXRoIG90aGVyIGNsaWVudHMuIFdlXHJcbiAgICAvLyBzdG9yZSB0aGUgbGFzdCBjaGFyYWN0ZXJzIHdlIGdlbmVyYXRlZCBiZWNhdXNlIGluIHRoZSBldmVudCBvZiBhIGNvbGxpc2lvbixcclxuICAgIC8vIHdlJ2xsIHVzZSB0aG9zZSBzYW1lIGNoYXJhY3RlcnMgZXhjZXB0IFwiaW5jcmVtZW50ZWRcIiBieSBvbmUuXHJcbiAgICBjb25zdCBsYXN0UmFuZENoYXJzID0gW107XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5vdykge1xyXG4gICAgICAgIGNvbnN0IGR1cGxpY2F0ZVRpbWUgPSBub3cgPT09IGxhc3RQdXNoVGltZTtcclxuICAgICAgICBsYXN0UHVzaFRpbWUgPSBub3c7XHJcbiAgICAgICAgbGV0IGk7XHJcbiAgICAgICAgY29uc3QgdGltZVN0YW1wQ2hhcnMgPSBuZXcgQXJyYXkoOCk7XHJcbiAgICAgICAgZm9yIChpID0gNzsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgdGltZVN0YW1wQ2hhcnNbaV0gPSBQVVNIX0NIQVJTLmNoYXJBdChub3cgJSA2NCk7XHJcbiAgICAgICAgICAgIC8vIE5PVEU6IENhbid0IHVzZSA8PCBoZXJlIGJlY2F1c2UgamF2YXNjcmlwdCB3aWxsIGNvbnZlcnQgdG8gaW50IGFuZCBsb3NlXHJcbiAgICAgICAgICAgIC8vIHRoZSB1cHBlciBiaXRzLlxyXG4gICAgICAgICAgICBub3cgPSBNYXRoLmZsb29yKG5vdyAvIDY0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXNzZXJ0KG5vdyA9PT0gMCwgJ0Nhbm5vdCBwdXNoIGF0IHRpbWUgPT0gMCcpO1xyXG4gICAgICAgIGxldCBpZCA9IHRpbWVTdGFtcENoYXJzLmpvaW4oJycpO1xyXG4gICAgICAgIGlmICghZHVwbGljYXRlVGltZSkge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGFzdFJhbmRDaGFyc1tpXSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDY0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gSWYgdGhlIHRpbWVzdGFtcCBoYXNuJ3QgY2hhbmdlZCBzaW5jZSBsYXN0IHB1c2gsIHVzZSB0aGUgc2FtZSByYW5kb21cclxuICAgICAgICAgICAgLy8gbnVtYmVyLCBleGNlcHQgaW5jcmVtZW50ZWQgYnkgMS5cclxuICAgICAgICAgICAgZm9yIChpID0gMTE7IGkgPj0gMCAmJiBsYXN0UmFuZENoYXJzW2ldID09PSA2MzsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICBsYXN0UmFuZENoYXJzW2ldID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsYXN0UmFuZENoYXJzW2ldKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlkICs9IFBVU0hfQ0hBUlMuY2hhckF0KGxhc3RSYW5kQ2hhcnNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhc3NlcnQoaWQubGVuZ3RoID09PSAyMCwgJ25leHRQdXNoSWQ6IExlbmd0aCBzaG91bGQgYmUgMjAuJyk7XHJcbiAgICAgICAgcmV0dXJuIGlkO1xyXG4gICAgfTtcclxufSkoKTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEVuY2Fwc3VsYXRlcyB0aGUgZGF0YSBuZWVkZWQgdG8gcmFpc2UgYW4gZXZlbnRcclxuICovXHJcbmNsYXNzIERhdGFFdmVudCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBldmVudFR5cGUgLSBPbmUgb2Y6IHZhbHVlLCBjaGlsZF9hZGRlZCwgY2hpbGRfY2hhbmdlZCwgY2hpbGRfbW92ZWQsIGNoaWxkX3JlbW92ZWRcclxuICAgICAqIEBwYXJhbSBldmVudFJlZ2lzdHJhdGlvbiAtIFRoZSBmdW5jdGlvbiB0byBjYWxsIHRvIHdpdGggdGhlIGV2ZW50IGRhdGEuIFVzZXIgcHJvdmlkZWRcclxuICAgICAqIEBwYXJhbSBzbmFwc2hvdCAtIFRoZSBkYXRhIGJhY2tpbmcgdGhlIGV2ZW50XHJcbiAgICAgKiBAcGFyYW0gcHJldk5hbWUgLSBPcHRpb25hbCwgdGhlIG5hbWUgb2YgdGhlIHByZXZpb3VzIGNoaWxkIGZvciBjaGlsZF8qIGV2ZW50cy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZXZlbnRUeXBlLCBldmVudFJlZ2lzdHJhdGlvbiwgc25hcHNob3QsIHByZXZOYW1lKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudFR5cGUgPSBldmVudFR5cGU7XHJcbiAgICAgICAgdGhpcy5ldmVudFJlZ2lzdHJhdGlvbiA9IGV2ZW50UmVnaXN0cmF0aW9uO1xyXG4gICAgICAgIHRoaXMuc25hcHNob3QgPSBzbmFwc2hvdDtcclxuICAgICAgICB0aGlzLnByZXZOYW1lID0gcHJldk5hbWU7XHJcbiAgICB9XHJcbiAgICBnZXRQYXRoKCkge1xyXG4gICAgICAgIGNvbnN0IHJlZiA9IHRoaXMuc25hcHNob3QucmVmO1xyXG4gICAgICAgIGlmICh0aGlzLmV2ZW50VHlwZSA9PT0gJ3ZhbHVlJykge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVmLl9wYXRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlZi5wYXJlbnQuX3BhdGg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0RXZlbnRUeXBlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50VHlwZTtcclxuICAgIH1cclxuICAgIGdldEV2ZW50UnVubmVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50UmVnaXN0cmF0aW9uLmdldEV2ZW50UnVubmVyKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmdldFBhdGgoKS50b1N0cmluZygpICtcclxuICAgICAgICAgICAgJzonICtcclxuICAgICAgICAgICAgdGhpcy5ldmVudFR5cGUgK1xyXG4gICAgICAgICAgICAnOicgK1xyXG4gICAgICAgICAgICBzdHJpbmdpZnkodGhpcy5zbmFwc2hvdC5leHBvcnRWYWwoKSkpO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIENhbmNlbEV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGV2ZW50UmVnaXN0cmF0aW9uLCBlcnJvciwgcGF0aCkge1xyXG4gICAgICAgIHRoaXMuZXZlbnRSZWdpc3RyYXRpb24gPSBldmVudFJlZ2lzdHJhdGlvbjtcclxuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XHJcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcclxuICAgIH1cclxuICAgIGdldFBhdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aDtcclxuICAgIH1cclxuICAgIGdldEV2ZW50VHlwZSgpIHtcclxuICAgICAgICByZXR1cm4gJ2NhbmNlbCc7XHJcbiAgICB9XHJcbiAgICBnZXRFdmVudFJ1bm5lcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ldmVudFJlZ2lzdHJhdGlvbi5nZXRFdmVudFJ1bm5lcih0aGlzKTtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhdGgudG9TdHJpbmcoKSArICc6Y2FuY2VsJztcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQSB3cmFwcGVyIGNsYXNzIHRoYXQgY29udmVydHMgZXZlbnRzIGZyb20gdGhlIGRhdGFiYXNlQGV4cCBTREsgdG8gdGhlIGxlZ2FjeVxyXG4gKiBEYXRhYmFzZSBTREsuIEV2ZW50cyBhcmUgbm90IGNvbnZlcnRlZCBkaXJlY3RseSBhcyBldmVudCByZWdpc3RyYXRpb24gcmVsaWVzXHJcbiAqIG9uIHJlZmVyZW5jZSBjb21wYXJpc29uIG9mIHRoZSBvcmlnaW5hbCB1c2VyIGNhbGxiYWNrIChzZWUgYG1hdGNoZXMoKWApIGFuZFxyXG4gKiByZWxpZXMgb24gZXF1YWxpdHkgb2YgdGhlIGxlZ2FjeSBTREsncyBgY29udGV4dGAgb2JqZWN0LlxyXG4gKi9cclxuY2xhc3MgQ2FsbGJhY2tDb250ZXh0IHtcclxuICAgIGNvbnN0cnVjdG9yKHNuYXBzaG90Q2FsbGJhY2ssIGNhbmNlbENhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5zbmFwc2hvdENhbGxiYWNrID0gc25hcHNob3RDYWxsYmFjaztcclxuICAgICAgICB0aGlzLmNhbmNlbENhbGxiYWNrID0gY2FuY2VsQ2FsbGJhY2s7XHJcbiAgICB9XHJcbiAgICBvblZhbHVlKGV4cERhdGFTbmFwc2hvdCwgcHJldmlvdXNDaGlsZE5hbWUpIHtcclxuICAgICAgICB0aGlzLnNuYXBzaG90Q2FsbGJhY2suY2FsbChudWxsLCBleHBEYXRhU25hcHNob3QsIHByZXZpb3VzQ2hpbGROYW1lKTtcclxuICAgIH1cclxuICAgIG9uQ2FuY2VsKGVycm9yKSB7XHJcbiAgICAgICAgYXNzZXJ0KHRoaXMuaGFzQ2FuY2VsQ2FsbGJhY2ssICdSYWlzaW5nIGEgY2FuY2VsIGV2ZW50IG9uIGEgbGlzdGVuZXIgd2l0aCBubyBjYW5jZWwgY2FsbGJhY2snKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYW5jZWxDYWxsYmFjay5jYWxsKG51bGwsIGVycm9yKTtcclxuICAgIH1cclxuICAgIGdldCBoYXNDYW5jZWxDYWxsYmFjaygpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLmNhbmNlbENhbGxiYWNrO1xyXG4gICAgfVxyXG4gICAgbWF0Y2hlcyhvdGhlcikge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5zbmFwc2hvdENhbGxiYWNrID09PSBvdGhlci5zbmFwc2hvdENhbGxiYWNrIHx8XHJcbiAgICAgICAgICAgICh0aGlzLnNuYXBzaG90Q2FsbGJhY2sudXNlckNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMuc25hcHNob3RDYWxsYmFjay51c2VyQ2FsbGJhY2sgPT09XHJcbiAgICAgICAgICAgICAgICAgICAgb3RoZXIuc25hcHNob3RDYWxsYmFjay51c2VyQ2FsbGJhY2sgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMuc25hcHNob3RDYWxsYmFjay5jb250ZXh0ID09PSBvdGhlci5zbmFwc2hvdENhbGxiYWNrLmNvbnRleHQpKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhlIGBvbkRpc2Nvbm5lY3RgIGNsYXNzIGFsbG93cyB5b3UgdG8gd3JpdGUgb3IgY2xlYXIgZGF0YSB3aGVuIHlvdXIgY2xpZW50XHJcbiAqIGRpc2Nvbm5lY3RzIGZyb20gdGhlIERhdGFiYXNlIHNlcnZlci4gVGhlc2UgdXBkYXRlcyBvY2N1ciB3aGV0aGVyIHlvdXJcclxuICogY2xpZW50IGRpc2Nvbm5lY3RzIGNsZWFubHkgb3Igbm90LCBzbyB5b3UgY2FuIHJlbHkgb24gdGhlbSB0byBjbGVhbiB1cCBkYXRhXHJcbiAqIGV2ZW4gaWYgYSBjb25uZWN0aW9uIGlzIGRyb3BwZWQgb3IgYSBjbGllbnQgY3Jhc2hlcy5cclxuICpcclxuICogVGhlIGBvbkRpc2Nvbm5lY3RgIGNsYXNzIGlzIG1vc3QgY29tbW9ubHkgdXNlZCB0byBtYW5hZ2UgcHJlc2VuY2UgaW5cclxuICogYXBwbGljYXRpb25zIHdoZXJlIGl0IGlzIHVzZWZ1bCB0byBkZXRlY3QgaG93IG1hbnkgY2xpZW50cyBhcmUgY29ubmVjdGVkIGFuZFxyXG4gKiB3aGVuIG90aGVyIGNsaWVudHMgZGlzY29ubmVjdC4gU2VlXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvb2ZmbGluZS1jYXBhYmlsaXRpZXMgfCBFbmFibGluZyBPZmZsaW5lIENhcGFiaWxpdGllcyBpbiBKYXZhU2NyaXB0fVxyXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuICpcclxuICogVG8gYXZvaWQgcHJvYmxlbXMgd2hlbiBhIGNvbm5lY3Rpb24gaXMgZHJvcHBlZCBiZWZvcmUgdGhlIHJlcXVlc3RzIGNhbiBiZVxyXG4gKiB0cmFuc2ZlcnJlZCB0byB0aGUgRGF0YWJhc2Ugc2VydmVyLCB0aGVzZSBmdW5jdGlvbnMgc2hvdWxkIGJlIGNhbGxlZCBiZWZvcmVcclxuICogd3JpdGluZyBhbnkgZGF0YS5cclxuICpcclxuICogTm90ZSB0aGF0IGBvbkRpc2Nvbm5lY3RgIG9wZXJhdGlvbnMgYXJlIG9ubHkgdHJpZ2dlcmVkIG9uY2UuIElmIHlvdSB3YW50IGFuXHJcbiAqIG9wZXJhdGlvbiB0byBvY2N1ciBlYWNoIHRpbWUgYSBkaXNjb25uZWN0IG9jY3VycywgeW91J2xsIG5lZWQgdG8gcmUtZXN0YWJsaXNoXHJcbiAqIHRoZSBgb25EaXNjb25uZWN0YCBvcGVyYXRpb25zIGVhY2ggdGltZSB5b3UgcmVjb25uZWN0LlxyXG4gKi9cclxuY2xhc3MgT25EaXNjb25uZWN0IHtcclxuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXHJcbiAgICBjb25zdHJ1Y3RvcihfcmVwbywgX3BhdGgpIHtcclxuICAgICAgICB0aGlzLl9yZXBvID0gX3JlcG87XHJcbiAgICAgICAgdGhpcy5fcGF0aCA9IF9wYXRoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYW5jZWxzIGFsbCBwcmV2aW91c2x5IHF1ZXVlZCBgb25EaXNjb25uZWN0KClgIHNldCBvciB1cGRhdGUgZXZlbnRzIGZvciB0aGlzXHJcbiAgICAgKiBsb2NhdGlvbiBhbmQgYWxsIGNoaWxkcmVuLlxyXG4gICAgICpcclxuICAgICAqIElmIGEgd3JpdGUgaGFzIGJlZW4gcXVldWVkIGZvciB0aGlzIGxvY2F0aW9uIHZpYSBhIGBzZXQoKWAgb3IgYHVwZGF0ZSgpYCBhdCBhXHJcbiAgICAgKiBwYXJlbnQgbG9jYXRpb24sIHRoZSB3cml0ZSBhdCB0aGlzIGxvY2F0aW9uIHdpbGwgYmUgY2FuY2VsZWQsIHRob3VnaCB3cml0ZXNcclxuICAgICAqIHRvIHNpYmxpbmcgbG9jYXRpb25zIHdpbGwgc3RpbGwgb2NjdXIuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgUmVzb2x2ZXMgd2hlbiBzeW5jaHJvbml6YXRpb24gdG8gdGhlIHNlcnZlciBpcyBjb21wbGV0ZS5cclxuICAgICAqL1xyXG4gICAgY2FuY2VsKCkge1xyXG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICAgICAgcmVwb09uRGlzY29ubmVjdENhbmNlbCh0aGlzLl9yZXBvLCB0aGlzLl9wYXRoLCBkZWZlcnJlZC53cmFwQ2FsbGJhY2soKCkgPT4geyB9KSk7XHJcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVuc3VyZXMgdGhlIGRhdGEgYXQgdGhpcyBsb2NhdGlvbiBpcyBkZWxldGVkIHdoZW4gdGhlIGNsaWVudCBpcyBkaXNjb25uZWN0ZWRcclxuICAgICAqIChkdWUgdG8gY2xvc2luZyB0aGUgYnJvd3NlciwgbmF2aWdhdGluZyB0byBhIG5ldyBwYWdlLCBvciBuZXR3b3JrIGlzc3VlcykuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgUmVzb2x2ZXMgd2hlbiBzeW5jaHJvbml6YXRpb24gdG8gdGhlIHNlcnZlciBpcyBjb21wbGV0ZS5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlKCkge1xyXG4gICAgICAgIHZhbGlkYXRlV3JpdGFibGVQYXRoKCdPbkRpc2Nvbm5lY3QucmVtb3ZlJywgdGhpcy5fcGF0aCk7XHJcbiAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgICAgICByZXBvT25EaXNjb25uZWN0U2V0KHRoaXMuX3JlcG8sIHRoaXMuX3BhdGgsIG51bGwsIGRlZmVycmVkLndyYXBDYWxsYmFjaygoKSA9PiB7IH0pKTtcclxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRW5zdXJlcyB0aGUgZGF0YSBhdCB0aGlzIGxvY2F0aW9uIGlzIHNldCB0byB0aGUgc3BlY2lmaWVkIHZhbHVlIHdoZW4gdGhlXHJcbiAgICAgKiBjbGllbnQgaXMgZGlzY29ubmVjdGVkIChkdWUgdG8gY2xvc2luZyB0aGUgYnJvd3NlciwgbmF2aWdhdGluZyB0byBhIG5ldyBwYWdlLFxyXG4gICAgICogb3IgbmV0d29yayBpc3N1ZXMpLlxyXG4gICAgICpcclxuICAgICAqIGBzZXQoKWAgaXMgZXNwZWNpYWxseSB1c2VmdWwgZm9yIGltcGxlbWVudGluZyBcInByZXNlbmNlXCIgc3lzdGVtcywgd2hlcmUgYVxyXG4gICAgICogdmFsdWUgc2hvdWxkIGJlIGNoYW5nZWQgb3IgY2xlYXJlZCB3aGVuIGEgdXNlciBkaXNjb25uZWN0cyBzbyB0aGF0IHRoZXlcclxuICAgICAqIGFwcGVhciBcIm9mZmxpbmVcIiB0byBvdGhlciB1c2Vycy4gU2VlXHJcbiAgICAgKiB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZGF0YWJhc2Uvd2ViL29mZmxpbmUtY2FwYWJpbGl0aWVzIHwgRW5hYmxpbmcgT2ZmbGluZSBDYXBhYmlsaXRpZXMgaW4gSmF2YVNjcmlwdH1cclxuICAgICAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIE5vdGUgdGhhdCBgb25EaXNjb25uZWN0YCBvcGVyYXRpb25zIGFyZSBvbmx5IHRyaWdnZXJlZCBvbmNlLiBJZiB5b3Ugd2FudCBhblxyXG4gICAgICogb3BlcmF0aW9uIHRvIG9jY3VyIGVhY2ggdGltZSBhIGRpc2Nvbm5lY3Qgb2NjdXJzLCB5b3UnbGwgbmVlZCB0byByZS1lc3RhYmxpc2hcclxuICAgICAqIHRoZSBgb25EaXNjb25uZWN0YCBvcGVyYXRpb25zIGVhY2ggdGltZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gYmUgd3JpdHRlbiB0byB0aGlzIGxvY2F0aW9uIG9uIGRpc2Nvbm5lY3QgKGNhblxyXG4gICAgICogYmUgYW4gb2JqZWN0LCBhcnJheSwgc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4sIG9yIG51bGwpLlxyXG4gICAgICogQHJldHVybnMgUmVzb2x2ZXMgd2hlbiBzeW5jaHJvbml6YXRpb24gdG8gdGhlIERhdGFiYXNlIGlzIGNvbXBsZXRlLlxyXG4gICAgICovXHJcbiAgICBzZXQodmFsdWUpIHtcclxuICAgICAgICB2YWxpZGF0ZVdyaXRhYmxlUGF0aCgnT25EaXNjb25uZWN0LnNldCcsIHRoaXMuX3BhdGgpO1xyXG4gICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdPbkRpc2Nvbm5lY3Quc2V0JywgdmFsdWUsIHRoaXMuX3BhdGgsIGZhbHNlKTtcclxuICAgICAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgICAgIHJlcG9PbkRpc2Nvbm5lY3RTZXQodGhpcy5fcmVwbywgdGhpcy5fcGF0aCwgdmFsdWUsIGRlZmVycmVkLndyYXBDYWxsYmFjaygoKSA9PiB7IH0pKTtcclxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRW5zdXJlcyB0aGUgZGF0YSBhdCB0aGlzIGxvY2F0aW9uIGlzIHNldCB0byB0aGUgc3BlY2lmaWVkIHZhbHVlIGFuZCBwcmlvcml0eVxyXG4gICAgICogd2hlbiB0aGUgY2xpZW50IGlzIGRpc2Nvbm5lY3RlZCAoZHVlIHRvIGNsb3NpbmcgdGhlIGJyb3dzZXIsIG5hdmlnYXRpbmcgdG8gYVxyXG4gICAgICogbmV3IHBhZ2UsIG9yIG5ldHdvcmsgaXNzdWVzKS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gYmUgd3JpdHRlbiB0byB0aGlzIGxvY2F0aW9uIG9uIGRpc2Nvbm5lY3QgKGNhblxyXG4gICAgICogYmUgYW4gb2JqZWN0LCBhcnJheSwgc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4sIG9yIG51bGwpLlxyXG4gICAgICogQHBhcmFtIHByaW9yaXR5IC0gVGhlIHByaW9yaXR5IHRvIGJlIHdyaXR0ZW4gKHN0cmluZywgbnVtYmVyLCBvciBudWxsKS5cclxuICAgICAqIEByZXR1cm5zIFJlc29sdmVzIHdoZW4gc3luY2hyb25pemF0aW9uIHRvIHRoZSBEYXRhYmFzZSBpcyBjb21wbGV0ZS5cclxuICAgICAqL1xyXG4gICAgc2V0V2l0aFByaW9yaXR5KHZhbHVlLCBwcmlvcml0eSkge1xyXG4gICAgICAgIHZhbGlkYXRlV3JpdGFibGVQYXRoKCdPbkRpc2Nvbm5lY3Quc2V0V2l0aFByaW9yaXR5JywgdGhpcy5fcGF0aCk7XHJcbiAgICAgICAgdmFsaWRhdGVGaXJlYmFzZURhdGFBcmcoJ09uRGlzY29ubmVjdC5zZXRXaXRoUHJpb3JpdHknLCB2YWx1ZSwgdGhpcy5fcGF0aCwgZmFsc2UpO1xyXG4gICAgICAgIHZhbGlkYXRlUHJpb3JpdHkoJ09uRGlzY29ubmVjdC5zZXRXaXRoUHJpb3JpdHknLCBwcmlvcml0eSwgZmFsc2UpO1xyXG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICAgICAgcmVwb09uRGlzY29ubmVjdFNldFdpdGhQcmlvcml0eSh0aGlzLl9yZXBvLCB0aGlzLl9wYXRoLCB2YWx1ZSwgcHJpb3JpdHksIGRlZmVycmVkLndyYXBDYWxsYmFjaygoKSA9PiB7IH0pKTtcclxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIG11bHRpcGxlIHZhbHVlcyBhdCB0aGlzIGxvY2F0aW9uIHdoZW4gdGhlIGNsaWVudCBpcyBkaXNjb25uZWN0ZWQgKGR1ZVxyXG4gICAgICogdG8gY2xvc2luZyB0aGUgYnJvd3NlciwgbmF2aWdhdGluZyB0byBhIG5ldyBwYWdlLCBvciBuZXR3b3JrIGlzc3VlcykuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGB2YWx1ZXNgIGFyZ3VtZW50IGNvbnRhaW5zIG11bHRpcGxlIHByb3BlcnR5LXZhbHVlIHBhaXJzIHRoYXQgd2lsbCBiZVxyXG4gICAgICogd3JpdHRlbiB0byB0aGUgRGF0YWJhc2UgdG9nZXRoZXIuIEVhY2ggY2hpbGQgcHJvcGVydHkgY2FuIGVpdGhlciBiZSBhIHNpbXBsZVxyXG4gICAgICogcHJvcGVydHkgKGZvciBleGFtcGxlLCBcIm5hbWVcIikgb3IgYSByZWxhdGl2ZSBwYXRoIChmb3IgZXhhbXBsZSwgXCJuYW1lL2ZpcnN0XCIpXHJcbiAgICAgKiBmcm9tIHRoZSBjdXJyZW50IGxvY2F0aW9uIHRvIHRoZSBkYXRhIHRvIHVwZGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBBcyBvcHBvc2VkIHRvIHRoZSBgc2V0KClgIG1ldGhvZCwgYHVwZGF0ZSgpYCBjYW4gYmUgdXNlIHRvIHNlbGVjdGl2ZWx5IHVwZGF0ZVxyXG4gICAgICogb25seSB0aGUgcmVmZXJlbmNlZCBwcm9wZXJ0aWVzIGF0IHRoZSBjdXJyZW50IGxvY2F0aW9uIChpbnN0ZWFkIG9mIHJlcGxhY2luZ1xyXG4gICAgICogYWxsIHRoZSBjaGlsZCBwcm9wZXJ0aWVzIGF0IHRoZSBjdXJyZW50IGxvY2F0aW9uKS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVzIC0gT2JqZWN0IGNvbnRhaW5pbmcgbXVsdGlwbGUgdmFsdWVzLlxyXG4gICAgICogQHJldHVybnMgUmVzb2x2ZXMgd2hlbiBzeW5jaHJvbml6YXRpb24gdG8gdGhlIERhdGFiYXNlIGlzIGNvbXBsZXRlLlxyXG4gICAgICovXHJcbiAgICB1cGRhdGUodmFsdWVzKSB7XHJcbiAgICAgICAgdmFsaWRhdGVXcml0YWJsZVBhdGgoJ09uRGlzY29ubmVjdC51cGRhdGUnLCB0aGlzLl9wYXRoKTtcclxuICAgICAgICB2YWxpZGF0ZUZpcmViYXNlTWVyZ2VEYXRhQXJnKCdPbkRpc2Nvbm5lY3QudXBkYXRlJywgdmFsdWVzLCB0aGlzLl9wYXRoLCBmYWxzZSk7XHJcbiAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgICAgICByZXBvT25EaXNjb25uZWN0VXBkYXRlKHRoaXMuX3JlcG8sIHRoaXMuX3BhdGgsIHZhbHVlcywgZGVmZXJyZWQud3JhcENhbGxiYWNrKCgpID0+IHsgfSkpO1xyXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIFF1ZXJ5SW1wbCB7XHJcbiAgICAvKipcclxuICAgICAqIEBoaWRlY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoX3JlcG8sIF9wYXRoLCBfcXVlcnlQYXJhbXMsIF9vcmRlckJ5Q2FsbGVkKSB7XHJcbiAgICAgICAgdGhpcy5fcmVwbyA9IF9yZXBvO1xyXG4gICAgICAgIHRoaXMuX3BhdGggPSBfcGF0aDtcclxuICAgICAgICB0aGlzLl9xdWVyeVBhcmFtcyA9IF9xdWVyeVBhcmFtcztcclxuICAgICAgICB0aGlzLl9vcmRlckJ5Q2FsbGVkID0gX29yZGVyQnlDYWxsZWQ7XHJcbiAgICB9XHJcbiAgICBnZXQga2V5KCkge1xyXG4gICAgICAgIGlmIChwYXRoSXNFbXB0eSh0aGlzLl9wYXRoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXRoR2V0QmFjayh0aGlzLl9wYXRoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgcmVmKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVmZXJlbmNlSW1wbCh0aGlzLl9yZXBvLCB0aGlzLl9wYXRoKTtcclxuICAgIH1cclxuICAgIGdldCBfcXVlcnlJZGVudGlmaWVyKCkge1xyXG4gICAgICAgIGNvbnN0IG9iaiA9IHF1ZXJ5UGFyYW1zR2V0UXVlcnlPYmplY3QodGhpcy5fcXVlcnlQYXJhbXMpO1xyXG4gICAgICAgIGNvbnN0IGlkID0gT2JqZWN0VG9VbmlxdWVLZXkob2JqKTtcclxuICAgICAgICByZXR1cm4gaWQgPT09ICd7fScgPyAnZGVmYXVsdCcgOiBpZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBxdWVyeSBwYXJhbWV0ZXJzIHVzZWQgYnkgdGhpcyBRdWVyeS5cclxuICAgICAqL1xyXG4gICAgZ2V0IF9xdWVyeU9iamVjdCgpIHtcclxuICAgICAgICByZXR1cm4gcXVlcnlQYXJhbXNHZXRRdWVyeU9iamVjdCh0aGlzLl9xdWVyeVBhcmFtcyk7XHJcbiAgICB9XHJcbiAgICBpc0VxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgb3RoZXIgPSBnZXRNb2R1bGFySW5zdGFuY2Uob3RoZXIpO1xyXG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgUXVlcnlJbXBsKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNhbWVSZXBvID0gdGhpcy5fcmVwbyA9PT0gb3RoZXIuX3JlcG87XHJcbiAgICAgICAgY29uc3Qgc2FtZVBhdGggPSBwYXRoRXF1YWxzKHRoaXMuX3BhdGgsIG90aGVyLl9wYXRoKTtcclxuICAgICAgICBjb25zdCBzYW1lUXVlcnlJZGVudGlmaWVyID0gdGhpcy5fcXVlcnlJZGVudGlmaWVyID09PSBvdGhlci5fcXVlcnlJZGVudGlmaWVyO1xyXG4gICAgICAgIHJldHVybiBzYW1lUmVwbyAmJiBzYW1lUGF0aCAmJiBzYW1lUXVlcnlJZGVudGlmaWVyO1xyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVwby50b1N0cmluZygpICsgcGF0aFRvVXJsRW5jb2RlZFN0cmluZyh0aGlzLl9wYXRoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVmFsaWRhdGVzIHRoYXQgbm8gb3RoZXIgb3JkZXIgYnkgY2FsbCBoYXMgYmVlbiBtYWRlXHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZU5vUHJldmlvdXNPcmRlckJ5Q2FsbChxdWVyeSwgZm5OYW1lKSB7XHJcbiAgICBpZiAocXVlcnkuX29yZGVyQnlDYWxsZWQgPT09IHRydWUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZm5OYW1lICsgXCI6IFlvdSBjYW4ndCBjb21iaW5lIG11bHRpcGxlIG9yZGVyQnkgY2FsbHMuXCIpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBWYWxpZGF0ZXMgc3RhcnQvZW5kIHZhbHVlcyBmb3IgcXVlcmllcy5cclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlUXVlcnlFbmRwb2ludHMocGFyYW1zKSB7XHJcbiAgICBsZXQgc3RhcnROb2RlID0gbnVsbDtcclxuICAgIGxldCBlbmROb2RlID0gbnVsbDtcclxuICAgIGlmIChwYXJhbXMuaGFzU3RhcnQoKSkge1xyXG4gICAgICAgIHN0YXJ0Tm9kZSA9IHBhcmFtcy5nZXRJbmRleFN0YXJ0VmFsdWUoKTtcclxuICAgIH1cclxuICAgIGlmIChwYXJhbXMuaGFzRW5kKCkpIHtcclxuICAgICAgICBlbmROb2RlID0gcGFyYW1zLmdldEluZGV4RW5kVmFsdWUoKTtcclxuICAgIH1cclxuICAgIGlmIChwYXJhbXMuZ2V0SW5kZXgoKSA9PT0gS0VZX0lOREVYKSB7XHJcbiAgICAgICAgY29uc3QgdG9vTWFueUFyZ3NFcnJvciA9ICdRdWVyeTogV2hlbiBvcmRlcmluZyBieSBrZXksIHlvdSBtYXkgb25seSBwYXNzIG9uZSBhcmd1bWVudCB0byAnICtcclxuICAgICAgICAgICAgJ3N0YXJ0QXQoKSwgZW5kQXQoKSwgb3IgZXF1YWxUbygpLic7XHJcbiAgICAgICAgY29uc3Qgd3JvbmdBcmdUeXBlRXJyb3IgPSAnUXVlcnk6IFdoZW4gb3JkZXJpbmcgYnkga2V5LCB0aGUgYXJndW1lbnQgcGFzc2VkIHRvIHN0YXJ0QXQoKSwgc3RhcnRBZnRlcigpLCAnICtcclxuICAgICAgICAgICAgJ2VuZEF0KCksIGVuZEJlZm9yZSgpLCBvciBlcXVhbFRvKCkgbXVzdCBiZSBhIHN0cmluZy4nO1xyXG4gICAgICAgIGlmIChwYXJhbXMuaGFzU3RhcnQoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBzdGFydE5hbWUgPSBwYXJhbXMuZ2V0SW5kZXhTdGFydE5hbWUoKTtcclxuICAgICAgICAgICAgaWYgKHN0YXJ0TmFtZSAhPT0gTUlOX05BTUUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0b29NYW55QXJnc0Vycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc3RhcnROb2RlICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHdyb25nQXJnVHlwZUVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGFyYW1zLmhhc0VuZCgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVuZE5hbWUgPSBwYXJhbXMuZ2V0SW5kZXhFbmROYW1lKCk7XHJcbiAgICAgICAgICAgIGlmIChlbmROYW1lICE9PSBNQVhfTkFNRSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRvb01hbnlBcmdzRXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBlbmROb2RlICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHdyb25nQXJnVHlwZUVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHBhcmFtcy5nZXRJbmRleCgpID09PSBQUklPUklUWV9JTkRFWCkge1xyXG4gICAgICAgIGlmICgoc3RhcnROb2RlICE9IG51bGwgJiYgIWlzVmFsaWRQcmlvcml0eShzdGFydE5vZGUpKSB8fFxyXG4gICAgICAgICAgICAoZW5kTm9kZSAhPSBudWxsICYmICFpc1ZhbGlkUHJpb3JpdHkoZW5kTm9kZSkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUXVlcnk6IFdoZW4gb3JkZXJpbmcgYnkgcHJpb3JpdHksIHRoZSBmaXJzdCBhcmd1bWVudCBwYXNzZWQgdG8gc3RhcnRBdCgpLCAnICtcclxuICAgICAgICAgICAgICAgICdzdGFydEFmdGVyKCkgZW5kQXQoKSwgZW5kQmVmb3JlKCksIG9yIGVxdWFsVG8oKSBtdXN0IGJlIGEgdmFsaWQgcHJpb3JpdHkgdmFsdWUgJyArXHJcbiAgICAgICAgICAgICAgICAnKG51bGwsIGEgbnVtYmVyLCBvciBhIHN0cmluZykuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYXNzZXJ0KHBhcmFtcy5nZXRJbmRleCgpIGluc3RhbmNlb2YgUGF0aEluZGV4IHx8XHJcbiAgICAgICAgICAgIHBhcmFtcy5nZXRJbmRleCgpID09PSBWQUxVRV9JTkRFWCwgJ3Vua25vd24gaW5kZXggdHlwZS4nKTtcclxuICAgICAgICBpZiAoKHN0YXJ0Tm9kZSAhPSBudWxsICYmIHR5cGVvZiBzdGFydE5vZGUgPT09ICdvYmplY3QnKSB8fFxyXG4gICAgICAgICAgICAoZW5kTm9kZSAhPSBudWxsICYmIHR5cGVvZiBlbmROb2RlID09PSAnb2JqZWN0JykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdRdWVyeTogRmlyc3QgYXJndW1lbnQgcGFzc2VkIHRvIHN0YXJ0QXQoKSwgc3RhcnRBZnRlcigpLCBlbmRBdCgpLCBlbmRCZWZvcmUoKSwgb3IgJyArXHJcbiAgICAgICAgICAgICAgICAnZXF1YWxUbygpIGNhbm5vdCBiZSBhbiBvYmplY3QuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBWYWxpZGF0ZXMgdGhhdCBsaW1pdCogaGFzIGJlZW4gY2FsbGVkIHdpdGggdGhlIGNvcnJlY3QgY29tYmluYXRpb24gb2YgcGFyYW1ldGVyc1xyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVMaW1pdChwYXJhbXMpIHtcclxuICAgIGlmIChwYXJhbXMuaGFzU3RhcnQoKSAmJlxyXG4gICAgICAgIHBhcmFtcy5oYXNFbmQoKSAmJlxyXG4gICAgICAgIHBhcmFtcy5oYXNMaW1pdCgpICYmXHJcbiAgICAgICAgIXBhcmFtcy5oYXNBbmNob3JlZExpbWl0KCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJRdWVyeTogQ2FuJ3QgY29tYmluZSBzdGFydEF0KCksIHN0YXJ0QWZ0ZXIoKSwgZW5kQXQoKSwgZW5kQmVmb3JlKCksIGFuZCBsaW1pdCgpLiBVc2UgXCIgK1xyXG4gICAgICAgICAgICAnbGltaXRUb0ZpcnN0KCkgb3IgbGltaXRUb0xhc3QoKSBpbnN0ZWFkLicpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIFJlZmVyZW5jZUltcGwgZXh0ZW5kcyBRdWVyeUltcGwge1xyXG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cclxuICAgIGNvbnN0cnVjdG9yKHJlcG8sIHBhdGgpIHtcclxuICAgICAgICBzdXBlcihyZXBvLCBwYXRoLCBuZXcgUXVlcnlQYXJhbXMoKSwgZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHBhcmVudCgpIHtcclxuICAgICAgICBjb25zdCBwYXJlbnRQYXRoID0gcGF0aFBhcmVudCh0aGlzLl9wYXRoKTtcclxuICAgICAgICByZXR1cm4gcGFyZW50UGF0aCA9PT0gbnVsbFxyXG4gICAgICAgICAgICA/IG51bGxcclxuICAgICAgICAgICAgOiBuZXcgUmVmZXJlbmNlSW1wbCh0aGlzLl9yZXBvLCBwYXJlbnRQYXRoKTtcclxuICAgIH1cclxuICAgIGdldCByb290KCkge1xyXG4gICAgICAgIGxldCByZWYgPSB0aGlzO1xyXG4gICAgICAgIHdoaWxlIChyZWYucGFyZW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlZiA9IHJlZi5wYXJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZWY7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEEgYERhdGFTbmFwc2hvdGAgY29udGFpbnMgZGF0YSBmcm9tIGEgRGF0YWJhc2UgbG9jYXRpb24uXHJcbiAqXHJcbiAqIEFueSB0aW1lIHlvdSByZWFkIGRhdGEgZnJvbSB0aGUgRGF0YWJhc2UsIHlvdSByZWNlaXZlIHRoZSBkYXRhIGFzIGFcclxuICogYERhdGFTbmFwc2hvdGAuIEEgYERhdGFTbmFwc2hvdGAgaXMgcGFzc2VkIHRvIHRoZSBldmVudCBjYWxsYmFja3MgeW91IGF0dGFjaFxyXG4gKiB3aXRoIGBvbigpYCBvciBgb25jZSgpYC4gWW91IGNhbiBleHRyYWN0IHRoZSBjb250ZW50cyBvZiB0aGUgc25hcHNob3QgYXMgYVxyXG4gKiBKYXZhU2NyaXB0IG9iamVjdCBieSBjYWxsaW5nIHRoZSBgdmFsKClgIG1ldGhvZC4gQWx0ZXJuYXRpdmVseSwgeW91IGNhblxyXG4gKiB0cmF2ZXJzZSBpbnRvIHRoZSBzbmFwc2hvdCBieSBjYWxsaW5nIGBjaGlsZCgpYCB0byByZXR1cm4gY2hpbGQgc25hcHNob3RzXHJcbiAqICh3aGljaCB5b3UgY291bGQgdGhlbiBjYWxsIGB2YWwoKWAgb24pLlxyXG4gKlxyXG4gKiBBIGBEYXRhU25hcHNob3RgIGlzIGFuIGVmZmljaWVudGx5IGdlbmVyYXRlZCwgaW1tdXRhYmxlIGNvcHkgb2YgdGhlIGRhdGEgYXRcclxuICogYSBEYXRhYmFzZSBsb2NhdGlvbi4gSXQgY2Fubm90IGJlIG1vZGlmaWVkIGFuZCB3aWxsIG5ldmVyIGNoYW5nZSAodG8gbW9kaWZ5XHJcbiAqIGRhdGEsIHlvdSBhbHdheXMgY2FsbCB0aGUgYHNldCgpYCBtZXRob2Qgb24gYSBgUmVmZXJlbmNlYCBkaXJlY3RseSkuXHJcbiAqL1xyXG5jbGFzcyBEYXRhU25hcHNob3Qge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gX25vZGUgLSBBIFNuYXBzaG90Tm9kZSB0byB3cmFwLlxyXG4gICAgICogQHBhcmFtIHJlZiAtIFRoZSBsb2NhdGlvbiB0aGlzIHNuYXBzaG90IGNhbWUgZnJvbS5cclxuICAgICAqIEBwYXJhbSBfaW5kZXggLSBUaGUgaXRlcmF0aW9uIG9yZGVyIGZvciB0aGlzIHNuYXBzaG90XHJcbiAgICAgKiBAaGlkZWNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKF9ub2RlLCBcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGxvY2F0aW9uIG9mIHRoaXMgRGF0YVNuYXBzaG90LlxyXG4gICAgICovXHJcbiAgICByZWYsIF9pbmRleCkge1xyXG4gICAgICAgIHRoaXMuX25vZGUgPSBfbm9kZTtcclxuICAgICAgICB0aGlzLnJlZiA9IHJlZjtcclxuICAgICAgICB0aGlzLl9pbmRleCA9IF9pbmRleDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgcHJpb3JpdHkgdmFsdWUgb2YgdGhlIGRhdGEgaW4gdGhpcyBgRGF0YVNuYXBzaG90YC5cclxuICAgICAqXHJcbiAgICAgKiBBcHBsaWNhdGlvbnMgbmVlZCBub3QgdXNlIHByaW9yaXR5IGJ1dCBjYW4gb3JkZXIgY29sbGVjdGlvbnMgYnlcclxuICAgICAqIG9yZGluYXJ5IHByb3BlcnRpZXMgKHNlZVxyXG4gICAgICoge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2RhdGFiYXNlL3dlYi9saXN0cy1vZi1kYXRhI3NvcnRpbmdfYW5kX2ZpbHRlcmluZ19kYXRhIHxTb3J0aW5nIGFuZCBmaWx0ZXJpbmcgZGF0YX1cclxuICAgICAqICkuXHJcbiAgICAgKi9cclxuICAgIGdldCBwcmlvcml0eSgpIHtcclxuICAgICAgICAvLyB0eXBlY2FzdCBoZXJlIGJlY2F1c2Ugd2UgbmV2ZXIgcmV0dXJuIGRlZmVycmVkIHZhbHVlcyBvciBpbnRlcm5hbCBwcmlvcml0aWVzIChNQVhfUFJJT1JJVFkpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vZGUuZ2V0UHJpb3JpdHkoKS52YWwoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGtleSAobGFzdCBwYXJ0IG9mIHRoZSBwYXRoKSBvZiB0aGUgbG9jYXRpb24gb2YgdGhpcyBgRGF0YVNuYXBzaG90YC5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgbGFzdCB0b2tlbiBpbiBhIERhdGFiYXNlIGxvY2F0aW9uIGlzIGNvbnNpZGVyZWQgaXRzIGtleS4gRm9yIGV4YW1wbGUsXHJcbiAgICAgKiBcImFkYVwiIGlzIHRoZSBrZXkgZm9yIHRoZSAvdXNlcnMvYWRhLyBub2RlLiBBY2Nlc3NpbmcgdGhlIGtleSBvbiBhbnlcclxuICAgICAqIGBEYXRhU25hcHNob3RgIHdpbGwgcmV0dXJuIHRoZSBrZXkgZm9yIHRoZSBsb2NhdGlvbiB0aGF0IGdlbmVyYXRlZCBpdC5cclxuICAgICAqIEhvd2V2ZXIsIGFjY2Vzc2luZyB0aGUga2V5IG9uIHRoZSByb290IFVSTCBvZiBhIERhdGFiYXNlIHdpbGwgcmV0dXJuXHJcbiAgICAgKiBgbnVsbGAuXHJcbiAgICAgKi9cclxuICAgIGdldCBrZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmLmtleTtcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgY2hpbGQgcHJvcGVydGllcyBvZiB0aGlzIGBEYXRhU25hcHNob3RgLiAqL1xyXG4gICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vZGUubnVtQ2hpbGRyZW4oKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhbm90aGVyIGBEYXRhU25hcHNob3RgIGZvciB0aGUgbG9jYXRpb24gYXQgdGhlIHNwZWNpZmllZCByZWxhdGl2ZSBwYXRoLlxyXG4gICAgICpcclxuICAgICAqIFBhc3NpbmcgYSByZWxhdGl2ZSBwYXRoIHRvIHRoZSBgY2hpbGQoKWAgbWV0aG9kIG9mIGEgRGF0YVNuYXBzaG90IHJldHVybnNcclxuICAgICAqIGFub3RoZXIgYERhdGFTbmFwc2hvdGAgZm9yIHRoZSBsb2NhdGlvbiBhdCB0aGUgc3BlY2lmaWVkIHJlbGF0aXZlIHBhdGguIFRoZVxyXG4gICAgICogcmVsYXRpdmUgcGF0aCBjYW4gZWl0aGVyIGJlIGEgc2ltcGxlIGNoaWxkIG5hbWUgKGZvciBleGFtcGxlLCBcImFkYVwiKSBvciBhXHJcbiAgICAgKiBkZWVwZXIsIHNsYXNoLXNlcGFyYXRlZCBwYXRoIChmb3IgZXhhbXBsZSwgXCJhZGEvbmFtZS9maXJzdFwiKS4gSWYgdGhlIGNoaWxkXHJcbiAgICAgKiBsb2NhdGlvbiBoYXMgbm8gZGF0YSwgYW4gZW1wdHkgYERhdGFTbmFwc2hvdGAgKHRoYXQgaXMsIGEgYERhdGFTbmFwc2hvdGBcclxuICAgICAqIHdob3NlIHZhbHVlIGlzIGBudWxsYCkgaXMgcmV0dXJuZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhdGggLSBBIHJlbGF0aXZlIHBhdGggdG8gdGhlIGxvY2F0aW9uIG9mIGNoaWxkIGRhdGEuXHJcbiAgICAgKi9cclxuICAgIGNoaWxkKHBhdGgpIHtcclxuICAgICAgICBjb25zdCBjaGlsZFBhdGggPSBuZXcgUGF0aChwYXRoKTtcclxuICAgICAgICBjb25zdCBjaGlsZFJlZiA9IGNoaWxkKHRoaXMucmVmLCBwYXRoKTtcclxuICAgICAgICByZXR1cm4gbmV3IERhdGFTbmFwc2hvdCh0aGlzLl9ub2RlLmdldENoaWxkKGNoaWxkUGF0aCksIGNoaWxkUmVmLCBQUklPUklUWV9JTkRFWCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGBEYXRhU25hcHNob3RgIGNvbnRhaW5zIGFueSBkYXRhLiBJdCBpcyBzbGlnaHRseSBtb3JlXHJcbiAgICAgKiBlZmZpY2llbnQgdGhhbiB1c2luZyBgc25hcHNob3QudmFsKCkgIT09IG51bGxgLlxyXG4gICAgICovXHJcbiAgICBleGlzdHMoKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLl9ub2RlLmlzRW1wdHkoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRXhwb3J0cyB0aGUgZW50aXJlIGNvbnRlbnRzIG9mIHRoZSBEYXRhU25hcHNob3QgYXMgYSBKYXZhU2NyaXB0IG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgYGV4cG9ydFZhbCgpYCBtZXRob2QgaXMgc2ltaWxhciB0byBgdmFsKClgLCBleGNlcHQgcHJpb3JpdHkgaW5mb3JtYXRpb25cclxuICAgICAqIGlzIGluY2x1ZGVkIChpZiBhdmFpbGFibGUpLCBtYWtpbmcgaXQgc3VpdGFibGUgZm9yIGJhY2tpbmcgdXAgeW91ciBkYXRhLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRoZSBEYXRhU25hcHNob3QncyBjb250ZW50cyBhcyBhIEphdmFTY3JpcHQgdmFsdWUgKE9iamVjdCxcclxuICAgICAqICAgQXJyYXksIHN0cmluZywgbnVtYmVyLCBib29sZWFuLCBvciBgbnVsbGApLlxyXG4gICAgICovXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgZXhwb3J0VmFsKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ub2RlLnZhbCh0cnVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRW51bWVyYXRlcyB0aGUgdG9wLWxldmVsIGNoaWxkcmVuIGluIHRoZSBgSXRlcmF0ZWREYXRhU25hcHNob3RgLlxyXG4gICAgICpcclxuICAgICAqIEJlY2F1c2Ugb2YgdGhlIHdheSBKYXZhU2NyaXB0IG9iamVjdHMgd29yaywgdGhlIG9yZGVyaW5nIG9mIGRhdGEgaW4gdGhlXHJcbiAgICAgKiBKYXZhU2NyaXB0IG9iamVjdCByZXR1cm5lZCBieSBgdmFsKClgIGlzIG5vdCBndWFyYW50ZWVkIHRvIG1hdGNoIHRoZVxyXG4gICAgICogb3JkZXJpbmcgb24gdGhlIHNlcnZlciBub3IgdGhlIG9yZGVyaW5nIG9mIGBvbkNoaWxkQWRkZWQoKWAgZXZlbnRzLiBUaGF0IGlzXHJcbiAgICAgKiB3aGVyZSBgZm9yRWFjaCgpYCBjb21lcyBpbiBoYW5keS4gSXQgZ3VhcmFudGVlcyB0aGUgY2hpbGRyZW4gb2YgYVxyXG4gICAgICogYERhdGFTbmFwc2hvdGAgd2lsbCBiZSBpdGVyYXRlZCBpbiB0aGVpciBxdWVyeSBvcmRlci5cclxuICAgICAqXHJcbiAgICAgKiBJZiBubyBleHBsaWNpdCBgb3JkZXJCeSooKWAgbWV0aG9kIGlzIHVzZWQsIHJlc3VsdHMgYXJlIHJldHVybmVkXHJcbiAgICAgKiBvcmRlcmVkIGJ5IGtleSAodW5sZXNzIHByaW9yaXRpZXMgYXJlIHVzZWQsIGluIHdoaWNoIGNhc2UsIHJlc3VsdHMgYXJlXHJcbiAgICAgKiByZXR1cm5lZCBieSBwcmlvcml0eSkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFjdGlvbiAtIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaCBjaGlsZCBEYXRhU25hcHNob3QuXHJcbiAgICAgKiBUaGUgY2FsbGJhY2sgY2FuIHJldHVybiB0cnVlIHRvIGNhbmNlbCBmdXJ0aGVyIGVudW1lcmF0aW9uLlxyXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBlbnVtZXJhdGlvbiB3YXMgY2FuY2VsZWQgZHVlIHRvIHlvdXIgY2FsbGJhY2sgcmV0dXJuaW5nXHJcbiAgICAgKiB0cnVlLlxyXG4gICAgICovXHJcbiAgICBmb3JFYWNoKGFjdGlvbikge1xyXG4gICAgICAgIGlmICh0aGlzLl9ub2RlLmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNoaWxkcmVuTm9kZSA9IHRoaXMuX25vZGU7XHJcbiAgICAgICAgLy8gU2FuaXRpemUgdGhlIHJldHVybiB2YWx1ZSB0byBhIGJvb2xlYW4uIENoaWxkcmVuTm9kZS5mb3JFYWNoQ2hpbGQgaGFzIGEgd2VpcmQgcmV0dXJuIHR5cGUuLi5cclxuICAgICAgICByZXR1cm4gISFjaGlsZHJlbk5vZGUuZm9yRWFjaENoaWxkKHRoaXMuX2luZGV4LCAoa2V5LCBub2RlKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb24obmV3IERhdGFTbmFwc2hvdChub2RlLCBjaGlsZCh0aGlzLnJlZiwga2V5KSwgUFJJT1JJVFlfSU5ERVgpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgY2hpbGQgcGF0aCBoYXMgKG5vbi1udWxsKSBkYXRhLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXRoIC0gQSByZWxhdGl2ZSBwYXRoIHRvIHRoZSBsb2NhdGlvbiBvZiBhIHBvdGVudGlhbCBjaGlsZC5cclxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiBkYXRhIGV4aXN0cyBhdCB0aGUgc3BlY2lmaWVkIGNoaWxkIHBhdGg7IGVsc2VcclxuICAgICAqICBgZmFsc2VgLlxyXG4gICAgICovXHJcbiAgICBoYXNDaGlsZChwYXRoKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGRQYXRoID0gbmV3IFBhdGgocGF0aCk7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLl9ub2RlLmdldENoaWxkKGNoaWxkUGF0aCkuaXNFbXB0eSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBgRGF0YVNuYXBzaG90YCBoYXMgYW55IG5vbi1gbnVsbGAgY2hpbGRcclxuICAgICAqIHByb3BlcnRpZXMuXHJcbiAgICAgKlxyXG4gICAgICogWW91IGNhbiB1c2UgYGhhc0NoaWxkcmVuKClgIHRvIGRldGVybWluZSBpZiBhIGBEYXRhU25hcHNob3RgIGhhcyBhbnlcclxuICAgICAqIGNoaWxkcmVuLiBJZiBpdCBkb2VzLCB5b3UgY2FuIGVudW1lcmF0ZSB0aGVtIHVzaW5nIGBmb3JFYWNoKClgLiBJZiBpdFxyXG4gICAgICogZG9lc24ndCwgdGhlbiBlaXRoZXIgdGhpcyBzbmFwc2hvdCBjb250YWlucyBhIHByaW1pdGl2ZSB2YWx1ZSAod2hpY2ggY2FuIGJlXHJcbiAgICAgKiByZXRyaWV2ZWQgd2l0aCBgdmFsKClgKSBvciBpdCBpcyBlbXB0eSAoaW4gd2hpY2ggY2FzZSwgYHZhbCgpYCB3aWxsIHJldHVyblxyXG4gICAgICogYG51bGxgKS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoaXMgc25hcHNob3QgaGFzIGFueSBjaGlsZHJlbjsgZWxzZSBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgaGFzQ2hpbGRyZW4oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX25vZGUuaXNMZWFmTm9kZSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5fbm9kZS5pc0VtcHR5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgSlNPTi1zZXJpYWxpemFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5leHBvcnRWYWwoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRXh0cmFjdHMgYSBKYXZhU2NyaXB0IHZhbHVlIGZyb20gYSBgRGF0YVNuYXBzaG90YC5cclxuICAgICAqXHJcbiAgICAgKiBEZXBlbmRpbmcgb24gdGhlIGRhdGEgaW4gYSBgRGF0YVNuYXBzaG90YCwgdGhlIGB2YWwoKWAgbWV0aG9kIG1heSByZXR1cm4gYVxyXG4gICAgICogc2NhbGFyIHR5cGUgKHN0cmluZywgbnVtYmVyLCBvciBib29sZWFuKSwgYW4gYXJyYXksIG9yIGFuIG9iamVjdC4gSXQgbWF5XHJcbiAgICAgKiBhbHNvIHJldHVybiBudWxsLCBpbmRpY2F0aW5nIHRoYXQgdGhlIGBEYXRhU25hcHNob3RgIGlzIGVtcHR5IChjb250YWlucyBub1xyXG4gICAgICogZGF0YSkuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIERhdGFTbmFwc2hvdCdzIGNvbnRlbnRzIGFzIGEgSmF2YVNjcmlwdCB2YWx1ZSAoT2JqZWN0LFxyXG4gICAgICogICBBcnJheSwgc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4sIG9yIGBudWxsYCkuXHJcbiAgICAgKi9cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICB2YWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vZGUudmFsKCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqIFJldHVybnMgYSBgUmVmZXJlbmNlYCByZXByZXNlbnRpbmcgdGhlIGxvY2F0aW9uIGluIHRoZSBEYXRhYmFzZVxyXG4gKiBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm92aWRlZCBwYXRoLiBJZiBubyBwYXRoIGlzIHByb3ZpZGVkLCB0aGUgYFJlZmVyZW5jZWBcclxuICogd2lsbCBwb2ludCB0byB0aGUgcm9vdCBvZiB0aGUgRGF0YWJhc2UuXHJcbiAqXHJcbiAqIEBwYXJhbSBkYiAtIFRoZSBkYXRhYmFzZSBpbnN0YW5jZSB0byBvYnRhaW4gYSByZWZlcmVuY2UgZm9yLlxyXG4gKiBAcGFyYW0gcGF0aCAtIE9wdGlvbmFsIHBhdGggcmVwcmVzZW50aW5nIHRoZSBsb2NhdGlvbiB0aGUgcmV0dXJuZWRcclxuICogICBgUmVmZXJlbmNlYCB3aWxsIHBvaW50LiBJZiBub3QgcHJvdmlkZWQsIHRoZSByZXR1cm5lZCBgUmVmZXJlbmNlYCB3aWxsXHJcbiAqICAgcG9pbnQgdG8gdGhlIHJvb3Qgb2YgdGhlIERhdGFiYXNlLlxyXG4gKiBAcmV0dXJucyBJZiBhIHBhdGggaXMgcHJvdmlkZWQsIGEgYFJlZmVyZW5jZWBcclxuICogICBwb2ludGluZyB0byB0aGUgcHJvdmlkZWQgcGF0aC4gT3RoZXJ3aXNlLCBhIGBSZWZlcmVuY2VgIHBvaW50aW5nIHRvIHRoZVxyXG4gKiAgIHJvb3Qgb2YgdGhlIERhdGFiYXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVmKGRiLCBwYXRoKSB7XHJcbiAgICBkYiA9IGdldE1vZHVsYXJJbnN0YW5jZShkYik7XHJcbiAgICBkYi5fY2hlY2tOb3REZWxldGVkKCdyZWYnKTtcclxuICAgIHJldHVybiBwYXRoICE9PSB1bmRlZmluZWQgPyBjaGlsZChkYi5fcm9vdCwgcGF0aCkgOiBkYi5fcm9vdDtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIGBSZWZlcmVuY2VgIHJlcHJlc2VudGluZyB0aGUgbG9jYXRpb24gaW4gdGhlIERhdGFiYXNlXHJcbiAqIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3ZpZGVkIEZpcmViYXNlIFVSTC5cclxuICpcclxuICogQW4gZXhjZXB0aW9uIGlzIHRocm93biBpZiB0aGUgVVJMIGlzIG5vdCBhIHZhbGlkIEZpcmViYXNlIERhdGFiYXNlIFVSTCBvciBpdFxyXG4gKiBoYXMgYSBkaWZmZXJlbnQgZG9tYWluIHRoYW4gdGhlIGN1cnJlbnQgYERhdGFiYXNlYCBpbnN0YW5jZS5cclxuICpcclxuICogTm90ZSB0aGF0IGFsbCBxdWVyeSBwYXJhbWV0ZXJzIChgb3JkZXJCeWAsIGBsaW1pdFRvTGFzdGAsIGV0Yy4pIGFyZSBpZ25vcmVkXHJcbiAqIGFuZCBhcmUgbm90IGFwcGxpZWQgdG8gdGhlIHJldHVybmVkIGBSZWZlcmVuY2VgLlxyXG4gKlxyXG4gKiBAcGFyYW0gZGIgLSBUaGUgZGF0YWJhc2UgaW5zdGFuY2UgdG8gb2J0YWluIGEgcmVmZXJlbmNlIGZvci5cclxuICogQHBhcmFtIHVybCAtIFRoZSBGaXJlYmFzZSBVUkwgYXQgd2hpY2ggdGhlIHJldHVybmVkIGBSZWZlcmVuY2VgIHdpbGxcclxuICogICBwb2ludC5cclxuICogQHJldHVybnMgQSBgUmVmZXJlbmNlYCBwb2ludGluZyB0byB0aGUgcHJvdmlkZWRcclxuICogICBGaXJlYmFzZSBVUkwuXHJcbiAqL1xyXG5mdW5jdGlvbiByZWZGcm9tVVJMKGRiLCB1cmwpIHtcclxuICAgIGRiID0gZ2V0TW9kdWxhckluc3RhbmNlKGRiKTtcclxuICAgIGRiLl9jaGVja05vdERlbGV0ZWQoJ3JlZkZyb21VUkwnKTtcclxuICAgIGNvbnN0IHBhcnNlZFVSTCA9IHBhcnNlUmVwb0luZm8odXJsLCBkYi5fcmVwby5yZXBvSW5mb18ubm9kZUFkbWluKTtcclxuICAgIHZhbGlkYXRlVXJsKCdyZWZGcm9tVVJMJywgcGFyc2VkVVJMKTtcclxuICAgIGNvbnN0IHJlcG9JbmZvID0gcGFyc2VkVVJMLnJlcG9JbmZvO1xyXG4gICAgaWYgKCFkYi5fcmVwby5yZXBvSW5mb18uaXNDdXN0b21Ib3N0KCkgJiZcclxuICAgICAgICByZXBvSW5mby5ob3N0ICE9PSBkYi5fcmVwby5yZXBvSW5mb18uaG9zdCkge1xyXG4gICAgICAgIGZhdGFsKCdyZWZGcm9tVVJMJyArXHJcbiAgICAgICAgICAgICc6IEhvc3QgbmFtZSBkb2VzIG5vdCBtYXRjaCB0aGUgY3VycmVudCBkYXRhYmFzZTogJyArXHJcbiAgICAgICAgICAgICcoZm91bmQgJyArXHJcbiAgICAgICAgICAgIHJlcG9JbmZvLmhvc3QgK1xyXG4gICAgICAgICAgICAnIGJ1dCBleHBlY3RlZCAnICtcclxuICAgICAgICAgICAgZGIuX3JlcG8ucmVwb0luZm9fLmhvc3QgK1xyXG4gICAgICAgICAgICAnKScpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlZihkYiwgcGFyc2VkVVJMLnBhdGgudG9TdHJpbmcoKSk7XHJcbn1cclxuLyoqXHJcbiAqIEdldHMgYSBgUmVmZXJlbmNlYCBmb3IgdGhlIGxvY2F0aW9uIGF0IHRoZSBzcGVjaWZpZWQgcmVsYXRpdmUgcGF0aC5cclxuICpcclxuICogVGhlIHJlbGF0aXZlIHBhdGggY2FuIGVpdGhlciBiZSBhIHNpbXBsZSBjaGlsZCBuYW1lIChmb3IgZXhhbXBsZSwgXCJhZGFcIikgb3JcclxuICogYSBkZWVwZXIgc2xhc2gtc2VwYXJhdGVkIHBhdGggKGZvciBleGFtcGxlLCBcImFkYS9uYW1lL2ZpcnN0XCIpLlxyXG4gKlxyXG4gKiBAcGFyYW0gcGFyZW50IC0gVGhlIHBhcmVudCBsb2NhdGlvbi5cclxuICogQHBhcmFtIHBhdGggLSBBIHJlbGF0aXZlIHBhdGggZnJvbSB0aGlzIGxvY2F0aW9uIHRvIHRoZSBkZXNpcmVkIGNoaWxkXHJcbiAqICAgbG9jYXRpb24uXHJcbiAqIEByZXR1cm5zIFRoZSBzcGVjaWZpZWQgY2hpbGQgbG9jYXRpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBjaGlsZChwYXJlbnQsIHBhdGgpIHtcclxuICAgIHBhcmVudCA9IGdldE1vZHVsYXJJbnN0YW5jZShwYXJlbnQpO1xyXG4gICAgaWYgKHBhdGhHZXRGcm9udChwYXJlbnQuX3BhdGgpID09PSBudWxsKSB7XHJcbiAgICAgICAgdmFsaWRhdGVSb290UGF0aFN0cmluZygnY2hpbGQnLCAncGF0aCcsIHBhdGgsIGZhbHNlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhbGlkYXRlUGF0aFN0cmluZygnY2hpbGQnLCAncGF0aCcsIHBhdGgsIGZhbHNlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgUmVmZXJlbmNlSW1wbChwYXJlbnQuX3JlcG8sIHBhdGhDaGlsZChwYXJlbnQuX3BhdGgsIHBhdGgpKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhbiBgT25EaXNjb25uZWN0YCBvYmplY3QgLSBzZWVcclxuICoge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2RhdGFiYXNlL3dlYi9vZmZsaW5lLWNhcGFiaWxpdGllcyB8IEVuYWJsaW5nIE9mZmxpbmUgQ2FwYWJpbGl0aWVzIGluIEphdmFTY3JpcHR9XHJcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGhvdyB0byB1c2UgaXQuXHJcbiAqXHJcbiAqIEBwYXJhbSByZWYgLSBUaGUgcmVmZXJlbmNlIHRvIGFkZCBPbkRpc2Nvbm5lY3QgdHJpZ2dlcnMgZm9yLlxyXG4gKi9cclxuZnVuY3Rpb24gb25EaXNjb25uZWN0KHJlZikge1xyXG4gICAgcmVmID0gZ2V0TW9kdWxhckluc3RhbmNlKHJlZik7XHJcbiAgICByZXR1cm4gbmV3IE9uRGlzY29ubmVjdChyZWYuX3JlcG8sIHJlZi5fcGF0aCk7XHJcbn1cclxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIG5ldyBjaGlsZCBsb2NhdGlvbiB1c2luZyBhIHVuaXF1ZSBrZXkgYW5kIHJldHVybnMgaXRzXHJcbiAqIGBSZWZlcmVuY2VgLlxyXG4gKlxyXG4gKiBUaGlzIGlzIHRoZSBtb3N0IGNvbW1vbiBwYXR0ZXJuIGZvciBhZGRpbmcgZGF0YSB0byBhIGNvbGxlY3Rpb24gb2YgaXRlbXMuXHJcbiAqXHJcbiAqIElmIHlvdSBwcm92aWRlIGEgdmFsdWUgdG8gYHB1c2goKWAsIHRoZSB2YWx1ZSBpcyB3cml0dGVuIHRvIHRoZVxyXG4gKiBnZW5lcmF0ZWQgbG9jYXRpb24uIElmIHlvdSBkb24ndCBwYXNzIGEgdmFsdWUsIG5vdGhpbmcgaXMgd3JpdHRlbiB0byB0aGVcclxuICogZGF0YWJhc2UgYW5kIHRoZSBjaGlsZCByZW1haW5zIGVtcHR5IChidXQgeW91IGNhbiB1c2UgdGhlIGBSZWZlcmVuY2VgXHJcbiAqIGVsc2V3aGVyZSkuXHJcbiAqXHJcbiAqIFRoZSB1bmlxdWUga2V5cyBnZW5lcmF0ZWQgYnkgYHB1c2goKWAgYXJlIG9yZGVyZWQgYnkgdGhlIGN1cnJlbnQgdGltZSwgc28gdGhlXHJcbiAqIHJlc3VsdGluZyBsaXN0IG9mIGl0ZW1zIGlzIGNocm9ub2xvZ2ljYWxseSBzb3J0ZWQuIFRoZSBrZXlzIGFyZSBhbHNvXHJcbiAqIGRlc2lnbmVkIHRvIGJlIHVuZ3Vlc3NhYmxlICh0aGV5IGNvbnRhaW4gNzIgcmFuZG9tIGJpdHMgb2YgZW50cm9weSkuXHJcbiAqXHJcbiAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZGF0YWJhc2Uvd2ViL2xpc3RzLW9mLWRhdGEjYXBwZW5kX3RvX2FfbGlzdF9vZl9kYXRhIHwgQXBwZW5kIHRvIGEgbGlzdCBvZiBkYXRhfS5cclxuICogU2VlIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZWJsb2cuY29tLzIwMTUvMDIvdGhlLTIxMjAtd2F5cy10by1lbnN1cmUtdW5pcXVlXzY4Lmh0bWwgfCBUaGUgMl4xMjAgV2F5cyB0byBFbnN1cmUgVW5pcXVlIElkZW50aWZpZXJzfS5cclxuICpcclxuICogQHBhcmFtIHBhcmVudCAtIFRoZSBwYXJlbnQgbG9jYXRpb24uXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIE9wdGlvbmFsIHZhbHVlIHRvIGJlIHdyaXR0ZW4gYXQgdGhlIGdlbmVyYXRlZCBsb2NhdGlvbi5cclxuICogQHJldHVybnMgQ29tYmluZWQgYFByb21pc2VgIGFuZCBgUmVmZXJlbmNlYDsgcmVzb2x2ZXMgd2hlbiB3cml0ZSBpcyBjb21wbGV0ZSxcclxuICogYnV0IGNhbiBiZSB1c2VkIGltbWVkaWF0ZWx5IGFzIHRoZSBgUmVmZXJlbmNlYCB0byB0aGUgY2hpbGQgbG9jYXRpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBwdXNoKHBhcmVudCwgdmFsdWUpIHtcclxuICAgIHBhcmVudCA9IGdldE1vZHVsYXJJbnN0YW5jZShwYXJlbnQpO1xyXG4gICAgdmFsaWRhdGVXcml0YWJsZVBhdGgoJ3B1c2gnLCBwYXJlbnQuX3BhdGgpO1xyXG4gICAgdmFsaWRhdGVGaXJlYmFzZURhdGFBcmcoJ3B1c2gnLCB2YWx1ZSwgcGFyZW50Ll9wYXRoLCB0cnVlKTtcclxuICAgIGNvbnN0IG5vdyA9IHJlcG9TZXJ2ZXJUaW1lKHBhcmVudC5fcmVwbyk7XHJcbiAgICBjb25zdCBuYW1lID0gbmV4dFB1c2hJZChub3cpO1xyXG4gICAgLy8gcHVzaCgpIHJldHVybnMgYSBUaGVubmFibGVSZWZlcmVuY2Ugd2hvc2UgcHJvbWlzZSBpcyBmdWxmaWxsZWQgd2l0aCBhXHJcbiAgICAvLyByZWd1bGFyIFJlZmVyZW5jZS4gV2UgdXNlIGNoaWxkKCkgdG8gY3JlYXRlIGhhbmRsZXMgdG8gdHdvIGRpZmZlcmVudFxyXG4gICAgLy8gcmVmZXJlbmNlcy4gVGhlIGZpcnN0IGlzIHR1cm5lZCBpbnRvIGEgVGhlbm5hYmxlUmVmZXJlbmNlIGJlbG93IGJ5IGFkZGluZ1xyXG4gICAgLy8gdGhlbigpIGFuZCBjYXRjaCgpIG1ldGhvZHMgYW5kIGlzIHVzZWQgYXMgdGhlIHJldHVybiB2YWx1ZSBvZiBwdXNoKCkuIFRoZVxyXG4gICAgLy8gc2Vjb25kIHJlbWFpbnMgYSByZWd1bGFyIFJlZmVyZW5jZSBhbmQgaXMgdXNlZCBhcyB0aGUgZnVsZmlsbGVkIHZhbHVlIG9mXHJcbiAgICAvLyB0aGUgZmlyc3QgVGhlbm5hYmxlUmVmZXJlbmNlLlxyXG4gICAgY29uc3QgdGhlbm5hYmxlUHVzaFJlZiA9IGNoaWxkKHBhcmVudCwgbmFtZSk7XHJcbiAgICBjb25zdCBwdXNoUmVmID0gY2hpbGQocGFyZW50LCBuYW1lKTtcclxuICAgIGxldCBwcm9taXNlO1xyXG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICBwcm9taXNlID0gc2V0KHB1c2hSZWYsIHZhbHVlKS50aGVuKCgpID0+IHB1c2hSZWYpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShwdXNoUmVmKTtcclxuICAgIH1cclxuICAgIHRoZW5uYWJsZVB1c2hSZWYudGhlbiA9IHByb21pc2UudGhlbi5iaW5kKHByb21pc2UpO1xyXG4gICAgdGhlbm5hYmxlUHVzaFJlZi5jYXRjaCA9IHByb21pc2UudGhlbi5iaW5kKHByb21pc2UsIHVuZGVmaW5lZCk7XHJcbiAgICByZXR1cm4gdGhlbm5hYmxlUHVzaFJlZjtcclxufVxyXG4vKipcclxuICogUmVtb3ZlcyB0aGUgZGF0YSBhdCB0aGlzIERhdGFiYXNlIGxvY2F0aW9uLlxyXG4gKlxyXG4gKiBBbnkgZGF0YSBhdCBjaGlsZCBsb2NhdGlvbnMgd2lsbCBhbHNvIGJlIGRlbGV0ZWQuXHJcbiAqXHJcbiAqIFRoZSBlZmZlY3Qgb2YgdGhlIHJlbW92ZSB3aWxsIGJlIHZpc2libGUgaW1tZWRpYXRlbHkgYW5kIHRoZSBjb3JyZXNwb25kaW5nXHJcbiAqIGV2ZW50ICd2YWx1ZScgd2lsbCBiZSB0cmlnZ2VyZWQuIFN5bmNocm9uaXphdGlvbiBvZiB0aGUgcmVtb3ZlIHRvIHRoZVxyXG4gKiBGaXJlYmFzZSBzZXJ2ZXJzIHdpbGwgYWxzbyBiZSBzdGFydGVkLCBhbmQgdGhlIHJldHVybmVkIFByb21pc2Ugd2lsbCByZXNvbHZlXHJcbiAqIHdoZW4gY29tcGxldGUuIElmIHByb3ZpZGVkLCB0aGUgb25Db21wbGV0ZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZFxyXG4gKiBhc3luY2hyb25vdXNseSBhZnRlciBzeW5jaHJvbml6YXRpb24gaGFzIGZpbmlzaGVkLlxyXG4gKlxyXG4gKiBAcGFyYW0gcmVmIC0gVGhlIGxvY2F0aW9uIHRvIHJlbW92ZS5cclxuICogQHJldHVybnMgUmVzb2x2ZXMgd2hlbiByZW1vdmUgb24gc2VydmVyIGlzIGNvbXBsZXRlLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVtb3ZlKHJlZikge1xyXG4gICAgdmFsaWRhdGVXcml0YWJsZVBhdGgoJ3JlbW92ZScsIHJlZi5fcGF0aCk7XHJcbiAgICByZXR1cm4gc2V0KHJlZiwgbnVsbCk7XHJcbn1cclxuLyoqXHJcbiAqIFdyaXRlcyBkYXRhIHRvIHRoaXMgRGF0YWJhc2UgbG9jYXRpb24uXHJcbiAqXHJcbiAqIFRoaXMgd2lsbCBvdmVyd3JpdGUgYW55IGRhdGEgYXQgdGhpcyBsb2NhdGlvbiBhbmQgYWxsIGNoaWxkIGxvY2F0aW9ucy5cclxuICpcclxuICogVGhlIGVmZmVjdCBvZiB0aGUgd3JpdGUgd2lsbCBiZSB2aXNpYmxlIGltbWVkaWF0ZWx5LCBhbmQgdGhlIGNvcnJlc3BvbmRpbmdcclxuICogZXZlbnRzIChcInZhbHVlXCIsIFwiY2hpbGRfYWRkZWRcIiwgZXRjLikgd2lsbCBiZSB0cmlnZ2VyZWQuIFN5bmNocm9uaXphdGlvbiBvZlxyXG4gKiB0aGUgZGF0YSB0byB0aGUgRmlyZWJhc2Ugc2VydmVycyB3aWxsIGFsc28gYmUgc3RhcnRlZCwgYW5kIHRoZSByZXR1cm5lZFxyXG4gKiBQcm9taXNlIHdpbGwgcmVzb2x2ZSB3aGVuIGNvbXBsZXRlLiBJZiBwcm92aWRlZCwgdGhlIGBvbkNvbXBsZXRlYCBjYWxsYmFja1xyXG4gKiB3aWxsIGJlIGNhbGxlZCBhc3luY2hyb25vdXNseSBhZnRlciBzeW5jaHJvbml6YXRpb24gaGFzIGZpbmlzaGVkLlxyXG4gKlxyXG4gKiBQYXNzaW5nIGBudWxsYCBmb3IgdGhlIG5ldyB2YWx1ZSBpcyBlcXVpdmFsZW50IHRvIGNhbGxpbmcgYHJlbW92ZSgpYDsgbmFtZWx5LFxyXG4gKiBhbGwgZGF0YSBhdCB0aGlzIGxvY2F0aW9uIGFuZCBhbGwgY2hpbGQgbG9jYXRpb25zIHdpbGwgYmUgZGVsZXRlZC5cclxuICpcclxuICogYHNldCgpYCB3aWxsIHJlbW92ZSBhbnkgcHJpb3JpdHkgc3RvcmVkIGF0IHRoaXMgbG9jYXRpb24sIHNvIGlmIHByaW9yaXR5IGlzXHJcbiAqIG1lYW50IHRvIGJlIHByZXNlcnZlZCwgeW91IG5lZWQgdG8gdXNlIGBzZXRXaXRoUHJpb3JpdHkoKWAgaW5zdGVhZC5cclxuICpcclxuICogTm90ZSB0aGF0IG1vZGlmeWluZyBkYXRhIHdpdGggYHNldCgpYCB3aWxsIGNhbmNlbCBhbnkgcGVuZGluZyB0cmFuc2FjdGlvbnNcclxuICogYXQgdGhhdCBsb2NhdGlvbiwgc28gZXh0cmVtZSBjYXJlIHNob3VsZCBiZSB0YWtlbiBpZiBtaXhpbmcgYHNldCgpYCBhbmRcclxuICogYHRyYW5zYWN0aW9uKClgIHRvIG1vZGlmeSB0aGUgc2FtZSBkYXRhLlxyXG4gKlxyXG4gKiBBIHNpbmdsZSBgc2V0KClgIHdpbGwgZ2VuZXJhdGUgYSBzaW5nbGUgXCJ2YWx1ZVwiIGV2ZW50IGF0IHRoZSBsb2NhdGlvbiB3aGVyZVxyXG4gKiB0aGUgYHNldCgpYCB3YXMgcGVyZm9ybWVkLlxyXG4gKlxyXG4gKiBAcGFyYW0gcmVmIC0gVGhlIGxvY2F0aW9uIHRvIHdyaXRlIHRvLlxyXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gYmUgd3JpdHRlbiAoc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4sIG9iamVjdCxcclxuICogICBhcnJheSwgb3IgbnVsbCkuXHJcbiAqIEByZXR1cm5zIFJlc29sdmVzIHdoZW4gd3JpdGUgdG8gc2VydmVyIGlzIGNvbXBsZXRlLlxyXG4gKi9cclxuZnVuY3Rpb24gc2V0KHJlZiwgdmFsdWUpIHtcclxuICAgIHJlZiA9IGdldE1vZHVsYXJJbnN0YW5jZShyZWYpO1xyXG4gICAgdmFsaWRhdGVXcml0YWJsZVBhdGgoJ3NldCcsIHJlZi5fcGF0aCk7XHJcbiAgICB2YWxpZGF0ZUZpcmViYXNlRGF0YUFyZygnc2V0JywgdmFsdWUsIHJlZi5fcGF0aCwgZmFsc2UpO1xyXG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgIHJlcG9TZXRXaXRoUHJpb3JpdHkocmVmLl9yZXBvLCByZWYuX3BhdGgsIHZhbHVlLCBcclxuICAgIC8qcHJpb3JpdHk9Ki8gbnVsbCwgZGVmZXJyZWQud3JhcENhbGxiYWNrKCgpID0+IHsgfSkpO1xyXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbn1cclxuLyoqXHJcbiAqIFNldHMgYSBwcmlvcml0eSBmb3IgdGhlIGRhdGEgYXQgdGhpcyBEYXRhYmFzZSBsb2NhdGlvbi5cclxuICpcclxuICogQXBwbGljYXRpb25zIG5lZWQgbm90IHVzZSBwcmlvcml0eSBidXQgY2FuIG9yZGVyIGNvbGxlY3Rpb25zIGJ5XHJcbiAqIG9yZGluYXJ5IHByb3BlcnRpZXMgKHNlZVxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZGF0YWJhc2Uvd2ViL2xpc3RzLW9mLWRhdGEjc29ydGluZ19hbmRfZmlsdGVyaW5nX2RhdGEgfCBTb3J0aW5nIGFuZCBmaWx0ZXJpbmcgZGF0YX1cclxuICogKS5cclxuICpcclxuICogQHBhcmFtIHJlZiAtIFRoZSBsb2NhdGlvbiB0byB3cml0ZSB0by5cclxuICogQHBhcmFtIHByaW9yaXR5IC0gVGhlIHByaW9yaXR5IHRvIGJlIHdyaXR0ZW4gKHN0cmluZywgbnVtYmVyLCBvciBudWxsKS5cclxuICogQHJldHVybnMgUmVzb2x2ZXMgd2hlbiB3cml0ZSB0byBzZXJ2ZXIgaXMgY29tcGxldGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRQcmlvcml0eShyZWYsIHByaW9yaXR5KSB7XHJcbiAgICByZWYgPSBnZXRNb2R1bGFySW5zdGFuY2UocmVmKTtcclxuICAgIHZhbGlkYXRlV3JpdGFibGVQYXRoKCdzZXRQcmlvcml0eScsIHJlZi5fcGF0aCk7XHJcbiAgICB2YWxpZGF0ZVByaW9yaXR5KCdzZXRQcmlvcml0eScsIHByaW9yaXR5LCBmYWxzZSk7XHJcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgcmVwb1NldFdpdGhQcmlvcml0eShyZWYuX3JlcG8sIHBhdGhDaGlsZChyZWYuX3BhdGgsICcucHJpb3JpdHknKSwgcHJpb3JpdHksIG51bGwsIGRlZmVycmVkLndyYXBDYWxsYmFjaygoKSA9PiB7IH0pKTtcclxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xyXG59XHJcbi8qKlxyXG4gKiBXcml0ZXMgZGF0YSB0aGUgRGF0YWJhc2UgbG9jYXRpb24uIExpa2UgYHNldCgpYCBidXQgYWxzbyBzcGVjaWZpZXMgdGhlXHJcbiAqIHByaW9yaXR5IGZvciB0aGF0IGRhdGEuXHJcbiAqXHJcbiAqIEFwcGxpY2F0aW9ucyBuZWVkIG5vdCB1c2UgcHJpb3JpdHkgYnV0IGNhbiBvcmRlciBjb2xsZWN0aW9ucyBieVxyXG4gKiBvcmRpbmFyeSBwcm9wZXJ0aWVzIChzZWVcclxuICoge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2RhdGFiYXNlL3dlYi9saXN0cy1vZi1kYXRhI3NvcnRpbmdfYW5kX2ZpbHRlcmluZ19kYXRhIHwgU29ydGluZyBhbmQgZmlsdGVyaW5nIGRhdGF9XHJcbiAqICkuXHJcbiAqXHJcbiAqIEBwYXJhbSByZWYgLSBUaGUgbG9jYXRpb24gdG8gd3JpdGUgdG8uXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBiZSB3cml0dGVuIChzdHJpbmcsIG51bWJlciwgYm9vbGVhbiwgb2JqZWN0LFxyXG4gKiAgIGFycmF5LCBvciBudWxsKS5cclxuICogQHBhcmFtIHByaW9yaXR5IC0gVGhlIHByaW9yaXR5IHRvIGJlIHdyaXR0ZW4gKHN0cmluZywgbnVtYmVyLCBvciBudWxsKS5cclxuICogQHJldHVybnMgUmVzb2x2ZXMgd2hlbiB3cml0ZSB0byBzZXJ2ZXIgaXMgY29tcGxldGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRXaXRoUHJpb3JpdHkocmVmLCB2YWx1ZSwgcHJpb3JpdHkpIHtcclxuICAgIHZhbGlkYXRlV3JpdGFibGVQYXRoKCdzZXRXaXRoUHJpb3JpdHknLCByZWYuX3BhdGgpO1xyXG4gICAgdmFsaWRhdGVGaXJlYmFzZURhdGFBcmcoJ3NldFdpdGhQcmlvcml0eScsIHZhbHVlLCByZWYuX3BhdGgsIGZhbHNlKTtcclxuICAgIHZhbGlkYXRlUHJpb3JpdHkoJ3NldFdpdGhQcmlvcml0eScsIHByaW9yaXR5LCBmYWxzZSk7XHJcbiAgICBpZiAocmVmLmtleSA9PT0gJy5sZW5ndGgnIHx8IHJlZi5rZXkgPT09ICcua2V5cycpIHtcclxuICAgICAgICB0aHJvdyAnc2V0V2l0aFByaW9yaXR5IGZhaWxlZDogJyArIHJlZi5rZXkgKyAnIGlzIGEgcmVhZC1vbmx5IG9iamVjdC4nO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgIHJlcG9TZXRXaXRoUHJpb3JpdHkocmVmLl9yZXBvLCByZWYuX3BhdGgsIHZhbHVlLCBwcmlvcml0eSwgZGVmZXJyZWQud3JhcENhbGxiYWNrKCgpID0+IHsgfSkpO1xyXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbn1cclxuLyoqXHJcbiAqIFdyaXRlcyBtdWx0aXBsZSB2YWx1ZXMgdG8gdGhlIERhdGFiYXNlIGF0IG9uY2UuXHJcbiAqXHJcbiAqIFRoZSBgdmFsdWVzYCBhcmd1bWVudCBjb250YWlucyBtdWx0aXBsZSBwcm9wZXJ0eS12YWx1ZSBwYWlycyB0aGF0IHdpbGwgYmVcclxuICogd3JpdHRlbiB0byB0aGUgRGF0YWJhc2UgdG9nZXRoZXIuIEVhY2ggY2hpbGQgcHJvcGVydHkgY2FuIGVpdGhlciBiZSBhIHNpbXBsZVxyXG4gKiBwcm9wZXJ0eSAoZm9yIGV4YW1wbGUsIFwibmFtZVwiKSBvciBhIHJlbGF0aXZlIHBhdGggKGZvciBleGFtcGxlLFxyXG4gKiBcIm5hbWUvZmlyc3RcIikgZnJvbSB0aGUgY3VycmVudCBsb2NhdGlvbiB0byB0aGUgZGF0YSB0byB1cGRhdGUuXHJcbiAqXHJcbiAqIEFzIG9wcG9zZWQgdG8gdGhlIGBzZXQoKWAgbWV0aG9kLCBgdXBkYXRlKClgIGNhbiBiZSB1c2UgdG8gc2VsZWN0aXZlbHkgdXBkYXRlXHJcbiAqIG9ubHkgdGhlIHJlZmVyZW5jZWQgcHJvcGVydGllcyBhdCB0aGUgY3VycmVudCBsb2NhdGlvbiAoaW5zdGVhZCBvZiByZXBsYWNpbmdcclxuICogYWxsIHRoZSBjaGlsZCBwcm9wZXJ0aWVzIGF0IHRoZSBjdXJyZW50IGxvY2F0aW9uKS5cclxuICpcclxuICogVGhlIGVmZmVjdCBvZiB0aGUgd3JpdGUgd2lsbCBiZSB2aXNpYmxlIGltbWVkaWF0ZWx5LCBhbmQgdGhlIGNvcnJlc3BvbmRpbmdcclxuICogZXZlbnRzICgndmFsdWUnLCAnY2hpbGRfYWRkZWQnLCBldGMuKSB3aWxsIGJlIHRyaWdnZXJlZC4gU3luY2hyb25pemF0aW9uIG9mXHJcbiAqIHRoZSBkYXRhIHRvIHRoZSBGaXJlYmFzZSBzZXJ2ZXJzIHdpbGwgYWxzbyBiZSBzdGFydGVkLCBhbmQgdGhlIHJldHVybmVkXHJcbiAqIFByb21pc2Ugd2lsbCByZXNvbHZlIHdoZW4gY29tcGxldGUuIElmIHByb3ZpZGVkLCB0aGUgYG9uQ29tcGxldGVgIGNhbGxiYWNrXHJcbiAqIHdpbGwgYmUgY2FsbGVkIGFzeW5jaHJvbm91c2x5IGFmdGVyIHN5bmNocm9uaXphdGlvbiBoYXMgZmluaXNoZWQuXHJcbiAqXHJcbiAqIEEgc2luZ2xlIGB1cGRhdGUoKWAgd2lsbCBnZW5lcmF0ZSBhIHNpbmdsZSBcInZhbHVlXCIgZXZlbnQgYXQgdGhlIGxvY2F0aW9uXHJcbiAqIHdoZXJlIHRoZSBgdXBkYXRlKClgIHdhcyBwZXJmb3JtZWQsIHJlZ2FyZGxlc3Mgb2YgaG93IG1hbnkgY2hpbGRyZW4gd2VyZVxyXG4gKiBtb2RpZmllZC5cclxuICpcclxuICogTm90ZSB0aGF0IG1vZGlmeWluZyBkYXRhIHdpdGggYHVwZGF0ZSgpYCB3aWxsIGNhbmNlbCBhbnkgcGVuZGluZ1xyXG4gKiB0cmFuc2FjdGlvbnMgYXQgdGhhdCBsb2NhdGlvbiwgc28gZXh0cmVtZSBjYXJlIHNob3VsZCBiZSB0YWtlbiBpZiBtaXhpbmdcclxuICogYHVwZGF0ZSgpYCBhbmQgYHRyYW5zYWN0aW9uKClgIHRvIG1vZGlmeSB0aGUgc2FtZSBkYXRhLlxyXG4gKlxyXG4gKiBQYXNzaW5nIGBudWxsYCB0byBgdXBkYXRlKClgIHdpbGwgcmVtb3ZlIHRoZSBkYXRhIGF0IHRoaXMgbG9jYXRpb24uXHJcbiAqXHJcbiAqIFNlZVxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGVibG9nLmNvbS8yMDE1LzA5L2ludHJvZHVjaW5nLW11bHRpLWxvY2F0aW9uLXVwZGF0ZXMtYW5kXzg2Lmh0bWwgfCBJbnRyb2R1Y2luZyBtdWx0aS1sb2NhdGlvbiB1cGRhdGVzIGFuZCBtb3JlfS5cclxuICpcclxuICogQHBhcmFtIHJlZiAtIFRoZSBsb2NhdGlvbiB0byB3cml0ZSB0by5cclxuICogQHBhcmFtIHZhbHVlcyAtIE9iamVjdCBjb250YWluaW5nIG11bHRpcGxlIHZhbHVlcy5cclxuICogQHJldHVybnMgUmVzb2x2ZXMgd2hlbiB1cGRhdGUgb24gc2VydmVyIGlzIGNvbXBsZXRlLlxyXG4gKi9cclxuZnVuY3Rpb24gdXBkYXRlKHJlZiwgdmFsdWVzKSB7XHJcbiAgICB2YWxpZGF0ZUZpcmViYXNlTWVyZ2VEYXRhQXJnKCd1cGRhdGUnLCB2YWx1ZXMsIHJlZi5fcGF0aCwgZmFsc2UpO1xyXG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgIHJlcG9VcGRhdGUocmVmLl9yZXBvLCByZWYuX3BhdGgsIHZhbHVlcywgZGVmZXJyZWQud3JhcENhbGxiYWNrKCgpID0+IHsgfSkpO1xyXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbn1cclxuLyoqXHJcbiAqIEdldHMgdGhlIG1vc3QgdXAtdG8tZGF0ZSByZXN1bHQgZm9yIHRoaXMgcXVlcnkuXHJcbiAqXHJcbiAqIEBwYXJhbSBxdWVyeSAtIFRoZSBxdWVyeSB0byBydW4uXHJcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHdoaWNoIHJlc29sdmVzIHRvIHRoZSByZXN1bHRpbmcgRGF0YVNuYXBzaG90IGlmIGEgdmFsdWUgaXNcclxuICogYXZhaWxhYmxlLCBvciByZWplY3RzIGlmIHRoZSBjbGllbnQgaXMgdW5hYmxlIHRvIHJldHVybiBhIHZhbHVlIChlLmcuLCBpZiB0aGVcclxuICogc2VydmVyIGlzIHVucmVhY2hhYmxlIGFuZCB0aGVyZSBpcyBub3RoaW5nIGNhY2hlZCkuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXQocXVlcnkpIHtcclxuICAgIHF1ZXJ5ID0gZ2V0TW9kdWxhckluc3RhbmNlKHF1ZXJ5KTtcclxuICAgIGNvbnN0IGNhbGxiYWNrQ29udGV4dCA9IG5ldyBDYWxsYmFja0NvbnRleHQoKCkgPT4geyB9KTtcclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IG5ldyBWYWx1ZUV2ZW50UmVnaXN0cmF0aW9uKGNhbGxiYWNrQ29udGV4dCk7XHJcbiAgICByZXR1cm4gcmVwb0dldFZhbHVlKHF1ZXJ5Ll9yZXBvLCBxdWVyeSwgY29udGFpbmVyKS50aGVuKG5vZGUgPT4ge1xyXG4gICAgICAgIHJldHVybiBuZXcgRGF0YVNuYXBzaG90KG5vZGUsIG5ldyBSZWZlcmVuY2VJbXBsKHF1ZXJ5Ll9yZXBvLCBxdWVyeS5fcGF0aCksIHF1ZXJ5Ll9xdWVyeVBhcmFtcy5nZXRJbmRleCgpKTtcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIHJlZ2lzdHJhdGlvbiBmb3IgJ3ZhbHVlJyBldmVudHMuXHJcbiAqL1xyXG5jbGFzcyBWYWx1ZUV2ZW50UmVnaXN0cmF0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKGNhbGxiYWNrQ29udGV4dCkge1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tDb250ZXh0ID0gY2FsbGJhY2tDb250ZXh0O1xyXG4gICAgfVxyXG4gICAgcmVzcG9uZHNUbyhldmVudFR5cGUpIHtcclxuICAgICAgICByZXR1cm4gZXZlbnRUeXBlID09PSAndmFsdWUnO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlRXZlbnQoY2hhbmdlLCBxdWVyeSkge1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gcXVlcnkuX3F1ZXJ5UGFyYW1zLmdldEluZGV4KCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhRXZlbnQoJ3ZhbHVlJywgdGhpcywgbmV3IERhdGFTbmFwc2hvdChjaGFuZ2Uuc25hcHNob3ROb2RlLCBuZXcgUmVmZXJlbmNlSW1wbChxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgpLCBpbmRleCkpO1xyXG4gICAgfVxyXG4gICAgZ2V0RXZlbnRSdW5uZXIoZXZlbnREYXRhKSB7XHJcbiAgICAgICAgaWYgKGV2ZW50RGF0YS5nZXRFdmVudFR5cGUoKSA9PT0gJ2NhbmNlbCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHRoaXMuY2FsbGJhY2tDb250ZXh0Lm9uQ2FuY2VsKGV2ZW50RGF0YS5lcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gdGhpcy5jYWxsYmFja0NvbnRleHQub25WYWx1ZShldmVudERhdGEuc25hcHNob3QsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNyZWF0ZUNhbmNlbEV2ZW50KGVycm9yLCBwYXRoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2tDb250ZXh0Lmhhc0NhbmNlbENhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2FuY2VsRXZlbnQodGhpcywgZXJyb3IsIHBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbWF0Y2hlcyhvdGhlcikge1xyXG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgVmFsdWVFdmVudFJlZ2lzdHJhdGlvbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghb3RoZXIuY2FsbGJhY2tDb250ZXh0IHx8ICF0aGlzLmNhbGxiYWNrQ29udGV4dCkge1xyXG4gICAgICAgICAgICAvLyBJZiBubyBjYWxsYmFjayBzcGVjaWZpZWQsIHdlIGNvbnNpZGVyIGl0IHRvIG1hdGNoIGFueSBjYWxsYmFjay5cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gb3RoZXIuY2FsbGJhY2tDb250ZXh0Lm1hdGNoZXModGhpcy5jYWxsYmFja0NvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGhhc0FueUNhbGxiYWNrKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxiYWNrQ29udGV4dCAhPT0gbnVsbDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmVwcmVzZW50cyB0aGUgcmVnaXN0cmF0aW9uIG9mIGEgY2hpbGRfeCBldmVudC5cclxuICovXHJcbmNsYXNzIENoaWxkRXZlbnRSZWdpc3RyYXRpb24ge1xyXG4gICAgY29uc3RydWN0b3IoZXZlbnRUeXBlLCBjYWxsYmFja0NvbnRleHQpIHtcclxuICAgICAgICB0aGlzLmV2ZW50VHlwZSA9IGV2ZW50VHlwZTtcclxuICAgICAgICB0aGlzLmNhbGxiYWNrQ29udGV4dCA9IGNhbGxiYWNrQ29udGV4dDtcclxuICAgIH1cclxuICAgIHJlc3BvbmRzVG8oZXZlbnRUeXBlKSB7XHJcbiAgICAgICAgbGV0IGV2ZW50VG9DaGVjayA9IGV2ZW50VHlwZSA9PT0gJ2NoaWxkcmVuX2FkZGVkJyA/ICdjaGlsZF9hZGRlZCcgOiBldmVudFR5cGU7XHJcbiAgICAgICAgZXZlbnRUb0NoZWNrID1cclxuICAgICAgICAgICAgZXZlbnRUb0NoZWNrID09PSAnY2hpbGRyZW5fcmVtb3ZlZCcgPyAnY2hpbGRfcmVtb3ZlZCcgOiBldmVudFRvQ2hlY2s7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRUeXBlID09PSBldmVudFRvQ2hlY2s7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVDYW5jZWxFdmVudChlcnJvciwgcGF0aCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNhbGxiYWNrQ29udGV4dC5oYXNDYW5jZWxDYWxsYmFjaykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENhbmNlbEV2ZW50KHRoaXMsIGVycm9yLCBwYXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNyZWF0ZUV2ZW50KGNoYW5nZSwgcXVlcnkpIHtcclxuICAgICAgICBhc3NlcnQoY2hhbmdlLmNoaWxkTmFtZSAhPSBudWxsLCAnQ2hpbGQgZXZlbnRzIHNob3VsZCBoYXZlIGEgY2hpbGROYW1lLicpO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkUmVmID0gY2hpbGQobmV3IFJlZmVyZW5jZUltcGwocXVlcnkuX3JlcG8sIHF1ZXJ5Ll9wYXRoKSwgY2hhbmdlLmNoaWxkTmFtZSk7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSBxdWVyeS5fcXVlcnlQYXJhbXMuZ2V0SW5kZXgoKTtcclxuICAgICAgICByZXR1cm4gbmV3IERhdGFFdmVudChjaGFuZ2UudHlwZSwgdGhpcywgbmV3IERhdGFTbmFwc2hvdChjaGFuZ2Uuc25hcHNob3ROb2RlLCBjaGlsZFJlZiwgaW5kZXgpLCBjaGFuZ2UucHJldk5hbWUpO1xyXG4gICAgfVxyXG4gICAgZ2V0RXZlbnRSdW5uZXIoZXZlbnREYXRhKSB7XHJcbiAgICAgICAgaWYgKGV2ZW50RGF0YS5nZXRFdmVudFR5cGUoKSA9PT0gJ2NhbmNlbCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHRoaXMuY2FsbGJhY2tDb250ZXh0Lm9uQ2FuY2VsKGV2ZW50RGF0YS5lcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gdGhpcy5jYWxsYmFja0NvbnRleHQub25WYWx1ZShldmVudERhdGEuc25hcHNob3QsIGV2ZW50RGF0YS5wcmV2TmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbWF0Y2hlcyhvdGhlcikge1xyXG4gICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIENoaWxkRXZlbnRSZWdpc3RyYXRpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmV2ZW50VHlwZSA9PT0gb3RoZXIuZXZlbnRUeXBlICYmXHJcbiAgICAgICAgICAgICAgICAoIXRoaXMuY2FsbGJhY2tDb250ZXh0IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgIW90aGVyLmNhbGxiYWNrQ29udGV4dCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tDb250ZXh0Lm1hdGNoZXMob3RoZXIuY2FsbGJhY2tDb250ZXh0KSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBoYXNBbnlDYWxsYmFjaygpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLmNhbGxiYWNrQ29udGV4dDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKHF1ZXJ5LCBldmVudFR5cGUsIGNhbGxiYWNrLCBjYW5jZWxDYWxsYmFja09yTGlzdGVuT3B0aW9ucywgb3B0aW9ucykge1xyXG4gICAgbGV0IGNhbmNlbENhbGxiYWNrO1xyXG4gICAgaWYgKHR5cGVvZiBjYW5jZWxDYWxsYmFja09yTGlzdGVuT3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICBjYW5jZWxDYWxsYmFjayA9IHVuZGVmaW5lZDtcclxuICAgICAgICBvcHRpb25zID0gY2FuY2VsQ2FsbGJhY2tPckxpc3Rlbk9wdGlvbnM7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGNhbmNlbENhbGxiYWNrT3JMaXN0ZW5PcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgY2FuY2VsQ2FsbGJhY2sgPSBjYW5jZWxDYWxsYmFja09yTGlzdGVuT3B0aW9ucztcclxuICAgIH1cclxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMub25seU9uY2UpIHtcclxuICAgICAgICBjb25zdCB1c2VyQ2FsbGJhY2sgPSBjYWxsYmFjaztcclxuICAgICAgICBjb25zdCBvbmNlQ2FsbGJhY2sgPSAoZGF0YVNuYXBzaG90LCBwcmV2aW91c0NoaWxkTmFtZSkgPT4ge1xyXG4gICAgICAgICAgICByZXBvUmVtb3ZlRXZlbnRDYWxsYmFja0ZvclF1ZXJ5KHF1ZXJ5Ll9yZXBvLCBxdWVyeSwgY29udGFpbmVyKTtcclxuICAgICAgICAgICAgdXNlckNhbGxiYWNrKGRhdGFTbmFwc2hvdCwgcHJldmlvdXNDaGlsZE5hbWUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgb25jZUNhbGxiYWNrLnVzZXJDYWxsYmFjayA9IGNhbGxiYWNrLnVzZXJDYWxsYmFjaztcclxuICAgICAgICBvbmNlQ2FsbGJhY2suY29udGV4dCA9IGNhbGxiYWNrLmNvbnRleHQ7XHJcbiAgICAgICAgY2FsbGJhY2sgPSBvbmNlQ2FsbGJhY2s7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjYWxsYmFja0NvbnRleHQgPSBuZXcgQ2FsbGJhY2tDb250ZXh0KGNhbGxiYWNrLCBjYW5jZWxDYWxsYmFjayB8fCB1bmRlZmluZWQpO1xyXG4gICAgY29uc3QgY29udGFpbmVyID0gZXZlbnRUeXBlID09PSAndmFsdWUnXHJcbiAgICAgICAgPyBuZXcgVmFsdWVFdmVudFJlZ2lzdHJhdGlvbihjYWxsYmFja0NvbnRleHQpXHJcbiAgICAgICAgOiBuZXcgQ2hpbGRFdmVudFJlZ2lzdHJhdGlvbihldmVudFR5cGUsIGNhbGxiYWNrQ29udGV4dCk7XHJcbiAgICByZXBvQWRkRXZlbnRDYWxsYmFja0ZvclF1ZXJ5KHF1ZXJ5Ll9yZXBvLCBxdWVyeSwgY29udGFpbmVyKTtcclxuICAgIHJldHVybiAoKSA9PiByZXBvUmVtb3ZlRXZlbnRDYWxsYmFja0ZvclF1ZXJ5KHF1ZXJ5Ll9yZXBvLCBxdWVyeSwgY29udGFpbmVyKTtcclxufVxyXG5mdW5jdGlvbiBvblZhbHVlKHF1ZXJ5LCBjYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2tPckxpc3Rlbk9wdGlvbnMsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBhZGRFdmVudExpc3RlbmVyKHF1ZXJ5LCAndmFsdWUnLCBjYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2tPckxpc3Rlbk9wdGlvbnMsIG9wdGlvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIG9uQ2hpbGRBZGRlZChxdWVyeSwgY2FsbGJhY2ssIGNhbmNlbENhbGxiYWNrT3JMaXN0ZW5PcHRpb25zLCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gYWRkRXZlbnRMaXN0ZW5lcihxdWVyeSwgJ2NoaWxkX2FkZGVkJywgY2FsbGJhY2ssIGNhbmNlbENhbGxiYWNrT3JMaXN0ZW5PcHRpb25zLCBvcHRpb25zKTtcclxufVxyXG5mdW5jdGlvbiBvbkNoaWxkQ2hhbmdlZChxdWVyeSwgY2FsbGJhY2ssIGNhbmNlbENhbGxiYWNrT3JMaXN0ZW5PcHRpb25zLCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gYWRkRXZlbnRMaXN0ZW5lcihxdWVyeSwgJ2NoaWxkX2NoYW5nZWQnLCBjYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2tPckxpc3Rlbk9wdGlvbnMsIG9wdGlvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIG9uQ2hpbGRNb3ZlZChxdWVyeSwgY2FsbGJhY2ssIGNhbmNlbENhbGxiYWNrT3JMaXN0ZW5PcHRpb25zLCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gYWRkRXZlbnRMaXN0ZW5lcihxdWVyeSwgJ2NoaWxkX21vdmVkJywgY2FsbGJhY2ssIGNhbmNlbENhbGxiYWNrT3JMaXN0ZW5PcHRpb25zLCBvcHRpb25zKTtcclxufVxyXG5mdW5jdGlvbiBvbkNoaWxkUmVtb3ZlZChxdWVyeSwgY2FsbGJhY2ssIGNhbmNlbENhbGxiYWNrT3JMaXN0ZW5PcHRpb25zLCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gYWRkRXZlbnRMaXN0ZW5lcihxdWVyeSwgJ2NoaWxkX3JlbW92ZWQnLCBjYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2tPckxpc3Rlbk9wdGlvbnMsIG9wdGlvbnMpO1xyXG59XHJcbi8qKlxyXG4gKiBEZXRhY2hlcyBhIGNhbGxiYWNrIHByZXZpb3VzbHkgYXR0YWNoZWQgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBgb24qKClgIChgb25WYWx1ZWAsIGBvbkNoaWxkQWRkZWRgKSBsaXN0ZW5lci5cclxuICogTm90ZTogVGhpcyBpcyBub3QgdGhlIHJlY29tbWVuZGVkIHdheSB0byByZW1vdmUgYSBsaXN0ZW5lci4gSW5zdGVhZCwgcGxlYXNlIHVzZSB0aGUgcmV0dXJuZWQgY2FsbGJhY2sgZnVuY3Rpb24gZnJvbVxyXG4gKiB0aGUgcmVzcGVjdGl2ZSBgb24qYCBjYWxsYmFja3MuXHJcbiAqXHJcbiAqIERldGFjaCBhIGNhbGxiYWNrIHByZXZpb3VzbHkgYXR0YWNoZWQgd2l0aCBgb24qKClgLiBDYWxsaW5nIGBvZmYoKWAgb24gYSBwYXJlbnQgbGlzdGVuZXJcclxuICogd2lsbCBub3QgYXV0b21hdGljYWxseSByZW1vdmUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgb24gY2hpbGQgbm9kZXMsIGBvZmYoKWBcclxuICogbXVzdCBhbHNvIGJlIGNhbGxlZCBvbiBhbnkgY2hpbGQgbGlzdGVuZXJzIHRvIHJlbW92ZSB0aGUgY2FsbGJhY2suXHJcbiAqXHJcbiAqIElmIGEgY2FsbGJhY2sgaXMgbm90IHNwZWNpZmllZCwgYWxsIGNhbGxiYWNrcyBmb3IgdGhlIHNwZWNpZmllZCBldmVudFR5cGVcclxuICogd2lsbCBiZSByZW1vdmVkLiBTaW1pbGFybHksIGlmIG5vIGV2ZW50VHlwZSBpcyBzcGVjaWZpZWQsIGFsbCBjYWxsYmFja3NcclxuICogZm9yIHRoZSBgUmVmZXJlbmNlYCB3aWxsIGJlIHJlbW92ZWQuXHJcbiAqXHJcbiAqIEluZGl2aWR1YWwgbGlzdGVuZXJzIGNhbiBhbHNvIGJlIHJlbW92ZWQgYnkgaW52b2tpbmcgdGhlaXIgdW5zdWJzY3JpYmVcclxuICogY2FsbGJhY2tzLlxyXG4gKlxyXG4gKiBAcGFyYW0gcXVlcnkgLSBUaGUgcXVlcnkgdGhhdCB0aGUgbGlzdGVuZXIgd2FzIHJlZ2lzdGVyZWQgd2l0aC5cclxuICogQHBhcmFtIGV2ZW50VHlwZSAtIE9uZSBvZiB0aGUgZm9sbG93aW5nIHN0cmluZ3M6IFwidmFsdWVcIiwgXCJjaGlsZF9hZGRlZFwiLFxyXG4gKiBcImNoaWxkX2NoYW5nZWRcIiwgXCJjaGlsZF9yZW1vdmVkXCIsIG9yIFwiY2hpbGRfbW92ZWQuXCIgSWYgb21pdHRlZCwgYWxsIGNhbGxiYWNrc1xyXG4gKiBmb3IgdGhlIGBSZWZlcmVuY2VgIHdpbGwgYmUgcmVtb3ZlZC5cclxuICogQHBhcmFtIGNhbGxiYWNrIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2FzIHBhc3NlZCB0byBgb24oKWAgb3JcclxuICogYHVuZGVmaW5lZGAgdG8gcmVtb3ZlIGFsbCBjYWxsYmFja3MuXHJcbiAqL1xyXG5mdW5jdGlvbiBvZmYocXVlcnksIGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcclxuICAgIGxldCBjb250YWluZXIgPSBudWxsO1xyXG4gICAgY29uc3QgZXhwQ2FsbGJhY2sgPSBjYWxsYmFjayA/IG5ldyBDYWxsYmFja0NvbnRleHQoY2FsbGJhY2spIDogbnVsbDtcclxuICAgIGlmIChldmVudFR5cGUgPT09ICd2YWx1ZScpIHtcclxuICAgICAgICBjb250YWluZXIgPSBuZXcgVmFsdWVFdmVudFJlZ2lzdHJhdGlvbihleHBDYWxsYmFjayk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChldmVudFR5cGUpIHtcclxuICAgICAgICBjb250YWluZXIgPSBuZXcgQ2hpbGRFdmVudFJlZ2lzdHJhdGlvbihldmVudFR5cGUsIGV4cENhbGxiYWNrKTtcclxuICAgIH1cclxuICAgIHJlcG9SZW1vdmVFdmVudENhbGxiYWNrRm9yUXVlcnkocXVlcnkuX3JlcG8sIHF1ZXJ5LCBjb250YWluZXIpO1xyXG59XHJcbi8qKlxyXG4gKiBBIGBRdWVyeUNvbnN0cmFpbnRgIGlzIHVzZWQgdG8gbmFycm93IHRoZSBzZXQgb2YgZG9jdW1lbnRzIHJldHVybmVkIGJ5IGFcclxuICogRGF0YWJhc2UgcXVlcnkuIGBRdWVyeUNvbnN0cmFpbnRgcyBhcmUgY3JlYXRlZCBieSBpbnZva2luZyB7QGxpbmsgZW5kQXR9LFxyXG4gKiB7QGxpbmsgZW5kQmVmb3JlfSwge0BsaW5rIHN0YXJ0QXR9LCB7QGxpbmsgc3RhcnRBZnRlcn0sIHtAbGlua1xyXG4gKiBsaW1pdFRvRmlyc3R9LCB7QGxpbmsgbGltaXRUb0xhc3R9LCB7QGxpbmsgb3JkZXJCeUNoaWxkfSxcclxuICoge0BsaW5rIG9yZGVyQnlDaGlsZH0sIHtAbGluayBvcmRlckJ5S2V5fSAsIHtAbGluayBvcmRlckJ5UHJpb3JpdHl9ICxcclxuICoge0BsaW5rIG9yZGVyQnlWYWx1ZX0gIG9yIHtAbGluayBlcXVhbFRvfSBhbmRcclxuICogY2FuIHRoZW4gYmUgcGFzc2VkIHRvIHtAbGluayBxdWVyeX0gdG8gY3JlYXRlIGEgbmV3IHF1ZXJ5IGluc3RhbmNlIHRoYXRcclxuICogYWxzbyBjb250YWlucyB0aGlzIGBRdWVyeUNvbnN0cmFpbnRgLlxyXG4gKi9cclxuY2xhc3MgUXVlcnlDb25zdHJhaW50IHtcclxufVxyXG5jbGFzcyBRdWVyeUVuZEF0Q29uc3RyYWludCBleHRlbmRzIFF1ZXJ5Q29uc3RyYWludCB7XHJcbiAgICBjb25zdHJ1Y3RvcihfdmFsdWUsIF9rZXkpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gX3ZhbHVlO1xyXG4gICAgICAgIHRoaXMuX2tleSA9IF9rZXk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ2VuZEF0JztcclxuICAgIH1cclxuICAgIF9hcHBseShxdWVyeSkge1xyXG4gICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdlbmRBdCcsIHRoaXMuX3ZhbHVlLCBxdWVyeS5fcGF0aCwgdHJ1ZSk7XHJcbiAgICAgICAgY29uc3QgbmV3UGFyYW1zID0gcXVlcnlQYXJhbXNFbmRBdChxdWVyeS5fcXVlcnlQYXJhbXMsIHRoaXMuX3ZhbHVlLCB0aGlzLl9rZXkpO1xyXG4gICAgICAgIHZhbGlkYXRlTGltaXQobmV3UGFyYW1zKTtcclxuICAgICAgICB2YWxpZGF0ZVF1ZXJ5RW5kcG9pbnRzKG5ld1BhcmFtcyk7XHJcbiAgICAgICAgaWYgKHF1ZXJ5Ll9xdWVyeVBhcmFtcy5oYXNFbmQoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuZEF0OiBTdGFydGluZyBwb2ludCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBlbmRBdCwgJyArXHJcbiAgICAgICAgICAgICAgICAnZW5kQmVmb3JlIG9yIGVxdWFsVG8pLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgsIG5ld1BhcmFtcywgcXVlcnkuX29yZGVyQnlDYWxsZWQpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgYFF1ZXJ5Q29uc3RyYWludGAgd2l0aCB0aGUgc3BlY2lmaWVkIGVuZGluZyBwb2ludC5cclxuICpcclxuICogVXNpbmcgYHN0YXJ0QXQoKWAsIGBzdGFydEFmdGVyKClgLCBgZW5kQmVmb3JlKClgLCBgZW5kQXQoKWAgYW5kIGBlcXVhbFRvKClgXHJcbiAqIGFsbG93cyB5b3UgdG8gY2hvb3NlIGFyYml0cmFyeSBzdGFydGluZyBhbmQgZW5kaW5nIHBvaW50cyBmb3IgeW91ciBxdWVyaWVzLlxyXG4gKlxyXG4gKiBUaGUgZW5kaW5nIHBvaW50IGlzIGluY2x1c2l2ZSwgc28gY2hpbGRyZW4gd2l0aCBleGFjdGx5IHRoZSBzcGVjaWZpZWQgdmFsdWVcclxuICogd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgcXVlcnkuIFRoZSBvcHRpb25hbCBrZXkgYXJndW1lbnQgY2FuIGJlIHVzZWQgdG9cclxuICogZnVydGhlciBsaW1pdCB0aGUgcmFuZ2Ugb2YgdGhlIHF1ZXJ5LiBJZiBpdCBpcyBzcGVjaWZpZWQsIHRoZW4gY2hpbGRyZW4gdGhhdFxyXG4gKiBoYXZlIGV4YWN0bHkgdGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGFsc28gaGF2ZSBhIGtleSBuYW1lIGxlc3MgdGhhbiBvciBlcXVhbFxyXG4gKiB0byB0aGUgc3BlY2lmaWVkIGtleS5cclxuICpcclxuICogWW91IGNhbiByZWFkIG1vcmUgYWJvdXQgYGVuZEF0KClgIGluXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvbGlzdHMtb2YtZGF0YSNmaWx0ZXJpbmdfZGF0YSB8IEZpbHRlcmluZyBkYXRhfS5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGVuZCBhdC4gVGhlIGFyZ3VtZW50IHR5cGUgZGVwZW5kcyBvbiB3aGljaFxyXG4gKiBgb3JkZXJCeSooKWAgZnVuY3Rpb24gd2FzIHVzZWQgaW4gdGhpcyBxdWVyeS4gU3BlY2lmeSBhIHZhbHVlIHRoYXQgbWF0Y2hlc1xyXG4gKiB0aGUgYG9yZGVyQnkqKClgIHR5cGUuIFdoZW4gdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIGBvcmRlckJ5S2V5KClgLCB0aGVcclxuICogdmFsdWUgbXVzdCBiZSBhIHN0cmluZy5cclxuICogQHBhcmFtIGtleSAtIFRoZSBjaGlsZCBrZXkgdG8gZW5kIGF0LCBhbW9uZyB0aGUgY2hpbGRyZW4gd2l0aCB0aGUgcHJldmlvdXNseVxyXG4gKiBzcGVjaWZpZWQgcHJpb3JpdHkuIFRoaXMgYXJndW1lbnQgaXMgb25seSBhbGxvd2VkIGlmIG9yZGVyaW5nIGJ5IGNoaWxkLFxyXG4gKiB2YWx1ZSwgb3IgcHJpb3JpdHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBlbmRBdCh2YWx1ZSwga2V5KSB7XHJcbiAgICB2YWxpZGF0ZUtleSgnZW5kQXQnLCAna2V5Jywga2V5LCB0cnVlKTtcclxuICAgIHJldHVybiBuZXcgUXVlcnlFbmRBdENvbnN0cmFpbnQodmFsdWUsIGtleSk7XHJcbn1cclxuY2xhc3MgUXVlcnlFbmRCZWZvcmVDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcclxuICAgIGNvbnN0cnVjdG9yKF92YWx1ZSwgX2tleSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBfdmFsdWU7XHJcbiAgICAgICAgdGhpcy5fa2V5ID0gX2tleTtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnZW5kQmVmb3JlJztcclxuICAgIH1cclxuICAgIF9hcHBseShxdWVyeSkge1xyXG4gICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdlbmRCZWZvcmUnLCB0aGlzLl92YWx1ZSwgcXVlcnkuX3BhdGgsIGZhbHNlKTtcclxuICAgICAgICBjb25zdCBuZXdQYXJhbXMgPSBxdWVyeVBhcmFtc0VuZEJlZm9yZShxdWVyeS5fcXVlcnlQYXJhbXMsIHRoaXMuX3ZhbHVlLCB0aGlzLl9rZXkpO1xyXG4gICAgICAgIHZhbGlkYXRlTGltaXQobmV3UGFyYW1zKTtcclxuICAgICAgICB2YWxpZGF0ZVF1ZXJ5RW5kcG9pbnRzKG5ld1BhcmFtcyk7XHJcbiAgICAgICAgaWYgKHF1ZXJ5Ll9xdWVyeVBhcmFtcy5oYXNFbmQoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuZEJlZm9yZTogU3RhcnRpbmcgcG9pbnQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gZW5kQXQsICcgK1xyXG4gICAgICAgICAgICAgICAgJ2VuZEJlZm9yZSBvciBlcXVhbFRvKS4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocXVlcnkuX3JlcG8sIHF1ZXJ5Ll9wYXRoLCBuZXdQYXJhbXMsIHF1ZXJ5Ll9vcmRlckJ5Q2FsbGVkKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIGBRdWVyeUNvbnN0cmFpbnRgIHdpdGggdGhlIHNwZWNpZmllZCBlbmRpbmcgcG9pbnQgKGV4Y2x1c2l2ZSkuXHJcbiAqXHJcbiAqIFVzaW5nIGBzdGFydEF0KClgLCBgc3RhcnRBZnRlcigpYCwgYGVuZEJlZm9yZSgpYCwgYGVuZEF0KClgIGFuZCBgZXF1YWxUbygpYFxyXG4gKiBhbGxvd3MgeW91IHRvIGNob29zZSBhcmJpdHJhcnkgc3RhcnRpbmcgYW5kIGVuZGluZyBwb2ludHMgZm9yIHlvdXIgcXVlcmllcy5cclxuICpcclxuICogVGhlIGVuZGluZyBwb2ludCBpcyBleGNsdXNpdmUuIElmIG9ubHkgYSB2YWx1ZSBpcyBwcm92aWRlZCwgY2hpbGRyZW5cclxuICogd2l0aCBhIHZhbHVlIGxlc3MgdGhhbiB0aGUgc3BlY2lmaWVkIHZhbHVlIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIHF1ZXJ5LlxyXG4gKiBJZiBhIGtleSBpcyBzcGVjaWZpZWQsIHRoZW4gY2hpbGRyZW4gbXVzdCBoYXZlIGEgdmFsdWUgbGVzcyB0aGFuIG9yIGVxdWFsXHJcbiAqIHRvIHRoZSBzcGVjaWZpZWQgdmFsdWUgYW5kIGEga2V5IG5hbWUgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQga2V5LlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZW5kIGJlZm9yZS4gVGhlIGFyZ3VtZW50IHR5cGUgZGVwZW5kcyBvbiB3aGljaFxyXG4gKiBgb3JkZXJCeSooKWAgZnVuY3Rpb24gd2FzIHVzZWQgaW4gdGhpcyBxdWVyeS4gU3BlY2lmeSBhIHZhbHVlIHRoYXQgbWF0Y2hlc1xyXG4gKiB0aGUgYG9yZGVyQnkqKClgIHR5cGUuIFdoZW4gdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIGBvcmRlckJ5S2V5KClgLCB0aGVcclxuICogdmFsdWUgbXVzdCBiZSBhIHN0cmluZy5cclxuICogQHBhcmFtIGtleSAtIFRoZSBjaGlsZCBrZXkgdG8gZW5kIGJlZm9yZSwgYW1vbmcgdGhlIGNoaWxkcmVuIHdpdGggdGhlXHJcbiAqIHByZXZpb3VzbHkgc3BlY2lmaWVkIHByaW9yaXR5LiBUaGlzIGFyZ3VtZW50IGlzIG9ubHkgYWxsb3dlZCBpZiBvcmRlcmluZyBieVxyXG4gKiBjaGlsZCwgdmFsdWUsIG9yIHByaW9yaXR5LlxyXG4gKi9cclxuZnVuY3Rpb24gZW5kQmVmb3JlKHZhbHVlLCBrZXkpIHtcclxuICAgIHZhbGlkYXRlS2V5KCdlbmRCZWZvcmUnLCAna2V5Jywga2V5LCB0cnVlKTtcclxuICAgIHJldHVybiBuZXcgUXVlcnlFbmRCZWZvcmVDb25zdHJhaW50KHZhbHVlLCBrZXkpO1xyXG59XHJcbmNsYXNzIFF1ZXJ5U3RhcnRBdENvbnN0cmFpbnQgZXh0ZW5kcyBRdWVyeUNvbnN0cmFpbnQge1xyXG4gICAgY29uc3RydWN0b3IoX3ZhbHVlLCBfa2V5KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl92YWx1ZSA9IF92YWx1ZTtcclxuICAgICAgICB0aGlzLl9rZXkgPSBfa2V5O1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdzdGFydEF0JztcclxuICAgIH1cclxuICAgIF9hcHBseShxdWVyeSkge1xyXG4gICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdzdGFydEF0JywgdGhpcy5fdmFsdWUsIHF1ZXJ5Ll9wYXRoLCB0cnVlKTtcclxuICAgICAgICBjb25zdCBuZXdQYXJhbXMgPSBxdWVyeVBhcmFtc1N0YXJ0QXQocXVlcnkuX3F1ZXJ5UGFyYW1zLCB0aGlzLl92YWx1ZSwgdGhpcy5fa2V5KTtcclxuICAgICAgICB2YWxpZGF0ZUxpbWl0KG5ld1BhcmFtcyk7XHJcbiAgICAgICAgdmFsaWRhdGVRdWVyeUVuZHBvaW50cyhuZXdQYXJhbXMpO1xyXG4gICAgICAgIGlmIChxdWVyeS5fcXVlcnlQYXJhbXMuaGFzU3RhcnQoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0QXQ6IFN0YXJ0aW5nIHBvaW50IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIHN0YXJ0QXQsICcgK1xyXG4gICAgICAgICAgICAgICAgJ3N0YXJ0QmVmb3JlIG9yIGVxdWFsVG8pLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgsIG5ld1BhcmFtcywgcXVlcnkuX29yZGVyQnlDYWxsZWQpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgYFF1ZXJ5Q29uc3RyYWludGAgd2l0aCB0aGUgc3BlY2lmaWVkIHN0YXJ0aW5nIHBvaW50LlxyXG4gKlxyXG4gKiBVc2luZyBgc3RhcnRBdCgpYCwgYHN0YXJ0QWZ0ZXIoKWAsIGBlbmRCZWZvcmUoKWAsIGBlbmRBdCgpYCBhbmQgYGVxdWFsVG8oKWBcclxuICogYWxsb3dzIHlvdSB0byBjaG9vc2UgYXJiaXRyYXJ5IHN0YXJ0aW5nIGFuZCBlbmRpbmcgcG9pbnRzIGZvciB5b3VyIHF1ZXJpZXMuXHJcbiAqXHJcbiAqIFRoZSBzdGFydGluZyBwb2ludCBpcyBpbmNsdXNpdmUsIHNvIGNoaWxkcmVuIHdpdGggZXhhY3RseSB0aGUgc3BlY2lmaWVkIHZhbHVlXHJcbiAqIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIHF1ZXJ5LiBUaGUgb3B0aW9uYWwga2V5IGFyZ3VtZW50IGNhbiBiZSB1c2VkIHRvXHJcbiAqIGZ1cnRoZXIgbGltaXQgdGhlIHJhbmdlIG9mIHRoZSBxdWVyeS4gSWYgaXQgaXMgc3BlY2lmaWVkLCB0aGVuIGNoaWxkcmVuIHRoYXRcclxuICogaGF2ZSBleGFjdGx5IHRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBhbHNvIGhhdmUgYSBrZXkgbmFtZSBncmVhdGVyIHRoYW4gb3JcclxuICogZXF1YWwgdG8gdGhlIHNwZWNpZmllZCBrZXkuXHJcbiAqXHJcbiAqIFlvdSBjYW4gcmVhZCBtb3JlIGFib3V0IGBzdGFydEF0KClgIGluXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvbGlzdHMtb2YtZGF0YSNmaWx0ZXJpbmdfZGF0YSB8IEZpbHRlcmluZyBkYXRhfS5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHN0YXJ0IGF0LiBUaGUgYXJndW1lbnQgdHlwZSBkZXBlbmRzIG9uIHdoaWNoXHJcbiAqIGBvcmRlckJ5KigpYCBmdW5jdGlvbiB3YXMgdXNlZCBpbiB0aGlzIHF1ZXJ5LiBTcGVjaWZ5IGEgdmFsdWUgdGhhdCBtYXRjaGVzXHJcbiAqIHRoZSBgb3JkZXJCeSooKWAgdHlwZS4gV2hlbiB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggYG9yZGVyQnlLZXkoKWAsIHRoZVxyXG4gKiB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nLlxyXG4gKiBAcGFyYW0ga2V5IC0gVGhlIGNoaWxkIGtleSB0byBzdGFydCBhdC4gVGhpcyBhcmd1bWVudCBpcyBvbmx5IGFsbG93ZWQgaWZcclxuICogb3JkZXJpbmcgYnkgY2hpbGQsIHZhbHVlLCBvciBwcmlvcml0eS5cclxuICovXHJcbmZ1bmN0aW9uIHN0YXJ0QXQodmFsdWUgPSBudWxsLCBrZXkpIHtcclxuICAgIHZhbGlkYXRlS2V5KCdzdGFydEF0JywgJ2tleScsIGtleSwgdHJ1ZSk7XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5U3RhcnRBdENvbnN0cmFpbnQodmFsdWUsIGtleSk7XHJcbn1cclxuY2xhc3MgUXVlcnlTdGFydEFmdGVyQ29uc3RyYWludCBleHRlbmRzIFF1ZXJ5Q29uc3RyYWludCB7XHJcbiAgICBjb25zdHJ1Y3RvcihfdmFsdWUsIF9rZXkpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gX3ZhbHVlO1xyXG4gICAgICAgIHRoaXMuX2tleSA9IF9rZXk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ3N0YXJ0QWZ0ZXInO1xyXG4gICAgfVxyXG4gICAgX2FwcGx5KHF1ZXJ5KSB7XHJcbiAgICAgICAgdmFsaWRhdGVGaXJlYmFzZURhdGFBcmcoJ3N0YXJ0QWZ0ZXInLCB0aGlzLl92YWx1ZSwgcXVlcnkuX3BhdGgsIGZhbHNlKTtcclxuICAgICAgICBjb25zdCBuZXdQYXJhbXMgPSBxdWVyeVBhcmFtc1N0YXJ0QWZ0ZXIocXVlcnkuX3F1ZXJ5UGFyYW1zLCB0aGlzLl92YWx1ZSwgdGhpcy5fa2V5KTtcclxuICAgICAgICB2YWxpZGF0ZUxpbWl0KG5ld1BhcmFtcyk7XHJcbiAgICAgICAgdmFsaWRhdGVRdWVyeUVuZHBvaW50cyhuZXdQYXJhbXMpO1xyXG4gICAgICAgIGlmIChxdWVyeS5fcXVlcnlQYXJhbXMuaGFzU3RhcnQoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0QWZ0ZXI6IFN0YXJ0aW5nIHBvaW50IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIHN0YXJ0QXQsICcgK1xyXG4gICAgICAgICAgICAgICAgJ3N0YXJ0QWZ0ZXIsIG9yIGVxdWFsVG8pLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgsIG5ld1BhcmFtcywgcXVlcnkuX29yZGVyQnlDYWxsZWQpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgYFF1ZXJ5Q29uc3RyYWludGAgd2l0aCB0aGUgc3BlY2lmaWVkIHN0YXJ0aW5nIHBvaW50IChleGNsdXNpdmUpLlxyXG4gKlxyXG4gKiBVc2luZyBgc3RhcnRBdCgpYCwgYHN0YXJ0QWZ0ZXIoKWAsIGBlbmRCZWZvcmUoKWAsIGBlbmRBdCgpYCBhbmQgYGVxdWFsVG8oKWBcclxuICogYWxsb3dzIHlvdSB0byBjaG9vc2UgYXJiaXRyYXJ5IHN0YXJ0aW5nIGFuZCBlbmRpbmcgcG9pbnRzIGZvciB5b3VyIHF1ZXJpZXMuXHJcbiAqXHJcbiAqIFRoZSBzdGFydGluZyBwb2ludCBpcyBleGNsdXNpdmUuIElmIG9ubHkgYSB2YWx1ZSBpcyBwcm92aWRlZCwgY2hpbGRyZW5cclxuICogd2l0aCBhIHZhbHVlIGdyZWF0ZXIgdGhhbiB0aGUgc3BlY2lmaWVkIHZhbHVlIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIHF1ZXJ5LlxyXG4gKiBJZiBhIGtleSBpcyBzcGVjaWZpZWQsIHRoZW4gY2hpbGRyZW4gbXVzdCBoYXZlIGEgdmFsdWUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsXHJcbiAqIHRvIHRoZSBzcGVjaWZpZWQgdmFsdWUgYW5kIGEgYSBrZXkgbmFtZSBncmVhdGVyIHRoYW4gdGhlIHNwZWNpZmllZCBrZXkuXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBzdGFydCBhZnRlci4gVGhlIGFyZ3VtZW50IHR5cGUgZGVwZW5kcyBvbiB3aGljaFxyXG4gKiBgb3JkZXJCeSooKWAgZnVuY3Rpb24gd2FzIHVzZWQgaW4gdGhpcyBxdWVyeS4gU3BlY2lmeSBhIHZhbHVlIHRoYXQgbWF0Y2hlc1xyXG4gKiB0aGUgYG9yZGVyQnkqKClgIHR5cGUuIFdoZW4gdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIGBvcmRlckJ5S2V5KClgLCB0aGVcclxuICogdmFsdWUgbXVzdCBiZSBhIHN0cmluZy5cclxuICogQHBhcmFtIGtleSAtIFRoZSBjaGlsZCBrZXkgdG8gc3RhcnQgYWZ0ZXIuIFRoaXMgYXJndW1lbnQgaXMgb25seSBhbGxvd2VkIGlmXHJcbiAqIG9yZGVyaW5nIGJ5IGNoaWxkLCB2YWx1ZSwgb3IgcHJpb3JpdHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBzdGFydEFmdGVyKHZhbHVlLCBrZXkpIHtcclxuICAgIHZhbGlkYXRlS2V5KCdzdGFydEFmdGVyJywgJ2tleScsIGtleSwgdHJ1ZSk7XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5U3RhcnRBZnRlckNvbnN0cmFpbnQodmFsdWUsIGtleSk7XHJcbn1cclxuY2xhc3MgUXVlcnlMaW1pdFRvRmlyc3RDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcclxuICAgIGNvbnN0cnVjdG9yKF9saW1pdCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fbGltaXQgPSBfbGltaXQ7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ2xpbWl0VG9GaXJzdCc7XHJcbiAgICB9XHJcbiAgICBfYXBwbHkocXVlcnkpIHtcclxuICAgICAgICBpZiAocXVlcnkuX3F1ZXJ5UGFyYW1zLmhhc0xpbWl0KCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsaW1pdFRvRmlyc3Q6IExpbWl0IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIGxpbWl0VG9GaXJzdCAnICtcclxuICAgICAgICAgICAgICAgICdvciBsaW1pdFRvTGFzdCkuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHF1ZXJ5Ll9yZXBvLCBxdWVyeS5fcGF0aCwgcXVlcnlQYXJhbXNMaW1pdFRvRmlyc3QocXVlcnkuX3F1ZXJ5UGFyYW1zLCB0aGlzLl9saW1pdCksIHF1ZXJ5Ll9vcmRlckJ5Q2FsbGVkKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBgUXVlcnlDb25zdHJhaW50YCB0aGF0IGlmIGxpbWl0ZWQgdG8gdGhlIGZpcnN0IHNwZWNpZmljIG51bWJlclxyXG4gKiBvZiBjaGlsZHJlbi5cclxuICpcclxuICogVGhlIGBsaW1pdFRvRmlyc3QoKWAgbWV0aG9kIGlzIHVzZWQgdG8gc2V0IGEgbWF4aW11bSBudW1iZXIgb2YgY2hpbGRyZW4gdG8gYmVcclxuICogc3luY2VkIGZvciBhIGdpdmVuIGNhbGxiYWNrLiBJZiB3ZSBzZXQgYSBsaW1pdCBvZiAxMDAsIHdlIHdpbGwgaW5pdGlhbGx5IG9ubHlcclxuICogcmVjZWl2ZSB1cCB0byAxMDAgYGNoaWxkX2FkZGVkYCBldmVudHMuIElmIHdlIGhhdmUgZmV3ZXIgdGhhbiAxMDAgbWVzc2FnZXNcclxuICogc3RvcmVkIGluIG91ciBEYXRhYmFzZSwgYSBgY2hpbGRfYWRkZWRgIGV2ZW50IHdpbGwgZmlyZSBmb3IgZWFjaCBtZXNzYWdlLlxyXG4gKiBIb3dldmVyLCBpZiB3ZSBoYXZlIG92ZXIgMTAwIG1lc3NhZ2VzLCB3ZSB3aWxsIG9ubHkgcmVjZWl2ZSBhIGBjaGlsZF9hZGRlZGBcclxuICogZXZlbnQgZm9yIHRoZSBmaXJzdCAxMDAgb3JkZXJlZCBtZXNzYWdlcy4gQXMgaXRlbXMgY2hhbmdlLCB3ZSB3aWxsIHJlY2VpdmVcclxuICogYGNoaWxkX3JlbW92ZWRgIGV2ZW50cyBmb3IgZWFjaCBpdGVtIHRoYXQgZHJvcHMgb3V0IG9mIHRoZSBhY3RpdmUgbGlzdCBzb1xyXG4gKiB0aGF0IHRoZSB0b3RhbCBudW1iZXIgc3RheXMgYXQgMTAwLlxyXG4gKlxyXG4gKiBZb3UgY2FuIHJlYWQgbW9yZSBhYm91dCBgbGltaXRUb0ZpcnN0KClgIGluXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvbGlzdHMtb2YtZGF0YSNmaWx0ZXJpbmdfZGF0YSB8IEZpbHRlcmluZyBkYXRhfS5cclxuICpcclxuICogQHBhcmFtIGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIG5vZGVzIHRvIGluY2x1ZGUgaW4gdGhpcyBxdWVyeS5cclxuICovXHJcbmZ1bmN0aW9uIGxpbWl0VG9GaXJzdChsaW1pdCkge1xyXG4gICAgaWYgKHR5cGVvZiBsaW1pdCAhPT0gJ251bWJlcicgfHwgTWF0aC5mbG9vcihsaW1pdCkgIT09IGxpbWl0IHx8IGxpbWl0IDw9IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xpbWl0VG9GaXJzdDogRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIuJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5TGltaXRUb0ZpcnN0Q29uc3RyYWludChsaW1pdCk7XHJcbn1cclxuY2xhc3MgUXVlcnlMaW1pdFRvTGFzdENvbnN0cmFpbnQgZXh0ZW5kcyBRdWVyeUNvbnN0cmFpbnQge1xyXG4gICAgY29uc3RydWN0b3IoX2xpbWl0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl9saW1pdCA9IF9saW1pdDtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnbGltaXRUb0xhc3QnO1xyXG4gICAgfVxyXG4gICAgX2FwcGx5KHF1ZXJ5KSB7XHJcbiAgICAgICAgaWYgKHF1ZXJ5Ll9xdWVyeVBhcmFtcy5oYXNMaW1pdCgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbGltaXRUb0xhc3Q6IExpbWl0IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIGxpbWl0VG9GaXJzdCAnICtcclxuICAgICAgICAgICAgICAgICdvciBsaW1pdFRvTGFzdCkuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHF1ZXJ5Ll9yZXBvLCBxdWVyeS5fcGF0aCwgcXVlcnlQYXJhbXNMaW1pdFRvTGFzdChxdWVyeS5fcXVlcnlQYXJhbXMsIHRoaXMuX2xpbWl0KSwgcXVlcnkuX29yZGVyQnlDYWxsZWQpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGBRdWVyeUNvbnN0cmFpbnRgIHRoYXQgaXMgbGltaXRlZCB0byByZXR1cm4gb25seSB0aGUgbGFzdFxyXG4gKiBzcGVjaWZpZWQgbnVtYmVyIG9mIGNoaWxkcmVuLlxyXG4gKlxyXG4gKiBUaGUgYGxpbWl0VG9MYXN0KClgIG1ldGhvZCBpcyB1c2VkIHRvIHNldCBhIG1heGltdW0gbnVtYmVyIG9mIGNoaWxkcmVuIHRvIGJlXHJcbiAqIHN5bmNlZCBmb3IgYSBnaXZlbiBjYWxsYmFjay4gSWYgd2Ugc2V0IGEgbGltaXQgb2YgMTAwLCB3ZSB3aWxsIGluaXRpYWxseSBvbmx5XHJcbiAqIHJlY2VpdmUgdXAgdG8gMTAwIGBjaGlsZF9hZGRlZGAgZXZlbnRzLiBJZiB3ZSBoYXZlIGZld2VyIHRoYW4gMTAwIG1lc3NhZ2VzXHJcbiAqIHN0b3JlZCBpbiBvdXIgRGF0YWJhc2UsIGEgYGNoaWxkX2FkZGVkYCBldmVudCB3aWxsIGZpcmUgZm9yIGVhY2ggbWVzc2FnZS5cclxuICogSG93ZXZlciwgaWYgd2UgaGF2ZSBvdmVyIDEwMCBtZXNzYWdlcywgd2Ugd2lsbCBvbmx5IHJlY2VpdmUgYSBgY2hpbGRfYWRkZWRgXHJcbiAqIGV2ZW50IGZvciB0aGUgbGFzdCAxMDAgb3JkZXJlZCBtZXNzYWdlcy4gQXMgaXRlbXMgY2hhbmdlLCB3ZSB3aWxsIHJlY2VpdmVcclxuICogYGNoaWxkX3JlbW92ZWRgIGV2ZW50cyBmb3IgZWFjaCBpdGVtIHRoYXQgZHJvcHMgb3V0IG9mIHRoZSBhY3RpdmUgbGlzdCBzb1xyXG4gKiB0aGF0IHRoZSB0b3RhbCBudW1iZXIgc3RheXMgYXQgMTAwLlxyXG4gKlxyXG4gKiBZb3UgY2FuIHJlYWQgbW9yZSBhYm91dCBgbGltaXRUb0xhc3QoKWAgaW5cclxuICoge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2RhdGFiYXNlL3dlYi9saXN0cy1vZi1kYXRhI2ZpbHRlcmluZ19kYXRhIHwgRmlsdGVyaW5nIGRhdGF9LlxyXG4gKlxyXG4gKiBAcGFyYW0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygbm9kZXMgdG8gaW5jbHVkZSBpbiB0aGlzIHF1ZXJ5LlxyXG4gKi9cclxuZnVuY3Rpb24gbGltaXRUb0xhc3QobGltaXQpIHtcclxuICAgIGlmICh0eXBlb2YgbGltaXQgIT09ICdudW1iZXInIHx8IE1hdGguZmxvb3IobGltaXQpICE9PSBsaW1pdCB8fCBsaW1pdCA8PSAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsaW1pdFRvTGFzdDogRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIuJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5TGltaXRUb0xhc3RDb25zdHJhaW50KGxpbWl0KTtcclxufVxyXG5jbGFzcyBRdWVyeU9yZGVyQnlDaGlsZENvbnN0cmFpbnQgZXh0ZW5kcyBRdWVyeUNvbnN0cmFpbnQge1xyXG4gICAgY29uc3RydWN0b3IoX3BhdGgpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX3BhdGggPSBfcGF0aDtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnb3JkZXJCeUNoaWxkJztcclxuICAgIH1cclxuICAgIF9hcHBseShxdWVyeSkge1xyXG4gICAgICAgIHZhbGlkYXRlTm9QcmV2aW91c09yZGVyQnlDYWxsKHF1ZXJ5LCAnb3JkZXJCeUNoaWxkJyk7XHJcbiAgICAgICAgY29uc3QgcGFyc2VkUGF0aCA9IG5ldyBQYXRoKHRoaXMuX3BhdGgpO1xyXG4gICAgICAgIGlmIChwYXRoSXNFbXB0eShwYXJzZWRQYXRoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29yZGVyQnlDaGlsZDogY2Fubm90IHBhc3MgaW4gZW1wdHkgcGF0aC4gVXNlIG9yZGVyQnlWYWx1ZSgpIGluc3RlYWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gbmV3IFBhdGhJbmRleChwYXJzZWRQYXRoKTtcclxuICAgICAgICBjb25zdCBuZXdQYXJhbXMgPSBxdWVyeVBhcmFtc09yZGVyQnkocXVlcnkuX3F1ZXJ5UGFyYW1zLCBpbmRleCk7XHJcbiAgICAgICAgdmFsaWRhdGVRdWVyeUVuZHBvaW50cyhuZXdQYXJhbXMpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHF1ZXJ5Ll9yZXBvLCBxdWVyeS5fcGF0aCwgbmV3UGFyYW1zLCBcclxuICAgICAgICAvKm9yZGVyQnlDYWxsZWQ9Ki8gdHJ1ZSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgYFF1ZXJ5Q29uc3RyYWludGAgdGhhdCBvcmRlcnMgYnkgdGhlIHNwZWNpZmllZCBjaGlsZCBrZXkuXHJcbiAqXHJcbiAqIFF1ZXJpZXMgY2FuIG9ubHkgb3JkZXIgYnkgb25lIGtleSBhdCBhIHRpbWUuIENhbGxpbmcgYG9yZGVyQnlDaGlsZCgpYFxyXG4gKiBtdWx0aXBsZSB0aW1lcyBvbiB0aGUgc2FtZSBxdWVyeSBpcyBhbiBlcnJvci5cclxuICpcclxuICogRmlyZWJhc2UgcXVlcmllcyBhbGxvdyB5b3UgdG8gb3JkZXIgeW91ciBkYXRhIGJ5IGFueSBjaGlsZCBrZXkgb24gdGhlIGZseS5cclxuICogSG93ZXZlciwgaWYgeW91IGtub3cgaW4gYWR2YW5jZSB3aGF0IHlvdXIgaW5kZXhlcyB3aWxsIGJlLCB5b3UgY2FuIGRlZmluZVxyXG4gKiB0aGVtIHZpYSB0aGUgLmluZGV4T24gcnVsZSBpbiB5b3VyIFNlY3VyaXR5IFJ1bGVzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuIFNlZVxyXG4gKiB0aGV7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZGF0YWJhc2Uvc2VjdXJpdHkvaW5kZXhpbmctZGF0YX1cclxuICogcnVsZSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuICpcclxuICogWW91IGNhbiByZWFkIG1vcmUgYWJvdXQgYG9yZGVyQnlDaGlsZCgpYCBpblxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZGF0YWJhc2Uvd2ViL2xpc3RzLW9mLWRhdGEjc29ydF9kYXRhIHwgU29ydCBkYXRhfS5cclxuICpcclxuICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byBvcmRlciBieS5cclxuICovXHJcbmZ1bmN0aW9uIG9yZGVyQnlDaGlsZChwYXRoKSB7XHJcbiAgICBpZiAocGF0aCA9PT0gJyRrZXknKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcmRlckJ5Q2hpbGQ6IFwiJGtleVwiIGlzIGludmFsaWQuICBVc2Ugb3JkZXJCeUtleSgpIGluc3RlYWQuJyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwYXRoID09PSAnJHByaW9yaXR5Jykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3JkZXJCeUNoaWxkOiBcIiRwcmlvcml0eVwiIGlzIGludmFsaWQuICBVc2Ugb3JkZXJCeVByaW9yaXR5KCkgaW5zdGVhZC4nKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHBhdGggPT09ICckdmFsdWUnKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcmRlckJ5Q2hpbGQ6IFwiJHZhbHVlXCIgaXMgaW52YWxpZC4gIFVzZSBvcmRlckJ5VmFsdWUoKSBpbnN0ZWFkLicpO1xyXG4gICAgfVxyXG4gICAgdmFsaWRhdGVQYXRoU3RyaW5nKCdvcmRlckJ5Q2hpbGQnLCAncGF0aCcsIHBhdGgsIGZhbHNlKTtcclxuICAgIHJldHVybiBuZXcgUXVlcnlPcmRlckJ5Q2hpbGRDb25zdHJhaW50KHBhdGgpO1xyXG59XHJcbmNsYXNzIFF1ZXJ5T3JkZXJCeUtleUNvbnN0cmFpbnQgZXh0ZW5kcyBRdWVyeUNvbnN0cmFpbnQge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnb3JkZXJCeUtleSc7XHJcbiAgICB9XHJcbiAgICBfYXBwbHkocXVlcnkpIHtcclxuICAgICAgICB2YWxpZGF0ZU5vUHJldmlvdXNPcmRlckJ5Q2FsbChxdWVyeSwgJ29yZGVyQnlLZXknKTtcclxuICAgICAgICBjb25zdCBuZXdQYXJhbXMgPSBxdWVyeVBhcmFtc09yZGVyQnkocXVlcnkuX3F1ZXJ5UGFyYW1zLCBLRVlfSU5ERVgpO1xyXG4gICAgICAgIHZhbGlkYXRlUXVlcnlFbmRwb2ludHMobmV3UGFyYW1zKTtcclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgsIG5ld1BhcmFtcywgXHJcbiAgICAgICAgLypvcmRlckJ5Q2FsbGVkPSovIHRydWUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGBRdWVyeUNvbnN0cmFpbnRgIHRoYXQgb3JkZXJzIGJ5IHRoZSBrZXkuXHJcbiAqXHJcbiAqIFNvcnRzIHRoZSByZXN1bHRzIG9mIGEgcXVlcnkgYnkgdGhlaXIgKGFzY2VuZGluZykga2V5IHZhbHVlcy5cclxuICpcclxuICogWW91IGNhbiByZWFkIG1vcmUgYWJvdXQgYG9yZGVyQnlLZXkoKWAgaW5cclxuICoge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2RhdGFiYXNlL3dlYi9saXN0cy1vZi1kYXRhI3NvcnRfZGF0YSB8IFNvcnQgZGF0YX0uXHJcbiAqL1xyXG5mdW5jdGlvbiBvcmRlckJ5S2V5KCkge1xyXG4gICAgcmV0dXJuIG5ldyBRdWVyeU9yZGVyQnlLZXlDb25zdHJhaW50KCk7XHJcbn1cclxuY2xhc3MgUXVlcnlPcmRlckJ5UHJpb3JpdHlDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ29yZGVyQnlQcmlvcml0eSc7XHJcbiAgICB9XHJcbiAgICBfYXBwbHkocXVlcnkpIHtcclxuICAgICAgICB2YWxpZGF0ZU5vUHJldmlvdXNPcmRlckJ5Q2FsbChxdWVyeSwgJ29yZGVyQnlQcmlvcml0eScpO1xyXG4gICAgICAgIGNvbnN0IG5ld1BhcmFtcyA9IHF1ZXJ5UGFyYW1zT3JkZXJCeShxdWVyeS5fcXVlcnlQYXJhbXMsIFBSSU9SSVRZX0lOREVYKTtcclxuICAgICAgICB2YWxpZGF0ZVF1ZXJ5RW5kcG9pbnRzKG5ld1BhcmFtcyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocXVlcnkuX3JlcG8sIHF1ZXJ5Ll9wYXRoLCBuZXdQYXJhbXMsIFxyXG4gICAgICAgIC8qb3JkZXJCeUNhbGxlZD0qLyB0cnVlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBgUXVlcnlDb25zdHJhaW50YCB0aGF0IG9yZGVycyBieSBwcmlvcml0eS5cclxuICpcclxuICogQXBwbGljYXRpb25zIG5lZWQgbm90IHVzZSBwcmlvcml0eSBidXQgY2FuIG9yZGVyIGNvbGxlY3Rpb25zIGJ5XHJcbiAqIG9yZGluYXJ5IHByb3BlcnRpZXMgKHNlZVxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZGF0YWJhc2Uvd2ViL2xpc3RzLW9mLWRhdGEjc29ydF9kYXRhIHwgU29ydCBkYXRhfVxyXG4gKiBmb3IgYWx0ZXJuYXRpdmVzIHRvIHByaW9yaXR5LlxyXG4gKi9cclxuZnVuY3Rpb24gb3JkZXJCeVByaW9yaXR5KCkge1xyXG4gICAgcmV0dXJuIG5ldyBRdWVyeU9yZGVyQnlQcmlvcml0eUNvbnN0cmFpbnQoKTtcclxufVxyXG5jbGFzcyBRdWVyeU9yZGVyQnlWYWx1ZUNvbnN0cmFpbnQgZXh0ZW5kcyBRdWVyeUNvbnN0cmFpbnQge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnb3JkZXJCeVZhbHVlJztcclxuICAgIH1cclxuICAgIF9hcHBseShxdWVyeSkge1xyXG4gICAgICAgIHZhbGlkYXRlTm9QcmV2aW91c09yZGVyQnlDYWxsKHF1ZXJ5LCAnb3JkZXJCeVZhbHVlJyk7XHJcbiAgICAgICAgY29uc3QgbmV3UGFyYW1zID0gcXVlcnlQYXJhbXNPcmRlckJ5KHF1ZXJ5Ll9xdWVyeVBhcmFtcywgVkFMVUVfSU5ERVgpO1xyXG4gICAgICAgIHZhbGlkYXRlUXVlcnlFbmRwb2ludHMobmV3UGFyYW1zKTtcclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgsIG5ld1BhcmFtcywgXHJcbiAgICAgICAgLypvcmRlckJ5Q2FsbGVkPSovIHRydWUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGBRdWVyeUNvbnN0cmFpbnRgIHRoYXQgb3JkZXJzIGJ5IHZhbHVlLlxyXG4gKlxyXG4gKiBJZiB0aGUgY2hpbGRyZW4gb2YgYSBxdWVyeSBhcmUgYWxsIHNjYWxhciB2YWx1ZXMgKHN0cmluZywgbnVtYmVyLCBvclxyXG4gKiBib29sZWFuKSwgeW91IGNhbiBvcmRlciB0aGUgcmVzdWx0cyBieSB0aGVpciAoYXNjZW5kaW5nKSB2YWx1ZXMuXHJcbiAqXHJcbiAqIFlvdSBjYW4gcmVhZCBtb3JlIGFib3V0IGBvcmRlckJ5VmFsdWUoKWAgaW5cclxuICoge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2RhdGFiYXNlL3dlYi9saXN0cy1vZi1kYXRhI3NvcnRfZGF0YSB8IFNvcnQgZGF0YX0uXHJcbiAqL1xyXG5mdW5jdGlvbiBvcmRlckJ5VmFsdWUoKSB7XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5T3JkZXJCeVZhbHVlQ29uc3RyYWludCgpO1xyXG59XHJcbmNsYXNzIFF1ZXJ5RXF1YWxUb1ZhbHVlQ29uc3RyYWludCBleHRlbmRzIFF1ZXJ5Q29uc3RyYWludCB7XHJcbiAgICBjb25zdHJ1Y3RvcihfdmFsdWUsIF9rZXkpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gX3ZhbHVlO1xyXG4gICAgICAgIHRoaXMuX2tleSA9IF9rZXk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ2VxdWFsVG8nO1xyXG4gICAgfVxyXG4gICAgX2FwcGx5KHF1ZXJ5KSB7XHJcbiAgICAgICAgdmFsaWRhdGVGaXJlYmFzZURhdGFBcmcoJ2VxdWFsVG8nLCB0aGlzLl92YWx1ZSwgcXVlcnkuX3BhdGgsIGZhbHNlKTtcclxuICAgICAgICBpZiAocXVlcnkuX3F1ZXJ5UGFyYW1zLmhhc1N0YXJ0KCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlcXVhbFRvOiBTdGFydGluZyBwb2ludCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBzdGFydEF0L3N0YXJ0QWZ0ZXIgb3IgJyArXHJcbiAgICAgICAgICAgICAgICAnZXF1YWxUbykuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChxdWVyeS5fcXVlcnlQYXJhbXMuaGFzRW5kKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlcXVhbFRvOiBFbmRpbmcgcG9pbnQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gZW5kQXQvZW5kQmVmb3JlIG9yICcgK1xyXG4gICAgICAgICAgICAgICAgJ2VxdWFsVG8pLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5RW5kQXRDb25zdHJhaW50KHRoaXMuX3ZhbHVlLCB0aGlzLl9rZXkpLl9hcHBseShuZXcgUXVlcnlTdGFydEF0Q29uc3RyYWludCh0aGlzLl92YWx1ZSwgdGhpcy5fa2V5KS5fYXBwbHkocXVlcnkpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIGBRdWVyeUNvbnN0cmFpbnRgIHRoYXQgaW5jbHVkZXMgY2hpbGRyZW4gdGhhdCBtYXRjaCB0aGUgc3BlY2lmaWVkXHJcbiAqIHZhbHVlLlxyXG4gKlxyXG4gKiBVc2luZyBgc3RhcnRBdCgpYCwgYHN0YXJ0QWZ0ZXIoKWAsIGBlbmRCZWZvcmUoKWAsIGBlbmRBdCgpYCBhbmQgYGVxdWFsVG8oKWBcclxuICogYWxsb3dzIHlvdSB0byBjaG9vc2UgYXJiaXRyYXJ5IHN0YXJ0aW5nIGFuZCBlbmRpbmcgcG9pbnRzIGZvciB5b3VyIHF1ZXJpZXMuXHJcbiAqXHJcbiAqIFRoZSBvcHRpb25hbCBrZXkgYXJndW1lbnQgY2FuIGJlIHVzZWQgdG8gZnVydGhlciBsaW1pdCB0aGUgcmFuZ2Ugb2YgdGhlXHJcbiAqIHF1ZXJ5LiBJZiBpdCBpcyBzcGVjaWZpZWQsIHRoZW4gY2hpbGRyZW4gdGhhdCBoYXZlIGV4YWN0bHkgdGhlIHNwZWNpZmllZFxyXG4gKiB2YWx1ZSBtdXN0IGFsc28gaGF2ZSBleGFjdGx5IHRoZSBzcGVjaWZpZWQga2V5IGFzIHRoZWlyIGtleSBuYW1lLiBUaGlzIGNhbiBiZVxyXG4gKiB1c2VkIHRvIGZpbHRlciByZXN1bHQgc2V0cyB3aXRoIG1hbnkgbWF0Y2hlcyBmb3IgdGhlIHNhbWUgdmFsdWUuXHJcbiAqXHJcbiAqIFlvdSBjYW4gcmVhZCBtb3JlIGFib3V0IGBlcXVhbFRvKClgIGluXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvbGlzdHMtb2YtZGF0YSNmaWx0ZXJpbmdfZGF0YSB8IEZpbHRlcmluZyBkYXRhfS5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIG1hdGNoIGZvci4gVGhlIGFyZ3VtZW50IHR5cGUgZGVwZW5kcyBvbiB3aGljaFxyXG4gKiBgb3JkZXJCeSooKWAgZnVuY3Rpb24gd2FzIHVzZWQgaW4gdGhpcyBxdWVyeS4gU3BlY2lmeSBhIHZhbHVlIHRoYXQgbWF0Y2hlc1xyXG4gKiB0aGUgYG9yZGVyQnkqKClgIHR5cGUuIFdoZW4gdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIGBvcmRlckJ5S2V5KClgLCB0aGVcclxuICogdmFsdWUgbXVzdCBiZSBhIHN0cmluZy5cclxuICogQHBhcmFtIGtleSAtIFRoZSBjaGlsZCBrZXkgdG8gc3RhcnQgYXQsIGFtb25nIHRoZSBjaGlsZHJlbiB3aXRoIHRoZVxyXG4gKiBwcmV2aW91c2x5IHNwZWNpZmllZCBwcmlvcml0eS4gVGhpcyBhcmd1bWVudCBpcyBvbmx5IGFsbG93ZWQgaWYgb3JkZXJpbmcgYnlcclxuICogY2hpbGQsIHZhbHVlLCBvciBwcmlvcml0eS5cclxuICovXHJcbmZ1bmN0aW9uIGVxdWFsVG8odmFsdWUsIGtleSkge1xyXG4gICAgdmFsaWRhdGVLZXkoJ2VxdWFsVG8nLCAna2V5Jywga2V5LCB0cnVlKTtcclxuICAgIHJldHVybiBuZXcgUXVlcnlFcXVhbFRvVmFsdWVDb25zdHJhaW50KHZhbHVlLCBrZXkpO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGltbXV0YWJsZSBpbnN0YW5jZSBvZiBgUXVlcnlgIHRoYXQgaXMgZXh0ZW5kZWQgdG8gYWxzbyBpbmNsdWRlXHJcbiAqIGFkZGl0aW9uYWwgcXVlcnkgY29uc3RyYWludHMuXHJcbiAqXHJcbiAqIEBwYXJhbSBxdWVyeSAtIFRoZSBRdWVyeSBpbnN0YW5jZSB0byB1c2UgYXMgYSBiYXNlIGZvciB0aGUgbmV3IGNvbnN0cmFpbnRzLlxyXG4gKiBAcGFyYW0gcXVlcnlDb25zdHJhaW50cyAtIFRoZSBsaXN0IG9mIGBRdWVyeUNvbnN0cmFpbnRgcyB0byBhcHBseS5cclxuICogQHRocm93cyBpZiBhbnkgb2YgdGhlIHByb3ZpZGVkIHF1ZXJ5IGNvbnN0cmFpbnRzIGNhbm5vdCBiZSBjb21iaW5lZCB3aXRoIHRoZVxyXG4gKiBleGlzdGluZyBvciBuZXcgY29uc3RyYWludHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBxdWVyeShxdWVyeSwgLi4ucXVlcnlDb25zdHJhaW50cykge1xyXG4gICAgbGV0IHF1ZXJ5SW1wbCA9IGdldE1vZHVsYXJJbnN0YW5jZShxdWVyeSk7XHJcbiAgICBmb3IgKGNvbnN0IGNvbnN0cmFpbnQgb2YgcXVlcnlDb25zdHJhaW50cykge1xyXG4gICAgICAgIHF1ZXJ5SW1wbCA9IGNvbnN0cmFpbnQuX2FwcGx5KHF1ZXJ5SW1wbCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcXVlcnlJbXBsO1xyXG59XHJcbi8qKlxyXG4gKiBEZWZpbmUgcmVmZXJlbmNlIGNvbnN0cnVjdG9yIGluIHZhcmlvdXMgbW9kdWxlc1xyXG4gKlxyXG4gKiBXZSBhcmUgZG9pbmcgdGhpcyBoZXJlIHRvIGF2b2lkIHNldmVyYWwgY2lyY3VsYXJcclxuICogZGVwZW5kZW5jeSBpc3N1ZXNcclxuICovXHJcbnN5bmNQb2ludFNldFJlZmVyZW5jZUNvbnN0cnVjdG9yKFJlZmVyZW5jZUltcGwpO1xyXG5zeW5jVHJlZVNldFJlZmVyZW5jZUNvbnN0cnVjdG9yKFJlZmVyZW5jZUltcGwpO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhpcyB2YXJpYWJsZSBpcyBhbHNvIGRlZmluZWQgaW4gdGhlIGZpcmViYXNlIE5vZGUuanMgQWRtaW4gU0RLLiBCZWZvcmVcclxuICogbW9kaWZ5aW5nIHRoaXMgZGVmaW5pdGlvbiwgY29uc3VsdCB0aGUgZGVmaW5pdGlvbiBpbjpcclxuICpcclxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZpcmViYXNlL2ZpcmViYXNlLWFkbWluLW5vZGVcclxuICpcclxuICogYW5kIG1ha2Ugc3VyZSB0aGUgdHdvIGFyZSBjb25zaXN0ZW50LlxyXG4gKi9cclxuY29uc3QgRklSRUJBU0VfREFUQUJBU0VfRU1VTEFUT1JfSE9TVF9WQVIgPSAnRklSRUJBU0VfREFUQUJBU0VfRU1VTEFUT1JfSE9TVCc7XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFuZCBjYWNoZXMgYFJlcG9gIGluc3RhbmNlcy5cclxuICovXHJcbmNvbnN0IHJlcG9zID0ge307XHJcbi8qKlxyXG4gKiBJZiB0cnVlLCBhbnkgbmV3IGBSZXBvYCB3aWxsIGJlIGNyZWF0ZWQgdG8gdXNlIGBSZWFkb25seVJlc3RDbGllbnRgIChmb3IgdGVzdGluZyBwdXJwb3NlcykuXHJcbiAqL1xyXG5sZXQgdXNlUmVzdENsaWVudCA9IGZhbHNlO1xyXG4vKipcclxuICogVXBkYXRlIGFuIGV4aXN0aW5nIGBSZXBvYCBpbiBwbGFjZSB0byBwb2ludCB0byBhIG5ldyBob3N0L3BvcnQuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvTWFuYWdlckFwcGx5RW11bGF0b3JTZXR0aW5ncyhyZXBvLCBob3N0LCBwb3J0LCB0b2tlblByb3ZpZGVyKSB7XHJcbiAgICByZXBvLnJlcG9JbmZvXyA9IG5ldyBSZXBvSW5mbyhgJHtob3N0fToke3BvcnR9YCwgXHJcbiAgICAvKiBzZWN1cmU9ICovIGZhbHNlLCByZXBvLnJlcG9JbmZvXy5uYW1lc3BhY2UsIHJlcG8ucmVwb0luZm9fLndlYlNvY2tldE9ubHksIHJlcG8ucmVwb0luZm9fLm5vZGVBZG1pbiwgcmVwby5yZXBvSW5mb18ucGVyc2lzdGVuY2VLZXksIHJlcG8ucmVwb0luZm9fLmluY2x1ZGVOYW1lc3BhY2VJblF1ZXJ5UGFyYW1zLCBcclxuICAgIC8qaXNVc2luZ0VtdWxhdG9yPSovIHRydWUpO1xyXG4gICAgaWYgKHRva2VuUHJvdmlkZXIpIHtcclxuICAgICAgICByZXBvLmF1dGhUb2tlblByb3ZpZGVyXyA9IHRva2VuUHJvdmlkZXI7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgZXZlciBiZSBjYWxsZWQgdG8gQ1JFQVRFIGEgbmV3IGRhdGFiYXNlIGluc3RhbmNlLlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIHJlcG9NYW5hZ2VyRGF0YWJhc2VGcm9tQXBwKGFwcCwgYXV0aFByb3ZpZGVyLCBhcHBDaGVja1Byb3ZpZGVyLCB1cmwsIG5vZGVBZG1pbikge1xyXG4gICAgbGV0IGRiVXJsID0gdXJsIHx8IGFwcC5vcHRpb25zLmRhdGFiYXNlVVJMO1xyXG4gICAgaWYgKGRiVXJsID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBpZiAoIWFwcC5vcHRpb25zLnByb2plY3RJZCkge1xyXG4gICAgICAgICAgICBmYXRhbChcIkNhbid0IGRldGVybWluZSBGaXJlYmFzZSBEYXRhYmFzZSBVUkwuIEJlIHN1cmUgdG8gaW5jbHVkZSBcIiArXHJcbiAgICAgICAgICAgICAgICAnIGEgUHJvamVjdCBJRCB3aGVuIGNhbGxpbmcgZmlyZWJhc2UuaW5pdGlhbGl6ZUFwcCgpLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsb2coJ1VzaW5nIGRlZmF1bHQgaG9zdCBmb3IgcHJvamVjdCAnLCBhcHAub3B0aW9ucy5wcm9qZWN0SWQpO1xyXG4gICAgICAgIGRiVXJsID0gYCR7YXBwLm9wdGlvbnMucHJvamVjdElkfS1kZWZhdWx0LXJ0ZGIuZmlyZWJhc2Vpby5jb21gO1xyXG4gICAgfVxyXG4gICAgbGV0IHBhcnNlZFVybCA9IHBhcnNlUmVwb0luZm8oZGJVcmwsIG5vZGVBZG1pbik7XHJcbiAgICBsZXQgcmVwb0luZm8gPSBwYXJzZWRVcmwucmVwb0luZm87XHJcbiAgICBsZXQgaXNFbXVsYXRvcjtcclxuICAgIGxldCBkYkVtdWxhdG9ySG9zdCA9IHVuZGVmaW5lZDtcclxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYpIHtcclxuICAgICAgICBkYkVtdWxhdG9ySG9zdCA9IHByb2Nlc3MuZW52W0ZJUkVCQVNFX0RBVEFCQVNFX0VNVUxBVE9SX0hPU1RfVkFSXTtcclxuICAgIH1cclxuICAgIGlmIChkYkVtdWxhdG9ySG9zdCkge1xyXG4gICAgICAgIGlzRW11bGF0b3IgPSB0cnVlO1xyXG4gICAgICAgIGRiVXJsID0gYGh0dHA6Ly8ke2RiRW11bGF0b3JIb3N0fT9ucz0ke3JlcG9JbmZvLm5hbWVzcGFjZX1gO1xyXG4gICAgICAgIHBhcnNlZFVybCA9IHBhcnNlUmVwb0luZm8oZGJVcmwsIG5vZGVBZG1pbik7XHJcbiAgICAgICAgcmVwb0luZm8gPSBwYXJzZWRVcmwucmVwb0luZm87XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpc0VtdWxhdG9yID0gIXBhcnNlZFVybC5yZXBvSW5mby5zZWN1cmU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhdXRoVG9rZW5Qcm92aWRlciA9IG5vZGVBZG1pbiAmJiBpc0VtdWxhdG9yXHJcbiAgICAgICAgPyBuZXcgRW11bGF0b3JUb2tlblByb3ZpZGVyKEVtdWxhdG9yVG9rZW5Qcm92aWRlci5PV05FUilcclxuICAgICAgICA6IG5ldyBGaXJlYmFzZUF1dGhUb2tlblByb3ZpZGVyKGFwcC5uYW1lLCBhcHAub3B0aW9ucywgYXV0aFByb3ZpZGVyKTtcclxuICAgIHZhbGlkYXRlVXJsKCdJbnZhbGlkIEZpcmViYXNlIERhdGFiYXNlIFVSTCcsIHBhcnNlZFVybCk7XHJcbiAgICBpZiAoIXBhdGhJc0VtcHR5KHBhcnNlZFVybC5wYXRoKSkge1xyXG4gICAgICAgIGZhdGFsKCdEYXRhYmFzZSBVUkwgbXVzdCBwb2ludCB0byB0aGUgcm9vdCBvZiBhIEZpcmViYXNlIERhdGFiYXNlICcgK1xyXG4gICAgICAgICAgICAnKG5vdCBpbmNsdWRpbmcgYSBjaGlsZCBwYXRoKS4nKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHJlcG8gPSByZXBvTWFuYWdlckNyZWF0ZVJlcG8ocmVwb0luZm8sIGFwcCwgYXV0aFRva2VuUHJvdmlkZXIsIG5ldyBBcHBDaGVja1Rva2VuUHJvdmlkZXIoYXBwLm5hbWUsIGFwcENoZWNrUHJvdmlkZXIpKTtcclxuICAgIHJldHVybiBuZXcgRGF0YWJhc2UocmVwbywgYXBwKTtcclxufVxyXG4vKipcclxuICogUmVtb3ZlIHRoZSByZXBvIGFuZCBtYWtlIHN1cmUgaXQgaXMgZGlzY29ubmVjdGVkLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb01hbmFnZXJEZWxldGVSZXBvKHJlcG8sIGFwcE5hbWUpIHtcclxuICAgIGNvbnN0IGFwcFJlcG9zID0gcmVwb3NbYXBwTmFtZV07XHJcbiAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4uLi5cclxuICAgIGlmICghYXBwUmVwb3MgfHwgYXBwUmVwb3NbcmVwby5rZXldICE9PSByZXBvKSB7XHJcbiAgICAgICAgZmF0YWwoYERhdGFiYXNlICR7YXBwTmFtZX0oJHtyZXBvLnJlcG9JbmZvX30pIGhhcyBhbHJlYWR5IGJlZW4gZGVsZXRlZC5gKTtcclxuICAgIH1cclxuICAgIHJlcG9JbnRlcnJ1cHQocmVwbyk7XHJcbiAgICBkZWxldGUgYXBwUmVwb3NbcmVwby5rZXldO1xyXG59XHJcbi8qKlxyXG4gKiBFbnN1cmVzIGEgcmVwbyBkb2Vzbid0IGFscmVhZHkgZXhpc3QgYW5kIHRoZW4gY3JlYXRlcyBvbmUgdXNpbmcgdGhlXHJcbiAqIHByb3ZpZGVkIGFwcC5cclxuICpcclxuICogQHBhcmFtIHJlcG9JbmZvIC0gVGhlIG1ldGFkYXRhIGFib3V0IHRoZSBSZXBvXHJcbiAqIEByZXR1cm5zIFRoZSBSZXBvIG9iamVjdCBmb3IgdGhlIHNwZWNpZmllZCBzZXJ2ZXIgLyByZXBvTmFtZS5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9NYW5hZ2VyQ3JlYXRlUmVwbyhyZXBvSW5mbywgYXBwLCBhdXRoVG9rZW5Qcm92aWRlciwgYXBwQ2hlY2tQcm92aWRlcikge1xyXG4gICAgbGV0IGFwcFJlcG9zID0gcmVwb3NbYXBwLm5hbWVdO1xyXG4gICAgaWYgKCFhcHBSZXBvcykge1xyXG4gICAgICAgIGFwcFJlcG9zID0ge307XHJcbiAgICAgICAgcmVwb3NbYXBwLm5hbWVdID0gYXBwUmVwb3M7XHJcbiAgICB9XHJcbiAgICBsZXQgcmVwbyA9IGFwcFJlcG9zW3JlcG9JbmZvLnRvVVJMU3RyaW5nKCldO1xyXG4gICAgaWYgKHJlcG8pIHtcclxuICAgICAgICBmYXRhbCgnRGF0YWJhc2UgaW5pdGlhbGl6ZWQgbXVsdGlwbGUgdGltZXMuIFBsZWFzZSBtYWtlIHN1cmUgdGhlIGZvcm1hdCBvZiB0aGUgZGF0YWJhc2UgVVJMIG1hdGNoZXMgd2l0aCBlYWNoIGRhdGFiYXNlKCkgY2FsbC4nKTtcclxuICAgIH1cclxuICAgIHJlcG8gPSBuZXcgUmVwbyhyZXBvSW5mbywgdXNlUmVzdENsaWVudCwgYXV0aFRva2VuUHJvdmlkZXIsIGFwcENoZWNrUHJvdmlkZXIpO1xyXG4gICAgYXBwUmVwb3NbcmVwb0luZm8udG9VUkxTdHJpbmcoKV0gPSByZXBvO1xyXG4gICAgcmV0dXJuIHJlcG87XHJcbn1cclxuLyoqXHJcbiAqIEZvcmNlcyB1cyB0byB1c2UgUmVhZG9ubHlSZXN0Q2xpZW50IGluc3RlYWQgb2YgUGVyc2lzdGVudENvbm5lY3Rpb24gZm9yIG5ldyBSZXBvcy5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9NYW5hZ2VyRm9yY2VSZXN0Q2xpZW50KGZvcmNlUmVzdENsaWVudCkge1xyXG4gICAgdXNlUmVzdENsaWVudCA9IGZvcmNlUmVzdENsaWVudDtcclxufVxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgRmlyZWJhc2UgUmVhbHRpbWUgRGF0YWJhc2UuXHJcbiAqL1xyXG5jbGFzcyBEYXRhYmFzZSB7XHJcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xyXG4gICAgY29uc3RydWN0b3IoX3JlcG9JbnRlcm5hbCwgXHJcbiAgICAvKiogVGhlIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlQXBwfSBhc3NvY2lhdGVkIHdpdGggdGhpcyBSZWFsdGltZSBEYXRhYmFzZSBpbnN0YW5jZS4gKi9cclxuICAgIGFwcCkge1xyXG4gICAgICAgIHRoaXMuX3JlcG9JbnRlcm5hbCA9IF9yZXBvSW50ZXJuYWw7XHJcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XHJcbiAgICAgICAgLyoqIFJlcHJlc2VudHMgYSBgRGF0YWJhc2VgIGluc3RhbmNlLiAqL1xyXG4gICAgICAgIHRoaXNbJ3R5cGUnXSA9ICdkYXRhYmFzZSc7XHJcbiAgICAgICAgLyoqIFRyYWNrIGlmIHRoZSBpbnN0YW5jZSBoYXMgYmVlbiB1c2VkIChyb290IG9yIHJlcG8gYWNjZXNzZWQpICovXHJcbiAgICAgICAgdGhpcy5faW5zdGFuY2VTdGFydGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBnZXQgX3JlcG8oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pbnN0YW5jZVN0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgcmVwb1N0YXJ0KHRoaXMuX3JlcG9JbnRlcm5hbCwgdGhpcy5hcHAub3B0aW9ucy5hcHBJZCwgdGhpcy5hcHAub3B0aW9uc1snZGF0YWJhc2VBdXRoVmFyaWFibGVPdmVycmlkZSddKTtcclxuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2VTdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlcG9JbnRlcm5hbDtcclxuICAgIH1cclxuICAgIGdldCBfcm9vdCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3Jvb3RJbnRlcm5hbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yb290SW50ZXJuYWwgPSBuZXcgUmVmZXJlbmNlSW1wbCh0aGlzLl9yZXBvLCBuZXdFbXB0eVBhdGgoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9yb290SW50ZXJuYWw7XHJcbiAgICB9XHJcbiAgICBfZGVsZXRlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9yb290SW50ZXJuYWwgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmVwb01hbmFnZXJEZWxldGVSZXBvKHRoaXMuX3JlcG8sIHRoaXMuYXBwLm5hbWUpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZXBvSW50ZXJuYWwgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9yb290SW50ZXJuYWwgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICBfY2hlY2tOb3REZWxldGVkKGFwaU5hbWUpIHtcclxuICAgICAgICBpZiAodGhpcy5fcm9vdEludGVybmFsID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGZhdGFsKCdDYW5ub3QgY2FsbCAnICsgYXBpTmFtZSArICcgb24gYSBkZWxldGVkIGRhdGFiYXNlLicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjaGVja1RyYW5zcG9ydEluaXQoKSB7XHJcbiAgICBpZiAoVHJhbnNwb3J0TWFuYWdlci5JU19UUkFOU1BPUlRfSU5JVElBTElaRUQpIHtcclxuICAgICAgICB3YXJuKCdUcmFuc3BvcnQgaGFzIGFscmVhZHkgYmVlbiBpbml0aWFsaXplZC4gUGxlYXNlIGNhbGwgdGhpcyBmdW5jdGlvbiBiZWZvcmUgY2FsbGluZyByZWYgb3Igc2V0dGluZyB1cCBhIGxpc3RlbmVyJyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEZvcmNlIHRoZSB1c2Ugb2Ygd2Vic29ja2V0cyBpbnN0ZWFkIG9mIGxvbmdQb2xsaW5nLlxyXG4gKi9cclxuZnVuY3Rpb24gZm9yY2VXZWJTb2NrZXRzKCkge1xyXG4gICAgY2hlY2tUcmFuc3BvcnRJbml0KCk7XHJcbiAgICBCcm93c2VyUG9sbENvbm5lY3Rpb24uZm9yY2VEaXNhbGxvdygpO1xyXG59XHJcbi8qKlxyXG4gKiBGb3JjZSB0aGUgdXNlIG9mIGxvbmdQb2xsaW5nIGluc3RlYWQgb2Ygd2Vic29ja2V0cy4gVGhpcyB3aWxsIGJlIGlnbm9yZWQgaWYgd2Vic29ja2V0IHByb3RvY29sIGlzIHVzZWQgaW4gZGF0YWJhc2VVUkwuXHJcbiAqL1xyXG5mdW5jdGlvbiBmb3JjZUxvbmdQb2xsaW5nKCkge1xyXG4gICAgY2hlY2tUcmFuc3BvcnRJbml0KCk7XHJcbiAgICBXZWJTb2NrZXRDb25uZWN0aW9uLmZvcmNlRGlzYWxsb3coKTtcclxuICAgIEJyb3dzZXJQb2xsQ29ubmVjdGlvbi5mb3JjZUFsbG93KCk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIHRoZSBSZWFsdGltZSBEYXRhYmFzZSBTREsgdGhhdCBpcyBhc3NvY2lhdGVkXHJcbiAqIHdpdGggdGhlIHByb3ZpZGVkIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlQXBwfS4gSW5pdGlhbGl6ZXMgYSBuZXcgaW5zdGFuY2Ugd2l0aFxyXG4gKiB3aXRoIGRlZmF1bHQgc2V0dGluZ3MgaWYgbm8gaW5zdGFuY2UgZXhpc3RzIG9yIGlmIHRoZSBleGlzdGluZyBpbnN0YW5jZSB1c2VzXHJcbiAqIGEgY3VzdG9tIGRhdGFiYXNlIFVSTC5cclxuICpcclxuICogQHBhcmFtIGFwcCAtIFRoZSB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZUFwcH0gaW5zdGFuY2UgdGhhdCB0aGUgcmV0dXJuZWQgUmVhbHRpbWVcclxuICogRGF0YWJhc2UgaW5zdGFuY2UgaXMgYXNzb2NpYXRlZCB3aXRoLlxyXG4gKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCBvZiB0aGUgUmVhbHRpbWUgRGF0YWJhc2UgaW5zdGFuY2UgdG8gY29ubmVjdCB0by4gSWYgbm90XHJcbiAqIHByb3ZpZGVkLCB0aGUgU0RLIGNvbm5lY3RzIHRvIHRoZSBkZWZhdWx0IGluc3RhbmNlIG9mIHRoZSBGaXJlYmFzZSBBcHAuXHJcbiAqIEByZXR1cm5zIFRoZSBgRGF0YWJhc2VgIGluc3RhbmNlIG9mIHRoZSBwcm92aWRlZCBhcHAuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXREYXRhYmFzZShhcHAgPSBnZXRBcHAoKSwgdXJsKSB7XHJcbiAgICBjb25zdCBkYiA9IF9nZXRQcm92aWRlcihhcHAsICdkYXRhYmFzZScpLmdldEltbWVkaWF0ZSh7XHJcbiAgICAgICAgaWRlbnRpZmllcjogdXJsXHJcbiAgICB9KTtcclxuICAgIGlmICghZGIuX2luc3RhbmNlU3RhcnRlZCkge1xyXG4gICAgICAgIGNvbnN0IGVtdWxhdG9yID0gZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdG5hbWVBbmRQb3J0KCdkYXRhYmFzZScpO1xyXG4gICAgICAgIGlmIChlbXVsYXRvcikge1xyXG4gICAgICAgICAgICBjb25uZWN0RGF0YWJhc2VFbXVsYXRvcihkYiwgLi4uZW11bGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkYjtcclxufVxyXG4vKipcclxuICogTW9kaWZ5IHRoZSBwcm92aWRlZCBpbnN0YW5jZSB0byBjb21tdW5pY2F0ZSB3aXRoIHRoZSBSZWFsdGltZSBEYXRhYmFzZVxyXG4gKiBlbXVsYXRvci5cclxuICpcclxuICogPHA+Tm90ZTogVGhpcyBtZXRob2QgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIHBlcmZvcm1pbmcgYW55IG90aGVyIG9wZXJhdGlvbi5cclxuICpcclxuICogQHBhcmFtIGRiIC0gVGhlIGluc3RhbmNlIHRvIG1vZGlmeS5cclxuICogQHBhcmFtIGhvc3QgLSBUaGUgZW11bGF0b3IgaG9zdCAoZXg6IGxvY2FsaG9zdClcclxuICogQHBhcmFtIHBvcnQgLSBUaGUgZW11bGF0b3IgcG9ydCAoZXg6IDgwODApXHJcbiAqIEBwYXJhbSBvcHRpb25zLm1vY2tVc2VyVG9rZW4gLSB0aGUgbW9jayBhdXRoIHRva2VuIHRvIHVzZSBmb3IgdW5pdCB0ZXN0aW5nIFNlY3VyaXR5IFJ1bGVzXHJcbiAqL1xyXG5mdW5jdGlvbiBjb25uZWN0RGF0YWJhc2VFbXVsYXRvcihkYiwgaG9zdCwgcG9ydCwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBkYiA9IGdldE1vZHVsYXJJbnN0YW5jZShkYik7XHJcbiAgICBkYi5fY2hlY2tOb3REZWxldGVkKCd1c2VFbXVsYXRvcicpO1xyXG4gICAgaWYgKGRiLl9pbnN0YW5jZVN0YXJ0ZWQpIHtcclxuICAgICAgICBmYXRhbCgnQ2Fubm90IGNhbGwgdXNlRW11bGF0b3IoKSBhZnRlciBpbnN0YW5jZSBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpemVkLicpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVwbyA9IGRiLl9yZXBvSW50ZXJuYWw7XHJcbiAgICBsZXQgdG9rZW5Qcm92aWRlciA9IHVuZGVmaW5lZDtcclxuICAgIGlmIChyZXBvLnJlcG9JbmZvXy5ub2RlQWRtaW4pIHtcclxuICAgICAgICBpZiAob3B0aW9ucy5tb2NrVXNlclRva2VuKSB7XHJcbiAgICAgICAgICAgIGZhdGFsKCdtb2NrVXNlclRva2VuIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIEFkbWluIFNESy4gRm9yIGNsaWVudCBhY2Nlc3Mgd2l0aCBtb2NrIHVzZXJzLCBwbGVhc2UgdXNlIHRoZSBcImZpcmViYXNlXCIgcGFja2FnZSBpbnN0ZWFkIG9mIFwiZmlyZWJhc2UtYWRtaW5cIi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdG9rZW5Qcm92aWRlciA9IG5ldyBFbXVsYXRvclRva2VuUHJvdmlkZXIoRW11bGF0b3JUb2tlblByb3ZpZGVyLk9XTkVSKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG9wdGlvbnMubW9ja1VzZXJUb2tlbikge1xyXG4gICAgICAgIGNvbnN0IHRva2VuID0gdHlwZW9mIG9wdGlvbnMubW9ja1VzZXJUb2tlbiA9PT0gJ3N0cmluZydcclxuICAgICAgICAgICAgPyBvcHRpb25zLm1vY2tVc2VyVG9rZW5cclxuICAgICAgICAgICAgOiBjcmVhdGVNb2NrVXNlclRva2VuKG9wdGlvbnMubW9ja1VzZXJUb2tlbiwgZGIuYXBwLm9wdGlvbnMucHJvamVjdElkKTtcclxuICAgICAgICB0b2tlblByb3ZpZGVyID0gbmV3IEVtdWxhdG9yVG9rZW5Qcm92aWRlcih0b2tlbik7XHJcbiAgICB9XHJcbiAgICAvLyBNb2RpZnkgdGhlIHJlcG8gdG8gYXBwbHkgZW11bGF0b3Igc2V0dGluZ3NcclxuICAgIHJlcG9NYW5hZ2VyQXBwbHlFbXVsYXRvclNldHRpbmdzKHJlcG8sIGhvc3QsIHBvcnQsIHRva2VuUHJvdmlkZXIpO1xyXG59XHJcbi8qKlxyXG4gKiBEaXNjb25uZWN0cyBmcm9tIHRoZSBzZXJ2ZXIgKGFsbCBEYXRhYmFzZSBvcGVyYXRpb25zIHdpbGwgYmUgY29tcGxldGVkXHJcbiAqIG9mZmxpbmUpLlxyXG4gKlxyXG4gKiBUaGUgY2xpZW50IGF1dG9tYXRpY2FsbHkgbWFpbnRhaW5zIGEgcGVyc2lzdGVudCBjb25uZWN0aW9uIHRvIHRoZSBEYXRhYmFzZVxyXG4gKiBzZXJ2ZXIsIHdoaWNoIHdpbGwgcmVtYWluIGFjdGl2ZSBpbmRlZmluaXRlbHkgYW5kIHJlY29ubmVjdCB3aGVuXHJcbiAqIGRpc2Nvbm5lY3RlZC4gSG93ZXZlciwgdGhlIGBnb09mZmxpbmUoKWAgYW5kIGBnb09ubGluZSgpYCBtZXRob2RzIG1heSBiZSB1c2VkXHJcbiAqIHRvIGNvbnRyb2wgdGhlIGNsaWVudCBjb25uZWN0aW9uIGluIGNhc2VzIHdoZXJlIGEgcGVyc2lzdGVudCBjb25uZWN0aW9uIGlzXHJcbiAqIHVuZGVzaXJhYmxlLlxyXG4gKlxyXG4gKiBXaGlsZSBvZmZsaW5lLCB0aGUgY2xpZW50IHdpbGwgbm8gbG9uZ2VyIHJlY2VpdmUgZGF0YSB1cGRhdGVzIGZyb20gdGhlXHJcbiAqIERhdGFiYXNlLiBIb3dldmVyLCBhbGwgRGF0YWJhc2Ugb3BlcmF0aW9ucyBwZXJmb3JtZWQgbG9jYWxseSB3aWxsIGNvbnRpbnVlIHRvXHJcbiAqIGltbWVkaWF0ZWx5IGZpcmUgZXZlbnRzLCBhbGxvd2luZyB5b3VyIGFwcGxpY2F0aW9uIHRvIGNvbnRpbnVlIGJlaGF2aW5nXHJcbiAqIG5vcm1hbGx5LiBBZGRpdGlvbmFsbHksIGVhY2ggb3BlcmF0aW9uIHBlcmZvcm1lZCBsb2NhbGx5IHdpbGwgYXV0b21hdGljYWxseVxyXG4gKiBiZSBxdWV1ZWQgYW5kIHJldHJpZWQgdXBvbiByZWNvbm5lY3Rpb24gdG8gdGhlIERhdGFiYXNlIHNlcnZlci5cclxuICpcclxuICogVG8gcmVjb25uZWN0IHRvIHRoZSBEYXRhYmFzZSBhbmQgYmVnaW4gcmVjZWl2aW5nIHJlbW90ZSBldmVudHMsIHNlZVxyXG4gKiBgZ29PbmxpbmUoKWAuXHJcbiAqXHJcbiAqIEBwYXJhbSBkYiAtIFRoZSBpbnN0YW5jZSB0byBkaXNjb25uZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gZ29PZmZsaW5lKGRiKSB7XHJcbiAgICBkYiA9IGdldE1vZHVsYXJJbnN0YW5jZShkYik7XHJcbiAgICBkYi5fY2hlY2tOb3REZWxldGVkKCdnb09mZmxpbmUnKTtcclxuICAgIHJlcG9JbnRlcnJ1cHQoZGIuX3JlcG8pO1xyXG59XHJcbi8qKlxyXG4gKiBSZWNvbm5lY3RzIHRvIHRoZSBzZXJ2ZXIgYW5kIHN5bmNocm9uaXplcyB0aGUgb2ZmbGluZSBEYXRhYmFzZSBzdGF0ZVxyXG4gKiB3aXRoIHRoZSBzZXJ2ZXIgc3RhdGUuXHJcbiAqXHJcbiAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSB1c2VkIGFmdGVyIGRpc2FibGluZyB0aGUgYWN0aXZlIGNvbm5lY3Rpb24gd2l0aFxyXG4gKiBgZ29PZmZsaW5lKClgLiBPbmNlIHJlY29ubmVjdGVkLCB0aGUgY2xpZW50IHdpbGwgdHJhbnNtaXQgdGhlIHByb3BlciBkYXRhXHJcbiAqIGFuZCBmaXJlIHRoZSBhcHByb3ByaWF0ZSBldmVudHMgc28gdGhhdCB5b3VyIGNsaWVudCBcImNhdGNoZXMgdXBcIlxyXG4gKiBhdXRvbWF0aWNhbGx5LlxyXG4gKlxyXG4gKiBAcGFyYW0gZGIgLSBUaGUgaW5zdGFuY2UgdG8gcmVjb25uZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gZ29PbmxpbmUoZGIpIHtcclxuICAgIGRiID0gZ2V0TW9kdWxhckluc3RhbmNlKGRiKTtcclxuICAgIGRiLl9jaGVja05vdERlbGV0ZWQoJ2dvT25saW5lJyk7XHJcbiAgICByZXBvUmVzdW1lKGRiLl9yZXBvKTtcclxufVxyXG5mdW5jdGlvbiBlbmFibGVMb2dnaW5nKGxvZ2dlciwgcGVyc2lzdGVudCkge1xyXG4gICAgZW5hYmxlTG9nZ2luZyQxKGxvZ2dlciwgcGVyc2lzdGVudCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVnaXN0ZXJEYXRhYmFzZSh2YXJpYW50KSB7XHJcbiAgICBzZXRTREtWZXJzaW9uKFNES19WRVJTSU9OJDEpO1xyXG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoJ2RhdGFiYXNlJywgKGNvbnRhaW5lciwgeyBpbnN0YW5jZUlkZW50aWZpZXI6IHVybCB9KSA9PiB7XHJcbiAgICAgICAgY29uc3QgYXBwID0gY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAnKS5nZXRJbW1lZGlhdGUoKTtcclxuICAgICAgICBjb25zdCBhdXRoUHJvdmlkZXIgPSBjb250YWluZXIuZ2V0UHJvdmlkZXIoJ2F1dGgtaW50ZXJuYWwnKTtcclxuICAgICAgICBjb25zdCBhcHBDaGVja1Byb3ZpZGVyID0gY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAtY2hlY2staW50ZXJuYWwnKTtcclxuICAgICAgICByZXR1cm4gcmVwb01hbmFnZXJEYXRhYmFzZUZyb21BcHAoYXBwLCBhdXRoUHJvdmlkZXIsIGFwcENoZWNrUHJvdmlkZXIsIHVybCk7XHJcbiAgICB9LCBcIlBVQkxJQ1wiIC8qIENvbXBvbmVudFR5cGUuUFVCTElDICovKS5zZXRNdWx0aXBsZUluc3RhbmNlcyh0cnVlKSk7XHJcbiAgICByZWdpc3RlclZlcnNpb24obmFtZSwgdmVyc2lvbiwgdmFyaWFudCk7XHJcbiAgICAvLyBCVUlMRF9UQVJHRVQgd2lsbCBiZSByZXBsYWNlZCBieSB2YWx1ZXMgbGlrZSBlc201LCBlc20yMDE3LCBjanM1LCBldGMgZHVyaW5nIHRoZSBjb21waWxhdGlvblxyXG4gICAgcmVnaXN0ZXJWZXJzaW9uKG5hbWUsIHZlcnNpb24sICdlc20yMDE3Jyk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgU0VSVkVSX1RJTUVTVEFNUCA9IHtcclxuICAgICcuc3YnOiAndGltZXN0YW1wJ1xyXG59O1xyXG4vKipcclxuICogUmV0dXJucyBhIHBsYWNlaG9sZGVyIHZhbHVlIGZvciBhdXRvLXBvcHVsYXRpbmcgdGhlIGN1cnJlbnQgdGltZXN0YW1wICh0aW1lXHJcbiAqIHNpbmNlIHRoZSBVbml4IGVwb2NoLCBpbiBtaWxsaXNlY29uZHMpIGFzIGRldGVybWluZWQgYnkgdGhlIEZpcmViYXNlXHJcbiAqIHNlcnZlcnMuXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXJ2ZXJUaW1lc3RhbXAoKSB7XHJcbiAgICByZXR1cm4gU0VSVkVSX1RJTUVTVEFNUDtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIHBsYWNlaG9sZGVyIHZhbHVlIHRoYXQgY2FuIGJlIHVzZWQgdG8gYXRvbWljYWxseSBpbmNyZW1lbnQgdGhlXHJcbiAqIGN1cnJlbnQgZGF0YWJhc2UgdmFsdWUgYnkgdGhlIHByb3ZpZGVkIGRlbHRhLlxyXG4gKlxyXG4gKiBAcGFyYW0gZGVsdGEgLSB0aGUgYW1vdW50IHRvIG1vZGlmeSB0aGUgY3VycmVudCB2YWx1ZSBhdG9taWNhbGx5LlxyXG4gKiBAcmV0dXJucyBBIHBsYWNlaG9sZGVyIHZhbHVlIGZvciBtb2RpZnlpbmcgZGF0YSBhdG9taWNhbGx5IHNlcnZlci1zaWRlLlxyXG4gKi9cclxuZnVuY3Rpb24gaW5jcmVtZW50KGRlbHRhKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgICcuc3YnOiB7XHJcbiAgICAgICAgICAgICdpbmNyZW1lbnQnOiBkZWx0YVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEEgdHlwZSBmb3IgdGhlIHJlc29sdmUgdmFsdWUgb2Yge0BsaW5rIHJ1blRyYW5zYWN0aW9ufS5cclxuICovXHJcbmNsYXNzIFRyYW5zYWN0aW9uUmVzdWx0IHtcclxuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKiBXaGV0aGVyIHRoZSB0cmFuc2FjdGlvbiB3YXMgc3VjY2Vzc2Z1bGx5IGNvbW1pdHRlZC4gKi9cclxuICAgIGNvbW1pdHRlZCwgXHJcbiAgICAvKiogVGhlIHJlc3VsdGluZyBkYXRhIHNuYXBzaG90LiAqL1xyXG4gICAgc25hcHNob3QpIHtcclxuICAgICAgICB0aGlzLmNvbW1pdHRlZCA9IGNvbW1pdHRlZDtcclxuICAgICAgICB0aGlzLnNuYXBzaG90ID0gc25hcHNob3Q7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyBhIEpTT04tc2VyaWFsaXphYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LiAqL1xyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiB7IGNvbW1pdHRlZDogdGhpcy5jb21taXR0ZWQsIHNuYXBzaG90OiB0aGlzLnNuYXBzaG90LnRvSlNPTigpIH07XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEF0b21pY2FsbHkgbW9kaWZpZXMgdGhlIGRhdGEgYXQgdGhpcyBsb2NhdGlvbi5cclxuICpcclxuICogQXRvbWljYWxseSBtb2RpZnkgdGhlIGRhdGEgYXQgdGhpcyBsb2NhdGlvbi4gVW5saWtlIGEgbm9ybWFsIGBzZXQoKWAsIHdoaWNoXHJcbiAqIGp1c3Qgb3ZlcndyaXRlcyB0aGUgZGF0YSByZWdhcmRsZXNzIG9mIGl0cyBwcmV2aW91cyB2YWx1ZSwgYHJ1blRyYW5zYWN0aW9uKClgIGlzXHJcbiAqIHVzZWQgdG8gbW9kaWZ5IHRoZSBleGlzdGluZyB2YWx1ZSB0byBhIG5ldyB2YWx1ZSwgZW5zdXJpbmcgdGhlcmUgYXJlIG5vXHJcbiAqIGNvbmZsaWN0cyB3aXRoIG90aGVyIGNsaWVudHMgd3JpdGluZyB0byB0aGUgc2FtZSBsb2NhdGlvbiBhdCB0aGUgc2FtZSB0aW1lLlxyXG4gKlxyXG4gKiBUbyBhY2NvbXBsaXNoIHRoaXMsIHlvdSBwYXNzIGBydW5UcmFuc2FjdGlvbigpYCBhbiB1cGRhdGUgZnVuY3Rpb24gd2hpY2ggaXNcclxuICogdXNlZCB0byB0cmFuc2Zvcm0gdGhlIGN1cnJlbnQgdmFsdWUgaW50byBhIG5ldyB2YWx1ZS4gSWYgYW5vdGhlciBjbGllbnRcclxuICogd3JpdGVzIHRvIHRoZSBsb2NhdGlvbiBiZWZvcmUgeW91ciBuZXcgdmFsdWUgaXMgc3VjY2Vzc2Z1bGx5IHdyaXR0ZW4sIHlvdXJcclxuICogdXBkYXRlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFnYWluIHdpdGggdGhlIG5ldyBjdXJyZW50IHZhbHVlLCBhbmQgdGhlXHJcbiAqIHdyaXRlIHdpbGwgYmUgcmV0cmllZC4gVGhpcyB3aWxsIGhhcHBlbiByZXBlYXRlZGx5IHVudGlsIHlvdXIgd3JpdGUgc3VjY2VlZHNcclxuICogd2l0aG91dCBjb25mbGljdCBvciB5b3UgYWJvcnQgdGhlIHRyYW5zYWN0aW9uIGJ5IG5vdCByZXR1cm5pbmcgYSB2YWx1ZSBmcm9tXHJcbiAqIHlvdXIgdXBkYXRlIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBOb3RlOiBNb2RpZnlpbmcgZGF0YSB3aXRoIGBzZXQoKWAgd2lsbCBjYW5jZWwgYW55IHBlbmRpbmcgdHJhbnNhY3Rpb25zIGF0XHJcbiAqIHRoYXQgbG9jYXRpb24sIHNvIGV4dHJlbWUgY2FyZSBzaG91bGQgYmUgdGFrZW4gaWYgbWl4aW5nIGBzZXQoKWAgYW5kXHJcbiAqIGBydW5UcmFuc2FjdGlvbigpYCB0byB1cGRhdGUgdGhlIHNhbWUgZGF0YS5cclxuICpcclxuICogTm90ZTogV2hlbiB1c2luZyB0cmFuc2FjdGlvbnMgd2l0aCBTZWN1cml0eSBhbmQgRmlyZWJhc2UgUnVsZXMgaW4gcGxhY2UsIGJlXHJcbiAqIGF3YXJlIHRoYXQgYSBjbGllbnQgbmVlZHMgYC5yZWFkYCBhY2Nlc3MgaW4gYWRkaXRpb24gdG8gYC53cml0ZWAgYWNjZXNzIGluXHJcbiAqIG9yZGVyIHRvIHBlcmZvcm0gYSB0cmFuc2FjdGlvbi4gVGhpcyBpcyBiZWNhdXNlIHRoZSBjbGllbnQtc2lkZSBuYXR1cmUgb2ZcclxuICogdHJhbnNhY3Rpb25zIHJlcXVpcmVzIHRoZSBjbGllbnQgdG8gcmVhZCB0aGUgZGF0YSBpbiBvcmRlciB0byB0cmFuc2FjdGlvbmFsbHlcclxuICogdXBkYXRlIGl0LlxyXG4gKlxyXG4gKiBAcGFyYW0gcmVmIC0gVGhlIGxvY2F0aW9uIHRvIGF0b21pY2FsbHkgbW9kaWZ5LlxyXG4gKiBAcGFyYW0gdHJhbnNhY3Rpb25VcGRhdGUgLSBBIGRldmVsb3Blci1zdXBwbGllZCBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIHBhc3NlZFxyXG4gKiB0aGUgY3VycmVudCBkYXRhIHN0b3JlZCBhdCB0aGlzIGxvY2F0aW9uIChhcyBhIEphdmFTY3JpcHQgb2JqZWN0KS4gVGhlXHJcbiAqIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gdGhlIG5ldyB2YWx1ZSBpdCB3b3VsZCBsaWtlIHdyaXR0ZW4gKGFzIGEgSmF2YVNjcmlwdFxyXG4gKiBvYmplY3QpLiBJZiBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZCAoaS5lLiB5b3UgcmV0dXJuIHdpdGggbm8gYXJndW1lbnRzKSB0aGVcclxuICogdHJhbnNhY3Rpb24gd2lsbCBiZSBhYm9ydGVkIGFuZCB0aGUgZGF0YSBhdCB0aGlzIGxvY2F0aW9uIHdpbGwgbm90IGJlXHJcbiAqIG1vZGlmaWVkLlxyXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbnMgb2JqZWN0IHRvIGNvbmZpZ3VyZSB0cmFuc2FjdGlvbnMuXHJcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgY2FuIG9wdGlvbmFsbHkgYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBgb25Db21wbGV0ZWBcclxuICogY2FsbGJhY2sgdG8gaGFuZGxlIHN1Y2Nlc3MgYW5kIGZhaWx1cmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBydW5UcmFuc2FjdGlvbihyZWYsIFxyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG50cmFuc2FjdGlvblVwZGF0ZSwgb3B0aW9ucykge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgcmVmID0gZ2V0TW9kdWxhckluc3RhbmNlKHJlZik7XHJcbiAgICB2YWxpZGF0ZVdyaXRhYmxlUGF0aCgnUmVmZXJlbmNlLnRyYW5zYWN0aW9uJywgcmVmLl9wYXRoKTtcclxuICAgIGlmIChyZWYua2V5ID09PSAnLmxlbmd0aCcgfHwgcmVmLmtleSA9PT0gJy5rZXlzJykge1xyXG4gICAgICAgIHRocm93ICgnUmVmZXJlbmNlLnRyYW5zYWN0aW9uIGZhaWxlZDogJyArIHJlZi5rZXkgKyAnIGlzIGEgcmVhZC1vbmx5IG9iamVjdC4nKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGFwcGx5TG9jYWxseSA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hcHBseUxvY2FsbHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWU7XHJcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgY29uc3QgcHJvbWlzZUNvbXBsZXRlID0gKGVycm9yLCBjb21taXR0ZWQsIG5vZGUpID0+IHtcclxuICAgICAgICBsZXQgZGF0YVNuYXBzaG90ID0gbnVsbDtcclxuICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRhdGFTbmFwc2hvdCA9IG5ldyBEYXRhU25hcHNob3Qobm9kZSwgbmV3IFJlZmVyZW5jZUltcGwocmVmLl9yZXBvLCByZWYuX3BhdGgpLCBQUklPUklUWV9JTkRFWCk7XHJcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUobmV3IFRyYW5zYWN0aW9uUmVzdWx0KGNvbW1pdHRlZCwgZGF0YVNuYXBzaG90KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEFkZCBhIHdhdGNoIHRvIG1ha2Ugc3VyZSB3ZSBnZXQgc2VydmVyIHVwZGF0ZXMuXHJcbiAgICBjb25zdCB1bndhdGNoZXIgPSBvblZhbHVlKHJlZiwgKCkgPT4geyB9KTtcclxuICAgIHJlcG9TdGFydFRyYW5zYWN0aW9uKHJlZi5fcmVwbywgcmVmLl9wYXRoLCB0cmFuc2FjdGlvblVwZGF0ZSwgcHJvbWlzZUNvbXBsZXRlLCB1bndhdGNoZXIsIGFwcGx5TG9jYWxseSk7XHJcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5QZXJzaXN0ZW50Q29ubmVjdGlvbjtcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnNpbXBsZUxpc3RlbiA9IGZ1bmN0aW9uIChwYXRoU3RyaW5nLCBvbkNvbXBsZXRlKSB7XHJcbiAgICB0aGlzLnNlbmRSZXF1ZXN0KCdxJywgeyBwOiBwYXRoU3RyaW5nIH0sIG9uQ29tcGxldGUpO1xyXG59O1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG5QZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUuZWNobyA9IGZ1bmN0aW9uIChkYXRhLCBvbkVjaG8pIHtcclxuICAgIHRoaXMuc2VuZFJlcXVlc3QoJ2VjaG8nLCB7IGQ6IGRhdGEgfSwgb25FY2hvKTtcclxufTtcclxuLy8gUmVhbFRpbWVDb25uZWN0aW9uIHByb3BlcnRpZXMgdGhhdCB3ZSB1c2UgaW4gdGVzdHMuXHJcbkNvbm5lY3Rpb247XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNvbnN0IGhpamFja0hhc2ggPSBmdW5jdGlvbiAobmV3SGFzaCkge1xyXG4gICAgY29uc3Qgb2xkUHV0ID0gUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnB1dDtcclxuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAocGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSwgaGFzaCkge1xyXG4gICAgICAgIGlmIChoYXNoICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaGFzaCA9IG5ld0hhc2goKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb2xkUHV0LmNhbGwodGhpcywgcGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSwgaGFzaCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUucHV0ID0gb2xkUHV0O1xyXG4gICAgfTtcclxufTtcclxuUmVwb0luZm87XHJcbi8qKlxyXG4gKiBGb3JjZXMgdGhlIFJlcG9NYW5hZ2VyIHRvIGNyZWF0ZSBSZXBvcyB0aGF0IHVzZSBSZWFkb25seVJlc3RDbGllbnQgaW5zdGVhZCBvZiBQZXJzaXN0ZW50Q29ubmVjdGlvbi5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCBmb3JjZVJlc3RDbGllbnQgPSBmdW5jdGlvbiAoZm9yY2VSZXN0Q2xpZW50KSB7XHJcbiAgICByZXBvTWFuYWdlckZvcmNlUmVzdENsaWVudChmb3JjZVJlc3RDbGllbnQpO1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVXNlZCBieSBjb25zb2xlIHRvIGNyZWF0ZSBhIGRhdGFiYXNlIGJhc2VkIG9uIHRoZSBhcHAsXHJcbiAqIHBhc3NlZCBkYXRhYmFzZSBVUkwgYW5kIGEgY3VzdG9tIGF1dGggaW1wbGVtZW50YXRpb24uXHJcbiAqIEBpbnRlcm5hbFxyXG4gKiBAcGFyYW0gYXBwIC0gQSB2YWxpZCBGaXJlYmFzZUFwcC1saWtlIG9iamVjdFxyXG4gKiBAcGFyYW0gdXJsIC0gQSB2YWxpZCBGaXJlYmFzZSBkYXRhYmFzZVVSTFxyXG4gKiBAcGFyYW0gdmVyc2lvbiAtIGN1c3RvbSB2ZXJzaW9uIGUuZy4gZmlyZWJhc2UtYWRtaW4gdmVyc2lvblxyXG4gKiBAcGFyYW0gY3VzdG9tQXBwQ2hlY2tJbXBsIC0gY3VzdG9tIGFwcCBjaGVjayBpbXBsZW1lbnRhdGlvblxyXG4gKiBAcGFyYW0gY3VzdG9tQXV0aEltcGwgLSBjdXN0b20gYXV0aCBpbXBsZW1lbnRhdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gX2luaXRTdGFuZGFsb25lKHsgYXBwLCB1cmwsIHZlcnNpb24sIGN1c3RvbUF1dGhJbXBsLCBjdXN0b21BcHBDaGVja0ltcGwsIG5vZGVBZG1pbiA9IGZhbHNlIH0pIHtcclxuICAgIHNldFNES1ZlcnNpb24odmVyc2lvbik7XHJcbiAgICAvKipcclxuICAgICAqIENvbXBvbmVudENvbnRhaW5lcignZGF0YWJhc2Utc3RhbmRhbG9uZScpIGlzIGp1c3QgYSBwbGFjZWhvbGRlciB0aGF0IGRvZXNuJ3QgcGVyZm9ybVxyXG4gICAgICogYW55IGFjdHVhbCBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgY29uc3QgY29tcG9uZW50Q29udGFpbmVyID0gbmV3IENvbXBvbmVudENvbnRhaW5lcignZGF0YWJhc2Utc3RhbmRhbG9uZScpO1xyXG4gICAgY29uc3QgYXV0aFByb3ZpZGVyID0gbmV3IFByb3ZpZGVyKCdhdXRoLWludGVybmFsJywgY29tcG9uZW50Q29udGFpbmVyKTtcclxuICAgIGxldCBhcHBDaGVja1Byb3ZpZGVyO1xyXG4gICAgaWYgKGN1c3RvbUFwcENoZWNrSW1wbCkge1xyXG4gICAgICAgIGFwcENoZWNrUHJvdmlkZXIgPSBuZXcgUHJvdmlkZXIoJ2FwcC1jaGVjay1pbnRlcm5hbCcsIGNvbXBvbmVudENvbnRhaW5lcik7XHJcbiAgICAgICAgYXBwQ2hlY2tQcm92aWRlci5zZXRDb21wb25lbnQobmV3IENvbXBvbmVudCgnYXBwLWNoZWNrLWludGVybmFsJywgKCkgPT4gY3VzdG9tQXBwQ2hlY2tJbXBsLCBcIlBSSVZBVEVcIiAvKiBDb21wb25lbnRUeXBlLlBSSVZBVEUgKi8pKTtcclxuICAgIH1cclxuICAgIGF1dGhQcm92aWRlci5zZXRDb21wb25lbnQobmV3IENvbXBvbmVudCgnYXV0aC1pbnRlcm5hbCcsICgpID0+IGN1c3RvbUF1dGhJbXBsLCBcIlBSSVZBVEVcIiAvKiBDb21wb25lbnRUeXBlLlBSSVZBVEUgKi8pKTtcclxuICAgIHJldHVybiByZXBvTWFuYWdlckRhdGFiYXNlRnJvbUFwcChhcHAsIGF1dGhQcm92aWRlciwgYXBwQ2hlY2tQcm92aWRlciwgdXJsLCBub2RlQWRtaW4pO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbnNldFdlYlNvY2tldEltcGwoV2Vic29ja2V0LkNsaWVudCk7XHJcbnJlZ2lzdGVyRGF0YWJhc2UoJ25vZGUnKTtcblxuZXhwb3J0IHsgRGF0YVNuYXBzaG90LCBEYXRhYmFzZSwgT25EaXNjb25uZWN0LCBRdWVyeUNvbnN0cmFpbnQsIFRyYW5zYWN0aW9uUmVzdWx0LCBRdWVyeUltcGwgYXMgX1F1ZXJ5SW1wbCwgUXVlcnlQYXJhbXMgYXMgX1F1ZXJ5UGFyYW1zLCBSZWZlcmVuY2VJbXBsIGFzIF9SZWZlcmVuY2VJbXBsLCBmb3JjZVJlc3RDbGllbnQgYXMgX1RFU1RfQUNDRVNTX2ZvcmNlUmVzdENsaWVudCwgaGlqYWNrSGFzaCBhcyBfVEVTVF9BQ0NFU1NfaGlqYWNrSGFzaCwgX2luaXRTdGFuZGFsb25lLCByZXBvTWFuYWdlckRhdGFiYXNlRnJvbUFwcCBhcyBfcmVwb01hbmFnZXJEYXRhYmFzZUZyb21BcHAsIHNldFNES1ZlcnNpb24gYXMgX3NldFNES1ZlcnNpb24sIHZhbGlkYXRlUGF0aFN0cmluZyBhcyBfdmFsaWRhdGVQYXRoU3RyaW5nLCB2YWxpZGF0ZVdyaXRhYmxlUGF0aCBhcyBfdmFsaWRhdGVXcml0YWJsZVBhdGgsIGNoaWxkLCBjb25uZWN0RGF0YWJhc2VFbXVsYXRvciwgZW5hYmxlTG9nZ2luZywgZW5kQXQsIGVuZEJlZm9yZSwgZXF1YWxUbywgZm9yY2VMb25nUG9sbGluZywgZm9yY2VXZWJTb2NrZXRzLCBnZXQsIGdldERhdGFiYXNlLCBnb09mZmxpbmUsIGdvT25saW5lLCBpbmNyZW1lbnQsIGxpbWl0VG9GaXJzdCwgbGltaXRUb0xhc3QsIG9mZiwgb25DaGlsZEFkZGVkLCBvbkNoaWxkQ2hhbmdlZCwgb25DaGlsZE1vdmVkLCBvbkNoaWxkUmVtb3ZlZCwgb25EaXNjb25uZWN0LCBvblZhbHVlLCBvcmRlckJ5Q2hpbGQsIG9yZGVyQnlLZXksIG9yZGVyQnlQcmlvcml0eSwgb3JkZXJCeVZhbHVlLCBwdXNoLCBxdWVyeSwgcmVmLCByZWZGcm9tVVJMLCByZW1vdmUsIHJ1blRyYW5zYWN0aW9uLCBzZXJ2ZXJUaW1lc3RhbXAsIHNldCwgc2V0UHJpb3JpdHksIHNldFdpdGhQcmlvcml0eSwgc3RhcnRBZnRlciwgc3RhcnRBdCwgdXBkYXRlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5ub2RlLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJXZWJzb2NrZXQiLCJzdHJpbmdpZnkiLCJqc29uRXZhbCIsImNvbnRhaW5zIiwiYXNzZXJ0IiwiaXNOb2RlU2RrIiwic3RyaW5nVG9CeXRlQXJyYXkiLCJTaGExIiwiYmFzZTY0IiwiZGVlcENvcHkiLCJiYXNlNjRFbmNvZGUiLCJpc01vYmlsZUNvcmRvdmEiLCJzdHJpbmdMZW5ndGgiLCJEZWZlcnJlZCIsInNhZmVHZXQiLCJpc0FkbWluIiwiaXNWYWxpZEZvcm1hdCIsImlzRW1wdHkiLCJpc1JlYWN0TmF0aXZlIiwiYXNzZXJ0aW9uRXJyb3IiLCJtYXAiLCJxdWVyeXN0cmluZyIsImVycm9yUHJlZml4IiwiZ2V0TW9kdWxhckluc3RhbmNlIiwiZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdG5hbWVBbmRQb3J0IiwiY3JlYXRlTW9ja1VzZXJUb2tlbiIsIkxvZ2dlciIsIkxvZ0xldmVsIiwiX2dldFByb3ZpZGVyIiwiZ2V0QXBwIiwiU0RLX1ZFUlNJT04iLCJTREtfVkVSU0lPTiQxIiwiX3JlZ2lzdGVyQ29tcG9uZW50IiwicmVnaXN0ZXJWZXJzaW9uIiwiQ29tcG9uZW50IiwiQ29tcG9uZW50Q29udGFpbmVyIiwiUHJvdmlkZXIiLCJQUk9UT0NPTF9WRVJTSU9OIiwiVkVSU0lPTl9QQVJBTSIsIlRSQU5TUE9SVF9TRVNTSU9OX1BBUkFNIiwiUkVGRVJFUl9QQVJBTSIsIkZPUkdFX1JFRiIsIkZPUkdFX0RPTUFJTl9SRSIsIkxBU1RfU0VTU0lPTl9QQVJBTSIsIkFQUExJQ0FUSU9OX0lEX1BBUkFNIiwiQVBQX0NIRUNLX1RPS0VOX1BBUkFNIiwiV0VCU09DS0VUIiwiTE9OR19QT0xMSU5HIiwiRE9NU3RvcmFnZVdyYXBwZXIiLCJjb25zdHJ1Y3RvciIsImRvbVN0b3JhZ2VfIiwicHJlZml4XyIsInNldCIsImtleSIsInZhbHVlIiwicmVtb3ZlSXRlbSIsInByZWZpeGVkTmFtZV8iLCJzZXRJdGVtIiwiZ2V0Iiwic3RvcmVkVmFsIiwiZ2V0SXRlbSIsInJlbW92ZSIsIm5hbWUiLCJ0b1N0cmluZyIsIk1lbW9yeVN0b3JhZ2UiLCJjYWNoZV8iLCJpc0luTWVtb3J5U3RvcmFnZSIsImNyZWF0ZVN0b3JhZ2Vmb3IiLCJkb21TdG9yYWdlTmFtZSIsIndpbmRvdyIsImRvbVN0b3JhZ2UiLCJlIiwiUGVyc2lzdGVudFN0b3JhZ2UiLCJTZXNzaW9uU3RvcmFnZSIsImxvZ0NsaWVudCIsIkxVSURHZW5lcmF0b3IiLCJpZCIsInNoYTEiLCJzdHIiLCJ1dGY4Qnl0ZXMiLCJ1cGRhdGUiLCJzaGExQnl0ZXMiLCJkaWdlc3QiLCJlbmNvZGVCeXRlQXJyYXkiLCJidWlsZExvZ01lc3NhZ2VfIiwidmFyQXJncyIsIm1lc3NhZ2UiLCJpIiwibGVuZ3RoIiwiYXJnIiwiQXJyYXkiLCJpc0FycmF5IiwiYXBwbHkiLCJsb2dnZXIiLCJmaXJzdExvZ18iLCJlbmFibGVMb2dnaW5nJDEiLCJsb2dnZXJfIiwicGVyc2lzdGVudCIsImxvZ0xldmVsIiwiVkVSQk9TRSIsImxvZyIsImJpbmQiLCJsb2dXcmFwcGVyIiwicHJlZml4IiwiZXJyb3IiLCJmYXRhbCIsIkVycm9yIiwid2FybiIsIndhcm5JZlBhZ2VJc1NlY3VyZSIsImxvY2F0aW9uIiwicHJvdG9jb2wiLCJpbmRleE9mIiwiaXNJbnZhbGlkSlNPTk51bWJlciIsImRhdGEiLCJOdW1iZXIiLCJQT1NJVElWRV9JTkZJTklUWSIsIk5FR0FUSVZFX0lORklOSVRZIiwiZXhlY3V0ZVdoZW5ET01SZWFkeSIsImZuIiwiZG9jdW1lbnQiLCJyZWFkeVN0YXRlIiwiY2FsbGVkIiwid3JhcHBlZEZuIiwiYm9keSIsInNldFRpbWVvdXQiLCJNYXRoIiwiZmxvb3IiLCJhZGRFdmVudExpc3RlbmVyIiwiYXR0YWNoRXZlbnQiLCJNSU5fTkFNRSIsIk1BWF9OQU1FIiwibmFtZUNvbXBhcmUiLCJhIiwiYiIsImFBc0ludCIsInRyeVBhcnNlSW50IiwiYkFzSW50Iiwic3RyaW5nQ29tcGFyZSIsInJlcXVpcmVLZXkiLCJvYmoiLCJPYmplY3RUb1VuaXF1ZUtleSIsImtleXMiLCJrIiwicHVzaCIsInNvcnQiLCJzcGxpdFN0cmluZ0J5U2l6ZSIsInNlZ3NpemUiLCJsZW4iLCJkYXRhU2VncyIsImMiLCJzdWJzdHJpbmciLCJlYWNoIiwiaGFzT3duUHJvcGVydHkiLCJkb3VibGVUb0lFRUU3NTRTdHJpbmciLCJ2IiwiZWJpdHMiLCJmYml0cyIsImJpYXMiLCJzIiwiZiIsImxuIiwiSW5maW5pdHkiLCJhYnMiLCJwb3ciLCJtaW4iLCJMTjIiLCJyb3VuZCIsImJpdHMiLCJyZXZlcnNlIiwiam9pbiIsImhleEJ5dGVTdHJpbmciLCJoZXhCeXRlIiwicGFyc2VJbnQiLCJzdWJzdHIiLCJ0b0xvd2VyQ2FzZSIsImlzQ2hyb21lRXh0ZW5zaW9uQ29udGVudFNjcmlwdCIsInRlc3QiLCJocmVmIiwiaXNXaW5kb3dzU3RvcmVBcHAiLCJXaW5kb3dzIiwiVUkiLCJlcnJvckZvclNlcnZlckNvZGUiLCJjb2RlIiwicXVlcnkiLCJyZWFzb24iLCJfcGF0aCIsInRvVXBwZXJDYXNlIiwiSU5URUdFUl9SRUdFWFBfIiwiUmVnRXhwIiwiSU5URUdFUl8zMl9NSU4iLCJJTlRFR0VSXzMyX01BWCIsImludFZhbCIsImV4Y2VwdGlvbkd1YXJkIiwic3RhY2siLCJiZWluZ0NyYXdsZWQiLCJ1c2VyQWdlbnQiLCJzZWFyY2giLCJzZXRUaW1lb3V0Tm9uQmxvY2tpbmciLCJ0aW1lIiwidGltZW91dCIsIkRlbm8iLCJ1bnJlZlRpbWVyIiwiUmVwb0luZm8iLCJob3N0Iiwic2VjdXJlIiwibmFtZXNwYWNlIiwid2ViU29ja2V0T25seSIsIm5vZGVBZG1pbiIsInBlcnNpc3RlbmNlS2V5IiwiaW5jbHVkZU5hbWVzcGFjZUluUXVlcnlQYXJhbXMiLCJpc1VzaW5nRW11bGF0b3IiLCJfaG9zdCIsIl9kb21haW4iLCJpbnRlcm5hbEhvc3QiLCJpc0NhY2hlYWJsZUhvc3QiLCJpc0N1c3RvbUhvc3QiLCJuZXdIb3N0IiwidG9VUkxTdHJpbmciLCJyZXBvSW5mb05lZWRzUXVlcnlQYXJhbSIsInJlcG9JbmZvIiwicmVwb0luZm9Db25uZWN0aW9uVVJMIiwidHlwZSIsInBhcmFtcyIsImNvbm5VUkwiLCJwYWlycyIsIlN0YXRzQ29sbGVjdGlvbiIsImNvdW50ZXJzXyIsImluY3JlbWVudENvdW50ZXIiLCJhbW91bnQiLCJjb2xsZWN0aW9ucyIsInJlcG9ydGVycyIsInN0YXRzTWFuYWdlckdldENvbGxlY3Rpb24iLCJoYXNoU3RyaW5nIiwic3RhdHNNYW5hZ2VyR2V0T3JDcmVhdGVSZXBvcnRlciIsImNyZWF0b3JGdW5jdGlvbiIsInNldFNES1ZlcnNpb24iLCJ2ZXJzaW9uIiwiV0VCU09DS0VUX01BWF9GUkFNRV9TSVpFIiwiV0VCU09DS0VUX0tFRVBBTElWRV9JTlRFUlZBTCIsIldlYlNvY2tldEltcGwiLCJNb3pXZWJTb2NrZXQiLCJXZWJTb2NrZXQiLCJzZXRXZWJTb2NrZXRJbXBsIiwiaW1wbCIsIldlYlNvY2tldENvbm5lY3Rpb24iLCJjb25uSWQiLCJhcHBsaWNhdGlvbklkIiwiYXBwQ2hlY2tUb2tlbiIsImF1dGhUb2tlbiIsInRyYW5zcG9ydFNlc3Npb25JZCIsImxhc3RTZXNzaW9uSWQiLCJrZWVwYWxpdmVUaW1lciIsImZyYW1lcyIsInRvdGFsRnJhbWVzIiwiYnl0ZXNTZW50IiwiYnl0ZXNSZWNlaXZlZCIsImxvZ18iLCJzdGF0c18iLCJjb25uZWN0aW9uVVJMXyIsInVybFBhcmFtcyIsImhvc3RuYW1lIiwib3BlbiIsIm9uTWVzc2FnZSIsIm9uRGlzY29ubmVjdCIsImV2ZXJDb25uZWN0ZWRfIiwib3B0aW9ucyIsImRldmljZSIsImhlYWRlcnMiLCJwcm9jZXNzIiwicGxhdGZvcm0iLCJlbnYiLCJwcm94eSIsIm9yaWdpbiIsIm15U29jayIsIm9uQ2xvc2VkXyIsIm9ub3BlbiIsIm9uY2xvc2UiLCJvbm1lc3NhZ2UiLCJtIiwiaGFuZGxlSW5jb21pbmdGcmFtZSIsIm9uZXJyb3IiLCJzdGFydCIsImZvcmNlRGlzYWxsb3ciLCJmb3JjZURpc2FsbG93XyIsImlzQXZhaWxhYmxlIiwiaXNPbGRBbmRyb2lkIiwibmF2aWdhdG9yIiwib2xkQW5kcm9pZFJlZ2V4Iiwib2xkQW5kcm9pZE1hdGNoIiwibWF0Y2giLCJwYXJzZUZsb2F0IiwicHJldmlvdXNseUZhaWxlZCIsIm1hcmtDb25uZWN0aW9uSGVhbHRoeSIsImFwcGVuZEZyYW1lXyIsImZ1bGxNZXNzIiwianNvbk1lc3MiLCJoYW5kbGVOZXdGcmFtZUNvdW50XyIsImZyYW1lQ291bnQiLCJleHRyYWN0RnJhbWVDb3VudF8iLCJpc05hTiIsIm1lc3MiLCJyZXNldEtlZXBBbGl2ZSIsInJlbWFpbmluZ0RhdGEiLCJzZW5kIiwiZGF0YVN0ciIsInNlbmRTdHJpbmdfIiwiU3RyaW5nIiwic2h1dGRvd25fIiwiaXNDbG9zZWRfIiwiY2xlYXJJbnRlcnZhbCIsImNsb3NlIiwic2V0SW50ZXJ2YWwiLCJyZXNwb25zZXNSZXF1aXJlZFRvQmVIZWFsdGh5IiwiaGVhbHRoeVRpbWVvdXQiLCJBcHBDaGVja1Rva2VuUHJvdmlkZXIiLCJhcHBOYW1lXyIsImFwcENoZWNrUHJvdmlkZXIiLCJhcHBDaGVjayIsImdldEltbWVkaWF0ZSIsIm9wdGlvbmFsIiwidGhlbiIsImdldFRva2VuIiwiZm9yY2VSZWZyZXNoIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJhZGRUb2tlbkNoYW5nZUxpc3RlbmVyIiwibGlzdGVuZXIiLCJfYSIsImFkZFRva2VuTGlzdGVuZXIiLCJub3RpZnlGb3JJbnZhbGlkVG9rZW4iLCJGaXJlYmFzZUF1dGhUb2tlblByb3ZpZGVyIiwiZmlyZWJhc2VPcHRpb25zXyIsImF1dGhQcm92aWRlcl8iLCJhdXRoXyIsIm9uSW5pdCIsImF1dGgiLCJjYXRjaCIsImFkZEF1dGhUb2tlbkxpc3RlbmVyIiwicmVtb3ZlVG9rZW5DaGFuZ2VMaXN0ZW5lciIsInJlbW92ZUF1dGhUb2tlbkxpc3RlbmVyIiwiZXJyb3JNZXNzYWdlIiwiRW11bGF0b3JUb2tlblByb3ZpZGVyIiwiYWNjZXNzVG9rZW4iLCJPV05FUiIsIlBhY2tldFJlY2VpdmVyIiwib25NZXNzYWdlXyIsInBlbmRpbmdSZXNwb25zZXMiLCJjdXJyZW50UmVzcG9uc2VOdW0iLCJjbG9zZUFmdGVyUmVzcG9uc2UiLCJvbkNsb3NlIiwiY2xvc2VBZnRlciIsInJlc3BvbnNlTnVtIiwiY2FsbGJhY2siLCJoYW5kbGVSZXNwb25zZSIsInJlcXVlc3ROdW0iLCJ0b1Byb2Nlc3MiLCJGSVJFQkFTRV9MT05HUE9MTF9TVEFSVF9QQVJBTSIsIkZJUkVCQVNFX0xPTkdQT0xMX0NMT1NFX0NPTU1BTkQiLCJGSVJFQkFTRV9MT05HUE9MTF9DT01NQU5EX0NCX05BTUUiLCJGSVJFQkFTRV9MT05HUE9MTF9EQVRBX0NCX05BTUUiLCJGSVJFQkFTRV9MT05HUE9MTF9JRF9QQVJBTSIsIkZJUkVCQVNFX0xPTkdQT0xMX1BXX1BBUkFNIiwiRklSRUJBU0VfTE9OR1BPTExfU0VSSUFMX1BBUkFNIiwiRklSRUJBU0VfTE9OR1BPTExfQ0FMTEJBQ0tfSURfUEFSQU0iLCJGSVJFQkFTRV9MT05HUE9MTF9TRUdNRU5UX05VTV9QQVJBTSIsIkZJUkVCQVNFX0xPTkdQT0xMX1NFR01FTlRTX0lOX1BBQ0tFVCIsIkZJUkVCQVNFX0xPTkdQT0xMX0RBVEFfUEFSQU0iLCJGSVJFQkFTRV9MT05HUE9MTF9ESVNDT05OX0ZSQU1FX1JFUVVFU1RfUEFSQU0iLCJNQVhfVVJMX0RBVEFfU0laRSIsIlNFR19IRUFERVJfU0laRSIsIk1BWF9QQVlMT0FEX1NJWkUiLCJLRUVQQUxJVkVfUkVRVUVTVF9JTlRFUlZBTCIsIkxQX0NPTk5FQ1RfVElNRU9VVCIsIkJyb3dzZXJQb2xsQ29ubmVjdGlvbiIsInVybEZuIiwiY3VyU2VnbWVudE51bSIsIm9uRGlzY29ubmVjdF8iLCJteVBhY2tldE9yZGVyZXIiLCJjb25uZWN0VGltZW91dFRpbWVyXyIsInNjcmlwdFRhZ0hvbGRlciIsIkZpcmViYXNlSUZyYW1lU2NyaXB0SG9sZGVyIiwiYXJncyIsImNvbW1hbmQiLCJhcmcxIiwiYXJnMiIsImFyZzMiLCJhcmc0IiwiaW5jcmVtZW50SW5jb21pbmdCeXRlc18iLCJjbGVhclRpbWVvdXQiLCJwYXNzd29yZCIsInNlbmROZXdQb2xscyIsInBOIiwicmFuZG9tIiwidW5pcXVlQ2FsbGJhY2tJZGVudGlmaWVyIiwiY29ubmVjdFVSTCIsImFkZFRhZyIsInN0YXJ0TG9uZ1BvbGwiLCJhZGREaXNjb25uZWN0UGluZ0ZyYW1lIiwiZm9yY2VBbGxvdyIsImZvcmNlQWxsb3dfIiwiY3JlYXRlRWxlbWVudCIsIm15RGlzY29ubkZyYW1lIiwicmVtb3ZlQ2hpbGQiLCJiYXNlNjRkYXRhIiwiZW5xdWV1ZVNlZ21lbnQiLCJwdyIsInNyYyIsInN0eWxlIiwiZGlzcGxheSIsImFwcGVuZENoaWxkIiwiY29tbWFuZENCIiwib25NZXNzYWdlQ0IiLCJvdXRzdGFuZGluZ1JlcXVlc3RzIiwiU2V0IiwicGVuZGluZ1NlZ3MiLCJjdXJyZW50U2VyaWFsIiwibXlJRnJhbWUiLCJjcmVhdGVJRnJhbWVfIiwic2NyaXB0IiwiY3VycmVudERvbWFpbiIsImRvbWFpbiIsImlmcmFtZUNvbnRlbnRzIiwiZG9jIiwid3JpdGUiLCJpZnJhbWUiLCJjb250ZW50V2luZG93IiwiY29udGVudERvY3VtZW50IiwiYWxpdmUiLCJ0ZXh0Q29udGVudCIsIm15SUQiLCJteVBXIiwibmV3UmVxdWVzdF8iLCJzaXplIiwidGhlVVJMIiwiY3VyRGF0YVN0cmluZyIsIm5leHRTZWciLCJkIiwidGhlU2VnIiwic2hpZnQiLCJzZWciLCJ0cyIsImFkZExvbmdQb2xsVGFnXyIsInNlZ251bSIsInRvdGFsc2VncyIsInVybCIsInNlcmlhbCIsImFkZCIsImRvTmV3UmVxdWVzdCIsImRlbGV0ZSIsImtlZXBhbGl2ZVRpbWVvdXQiLCJyZWFkeVN0YXRlQ0IiLCJsb2FkQ0IiLCJkb05vZGVMb25nUG9sbCIsIm5ld1NjcmlwdCIsImFzeW5jIiwib25sb2FkIiwib25yZWFkeXN0YXRlY2hhbmdlIiwicnN0YXRlIiwicGFyZW50Tm9kZSIsIlRyYW5zcG9ydE1hbmFnZXIiLCJpbml0VHJhbnNwb3J0c18iLCJBTExfVFJBTlNQT1JUUyIsIklTX1RSQU5TUE9SVF9JTklUSUFMSVpFRCIsImdsb2JhbFRyYW5zcG9ydEluaXRpYWxpemVkXyIsImlzV2ViU29ja2V0c0F2YWlsYWJsZSIsImlzU2tpcFBvbGxDb25uZWN0aW9uIiwidHJhbnNwb3J0c18iLCJ0cmFuc3BvcnRzIiwidHJhbnNwb3J0IiwiaW5pdGlhbFRyYW5zcG9ydCIsInVwZ3JhZGVUcmFuc3BvcnQiLCJVUEdSQURFX1RJTUVPVVQiLCJERUxBWV9CRUZPUkVfU0VORElOR19FWFRSQV9SRVFVRVNUUyIsIkJZVEVTX1NFTlRfSEVBTFRIWV9PVkVSUklERSIsIkJZVEVTX1JFQ0VJVkVEX0hFQUxUSFlfT1ZFUlJJREUiLCJNRVNTQUdFX1RZUEUiLCJNRVNTQUdFX0RBVEEiLCJDT05UUk9MX1NIVVRET1dOIiwiQ09OVFJPTF9SRVNFVCIsIkNPTlRST0xfRVJST1IiLCJDT05UUk9MX1BPTkciLCJTV0lUQ0hfQUNLIiwiRU5EX1RSQU5TTUlTU0lPTiIsIlBJTkciLCJTRVJWRVJfSEVMTE8iLCJDb25uZWN0aW9uIiwicmVwb0luZm9fIiwiYXBwbGljYXRpb25JZF8iLCJhcHBDaGVja1Rva2VuXyIsImF1dGhUb2tlbl8iLCJvblJlYWR5XyIsIm9uS2lsbF8iLCJjb25uZWN0aW9uQ291bnQiLCJwZW5kaW5nRGF0YU1lc3NhZ2VzIiwic3RhdGVfIiwidHJhbnNwb3J0TWFuYWdlcl8iLCJzdGFydF8iLCJjb25uIiwiY29ubl8iLCJuZXh0VHJhbnNwb3J0SWRfIiwicHJpbWFyeVJlc3BvbnNlc1JlcXVpcmVkXyIsIm9uTWVzc2FnZVJlY2VpdmVkIiwiY29ublJlY2VpdmVyXyIsIm9uQ29ubmVjdGlvbkxvc3QiLCJkaXNjb25uUmVjZWl2ZXJfIiwidHhfIiwicnhfIiwic2Vjb25kYXJ5Q29ubl8iLCJpc0hlYWx0aHlfIiwiaGVhbHRoeVRpbWVvdXRNUyIsImhlYWx0aHlUaW1lb3V0XyIsImV2ZXJDb25uZWN0ZWQiLCJvbkNvbm5lY3Rpb25Mb3N0XyIsIm9uU2Vjb25kYXJ5Q29ubmVjdGlvbkxvc3RfIiwib25QcmltYXJ5TWVzc2FnZVJlY2VpdmVkXyIsIm9uU2Vjb25kYXJ5TWVzc2FnZVJlY2VpdmVkXyIsInNlbmRSZXF1ZXN0IiwiZGF0YU1zZyIsIm1zZyIsInQiLCJzZW5kRGF0YV8iLCJ0cnlDbGVhbnVwQ29ubmVjdGlvbiIsIm9uU2Vjb25kYXJ5Q29udHJvbF8iLCJjb250cm9sRGF0YSIsImNtZCIsInVwZ3JhZGVJZlNlY29uZGFyeUhlYWx0aHlfIiwic2Vjb25kYXJ5UmVzcG9uc2VzUmVxdWlyZWRfIiwicGFyc2VkRGF0YSIsImxheWVyIiwicHJvY2VlZFdpdGhVcGdyYWRlXyIsIm9uQ29udHJvbF8iLCJvbkRhdGFNZXNzYWdlXyIsIm9uUHJpbWFyeVJlc3BvbnNlXyIsInBheWxvYWQiLCJoYW5kc2hha2VQYXlsb2FkIiwiT2JqZWN0IiwiYXNzaWduIiwiaCIsIm9uSGFuZHNoYWtlXyIsIm9uQ29ubmVjdGlvblNodXRkb3duXyIsIm9uUmVzZXRfIiwic2VuZFBpbmdPblByaW1hcnlJZk5lY2Vzc2FyeV8iLCJoYW5kc2hha2UiLCJ0aW1lc3RhbXAiLCJzZXNzaW9uSWQiLCJvbkNvbm5lY3Rpb25Fc3RhYmxpc2hlZF8iLCJ0cnlTdGFydFVwZ3JhZGVfIiwic3RhcnRVcGdyYWRlXyIsImNsb3NlQ29ubmVjdGlvbnNfIiwiU2VydmVyQWN0aW9ucyIsInB1dCIsInBhdGhTdHJpbmciLCJvbkNvbXBsZXRlIiwiaGFzaCIsIm1lcmdlIiwicmVmcmVzaEF1dGhUb2tlbiIsInRva2VuIiwicmVmcmVzaEFwcENoZWNrVG9rZW4iLCJvbkRpc2Nvbm5lY3RQdXQiLCJvbkRpc2Nvbm5lY3RNZXJnZSIsIm9uRGlzY29ubmVjdENhbmNlbCIsInJlcG9ydFN0YXRzIiwic3RhdHMiLCJFdmVudEVtaXR0ZXIiLCJhbGxvd2VkRXZlbnRzXyIsImxpc3RlbmVyc18iLCJ0cmlnZ2VyIiwiZXZlbnRUeXBlIiwibGlzdGVuZXJzIiwiY29udGV4dCIsIm9uIiwidmFsaWRhdGVFdmVudFR5cGVfIiwiZXZlbnREYXRhIiwiZ2V0SW5pdGlhbEV2ZW50Iiwib2ZmIiwic3BsaWNlIiwiZmluZCIsImV0IiwiT25saW5lTW9uaXRvciIsIm9ubGluZV8iLCJnZXRJbnN0YW5jZSIsImN1cnJlbnRseU9ubGluZSIsIk1BWF9QQVRIX0RFUFRIIiwiTUFYX1BBVEhfTEVOR1RIX0JZVEVTIiwiUGF0aCIsInBhdGhPclN0cmluZyIsInBpZWNlTnVtIiwicGllY2VzXyIsInNwbGl0IiwiY29weVRvIiwicGllY2VOdW1fIiwibmV3RW1wdHlQYXRoIiwicGF0aEdldEZyb250IiwicGF0aCIsInBhdGhHZXRMZW5ndGgiLCJwYXRoUG9wRnJvbnQiLCJwYXRoR2V0QmFjayIsInBhdGhUb1VybEVuY29kZWRTdHJpbmciLCJlbmNvZGVVUklDb21wb25lbnQiLCJwYXRoU2xpY2UiLCJiZWdpbiIsInNsaWNlIiwicGF0aFBhcmVudCIsInBpZWNlcyIsInBhdGhDaGlsZCIsImNoaWxkUGF0aE9iaiIsImNoaWxkUGllY2VzIiwicGF0aElzRW1wdHkiLCJuZXdSZWxhdGl2ZVBhdGgiLCJvdXRlclBhdGgiLCJpbm5lclBhdGgiLCJvdXRlciIsImlubmVyIiwicGF0aENvbXBhcmUiLCJsZWZ0IiwicmlnaHQiLCJsZWZ0S2V5cyIsInJpZ2h0S2V5cyIsImNtcCIsInBhdGhFcXVhbHMiLCJvdGhlciIsImoiLCJwYXRoQ29udGFpbnMiLCJWYWxpZGF0aW9uUGF0aCIsImVycm9yUHJlZml4XyIsInBhcnRzXyIsImJ5dGVMZW5ndGhfIiwibWF4IiwidmFsaWRhdGlvblBhdGhDaGVja1ZhbGlkIiwidmFsaWRhdGlvblBhdGhQdXNoIiwidmFsaWRhdGlvblBhdGgiLCJjaGlsZCIsInZhbGlkYXRpb25QYXRoUG9wIiwibGFzdCIsInBvcCIsInZhbGlkYXRpb25QYXRoVG9FcnJvclN0cmluZyIsIlZpc2liaWxpdHlNb25pdG9yIiwiaGlkZGVuIiwidmlzaWJpbGl0eUNoYW5nZSIsInZpc2libGVfIiwidmlzaWJsZSIsIlJFQ09OTkVDVF9NSU5fREVMQVkiLCJSRUNPTk5FQ1RfTUFYX0RFTEFZX0RFRkFVTFQiLCJSRUNPTk5FQ1RfTUFYX0RFTEFZX0ZPUl9BRE1JTlMiLCJSRUNPTk5FQ1RfREVMQVlfTVVMVElQTElFUiIsIlJFQ09OTkVDVF9ERUxBWV9SRVNFVF9USU1FT1VUIiwiU0VSVkVSX0tJTExfSU5URVJSVVBUX1JFQVNPTiIsIklOVkFMSURfVE9LRU5fVEhSRVNIT0xEIiwiUGVyc2lzdGVudENvbm5lY3Rpb24iLCJvbkRhdGFVcGRhdGVfIiwib25Db25uZWN0U3RhdHVzXyIsIm9uU2VydmVySW5mb1VwZGF0ZV8iLCJhdXRoVG9rZW5Qcm92aWRlcl8iLCJhcHBDaGVja1Rva2VuUHJvdmlkZXJfIiwiYXV0aE92ZXJyaWRlXyIsIm5leHRQZXJzaXN0ZW50Q29ubmVjdGlvbklkXyIsImludGVycnVwdFJlYXNvbnNfIiwibGlzdGVucyIsIk1hcCIsIm91dHN0YW5kaW5nUHV0c18iLCJvdXRzdGFuZGluZ0dldHNfIiwib3V0c3RhbmRpbmdQdXRDb3VudF8iLCJvdXRzdGFuZGluZ0dldENvdW50XyIsIm9uRGlzY29ubmVjdFJlcXVlc3RRdWV1ZV8iLCJjb25uZWN0ZWRfIiwicmVjb25uZWN0RGVsYXlfIiwibWF4UmVjb25uZWN0RGVsYXlfIiwic2VjdXJpdHlEZWJ1Z0NhbGxiYWNrXyIsImVzdGFibGlzaENvbm5lY3Rpb25UaW1lcl8iLCJyZXF1ZXN0Q0JIYXNoXyIsInJlcXVlc3ROdW1iZXJfIiwicmVhbHRpbWVfIiwiZm9yY2VUb2tlblJlZnJlc2hfIiwiaW52YWxpZEF1dGhUb2tlbkNvdW50XyIsImludmFsaWRBcHBDaGVja1Rva2VuQ291bnRfIiwiZmlyc3RDb25uZWN0aW9uXyIsImxhc3RDb25uZWN0aW9uQXR0ZW1wdFRpbWVfIiwibGFzdENvbm5lY3Rpb25Fc3RhYmxpc2hlZFRpbWVfIiwib25WaXNpYmxlXyIsIm9uT25saW5lXyIsImFjdGlvbiIsIm9uUmVzcG9uc2UiLCJjdXJSZXFOdW0iLCJyIiwiaW5pdENvbm5lY3Rpb25fIiwiZGVmZXJyZWQiLCJyZXF1ZXN0IiwicCIsInEiLCJfcXVlcnlPYmplY3QiLCJvdXRzdGFuZGluZ0dldCIsImluZGV4Iiwic2VuZEdldF8iLCJwcm9taXNlIiwibGlzdGVuIiwiY3VycmVudEhhc2hGbiIsInRhZyIsInF1ZXJ5SWQiLCJfcXVlcnlJZGVudGlmaWVyIiwiaGFzIiwiX3F1ZXJ5UGFyYW1zIiwiaXNEZWZhdWx0IiwibG9hZHNBbGxEYXRhIiwibGlzdGVuU3BlYyIsImhhc2hGbiIsInNlbmRMaXN0ZW5fIiwicmVxIiwic3RhdHVzIiwid2Fybk9uTGlzdGVuV2FybmluZ3NfIiwiY3VycmVudExpc3RlblNwZWMiLCJyZW1vdmVMaXN0ZW5fIiwid2FybmluZ3MiLCJpbmRleFNwZWMiLCJnZXRJbmRleCIsImluZGV4UGF0aCIsInRyeUF1dGgiLCJyZWR1Y2VSZWNvbm5lY3REZWxheUlmQWRtaW5DcmVkZW50aWFsXyIsImNyZWRlbnRpYWwiLCJpc0ZpcmViYXNlU2VjcmV0IiwidHJ5QXBwQ2hlY2siLCJhdXRoTWV0aG9kIiwicmVxdWVzdERhdGEiLCJjcmVkIiwicmVzIiwib25BdXRoUmV2b2tlZF8iLCJvbkFwcENoZWNrUmV2b2tlZF8iLCJ1bmxpc3RlbiIsInNlbmRVbmxpc3Rlbl8iLCJxdWVyeU9iaiIsInNlbmRPbkRpc2Nvbm5lY3RfIiwicmVzcG9uc2UiLCJwdXRJbnRlcm5hbCIsInVuZGVmaW5lZCIsInNlbmRQdXRfIiwicXVldWVkIiwicmVzdWx0IiwiZXJyb3JSZWFzb24iLCJyZXFOdW0iLCJvbkRhdGFQdXNoXyIsIm9uTGlzdGVuUmV2b2tlZF8iLCJvblNlY3VyaXR5RGVidWdQYWNrZXRfIiwiRGF0ZSIsImdldFRpbWUiLCJoYW5kbGVUaW1lc3RhbXBfIiwic2VuZENvbm5lY3RTdGF0c18iLCJyZXN0b3JlU3RhdGVfIiwic2NoZWR1bGVDb25uZWN0XyIsImVzdGFibGlzaENvbm5lY3Rpb25fIiwib25saW5lIiwib25SZWFsdGltZURpc2Nvbm5lY3RfIiwiY2FuY2VsU2VudFRyYW5zYWN0aW9uc18iLCJzaG91bGRSZWNvbm5lY3RfIiwidGltZVNpbmNlTGFzdENvbm5lY3RTdWNjZWVkZWQiLCJ0aW1lU2luY2VMYXN0Q29ubmVjdEF0dGVtcHQiLCJyZWNvbm5lY3REZWxheSIsIm9uRGF0YU1lc3NhZ2UiLCJvblJlYWR5IiwibmV4dENvbm5lY3Rpb25JZF8iLCJjYW5jZWxlZCIsImNvbm5lY3Rpb24iLCJjbG9zZUZuIiwic2VuZFJlcXVlc3RGbiIsImFsbCIsImludGVycnVwdCIsInJlc3VtZSIsImRlbHRhIiwic2VydmVyVGltZU9mZnNldCIsIm5vcm1hbGl6ZWRQYXRoU3RyaW5nIiwic3RhdHVzQ29kZSIsImV4cGxhbmF0aW9uIiwiY29uc29sZSIsInJlcGxhY2UiLCJxdWVyaWVzIiwidmFsdWVzIiwiY2xpZW50TmFtZSIsIk5hbWVkTm9kZSIsIm5vZGUiLCJXcmFwIiwiSW5kZXgiLCJnZXRDb21wYXJlIiwiY29tcGFyZSIsImluZGV4ZWRWYWx1ZUNoYW5nZWQiLCJvbGROb2RlIiwibmV3Tm9kZSIsIm9sZFdyYXBwZWQiLCJuZXdXcmFwcGVkIiwibWluUG9zdCIsIk1JTiIsIl9fRU1QVFlfTk9ERSIsIktleUluZGV4IiwidmFsIiwiaXNEZWZpbmVkT24iLCJtYXhQb3N0IiwibWFrZVBvc3QiLCJpbmRleFZhbHVlIiwiS0VZX0lOREVYIiwiU29ydGVkTWFwSXRlcmF0b3IiLCJzdGFydEtleSIsImNvbXBhcmF0b3IiLCJpc1JldmVyc2VfIiwicmVzdWx0R2VuZXJhdG9yXyIsIm5vZGVTdGFja18iLCJnZXROZXh0IiwiaGFzTmV4dCIsInBlZWsiLCJMTFJCTm9kZSIsImNvbG9yIiwiUkVEIiwiU29ydGVkTWFwIiwiRU1QVFlfTk9ERSIsImNvcHkiLCJjb3VudCIsImlub3JkZXJUcmF2ZXJzYWwiLCJyZXZlcnNlVHJhdmVyc2FsIiwibWluXyIsIm1pbktleSIsIm1heEtleSIsImluc2VydCIsIm4iLCJmaXhVcF8iLCJyZW1vdmVNaW5fIiwiaXNSZWRfIiwibW92ZVJlZExlZnRfIiwic21hbGxlc3QiLCJyb3RhdGVSaWdodF8iLCJtb3ZlUmVkUmlnaHRfIiwicm90YXRlTGVmdF8iLCJjb2xvckZsaXBfIiwibmwiLCJuciIsImNoZWNrTWF4RGVwdGhfIiwiYmxhY2tEZXB0aCIsImNoZWNrXyIsIkJMQUNLIiwiTExSQkVtcHR5Tm9kZSIsImNvbXBhcmF0b3JfIiwicm9vdF8iLCJnZXRQcmVkZWNlc3NvcktleSIsInJpZ2h0UGFyZW50IiwiZ2V0SXRlcmF0b3IiLCJyZXN1bHRHZW5lcmF0b3IiLCJnZXRJdGVyYXRvckZyb20iLCJnZXRSZXZlcnNlSXRlcmF0b3JGcm9tIiwiZ2V0UmV2ZXJzZUl0ZXJhdG9yIiwiTkFNRV9PTkxZX0NPTVBBUkFUT1IiLCJOQU1FX0NPTVBBUkFUT1IiLCJNQVhfTk9ERSQyIiwic2V0TWF4Tm9kZSQxIiwicHJpb3JpdHlIYXNoVGV4dCIsInByaW9yaXR5IiwidmFsaWRhdGVQcmlvcml0eU5vZGUiLCJwcmlvcml0eU5vZGUiLCJpc0xlYWZOb2RlIiwiZ2V0UHJpb3JpdHkiLCJfX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yIiwiTGVhZk5vZGUiLCJ2YWx1ZV8iLCJwcmlvcml0eU5vZGVfIiwibGF6eUhhc2hfIiwidXBkYXRlUHJpb3JpdHkiLCJuZXdQcmlvcml0eU5vZGUiLCJnZXRJbW1lZGlhdGVDaGlsZCIsImNoaWxkTmFtZSIsImdldENoaWxkIiwiaGFzQ2hpbGQiLCJnZXRQcmVkZWNlc3NvckNoaWxkTmFtZSIsImNoaWxkTm9kZSIsInVwZGF0ZUltbWVkaWF0ZUNoaWxkIiwibmV3Q2hpbGROb2RlIiwidXBkYXRlQ2hpbGQiLCJmcm9udCIsIm51bUNoaWxkcmVuIiwiZm9yRWFjaENoaWxkIiwiZXhwb3J0Rm9ybWF0IiwiZ2V0VmFsdWUiLCJ0b0hhc2giLCJjb21wYXJlVG8iLCJjb21wYXJlVG9MZWFmTm9kZV8iLCJvdGhlckxlYWYiLCJvdGhlckxlYWZUeXBlIiwidGhpc0xlYWZUeXBlIiwib3RoZXJJbmRleCIsIlZBTFVFX1RZUEVfT1JERVIiLCJ0aGlzSW5kZXgiLCJ3aXRoSW5kZXgiLCJpc0luZGV4ZWQiLCJlcXVhbHMiLCJub2RlRnJvbUpTT04kMSIsIk1BWF9OT0RFJDEiLCJzZXROb2RlRnJvbUpTT04iLCJzZXRNYXhOb2RlIiwiUHJpb3JpdHlJbmRleCIsImFQcmlvcml0eSIsImJQcmlvcml0eSIsImluZGV4Q21wIiwiUFJJT1JJVFlfSU5ERVgiLCJMT0dfMiIsIkJhc2UxMk51bSIsImxvZ0Jhc2UyIiwibnVtIiwiYml0TWFzayIsImN1cnJlbnRfIiwibWFzayIsImJpdHNfIiwibmV4dEJpdElzT25lIiwiYnVpbGRDaGlsZFNldCIsImNoaWxkTGlzdCIsImtleUZuIiwibWFwU29ydEZuIiwiYnVpbGRCYWxhbmNlZFRyZWUiLCJsb3ciLCJoaWdoIiwibmFtZWROb2RlIiwibWlkZGxlIiwiYnVpbGRGcm9tMTJBcnJheSIsImJhc2UxMiIsInJvb3QiLCJidWlsZFBlbm5hbnQiLCJjaHVua1NpemUiLCJjaGlsZFRyZWUiLCJhdHRhY2hQZW5uYW50IiwicGVubmFudCIsImlzT25lIiwiX2RlZmF1bHRJbmRleE1hcCIsImZhbGxiYWNrT2JqZWN0IiwiSW5kZXhNYXAiLCJpbmRleGVzXyIsImluZGV4U2V0XyIsIkRlZmF1bHQiLCJpbmRleEtleSIsInNvcnRlZE1hcCIsImhhc0luZGV4IiwiaW5kZXhEZWZpbml0aW9uIiwiYWRkSW5kZXgiLCJleGlzdGluZ0NoaWxkcmVuIiwic2F3SW5kZXhlZFZhbHVlIiwiaXRlciIsIm5leHQiLCJuZXdJbmRleCIsImluZGV4TmFtZSIsIm5ld0luZGV4U2V0IiwibmV3SW5kZXhlcyIsImFkZFRvSW5kZXhlcyIsImluZGV4ZWRDaGlsZHJlbiIsImV4aXN0aW5nU25hcCIsIm5ld0NoaWxkcmVuIiwicmVtb3ZlRnJvbUluZGV4ZXMiLCJDaGlsZHJlbk5vZGUiLCJjaGlsZHJlbl8iLCJpbmRleE1hcF8iLCJuZXdJbmRleE1hcCIsIm5ld1ByaW9yaXR5IiwibmV3SW1tZWRpYXRlQ2hpbGQiLCJudW1LZXlzIiwiYWxsSW50ZWdlcktleXMiLCJhcnJheSIsImNoaWxkSGFzaCIsImlkeCIsInJlc29sdmVJbmRleF8iLCJwcmVkZWNlc3NvciIsImdldEZpcnN0Q2hpbGROYW1lIiwiZ2V0Rmlyc3RDaGlsZCIsImdldExhc3RDaGlsZE5hbWUiLCJnZXRMYXN0Q2hpbGQiLCJ3cmFwcGVkTm9kZSIsInN0YXJ0UG9zdCIsIml0ZXJhdG9yIiwiZW5kUG9zdCIsIk1BWF9OT0RFIiwib3RoZXJDaGlsZHJlbk5vZGUiLCJ0aGlzSXRlciIsIm90aGVySXRlciIsInRoaXNDdXJyZW50Iiwib3RoZXJDdXJyZW50IiwiTWF4Tm9kZSIsImRlZmluZVByb3BlcnRpZXMiLCJNQVgiLCJVU0VfSElOWkUiLCJub2RlRnJvbUpTT04iLCJqc29uIiwianNvbkxlYWYiLCJjaGlsZHJlbiIsImNoaWxkcmVuSGF2ZVByaW9yaXR5IiwiaGluemVKc29uT2JqIiwiY2hpbGRTZXQiLCJzb3J0ZWRDaGlsZFNldCIsImNoaWxkRGF0YSIsIlBhdGhJbmRleCIsImluZGV4UGF0aF8iLCJleHRyYWN0Q2hpbGQiLCJzbmFwIiwiYUNoaWxkIiwiYkNoaWxkIiwidmFsdWVOb2RlIiwiVmFsdWVJbmRleCIsIlZBTFVFX0lOREVYIiwiY2hhbmdlVmFsdWUiLCJzbmFwc2hvdE5vZGUiLCJjaGFuZ2VDaGlsZEFkZGVkIiwiY2hhbmdlQ2hpbGRSZW1vdmVkIiwiY2hhbmdlQ2hpbGRDaGFuZ2VkIiwib2xkU25hcCIsImNoYW5nZUNoaWxkTW92ZWQiLCJJbmRleGVkRmlsdGVyIiwiaW5kZXhfIiwibmV3Q2hpbGQiLCJhZmZlY3RlZFBhdGgiLCJzb3VyY2UiLCJvcHRDaGFuZ2VBY2N1bXVsYXRvciIsIm9sZENoaWxkIiwidHJhY2tDaGlsZENoYW5nZSIsInVwZGF0ZUZ1bGxOb2RlIiwibmV3U25hcCIsImZpbHRlcnNOb2RlcyIsImdldEluZGV4ZWRGaWx0ZXIiLCJSYW5nZWRGaWx0ZXIiLCJpbmRleGVkRmlsdGVyXyIsInN0YXJ0UG9zdF8iLCJnZXRTdGFydFBvc3RfIiwiZW5kUG9zdF8iLCJnZXRFbmRQb3N0XyIsInN0YXJ0SXNJbmNsdXNpdmVfIiwic3RhcnRBZnRlclNldF8iLCJlbmRJc0luY2x1c2l2ZV8iLCJlbmRCZWZvcmVTZXRfIiwiZ2V0U3RhcnRQb3N0IiwiZ2V0RW5kUG9zdCIsIm1hdGNoZXMiLCJpc1dpdGhpblN0YXJ0IiwiaXNXaXRoaW5FbmQiLCJmaWx0ZXJlZCIsInNlbGYiLCJoYXNTdGFydCIsInN0YXJ0TmFtZSIsImdldEluZGV4U3RhcnROYW1lIiwiZ2V0SW5kZXhTdGFydFZhbHVlIiwiaGFzRW5kIiwiZW5kTmFtZSIsImdldEluZGV4RW5kTmFtZSIsImdldEluZGV4RW5kVmFsdWUiLCJMaW1pdGVkRmlsdGVyIiwid2l0aGluRGlyZWN0aW9uYWxTdGFydCIsInJldmVyc2VfIiwid2l0aGluRW5kUG9zdCIsIndpdGhpblN0YXJ0UG9zdCIsIndpdGhpbkRpcmVjdGlvbmFsRW5kIiwiY29tcGFyZVJlcyIsInJhbmdlZEZpbHRlcl8iLCJsaW1pdF8iLCJnZXRMaW1pdCIsImlzVmlld0Zyb21MZWZ0IiwiZnVsbExpbWl0VXBkYXRlQ2hpbGRfIiwiaW5SYW5nZSIsImNoaWxkS2V5IiwiY2hpbGRTbmFwIiwiY2hhbmdlQWNjdW11bGF0b3IiLCJvbGRFdmVudENhY2hlIiwibmV3Q2hpbGROYW1lZE5vZGUiLCJ3aW5kb3dCb3VuZGFyeSIsIm9sZENoaWxkU25hcCIsIm5leHRDaGlsZCIsImdldENoaWxkQWZ0ZXJDaGlsZCIsImNvbXBhcmVOZXh0IiwicmVtYWluc0luV2luZG93IiwibmV3RXZlbnRDYWNoZSIsIm5leHRDaGlsZEluUmFuZ2UiLCJRdWVyeVBhcmFtcyIsImxpbWl0U2V0XyIsInN0YXJ0U2V0XyIsInN0YXJ0TmFtZVNldF8iLCJlbmRTZXRfIiwiZW5kTmFtZVNldF8iLCJ2aWV3RnJvbV8iLCJpbmRleFN0YXJ0VmFsdWVfIiwiaW5kZXhTdGFydE5hbWVfIiwiaW5kZXhFbmRWYWx1ZV8iLCJpbmRleEVuZE5hbWVfIiwiaGFzTGltaXQiLCJoYXNBbmNob3JlZExpbWl0IiwicXVlcnlQYXJhbXNHZXROb2RlRmlsdGVyIiwicXVlcnlQYXJhbXMiLCJxdWVyeVBhcmFtc0xpbWl0VG9GaXJzdCIsIm5ld0xpbWl0IiwibmV3UGFyYW1zIiwicXVlcnlQYXJhbXNMaW1pdFRvTGFzdCIsInF1ZXJ5UGFyYW1zU3RhcnRBdCIsInF1ZXJ5UGFyYW1zU3RhcnRBZnRlciIsInF1ZXJ5UGFyYW1zRW5kQXQiLCJxdWVyeVBhcmFtc0VuZEJlZm9yZSIsInF1ZXJ5UGFyYW1zT3JkZXJCeSIsInF1ZXJ5UGFyYW1zVG9SZXN0UXVlcnlTdHJpbmdQYXJhbWV0ZXJzIiwicXMiLCJvcmRlckJ5Iiwic3RhcnRQYXJhbSIsImVuZFBhcmFtIiwicXVlcnlQYXJhbXNHZXRRdWVyeU9iamVjdCIsInZpZXdGcm9tIiwiUmVhZG9ubHlSZXN0Q2xpZW50IiwibGlzdGVuc18iLCJnZXRMaXN0ZW5JZF8iLCJsaXN0ZW5JZCIsInRoaXNMaXN0ZW4iLCJxdWVyeVN0cmluZ1BhcmFtZXRlcnMiLCJyZXN0UmVxdWVzdF8iLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsInJlc3BvbnNlVGV4dCIsIlNuYXBzaG90SG9sZGVyIiwicm9vdE5vZGVfIiwiZ2V0Tm9kZSIsInVwZGF0ZVNuYXBzaG90IiwibmV3U25hcHNob3ROb2RlIiwibmV3U3BhcnNlU25hcHNob3RUcmVlIiwic3BhcnNlU25hcHNob3RUcmVlUmVtZW1iZXIiLCJzcGFyc2VTbmFwc2hvdFRyZWUiLCJjbGVhciIsInNwYXJzZVNuYXBzaG90VHJlZUZvcmdldCIsInRyZWUiLCJzYWZlVG9SZW1vdmUiLCJzcGFyc2VTbmFwc2hvdFRyZWVGb3JFYWNoVHJlZSIsInByZWZpeFBhdGgiLCJmdW5jIiwic3BhcnNlU25hcHNob3RUcmVlRm9yRWFjaENoaWxkIiwiZm9yRWFjaCIsIlN0YXRzTGlzdGVuZXIiLCJjb2xsZWN0aW9uXyIsImxhc3RfIiwibmV3U3RhdHMiLCJzdGF0IiwiRklSU1RfU1RBVFNfTUlOX1RJTUUiLCJGSVJTVF9TVEFUU19NQVhfVElNRSIsIlJFUE9SVF9TVEFUU19JTlRFUlZBTCIsIlN0YXRzUmVwb3J0ZXIiLCJjb2xsZWN0aW9uIiwic2VydmVyXyIsInN0YXRzVG9SZXBvcnRfIiwic3RhdHNMaXN0ZW5lcl8iLCJyZXBvcnRTdGF0c18iLCJyZXBvcnRlZFN0YXRzIiwiaGF2ZVN0YXRzVG9SZXBvcnQiLCJPcGVyYXRpb25UeXBlIiwibmV3T3BlcmF0aW9uU291cmNlVXNlciIsImZyb21Vc2VyIiwiZnJvbVNlcnZlciIsInRhZ2dlZCIsIm5ld09wZXJhdGlvblNvdXJjZVNlcnZlciIsIm5ld09wZXJhdGlvblNvdXJjZVNlcnZlclRhZ2dlZFF1ZXJ5IiwiQWNrVXNlcldyaXRlIiwiYWZmZWN0ZWRUcmVlIiwicmV2ZXJ0IiwiQUNLX1VTRVJfV1JJVEUiLCJvcGVyYXRpb25Gb3JDaGlsZCIsInN1YnRyZWUiLCJMaXN0ZW5Db21wbGV0ZSIsIkxJU1RFTl9DT01QTEVURSIsIk92ZXJ3cml0ZSIsIk9WRVJXUklURSIsIk1lcmdlIiwiTUVSR0UiLCJDYWNoZU5vZGUiLCJub2RlXyIsImZ1bGx5SW5pdGlhbGl6ZWRfIiwiZmlsdGVyZWRfIiwiaXNGdWxseUluaXRpYWxpemVkIiwiaXNGaWx0ZXJlZCIsImlzQ29tcGxldGVGb3JQYXRoIiwiaXNDb21wbGV0ZUZvckNoaWxkIiwiRXZlbnRHZW5lcmF0b3IiLCJxdWVyeV8iLCJldmVudEdlbmVyYXRvckdlbmVyYXRlRXZlbnRzRm9yQ2hhbmdlcyIsImV2ZW50R2VuZXJhdG9yIiwiY2hhbmdlcyIsImV2ZW50Q2FjaGUiLCJldmVudFJlZ2lzdHJhdGlvbnMiLCJldmVudHMiLCJtb3ZlcyIsImNoYW5nZSIsImV2ZW50R2VuZXJhdG9yR2VuZXJhdGVFdmVudHNGb3JUeXBlIiwicmVnaXN0cmF0aW9ucyIsImZpbHRlcmVkQ2hhbmdlcyIsImZpbHRlciIsImV2ZW50R2VuZXJhdG9yQ29tcGFyZUNoYW5nZXMiLCJtYXRlcmlhbGl6ZWRDaGFuZ2UiLCJldmVudEdlbmVyYXRvck1hdGVyaWFsaXplU2luZ2xlQ2hhbmdlIiwicmVnaXN0cmF0aW9uIiwicmVzcG9uZHNUbyIsImNyZWF0ZUV2ZW50IiwicHJldk5hbWUiLCJhV3JhcHBlZCIsImJXcmFwcGVkIiwibmV3Vmlld0NhY2hlIiwic2VydmVyQ2FjaGUiLCJ2aWV3Q2FjaGVVcGRhdGVFdmVudFNuYXAiLCJ2aWV3Q2FjaGUiLCJldmVudFNuYXAiLCJjb21wbGV0ZSIsInZpZXdDYWNoZVVwZGF0ZVNlcnZlclNuYXAiLCJzZXJ2ZXJTbmFwIiwidmlld0NhY2hlR2V0Q29tcGxldGVFdmVudFNuYXAiLCJ2aWV3Q2FjaGVHZXRDb21wbGV0ZVNlcnZlclNuYXAiLCJlbXB0eUNoaWxkcmVuU2luZ2xldG9uIiwiRW1wdHlDaGlsZHJlbiIsIkltbXV0YWJsZVRyZWUiLCJmcm9tT2JqZWN0IiwiY2hpbGRQYXRoIiwiZmluZFJvb3RNb3N0TWF0Y2hpbmdQYXRoQW5kVmFsdWUiLCJyZWxhdGl2ZVBhdGgiLCJwcmVkaWNhdGUiLCJjaGlsZEV4aXN0aW5nUGF0aEFuZFZhbHVlIiwiZnVsbFBhdGgiLCJmaW5kUm9vdE1vc3RWYWx1ZUFuZFBhdGgiLCJ0b1NldCIsInNldFRyZWUiLCJuZXdUcmVlIiwiZm9sZCIsImZvbGRfIiwicGF0aFNvRmFyIiwiYWNjdW0iLCJmaW5kT25QYXRoIiwiZmluZE9uUGF0aF8iLCJwYXRoVG9Gb2xsb3ciLCJmb3JlYWNoT25QYXRoIiwiZm9yZWFjaE9uUGF0aF8iLCJjdXJyZW50UmVsYXRpdmVQYXRoIiwiZm9yZWFjaCIsImZvcmVhY2hfIiwiZm9yZWFjaENoaWxkIiwiQ29tcG91bmRXcml0ZSIsIndyaXRlVHJlZV8iLCJlbXB0eSIsImNvbXBvdW5kV3JpdGVBZGRXcml0ZSIsImNvbXBvdW5kV3JpdGUiLCJyb290bW9zdCIsInJvb3RNb3N0UGF0aCIsIm5ld1dyaXRlVHJlZSIsImNvbXBvdW5kV3JpdGVBZGRXcml0ZXMiLCJ1cGRhdGVzIiwibmV3V3JpdGUiLCJjb21wb3VuZFdyaXRlUmVtb3ZlV3JpdGUiLCJjb21wb3VuZFdyaXRlSGFzQ29tcGxldGVXcml0ZSIsImNvbXBvdW5kV3JpdGVHZXRDb21wbGV0ZU5vZGUiLCJjb21wb3VuZFdyaXRlR2V0Q29tcGxldGVDaGlsZHJlbiIsImNvbXBvdW5kV3JpdGVDaGlsZENvbXBvdW5kV3JpdGUiLCJzaGFkb3dpbmdOb2RlIiwiY29tcG91bmRXcml0ZUlzRW1wdHkiLCJjb21wb3VuZFdyaXRlQXBwbHkiLCJhcHBseVN1YnRyZWVXcml0ZSIsIndyaXRlVHJlZSIsInByaW9yaXR5V3JpdGUiLCJ3cml0ZVRyZWVDaGlsZFdyaXRlcyIsIm5ld1dyaXRlVHJlZVJlZiIsIndyaXRlVHJlZUFkZE92ZXJ3cml0ZSIsIndyaXRlSWQiLCJsYXN0V3JpdGVJZCIsImFsbFdyaXRlcyIsInZpc2libGVXcml0ZXMiLCJ3cml0ZVRyZWVBZGRNZXJnZSIsImNoYW5nZWRDaGlsZHJlbiIsIndyaXRlVHJlZUdldFdyaXRlIiwicmVjb3JkIiwid3JpdGVUcmVlUmVtb3ZlV3JpdGUiLCJmaW5kSW5kZXgiLCJ3cml0ZVRvUmVtb3ZlIiwicmVtb3ZlZFdyaXRlV2FzVmlzaWJsZSIsInJlbW92ZWRXcml0ZU92ZXJsYXBzV2l0aE90aGVyV3JpdGVzIiwiY3VycmVudFdyaXRlIiwid3JpdGVUcmVlUmVjb3JkQ29udGFpbnNQYXRoXyIsIndyaXRlVHJlZVJlc2V0VHJlZV8iLCJ3cml0ZVJlY29yZCIsIndyaXRlVHJlZUxheWVyVHJlZV8iLCJ3cml0ZVRyZWVEZWZhdWx0RmlsdGVyXyIsIndyaXRlcyIsInRyZWVSb290Iiwid3JpdGVQYXRoIiwiZGVlcE5vZGUiLCJ3cml0ZVRyZWVDYWxjQ29tcGxldGVFdmVudENhY2hlIiwidHJlZVBhdGgiLCJjb21wbGV0ZVNlcnZlckNhY2hlIiwid3JpdGVJZHNUb0V4Y2x1ZGUiLCJpbmNsdWRlSGlkZGVuV3JpdGVzIiwic3ViTWVyZ2UiLCJsYXllcmVkQ2FjaGUiLCJtZXJnZUF0UGF0aCIsIndyaXRlVHJlZUNhbGNDb21wbGV0ZUV2ZW50Q2hpbGRyZW4iLCJjb21wbGV0ZVNlcnZlckNoaWxkcmVuIiwiY29tcGxldGVDaGlsZHJlbiIsInRvcExldmVsU2V0Iiwid3JpdGVUcmVlQ2FsY0V2ZW50Q2FjaGVBZnRlclNlcnZlck92ZXJ3cml0ZSIsImV4aXN0aW5nRXZlbnRTbmFwIiwiZXhpc3RpbmdTZXJ2ZXJTbmFwIiwiY2hpbGRNZXJnZSIsIndyaXRlVHJlZUNhbGNDb21wbGV0ZUNoaWxkIiwid3JpdGVUcmVlU2hhZG93aW5nV3JpdGUiLCJ3cml0ZVRyZWVDYWxjSW5kZXhlZFNsaWNlIiwiY29tcGxldGVTZXJ2ZXJEYXRhIiwidG9JdGVyYXRlIiwibm9kZXMiLCJ3cml0ZVRyZWVSZWZDYWxjQ29tcGxldGVFdmVudENhY2hlIiwid3JpdGVUcmVlUmVmIiwid3JpdGVUcmVlUmVmQ2FsY0NvbXBsZXRlRXZlbnRDaGlsZHJlbiIsIndyaXRlVHJlZVJlZkNhbGNFdmVudENhY2hlQWZ0ZXJTZXJ2ZXJPdmVyd3JpdGUiLCJ3cml0ZVRyZWVSZWZTaGFkb3dpbmdXcml0ZSIsIndyaXRlVHJlZVJlZkNhbGNJbmRleGVkU2xpY2UiLCJ3cml0ZVRyZWVSZWZDYWxjQ29tcGxldGVDaGlsZCIsImV4aXN0aW5nU2VydmVyQ2FjaGUiLCJ3cml0ZVRyZWVSZWZDaGlsZCIsIkNoaWxkQ2hhbmdlQWNjdW11bGF0b3IiLCJjaGFuZ2VNYXAiLCJvbGRDaGFuZ2UiLCJvbGRUeXBlIiwiZ2V0Q2hhbmdlcyIsImZyb20iLCJOb0NvbXBsZXRlQ2hpbGRTb3VyY2VfIiwiZ2V0Q29tcGxldGVDaGlsZCIsIk5PX0NPTVBMRVRFX0NISUxEX1NPVVJDRSIsIldyaXRlVHJlZUNvbXBsZXRlQ2hpbGRTb3VyY2UiLCJ3cml0ZXNfIiwidmlld0NhY2hlXyIsIm9wdENvbXBsZXRlU2VydmVyQ2FjaGVfIiwic2VydmVyTm9kZSIsIm5ld1ZpZXdQcm9jZXNzb3IiLCJ2aWV3UHJvY2Vzc29yQXNzZXJ0SW5kZXhlZCIsInZpZXdQcm9jZXNzb3IiLCJ2aWV3UHJvY2Vzc29yQXBwbHlPcGVyYXRpb24iLCJvbGRWaWV3Q2FjaGUiLCJvcGVyYXRpb24iLCJ3cml0ZXNDYWNoZSIsImNvbXBsZXRlQ2FjaGUiLCJhY2N1bXVsYXRvciIsImZpbHRlclNlcnZlck5vZGUiLCJvdmVyd3JpdGUiLCJ2aWV3UHJvY2Vzc29yQXBwbHlVc2VyT3ZlcndyaXRlIiwidmlld1Byb2Nlc3NvckFwcGx5U2VydmVyT3ZlcndyaXRlIiwidmlld1Byb2Nlc3NvckFwcGx5VXNlck1lcmdlIiwidmlld1Byb2Nlc3NvckFwcGx5U2VydmVyTWVyZ2UiLCJhY2tVc2VyV3JpdGUiLCJ2aWV3UHJvY2Vzc29yQWNrVXNlcldyaXRlIiwidmlld1Byb2Nlc3NvclJldmVydFVzZXJXcml0ZSIsInZpZXdQcm9jZXNzb3JMaXN0ZW5Db21wbGV0ZSIsInZpZXdQcm9jZXNzb3JNYXliZUFkZFZhbHVlRXZlbnQiLCJpc0xlYWZPckVtcHR5Iiwib2xkQ29tcGxldGVTbmFwIiwidmlld1Byb2Nlc3NvckdlbmVyYXRlRXZlbnRDYWNoZUFmdGVyU2VydmVyRXZlbnQiLCJjaGFuZ2VQYXRoIiwib2xkRXZlbnRTbmFwIiwiY29tcGxldGVFdmVudENoaWxkcmVuIiwiY29tcGxldGVOb2RlIiwib2xkRXZlbnROb2RlIiwidXBkYXRlZFByaW9yaXR5IiwiY2hpbGRDaGFuZ2VQYXRoIiwibmV3RXZlbnRDaGlsZCIsImV2ZW50Q2hpbGRVcGRhdGUiLCJjaGFuZ2VkU25hcCIsIm9sZFNlcnZlclNuYXAiLCJuZXdTZXJ2ZXJDYWNoZSIsInNlcnZlckZpbHRlciIsIm5ld1NlcnZlck5vZGUiLCJuZXdFdmVudFNuYXAiLCJ2aWV3UHJvY2Vzc29yQ2FjaGVIYXNDaGlsZCIsImN1clZpZXdDYWNoZSIsInZpZXdQcm9jZXNzb3JBcHBseU1lcmdlIiwidmlld01lcmdlVHJlZSIsInNlcnZlckNoaWxkIiwiY2hpbGRNZXJnZVRyZWUiLCJpc1Vua25vd25EZWVwTWVyZ2UiLCJhY2tQYXRoIiwibWVyZ2VQYXRoIiwic2VydmVyQ2FjaGVQYXRoIiwib2xkU2VydmVyTm9kZSIsInNlcnZlckNoaWxkcmVuIiwiVmlldyIsImluaXRpYWxWaWV3Q2FjaGUiLCJldmVudFJlZ2lzdHJhdGlvbnNfIiwiaW5kZXhGaWx0ZXIiLCJwcm9jZXNzb3JfIiwiaW5pdGlhbFNlcnZlckNhY2hlIiwiaW5pdGlhbEV2ZW50Q2FjaGUiLCJldmVudEdlbmVyYXRvcl8iLCJ2aWV3R2V0U2VydmVyQ2FjaGUiLCJ2aWV3Iiwidmlld0dldENvbXBsZXRlTm9kZSIsInZpZXdHZXRDb21wbGV0ZVNlcnZlckNhY2hlIiwiY2FjaGUiLCJ2aWV3SXNFbXB0eSIsInZpZXdBZGRFdmVudFJlZ2lzdHJhdGlvbiIsImV2ZW50UmVnaXN0cmF0aW9uIiwidmlld1JlbW92ZUV2ZW50UmVnaXN0cmF0aW9uIiwiY2FuY2VsRXJyb3IiLCJjYW5jZWxFdmVudHMiLCJtYXliZUV2ZW50IiwiY3JlYXRlQ2FuY2VsRXZlbnQiLCJyZW1haW5pbmciLCJleGlzdGluZyIsImhhc0FueUNhbGxiYWNrIiwiY29uY2F0Iiwidmlld0FwcGx5T3BlcmF0aW9uIiwidmlld0dlbmVyYXRlRXZlbnRzRm9yQ2hhbmdlc18iLCJ2aWV3R2V0SW5pdGlhbEV2ZW50cyIsImluaXRpYWxDaGFuZ2VzIiwiZXZlbnROb2RlIiwicmVmZXJlbmNlQ29uc3RydWN0b3IkMSIsIlN5bmNQb2ludCIsInZpZXdzIiwic3luY1BvaW50U2V0UmVmZXJlbmNlQ29uc3RydWN0b3IiLCJzeW5jUG9pbnRHZXRSZWZlcmVuY2VDb25zdHJ1Y3RvciIsInN5bmNQb2ludElzRW1wdHkiLCJzeW5jUG9pbnQiLCJzeW5jUG9pbnRBcHBseU9wZXJhdGlvbiIsIm9wdENvbXBsZXRlU2VydmVyQ2FjaGUiLCJzeW5jUG9pbnRHZXRWaWV3Iiwic2VydmVyQ2FjaGVDb21wbGV0ZSIsImV2ZW50Q2FjaGVDb21wbGV0ZSIsInN5bmNQb2ludEFkZEV2ZW50UmVnaXN0cmF0aW9uIiwic3luY1BvaW50UmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24iLCJyZW1vdmVkIiwiaGFkQ29tcGxldGVWaWV3Iiwic3luY1BvaW50SGFzQ29tcGxldGVWaWV3Iiwidmlld1F1ZXJ5SWQiLCJlbnRyaWVzIiwiX3JlcG8iLCJzeW5jUG9pbnRHZXRRdWVyeVZpZXdzIiwic3luY1BvaW50R2V0Q29tcGxldGVTZXJ2ZXJDYWNoZSIsInN5bmNQb2ludFZpZXdGb3JRdWVyeSIsInN5bmNQb2ludEdldENvbXBsZXRlVmlldyIsInN5bmNQb2ludFZpZXdFeGlzdHNGb3JRdWVyeSIsInJlZmVyZW5jZUNvbnN0cnVjdG9yIiwic3luY1RyZWVTZXRSZWZlcmVuY2VDb25zdHJ1Y3RvciIsInN5bmNUcmVlR2V0UmVmZXJlbmNlQ29uc3RydWN0b3IiLCJzeW5jVHJlZU5leHRRdWVyeVRhZ18iLCJTeW5jVHJlZSIsImxpc3RlblByb3ZpZGVyXyIsInN5bmNQb2ludFRyZWVfIiwicGVuZGluZ1dyaXRlVHJlZV8iLCJ0YWdUb1F1ZXJ5TWFwIiwicXVlcnlUb1RhZ01hcCIsInN5bmNUcmVlQXBwbHlVc2VyT3ZlcndyaXRlIiwic3luY1RyZWUiLCJuZXdEYXRhIiwic3luY1RyZWVBcHBseU9wZXJhdGlvblRvU3luY1BvaW50c18iLCJzeW5jVHJlZUFwcGx5VXNlck1lcmdlIiwiY2hhbmdlVHJlZSIsInN5bmNUcmVlQWNrVXNlcldyaXRlIiwibmVlZFRvUmVldmFsdWF0ZSIsInN5bmNUcmVlQXBwbHlTZXJ2ZXJPdmVyd3JpdGUiLCJzeW5jVHJlZUFwcGx5U2VydmVyTWVyZ2UiLCJzeW5jVHJlZUFwcGx5TGlzdGVuQ29tcGxldGUiLCJzeW5jVHJlZUFwcGx5VGFnZ2VkTGlzdGVuQ29tcGxldGUiLCJxdWVyeUtleSIsInN5bmNUcmVlUXVlcnlLZXlGb3JUYWdfIiwic3luY1RyZWVQYXJzZVF1ZXJ5S2V5XyIsInF1ZXJ5UGF0aCIsIm9wIiwic3luY1RyZWVBcHBseVRhZ2dlZE9wZXJhdGlvbl8iLCJzeW5jVHJlZVJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uIiwic2tpcExpc3RlbmVyRGVkdXAiLCJtYXliZVN5bmNQb2ludCIsInJlbW92ZWRBbmRFdmVudHMiLCJyZW1vdmluZ0RlZmF1bHQiLCJjb3ZlcmVkIiwicGFyZW50U3luY1BvaW50IiwibmV3Vmlld3MiLCJzeW5jVHJlZUNvbGxlY3REaXN0aW5jdFZpZXdzRm9yU3ViVHJlZV8iLCJuZXdRdWVyeSIsInN5bmNUcmVlQ3JlYXRlTGlzdGVuZXJGb3JWaWV3XyIsInN0YXJ0TGlzdGVuaW5nIiwic3luY1RyZWVRdWVyeUZvckxpc3RlbmluZ18iLCJzeW5jVHJlZVRhZ0ZvclF1ZXJ5IiwiZGVmYXVsdFRhZyIsInN0b3BMaXN0ZW5pbmciLCJxdWVyeVRvUmVtb3ZlIiwidGFnVG9SZW1vdmUiLCJzeW5jVHJlZU1ha2VRdWVyeUtleV8iLCJzeW5jVHJlZVJlbW92ZVRhZ3NfIiwic3luY1RyZWVBcHBseVRhZ2dlZFF1ZXJ5T3ZlcndyaXRlIiwic3luY1RyZWVBcHBseVRhZ2dlZFF1ZXJ5TWVyZ2UiLCJzeW5jVHJlZUFkZEV2ZW50UmVnaXN0cmF0aW9uIiwic2tpcFNldHVwTGlzdGVuZXIiLCJmb3VuZEFuY2VzdG9yRGVmYXVsdFZpZXciLCJwYXRoVG9TeW5jUG9pbnQiLCJzcCIsImNoaWxkU3luY1BvaW50Iiwidmlld0FscmVhZHlFeGlzdHMiLCJzeW5jVHJlZUdldE5leHRRdWVyeVRhZ18iLCJzeW5jVHJlZVNldHVwTGlzdGVuZXJfIiwic3luY1RyZWVDYWxjQ29tcGxldGVFdmVudENhY2hlIiwiaW5jbHVkZUhpZGRlblNldHMiLCJzeW5jVHJlZUdldFNlcnZlclZhbHVlIiwic2VydmVyQ2FjaGVOb2RlIiwic3luY1RyZWVBcHBseU9wZXJhdGlvbkhlbHBlcl8iLCJzeW5jUG9pbnRUcmVlIiwic3luY1RyZWVBcHBseU9wZXJhdGlvbkRlc2NlbmRhbnRzSGVscGVyXyIsImNoaWxkT3BlcmF0aW9uIiwiY2hpbGRTZXJ2ZXJDYWNoZSIsImNoaWxkV3JpdGVzQ2FjaGUiLCJzcGxpdEluZGV4IiwibWF5YmVDaGlsZFN5bmNQb2ludCIsImNoaWxkTWFwIiwiY29tcGxldGVWaWV3IiwiX2tleSIsImNoaWxkVmlld3MiLCJyZW1vdmVkUXVlcnkiLCJyZW1vdmVkUXVlcnlLZXkiLCJyZW1vdmVkUXVlcnlUYWciLCJxdWVyaWVzVG9TdG9wIiwiY2hpbGRRdWVyaWVzIiwicXVlcnlUb1N0b3AiLCJFeGlzdGluZ1ZhbHVlUHJvdmlkZXIiLCJEZWZlcnJlZFZhbHVlUHJvdmlkZXIiLCJzeW5jVHJlZV8iLCJwYXRoXyIsImdlbmVyYXRlV2l0aFZhbHVlcyIsInJlc29sdmVEZWZlcnJlZExlYWZWYWx1ZSIsImV4aXN0aW5nVmFsIiwic2VydmVyVmFsdWVzIiwicmVzb2x2ZVNjYWxhckRlZmVycmVkVmFsdWUiLCJyZXNvbHZlQ29tcGxleERlZmVycmVkVmFsdWUiLCJKU09OIiwidW51c2VkIiwiZXhpc3RpbmdOb2RlIiwibGVhZiIsInJlc29sdmVEZWZlcnJlZFZhbHVlVHJlZSIsInJlc29sdmVEZWZlcnJlZFZhbHVlIiwicmVzb2x2ZURlZmVycmVkVmFsdWVTbmFwc2hvdCIsInJhd1ByaSIsImxlYWZOb2RlIiwiY2hpbGRyZW5Ob2RlIiwiVHJlZSIsInBhcmVudCIsImNoaWxkQ291bnQiLCJ0cmVlU3ViVHJlZSIsInBhdGhPYmoiLCJ0cmVlR2V0VmFsdWUiLCJ0cmVlU2V0VmFsdWUiLCJ0cmVlVXBkYXRlUGFyZW50cyIsInRyZWVIYXNDaGlsZHJlbiIsInRyZWVJc0VtcHR5IiwidHJlZUZvckVhY2hDaGlsZCIsInRyZWVGb3JFYWNoRGVzY2VuZGFudCIsImluY2x1ZGVTZWxmIiwiY2hpbGRyZW5GaXJzdCIsInRyZWVGb3JFYWNoQW5jZXN0b3IiLCJ0cmVlR2V0UGF0aCIsInRyZWVVcGRhdGVDaGlsZCIsImNoaWxkRW1wdHkiLCJjaGlsZEV4aXN0cyIsIklOVkFMSURfS0VZX1JFR0VYXyIsIklOVkFMSURfUEFUSF9SRUdFWF8iLCJNQVhfTEVBRl9TSVpFXyIsImlzVmFsaWRLZXkiLCJpc1ZhbGlkUGF0aFN0cmluZyIsImlzVmFsaWRSb290UGF0aFN0cmluZyIsImlzVmFsaWRQcmlvcml0eSIsInZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnIiwiZm5OYW1lIiwidmFsaWRhdGVGaXJlYmFzZURhdGEiLCJoYXNEb3RWYWx1ZSIsImhhc0FjdHVhbENoaWxkIiwidmFsaWRhdGVGaXJlYmFzZU1lcmdlUGF0aHMiLCJtZXJnZVBhdGhzIiwiY3VyUGF0aCIsInByZXZQYXRoIiwidmFsaWRhdGVGaXJlYmFzZU1lcmdlRGF0YUFyZyIsImVycm9yUHJlZml4JDEiLCJ2YWxpZGF0ZVByaW9yaXR5IiwidmFsaWRhdGVLZXkiLCJhcmd1bWVudE5hbWUiLCJ2YWxpZGF0ZVBhdGhTdHJpbmciLCJ2YWxpZGF0ZVJvb3RQYXRoU3RyaW5nIiwidmFsaWRhdGVXcml0YWJsZVBhdGgiLCJ2YWxpZGF0ZVVybCIsInBhcnNlZFVybCIsIkV2ZW50UXVldWUiLCJldmVudExpc3RzXyIsInJlY3Vyc2lvbkRlcHRoXyIsImV2ZW50UXVldWVRdWV1ZUV2ZW50cyIsImV2ZW50UXVldWUiLCJldmVudERhdGFMaXN0IiwiY3Vyckxpc3QiLCJnZXRQYXRoIiwiZXZlbnRRdWV1ZVJhaXNlRXZlbnRzQXRQYXRoIiwiZXZlbnRRdWV1ZVJhaXNlUXVldWVkRXZlbnRzTWF0Y2hpbmdQcmVkaWNhdGUiLCJldmVudFBhdGgiLCJldmVudFF1ZXVlUmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aCIsImNoYW5nZWRQYXRoIiwic2VudEFsbCIsImV2ZW50TGlzdCIsImV2ZW50TGlzdFJhaXNlIiwiZXZlbnRGbiIsImdldEV2ZW50UnVubmVyIiwiSU5URVJSVVBUX1JFQVNPTiIsIk1BWF9UUkFOU0FDVElPTl9SRVRSSUVTIiwiUmVwbyIsImZvcmNlUmVzdENsaWVudF8iLCJhcHBDaGVja1Byb3ZpZGVyXyIsImRhdGFVcGRhdGVDb3VudCIsImV2ZW50UXVldWVfIiwibmV4dFdyaXRlSWRfIiwiaW50ZXJjZXB0U2VydmVyRGF0YUNhbGxiYWNrXyIsInRyYW5zYWN0aW9uUXVldWVUcmVlXyIsInBlcnNpc3RlbnRDb25uZWN0aW9uXyIsInJlcG9TdGFydCIsInJlcG8iLCJhcHBJZCIsImF1dGhPdmVycmlkZSIsImlzTWVyZ2UiLCJyZXBvT25EYXRhVXBkYXRlIiwicmVwb09uQ29ubmVjdFN0YXR1cyIsImNvbm5lY3RTdGF0dXMiLCJyZXBvT25TZXJ2ZXJJbmZvVXBkYXRlIiwic3RhdHNSZXBvcnRlcl8iLCJpbmZvRGF0YV8iLCJpbmZvU3luY1RyZWVfIiwiaW5mb0V2ZW50cyIsInJlcG9VcGRhdGVJbmZvIiwic2VydmVyU3luY1RyZWVfIiwicmVwb1NlcnZlclRpbWUiLCJvZmZzZXROb2RlIiwib2Zmc2V0IiwicmVwb0dlbmVyYXRlU2VydmVyVmFsdWVzIiwidGFnZ2VkQ2hpbGRyZW4iLCJyYXciLCJ0YWdnZWRTbmFwIiwicmVwb1JlcnVuVHJhbnNhY3Rpb25zIiwicmVwb1J1bk9uRGlzY29ubmVjdEV2ZW50cyIsInJlcG9HZXROZXh0V3JpdGVJZCIsInJlcG9HZXRWYWx1ZSIsImNhY2hlZCIsImVyciIsInJlcG9Mb2ciLCJyZXBvU2V0V2l0aFByaW9yaXR5IiwibmV3VmFsIiwibmV3Tm9kZVVucmVzb2x2ZWQiLCJzdWNjZXNzIiwiY2xlYXJFdmVudHMiLCJyZXBvQ2FsbE9uQ29tcGxldGVDYWxsYmFjayIsInJlcG9BYm9ydFRyYW5zYWN0aW9ucyIsInJlcG9VcGRhdGUiLCJjaGlsZHJlblRvTWVyZ2UiLCJjaGFuZ2VkS2V5IiwiY2hhbmdlZFZhbHVlIiwicmVzb2x2ZWRPbkRpc2Nvbm5lY3RUcmVlIiwicmVzb2x2ZWQiLCJyZXBvT25EaXNjb25uZWN0Q2FuY2VsIiwicmVwb09uRGlzY29ubmVjdFNldCIsInJlcG9PbkRpc2Nvbm5lY3RTZXRXaXRoUHJpb3JpdHkiLCJyZXBvT25EaXNjb25uZWN0VXBkYXRlIiwicmVwb0FkZEV2ZW50Q2FsbGJhY2tGb3JRdWVyeSIsInJlcG9SZW1vdmVFdmVudENhbGxiYWNrRm9yUXVlcnkiLCJyZXBvSW50ZXJydXB0IiwicmVwb1Jlc3VtZSIsInJlcG9TdGFydFRyYW5zYWN0aW9uIiwidHJhbnNhY3Rpb25VcGRhdGUiLCJ1bndhdGNoZXIiLCJhcHBseUxvY2FsbHkiLCJ0cmFuc2FjdGlvbiIsIm9yZGVyIiwicmV0cnlDb3VudCIsImFib3J0UmVhc29uIiwiY3VycmVudFdyaXRlSWQiLCJjdXJyZW50SW5wdXRTbmFwc2hvdCIsImN1cnJlbnRPdXRwdXRTbmFwc2hvdFJhdyIsImN1cnJlbnRPdXRwdXRTbmFwc2hvdFJlc29sdmVkIiwiY3VycmVudFN0YXRlIiwicmVwb0dldExhdGVzdFN0YXRlIiwicXVldWVOb2RlIiwibm9kZVF1ZXVlIiwicHJpb3JpdHlGb3JOb2RlIiwiY3VycmVudE5vZGUiLCJyZXBvU2VuZFJlYWR5VHJhbnNhY3Rpb25zIiwiZXhjbHVkZVNldHMiLCJyZXBvUHJ1bmVDb21wbGV0ZWRUcmFuc2FjdGlvbnNCZWxvd05vZGUiLCJxdWV1ZSIsInJlcG9CdWlsZFRyYW5zYWN0aW9uUXVldWUiLCJhbGxSdW4iLCJldmVyeSIsInJlcG9TZW5kVHJhbnNhY3Rpb25RdWV1ZSIsInNldHNUb0lnbm9yZSIsInR4biIsImxhdGVzdFN0YXRlIiwic25hcFRvU2VuZCIsImxhdGVzdEhhc2giLCJkYXRhVG9TZW5kIiwicGF0aFRvU2VuZCIsImNhbGxiYWNrcyIsInJvb3RNb3N0VHJhbnNhY3Rpb25Ob2RlIiwicmVwb0dldEFuY2VzdG9yVHJhbnNhY3Rpb25Ob2RlIiwicmVwb1JlcnVuVHJhbnNhY3Rpb25RdWV1ZSIsInR4bnNUb1JlcnVuIiwiYWJvcnRUcmFuc2FjdGlvbiIsIm5ld0RhdGFOb2RlIiwiaGFzRXhwbGljaXRQcmlvcml0eSIsIm9sZFdyaXRlSWQiLCJuZXdOb2RlUmVzb2x2ZWQiLCJ0cmFuc2FjdGlvbk5vZGUiLCJ0cmFuc2FjdGlvblF1ZXVlIiwicmVwb0FnZ3JlZ2F0ZVRyYW5zYWN0aW9uUXVldWVzRm9yTm9kZSIsInRvIiwicmVwb0Fib3J0VHJhbnNhY3Rpb25zT25Ob2RlIiwibGFzdFNlbnQiLCJkZWNvZGVQYXRoIiwicGF0aFN0cmluZ0RlY29kZWQiLCJwaWVjZSIsImRlY29kZVVSSUNvbXBvbmVudCIsImRlY29kZVF1ZXJ5IiwicXVlcnlTdHJpbmciLCJyZXN1bHRzIiwiY2hhckF0Iiwic2VnbWVudCIsImt2IiwicGFyc2VSZXBvSW5mbyIsImRhdGFVUkwiLCJwYXJzZURhdGFiYXNlVVJMIiwic2NoZW1lIiwic3ViZG9tYWluIiwicG9ydCIsImNvbG9uSW5kIiwic2xhc2hJbmQiLCJxdWVzdGlvbk1hcmtJbmQiLCJob3N0V2l0aG91dFBvcnQiLCJkb3RJbmQiLCJQVVNIX0NIQVJTIiwibmV4dFB1c2hJZCIsImxhc3RQdXNoVGltZSIsImxhc3RSYW5kQ2hhcnMiLCJub3ciLCJkdXBsaWNhdGVUaW1lIiwidGltZVN0YW1wQ2hhcnMiLCJEYXRhRXZlbnQiLCJzbmFwc2hvdCIsInJlZiIsImdldEV2ZW50VHlwZSIsImV4cG9ydFZhbCIsIkNhbmNlbEV2ZW50IiwiQ2FsbGJhY2tDb250ZXh0Iiwic25hcHNob3RDYWxsYmFjayIsImNhbmNlbENhbGxiYWNrIiwib25WYWx1ZSIsImV4cERhdGFTbmFwc2hvdCIsInByZXZpb3VzQ2hpbGROYW1lIiwiY2FsbCIsIm9uQ2FuY2VsIiwiaGFzQ2FuY2VsQ2FsbGJhY2siLCJ1c2VyQ2FsbGJhY2siLCJPbkRpc2Nvbm5lY3QiLCJjYW5jZWwiLCJ3cmFwQ2FsbGJhY2siLCJzZXRXaXRoUHJpb3JpdHkiLCJRdWVyeUltcGwiLCJfb3JkZXJCeUNhbGxlZCIsIlJlZmVyZW5jZUltcGwiLCJpc0VxdWFsIiwic2FtZVJlcG8iLCJzYW1lUGF0aCIsInNhbWVRdWVyeUlkZW50aWZpZXIiLCJ0b0pTT04iLCJ2YWxpZGF0ZU5vUHJldmlvdXNPcmRlckJ5Q2FsbCIsInZhbGlkYXRlUXVlcnlFbmRwb2ludHMiLCJzdGFydE5vZGUiLCJlbmROb2RlIiwidG9vTWFueUFyZ3NFcnJvciIsIndyb25nQXJnVHlwZUVycm9yIiwidmFsaWRhdGVMaW1pdCIsInBhcmVudFBhdGgiLCJEYXRhU25hcHNob3QiLCJfbm9kZSIsIl9pbmRleCIsImNoaWxkUmVmIiwiZXhpc3RzIiwiaGFzQ2hpbGRyZW4iLCJkYiIsIl9jaGVja05vdERlbGV0ZWQiLCJfcm9vdCIsInJlZkZyb21VUkwiLCJwYXJzZWRVUkwiLCJ0aGVubmFibGVQdXNoUmVmIiwicHVzaFJlZiIsInNldFByaW9yaXR5IiwiY2FsbGJhY2tDb250ZXh0IiwiY29udGFpbmVyIiwiVmFsdWVFdmVudFJlZ2lzdHJhdGlvbiIsIkNoaWxkRXZlbnRSZWdpc3RyYXRpb24iLCJldmVudFRvQ2hlY2siLCJjYW5jZWxDYWxsYmFja09yTGlzdGVuT3B0aW9ucyIsIm9ubHlPbmNlIiwib25jZUNhbGxiYWNrIiwiZGF0YVNuYXBzaG90Iiwib25DaGlsZEFkZGVkIiwib25DaGlsZENoYW5nZWQiLCJvbkNoaWxkTW92ZWQiLCJvbkNoaWxkUmVtb3ZlZCIsImV4cENhbGxiYWNrIiwiUXVlcnlDb25zdHJhaW50IiwiUXVlcnlFbmRBdENvbnN0cmFpbnQiLCJfdmFsdWUiLCJfYXBwbHkiLCJlbmRBdCIsIlF1ZXJ5RW5kQmVmb3JlQ29uc3RyYWludCIsImVuZEJlZm9yZSIsIlF1ZXJ5U3RhcnRBdENvbnN0cmFpbnQiLCJzdGFydEF0IiwiUXVlcnlTdGFydEFmdGVyQ29uc3RyYWludCIsInN0YXJ0QWZ0ZXIiLCJRdWVyeUxpbWl0VG9GaXJzdENvbnN0cmFpbnQiLCJfbGltaXQiLCJsaW1pdFRvRmlyc3QiLCJsaW1pdCIsIlF1ZXJ5TGltaXRUb0xhc3RDb25zdHJhaW50IiwibGltaXRUb0xhc3QiLCJRdWVyeU9yZGVyQnlDaGlsZENvbnN0cmFpbnQiLCJwYXJzZWRQYXRoIiwib3JkZXJCeUNoaWxkIiwiUXVlcnlPcmRlckJ5S2V5Q29uc3RyYWludCIsImFyZ3VtZW50cyIsIm9yZGVyQnlLZXkiLCJRdWVyeU9yZGVyQnlQcmlvcml0eUNvbnN0cmFpbnQiLCJvcmRlckJ5UHJpb3JpdHkiLCJRdWVyeU9yZGVyQnlWYWx1ZUNvbnN0cmFpbnQiLCJvcmRlckJ5VmFsdWUiLCJRdWVyeUVxdWFsVG9WYWx1ZUNvbnN0cmFpbnQiLCJlcXVhbFRvIiwicXVlcnlDb25zdHJhaW50cyIsInF1ZXJ5SW1wbCIsImNvbnN0cmFpbnQiLCJGSVJFQkFTRV9EQVRBQkFTRV9FTVVMQVRPUl9IT1NUX1ZBUiIsInJlcG9zIiwidXNlUmVzdENsaWVudCIsInJlcG9NYW5hZ2VyQXBwbHlFbXVsYXRvclNldHRpbmdzIiwidG9rZW5Qcm92aWRlciIsInJlcG9NYW5hZ2VyRGF0YWJhc2VGcm9tQXBwIiwiYXBwIiwiYXV0aFByb3ZpZGVyIiwiZGJVcmwiLCJkYXRhYmFzZVVSTCIsInByb2plY3RJZCIsImlzRW11bGF0b3IiLCJkYkVtdWxhdG9ySG9zdCIsImF1dGhUb2tlblByb3ZpZGVyIiwicmVwb01hbmFnZXJDcmVhdGVSZXBvIiwiRGF0YWJhc2UiLCJyZXBvTWFuYWdlckRlbGV0ZVJlcG8iLCJhcHBOYW1lIiwiYXBwUmVwb3MiLCJyZXBvTWFuYWdlckZvcmNlUmVzdENsaWVudCIsImZvcmNlUmVzdENsaWVudCIsIl9yZXBvSW50ZXJuYWwiLCJfaW5zdGFuY2VTdGFydGVkIiwiX3Jvb3RJbnRlcm5hbCIsIl9kZWxldGUiLCJhcGlOYW1lIiwiY2hlY2tUcmFuc3BvcnRJbml0IiwiZm9yY2VXZWJTb2NrZXRzIiwiZm9yY2VMb25nUG9sbGluZyIsImdldERhdGFiYXNlIiwiaWRlbnRpZmllciIsImVtdWxhdG9yIiwiY29ubmVjdERhdGFiYXNlRW11bGF0b3IiLCJtb2NrVXNlclRva2VuIiwiZ29PZmZsaW5lIiwiZ29PbmxpbmUiLCJlbmFibGVMb2dnaW5nIiwicmVnaXN0ZXJEYXRhYmFzZSIsInZhcmlhbnQiLCJpbnN0YW5jZUlkZW50aWZpZXIiLCJnZXRQcm92aWRlciIsInNldE11bHRpcGxlSW5zdGFuY2VzIiwiU0VSVkVSX1RJTUVTVEFNUCIsInNlcnZlclRpbWVzdGFtcCIsImluY3JlbWVudCIsIlRyYW5zYWN0aW9uUmVzdWx0IiwiY29tbWl0dGVkIiwicnVuVHJhbnNhY3Rpb24iLCJwcm9taXNlQ29tcGxldGUiLCJwcm90b3R5cGUiLCJzaW1wbGVMaXN0ZW4iLCJlY2hvIiwib25FY2hvIiwiaGlqYWNrSGFzaCIsIm5ld0hhc2giLCJvbGRQdXQiLCJfaW5pdFN0YW5kYWxvbmUiLCJjdXN0b21BdXRoSW1wbCIsImN1c3RvbUFwcENoZWNrSW1wbCIsImNvbXBvbmVudENvbnRhaW5lciIsInNldENvbXBvbmVudCIsIkNsaWVudCIsIl9RdWVyeUltcGwiLCJfUXVlcnlQYXJhbXMiLCJfUmVmZXJlbmNlSW1wbCIsIl9URVNUX0FDQ0VTU19mb3JjZVJlc3RDbGllbnQiLCJfVEVTVF9BQ0NFU1NfaGlqYWNrSGFzaCIsIl9yZXBvTWFuYWdlckRhdGFiYXNlRnJvbUFwcCIsIl9zZXRTREtWZXJzaW9uIiwiX3ZhbGlkYXRlUGF0aFN0cmluZyIsIl92YWxpZGF0ZVdyaXRhYmxlUGF0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/database/dist/node-esm/index.node.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@firebase/logger/dist/esm/index.esm2017.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel),\n/* harmony export */   Logger: () => (/* binding */ Logger),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel),\n/* harmony export */   setUserLogHandler: () => (/* binding */ setUserLogHandler)\n/* harmony export */ });\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * A container for all of the Logger instances\r\n */ const instances = [];\n/**\r\n * The JS SDK supports 5 log levels and also allows a user the ability to\r\n * silence the logs altogether.\r\n *\r\n * The order is a follows:\r\n * DEBUG < VERBOSE < INFO < WARN < ERROR\r\n *\r\n * All of the log types above the current log level will be captured (i.e. if\r\n * you set the log level to `INFO`, errors will still be logged, but `DEBUG` and\r\n * `VERBOSE` logs will not)\r\n */ var LogLevel;\n(function(LogLevel) {\n    LogLevel[LogLevel[\"DEBUG\"] = 0] = \"DEBUG\";\n    LogLevel[LogLevel[\"VERBOSE\"] = 1] = \"VERBOSE\";\n    LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\n    LogLevel[LogLevel[\"WARN\"] = 3] = \"WARN\";\n    LogLevel[LogLevel[\"ERROR\"] = 4] = \"ERROR\";\n    LogLevel[LogLevel[\"SILENT\"] = 5] = \"SILENT\";\n})(LogLevel || (LogLevel = {}));\nconst levelStringToEnum = {\n    \"debug\": LogLevel.DEBUG,\n    \"verbose\": LogLevel.VERBOSE,\n    \"info\": LogLevel.INFO,\n    \"warn\": LogLevel.WARN,\n    \"error\": LogLevel.ERROR,\n    \"silent\": LogLevel.SILENT\n};\n/**\r\n * The default log level\r\n */ const defaultLogLevel = LogLevel.INFO;\n/**\r\n * By default, `console.debug` is not displayed in the developer console (in\r\n * chrome). To avoid forcing users to have to opt-in to these logs twice\r\n * (i.e. once for firebase, and once in the console), we are sending `DEBUG`\r\n * logs to the `console.log` function.\r\n */ const ConsoleMethod = {\n    [LogLevel.DEBUG]: \"log\",\n    [LogLevel.VERBOSE]: \"log\",\n    [LogLevel.INFO]: \"info\",\n    [LogLevel.WARN]: \"warn\",\n    [LogLevel.ERROR]: \"error\"\n};\n/**\r\n * The default log handler will forward DEBUG, VERBOSE, INFO, WARN, and ERROR\r\n * messages on to their corresponding console counterparts (if the log method\r\n * is supported by the current log level)\r\n */ const defaultLogHandler = (instance, logType, ...args)=>{\n    if (logType < instance.logLevel) {\n        return;\n    }\n    const now = new Date().toISOString();\n    const method = ConsoleMethod[logType];\n    if (method) {\n        console[method](`[${now}]  ${instance.name}:`, ...args);\n    } else {\n        throw new Error(`Attempted to log a message with an invalid logType (value: ${logType})`);\n    }\n};\nclass Logger {\n    /**\r\n     * Gives you an instance of a Logger to capture messages according to\r\n     * Firebase's logging scheme.\r\n     *\r\n     * @param name The name that the logs will be associated with\r\n     */ constructor(name){\n        this.name = name;\n        /**\r\n         * The log level of the given Logger instance.\r\n         */ this._logLevel = defaultLogLevel;\n        /**\r\n         * The main (internal) log handler for the Logger instance.\r\n         * Can be set to a new function in internal package code but not by user.\r\n         */ this._logHandler = defaultLogHandler;\n        /**\r\n         * The optional, additional, user-defined log handler for the Logger instance.\r\n         */ this._userLogHandler = null;\n        /**\r\n         * Capture the current instance for later use\r\n         */ instances.push(this);\n    }\n    get logLevel() {\n        return this._logLevel;\n    }\n    set logLevel(val) {\n        if (!(val in LogLevel)) {\n            throw new TypeError(`Invalid value \"${val}\" assigned to \\`logLevel\\``);\n        }\n        this._logLevel = val;\n    }\n    // Workaround for setter/getter having to be the same type.\n    setLogLevel(val) {\n        this._logLevel = typeof val === \"string\" ? levelStringToEnum[val] : val;\n    }\n    get logHandler() {\n        return this._logHandler;\n    }\n    set logHandler(val) {\n        if (typeof val !== \"function\") {\n            throw new TypeError(\"Value assigned to `logHandler` must be a function\");\n        }\n        this._logHandler = val;\n    }\n    get userLogHandler() {\n        return this._userLogHandler;\n    }\n    set userLogHandler(val) {\n        this._userLogHandler = val;\n    }\n    /**\r\n     * The functions below are all based on the `console` interface\r\n     */ debug(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.DEBUG, ...args);\n        this._logHandler(this, LogLevel.DEBUG, ...args);\n    }\n    log(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.VERBOSE, ...args);\n        this._logHandler(this, LogLevel.VERBOSE, ...args);\n    }\n    info(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...args);\n        this._logHandler(this, LogLevel.INFO, ...args);\n    }\n    warn(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...args);\n        this._logHandler(this, LogLevel.WARN, ...args);\n    }\n    error(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.ERROR, ...args);\n        this._logHandler(this, LogLevel.ERROR, ...args);\n    }\n}\nfunction setLogLevel(level) {\n    instances.forEach((inst)=>{\n        inst.setLogLevel(level);\n    });\n}\nfunction setUserLogHandler(logCallback, options) {\n    for (const instance of instances){\n        let customLogLevel = null;\n        if (options && options.level) {\n            customLogLevel = levelStringToEnum[options.level];\n        }\n        if (logCallback === null) {\n            instance.userLogHandler = null;\n        } else {\n            instance.userLogHandler = (instance, level, ...args)=>{\n                const message = args.map((arg)=>{\n                    if (arg == null) {\n                        return null;\n                    } else if (typeof arg === \"string\") {\n                        return arg;\n                    } else if (typeof arg === \"number\" || typeof arg === \"boolean\") {\n                        return arg.toString();\n                    } else if (arg instanceof Error) {\n                        return arg.message;\n                    } else {\n                        try {\n                            return JSON.stringify(arg);\n                        } catch (ignored) {\n                            return null;\n                        }\n                    }\n                }).filter((arg)=>arg).join(\" \");\n                if (level >= (customLogLevel !== null && customLogLevel !== void 0 ? customLogLevel : instance.logLevel)) {\n                    logCallback({\n                        level: LogLevel[level].toLowerCase(),\n                        message,\n                        args,\n                        type: instance.name\n                    });\n                }\n            };\n        }\n    }\n}\n //# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2xvZ2dlci9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRDs7Q0FFQyxHQUNELE1BQU1BLFlBQVksRUFBRTtBQUNwQjs7Ozs7Ozs7OztDQVVDLEdBQ0QsSUFBSUM7QUFDSCxVQUFVQSxRQUFRO0lBQ2ZBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLFFBQVEsR0FBRyxFQUFFLEdBQUc7SUFDbENBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7SUFDcENBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLE9BQU8sR0FBRyxFQUFFLEdBQUc7SUFDakNBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLE9BQU8sR0FBRyxFQUFFLEdBQUc7SUFDakNBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLFFBQVEsR0FBRyxFQUFFLEdBQUc7SUFDbENBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLFNBQVMsR0FBRyxFQUFFLEdBQUc7QUFDdkMsR0FBR0EsWUFBYUEsQ0FBQUEsV0FBVyxDQUFDO0FBQzVCLE1BQU1DLG9CQUFvQjtJQUN0QixTQUFTRCxTQUFTRSxLQUFLO0lBQ3ZCLFdBQVdGLFNBQVNHLE9BQU87SUFDM0IsUUFBUUgsU0FBU0ksSUFBSTtJQUNyQixRQUFRSixTQUFTSyxJQUFJO0lBQ3JCLFNBQVNMLFNBQVNNLEtBQUs7SUFDdkIsVUFBVU4sU0FBU08sTUFBTTtBQUM3QjtBQUNBOztDQUVDLEdBQ0QsTUFBTUMsa0JBQWtCUixTQUFTSSxJQUFJO0FBQ3JDOzs7OztDQUtDLEdBQ0QsTUFBTUssZ0JBQWdCO0lBQ2xCLENBQUNULFNBQVNFLEtBQUssQ0FBQyxFQUFFO0lBQ2xCLENBQUNGLFNBQVNHLE9BQU8sQ0FBQyxFQUFFO0lBQ3BCLENBQUNILFNBQVNJLElBQUksQ0FBQyxFQUFFO0lBQ2pCLENBQUNKLFNBQVNLLElBQUksQ0FBQyxFQUFFO0lB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Szt3QkFDRCxJQUFJOzRCQUNBLE9BQU9JLEtBQUtDLFNBQVMsQ0FBQ0g7d0JBQzFCLEVBQ0EsT0FBT0ksU0FBUzs0QkFDWixPQUFPO3dCQUNYO29CQUNKO2dCQUNKLEdBQ0tDLE1BQU0sQ0FBQ0wsQ0FBQUEsTUFBT0EsS0FDZE0sSUFBSSxDQUFDO2dCQUNWLElBQUlmLFNBQVVNLENBQUFBLG1CQUFtQixRQUFRQSxtQkFBbUIsS0FBSyxJQUFJQSxpQkFBaUJqQyxTQUFTRyxRQUFRLEdBQUc7b0JBQ3RHNEIsWUFBWTt3QkFDUkosT0FBT3RDLFFBQVEsQ0FBQ3NDLE1BQU0sQ0FBQ2dCLFdBQVc7d0JBQ2xDVDt3QkFDQWhDO3dCQUNBMEMsTUFBTTVDLFNBQVNTLElBQUk7b0JBQ3ZCO2dCQUNKO1lBQ0o7UUFDSjtJQUNKO0FBQ0o7QUFFNEQsQ0FDNUQseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd29ybGR3ZWIvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2xvZ2dlci9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzPzM5OGUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEEgY29udGFpbmVyIGZvciBhbGwgb2YgdGhlIExvZ2dlciBpbnN0YW5jZXNcclxuICovXHJcbmNvbnN0IGluc3RhbmNlcyA9IFtdO1xyXG4vKipcclxuICogVGhlIEpTIFNESyBzdXBwb3J0cyA1IGxvZyBsZXZlbHMgYW5kIGFsc28gYWxsb3dzIGEgdXNlciB0aGUgYWJpbGl0eSB0b1xyXG4gKiBzaWxlbmNlIHRoZSBsb2dzIGFsdG9nZXRoZXIuXHJcbiAqXHJcbiAqIFRoZSBvcmRlciBpcyBhIGZvbGxvd3M6XHJcbiAqIERFQlVHIDwgVkVSQk9TRSA8IElORk8gPCBXQVJOIDwgRVJST1JcclxuICpcclxuICogQWxsIG9mIHRoZSBsb2cgdHlwZXMgYWJvdmUgdGhlIGN1cnJlbnQgbG9nIGxldmVsIHdpbGwgYmUgY2FwdHVyZWQgKGkuZS4gaWZcclxuICogeW91IHNldCB0aGUgbG9nIGxldmVsIHRvIGBJTkZPYCwgZXJyb3JzIHdpbGwgc3RpbGwgYmUgbG9nZ2VkLCBidXQgYERFQlVHYCBhbmRcclxuICogYFZFUkJPU0VgIGxvZ3Mgd2lsbCBub3QpXHJcbiAqL1xyXG52YXIgTG9nTGV2ZWw7XHJcbihmdW5jdGlvbiAoTG9nTGV2ZWwpIHtcclxuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiREVCVUdcIl0gPSAwXSA9IFwiREVCVUdcIjtcclxuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiVkVSQk9TRVwiXSA9IDFdID0gXCJWRVJCT1NFXCI7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIklORk9cIl0gPSAyXSA9IFwiSU5GT1wiO1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJXQVJOXCJdID0gM10gPSBcIldBUk5cIjtcclxuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiRVJST1JcIl0gPSA0XSA9IFwiRVJST1JcIjtcclxuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiU0lMRU5UXCJdID0gNV0gPSBcIlNJTEVOVFwiO1xyXG59KShMb2dMZXZlbCB8fCAoTG9nTGV2ZWwgPSB7fSkpO1xyXG5jb25zdCBsZXZlbFN0cmluZ1RvRW51bSA9IHtcclxuICAgICdkZWJ1Zyc6IExvZ0xldmVsLkRFQlVHLFxyXG4gICAgJ3ZlcmJvc2UnOiBMb2dMZXZlbC5WRVJCT1NFLFxyXG4gICAgJ2luZm8nOiBMb2dMZXZlbC5JTkZPLFxyXG4gICAgJ3dhcm4nOiBMb2dMZXZlbC5XQVJOLFxyXG4gICAgJ2Vycm9yJzogTG9nTGV2ZWwuRVJST1IsXHJcbiAgICAnc2lsZW50JzogTG9nTGV2ZWwuU0lMRU5UXHJcbn07XHJcbi8qKlxyXG4gKiBUaGUgZGVmYXVsdCBsb2cgbGV2ZWxcclxuICovXHJcbmNvbnN0IGRlZmF1bHRMb2dMZXZlbCA9IExvZ0xldmVsLklORk87XHJcbi8qKlxyXG4gKiBCeSBkZWZhdWx0LCBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGRpc3BsYXllZCBpbiB0aGUgZGV2ZWxvcGVyIGNvbnNvbGUgKGluXHJcbiAqIGNocm9tZSkuIFRvIGF2b2lkIGZvcmNpbmcgdXNlcnMgdG8gaGF2ZSB0byBvcHQtaW4gdG8gdGhlc2UgbG9ncyB0d2ljZVxyXG4gKiAoaS5lLiBvbmNlIGZvciBmaXJlYmFzZSwgYW5kIG9uY2UgaW4gdGhlIGNvbnNvbGUpLCB3ZSBhcmUgc2VuZGluZyBgREVCVUdgXHJcbiAqIGxvZ3MgdG8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24uXHJcbiAqL1xyXG5jb25zdCBDb25zb2xlTWV0aG9kID0ge1xyXG4gICAgW0xvZ0xldmVsLkRFQlVHXTogJ2xvZycsXHJcbiAgICBbTG9nTGV2ZWwuVkVSQk9TRV06ICdsb2cnLFxyXG4gICAgW0xvZ0xldmVsLklORk9dOiAnaW5mbycsXHJcbiAgICBbTG9nTGV2ZWwuV0FSTl06ICd3YXJuJyxcclxuICAgIFtMb2dMZXZlbC5FUlJPUl06ICdlcnJvcidcclxufTtcclxuLyoqXHJcbiAqIFRoZSBkZWZhdWx0IGxvZyBoYW5kbGVyIHdpbGwgZm9yd2FyZCBERUJVRywgVkVSQk9TRSwgSU5GTywgV0FSTiwgYW5kIEVSUk9SXHJcbiAqIG1lc3NhZ2VzIG9uIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmcgY29uc29sZSBjb3VudGVycGFydHMgKGlmIHRoZSBsb2cgbWV0aG9kXHJcbiAqIGlzIHN1cHBvcnRlZCBieSB0aGUgY3VycmVudCBsb2cgbGV2ZWwpXHJcbiAqL1xyXG5jb25zdCBkZWZhdWx0TG9nSGFuZGxlciA9IChpbnN0YW5jZSwgbG9nVHlwZSwgLi4uYXJncykgPT4ge1xyXG4gICAgaWYgKGxvZ1R5cGUgPCBpbnN0YW5jZS5sb2dMZXZlbCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcclxuICAgIGNvbnN0IG1ldGhvZCA9IENvbnNvbGVNZXRob2RbbG9nVHlwZV07XHJcbiAgICBpZiAobWV0aG9kKSB7XHJcbiAgICAgICAgY29uc29sZVttZXRob2RdKGBbJHtub3d9XSAgJHtpbnN0YW5jZS5uYW1lfTpgLCAuLi5hcmdzKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQXR0ZW1wdGVkIHRvIGxvZyBhIG1lc3NhZ2Ugd2l0aCBhbiBpbnZhbGlkIGxvZ1R5cGUgKHZhbHVlOiAke2xvZ1R5cGV9KWApO1xyXG4gICAgfVxyXG59O1xyXG5jbGFzcyBMb2dnZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlcyB5b3UgYW4gaW5zdGFuY2Ugb2YgYSBMb2dnZXIgdG8gY2FwdHVyZSBtZXNzYWdlcyBhY2NvcmRpbmcgdG9cclxuICAgICAqIEZpcmViYXNlJ3MgbG9nZ2luZyBzY2hlbWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgdGhhdCB0aGUgbG9ncyB3aWxsIGJlIGFzc29jaWF0ZWQgd2l0aFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbG9nIGxldmVsIG9mIHRoZSBnaXZlbiBMb2dnZXIgaW5zdGFuY2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fbG9nTGV2ZWwgPSBkZWZhdWx0TG9nTGV2ZWw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG1haW4gKGludGVybmFsKSBsb2cgaGFuZGxlciBmb3IgdGhlIExvZ2dlciBpbnN0YW5jZS5cclxuICAgICAgICAgKiBDYW4gYmUgc2V0IHRvIGEgbmV3IGZ1bmN0aW9uIGluIGludGVybmFsIHBhY2thZ2UgY29kZSBidXQgbm90IGJ5IHVzZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fbG9nSGFuZGxlciA9IGRlZmF1bHRMb2dIYW5kbGVyO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBvcHRpb25hbCwgYWRkaXRpb25hbCwgdXNlci1kZWZpbmVkIGxvZyBoYW5kbGVyIGZvciB0aGUgTG9nZ2VyIGluc3RhbmNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYXB0dXJlIHRoZSBjdXJyZW50IGluc3RhbmNlIGZvciBsYXRlciB1c2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBpbnN0YW5jZXMucHVzaCh0aGlzKTtcclxuICAgIH1cclxuICAgIGdldCBsb2dMZXZlbCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9nTGV2ZWw7XHJcbiAgICB9XHJcbiAgICBzZXQgbG9nTGV2ZWwodmFsKSB7XHJcbiAgICAgICAgaWYgKCEodmFsIGluIExvZ0xldmVsKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHZhbHVlIFwiJHt2YWx9XCIgYXNzaWduZWQgdG8gXFxgbG9nTGV2ZWxcXGBgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbG9nTGV2ZWwgPSB2YWw7XHJcbiAgICB9XHJcbiAgICAvLyBXb3JrYXJvdW5kIGZvciBzZXR0ZXIvZ2V0dGVyIGhhdmluZyB0byBiZSB0aGUgc2FtZSB0eXBlLlxyXG4gICAgc2V0TG9nTGV2ZWwodmFsKSB7XHJcbiAgICAgICAgdGhpcy5fbG9nTGV2ZWwgPSB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyA/IGxldmVsU3RyaW5nVG9FbnVtW3ZhbF0gOiB2YWw7XHJcbiAgICB9XHJcbiAgICBnZXQgbG9nSGFuZGxlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9nSGFuZGxlcjtcclxuICAgIH1cclxuICAgIHNldCBsb2dIYW5kbGVyKHZhbCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1ZhbHVlIGFzc2lnbmVkIHRvIGBsb2dIYW5kbGVyYCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbG9nSGFuZGxlciA9IHZhbDtcclxuICAgIH1cclxuICAgIGdldCB1c2VyTG9nSGFuZGxlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdXNlckxvZ0hhbmRsZXI7XHJcbiAgICB9XHJcbiAgICBzZXQgdXNlckxvZ0hhbmRsZXIodmFsKSB7XHJcbiAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgPSB2YWw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmdW5jdGlvbnMgYmVsb3cgYXJlIGFsbCBiYXNlZCBvbiB0aGUgYGNvbnNvbGVgIGludGVyZmFjZVxyXG4gICAgICovXHJcbiAgICBkZWJ1ZyguLi5hcmdzKSB7XHJcbiAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgJiYgdGhpcy5fdXNlckxvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuREVCVUcsIC4uLmFyZ3MpO1xyXG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuREVCVUcsIC4uLmFyZ3MpO1xyXG4gICAgfVxyXG4gICAgbG9nKC4uLmFyZ3MpIHtcclxuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciAmJlxyXG4gICAgICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5WRVJCT1NFLCAuLi5hcmdzKTtcclxuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLlZFUkJPU0UsIC4uLmFyZ3MpO1xyXG4gICAgfVxyXG4gICAgaW5mbyguLi5hcmdzKSB7XHJcbiAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgJiYgdGhpcy5fdXNlckxvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuSU5GTywgLi4uYXJncyk7XHJcbiAgICAgICAgdGhpcy5fbG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5JTkZPLCAuLi5hcmdzKTtcclxuICAgIH1cclxuICAgIHdhcm4oLi4uYXJncykge1xyXG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyICYmIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLldBUk4sIC4uLmFyZ3MpO1xyXG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuV0FSTiwgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICBlcnJvciguLi5hcmdzKSB7XHJcbiAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgJiYgdGhpcy5fdXNlckxvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuRVJST1IsIC4uLmFyZ3MpO1xyXG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuRVJST1IsIC4uLmFyZ3MpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNldExvZ0xldmVsKGxldmVsKSB7XHJcbiAgICBpbnN0YW5jZXMuZm9yRWFjaChpbnN0ID0+IHtcclxuICAgICAgICBpbnN0LnNldExvZ0xldmVsKGxldmVsKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHNldFVzZXJMb2dIYW5kbGVyKGxvZ0NhbGxiYWNrLCBvcHRpb25zKSB7XHJcbiAgICBmb3IgKGNvbnN0IGluc3RhbmNlIG9mIGluc3RhbmNlcykge1xyXG4gICAgICAgIGxldCBjdXN0b21Mb2dMZXZlbCA9IG51bGw7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5sZXZlbCkge1xyXG4gICAgICAgICAgICBjdXN0b21Mb2dMZXZlbCA9IGxldmVsU3RyaW5nVG9FbnVtW29wdGlvbnMubGV2ZWxdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobG9nQ2FsbGJhY2sgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UudXNlckxvZ0hhbmRsZXIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UudXNlckxvZ0hhbmRsZXIgPSAoaW5zdGFuY2UsIGxldmVsLCAuLi5hcmdzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYXJnc1xyXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoYXJnID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJnID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8IHR5cGVvZiBhcmcgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmcubWVzc2FnZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoaWdub3JlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoYXJnID0+IGFyZylcclxuICAgICAgICAgICAgICAgICAgICAuam9pbignICcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxldmVsID49IChjdXN0b21Mb2dMZXZlbCAhPT0gbnVsbCAmJiBjdXN0b21Mb2dMZXZlbCAhPT0gdm9pZCAwID8gY3VzdG9tTG9nTGV2ZWwgOiBpbnN0YW5jZS5sb2dMZXZlbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2dDYWxsYmFjayh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsOiBMb2dMZXZlbFtsZXZlbF0udG9Mb3dlckNhc2UoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogaW5zdGFuY2UubmFtZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5leHBvcnQgeyBMb2dMZXZlbCwgTG9nZ2VyLCBzZXRMb2dMZXZlbCwgc2V0VXNlckxvZ0hhbmRsZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbTIwMTcuanMubWFwXG4iXSwibmFtZXMiOlsiaW5zdGFuY2VzIiwiTG9nTGV2ZWwiLCJsZXZlbFN0cmluZ1RvRW51bSIsIkRFQlVHIiwiVkVSQk9TRSIsIklORk8iLCJXQVJOIiwiRVJST1IiLCJTSUxFTlQiLCJkZWZhdWx0TG9nTGV2ZWwiLCJDb25zb2xlTWV0aG9kIiwiZGVmYXVsdExvZ0hhbmRsZXIiLCJpbnN0YW5jZSIsImxvZ1R5cGUiLCJhcmdzIiwibG9nTGV2ZWwiLCJub3ciLCJEYXRlIiwidG9JU09TdHJpbmciLCJtZXRob2QiLCJjb25zb2xlIiwibmFtZSIsIkVycm9yIiwiTG9nZ2VyIiwiY29uc3RydWN0b3IiLCJfbG9nTGV2ZWwiLCJfbG9nSGFuZGxlciIsIl91c2VyTG9nSGFuZGxlciIsInB1c2giLCJ2YWwiLCJUeXBlRXJyb3IiLCJzZXRMb2dMZXZlbCIsImxvZ0hhbmRsZXIiLCJ1c2VyTG9nSGFuZGxlciIsImRlYnVnIiwibG9nIiwiaW5mbyIsIndhcm4iLCJlcnJvciIsImxldmVsIiwiZm9yRWFjaCIsImluc3QiLCJzZXRVc2VyTG9nSGFuZGxlciIsImxvZ0NhbGxiYWNrIiwib3B0aW9ucyIsImN1c3RvbUxvZ0xldmVsIiwibWVzc2FnZSIsIm1hcCIsImFyZyIsInRvU3RyaW5nIiwiSlNPTiIsInN0cmluZ2lmeSIsImlnbm9yZWQiLCJmaWx0ZXIiLCJqb2luIiwidG9Mb3dlckNhc2UiLCJ0eXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@firebase/util/dist/node-esm/index.node.esm.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONSTANTS: () => (/* binding */ CONSTANTS),\n/* harmony export */   DecodeBase64StringError: () => (/* binding */ DecodeBase64StringError),\n/* harmony export */   Deferred: () => (/* binding */ Deferred),\n/* harmony export */   ErrorFactory: () => (/* binding */ ErrorFactory),\n/* harmony export */   FirebaseError: () => (/* binding */ FirebaseError),\n/* harmony export */   MAX_VALUE_MILLIS: () => (/* binding */ MAX_VALUE_MILLIS),\n/* harmony export */   RANDOM_FACTOR: () => (/* binding */ RANDOM_FACTOR),\n/* harmony export */   Sha1: () => (/* binding */ Sha1),\n/* harmony export */   areCookiesEnabled: () => (/* binding */ areCookiesEnabled),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertionError: () => (/* binding */ assertionError),\n/* harmony export */   async: () => (/* binding */ async),\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   base64Decode: () => (/* binding */ base64Decode),\n/* harmony export */   base64Encode: () => (/* binding */ base64Encode),\n/* harmony export */   base64urlEncodeWithoutPadding: () => (/* binding */ base64urlEncodeWithoutPadding),\n/* harmony export */   calculateBackoffMillis: () => (/* binding */ calculateBackoffMillis),\n/* harmony export */   contains: () => (/* binding */ contains),\n/* harmony export */   createMockUserToken: () => (/* binding */ createMockUserToken),\n/* harmony export */   createSubscribe: () => (/* binding */ createSubscribe),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   deepCopy: () => (/* binding */ deepCopy),\n/* harmony export */   deepEqual: () => (/* binding */ deepEqual),\n/* harmony export */   deepExtend: () => (/* binding */ deepExtend),\n/* harmony export */   errorPrefix: () => (/* binding */ errorPrefix),\n/* harmony export */   extractQuerystring: () => (/* binding */ extractQuerystring),\n/* harmony export */   getDefaultAppConfig: () => (/* binding */ getDefaultAppConfig),\n/* harmony export */   getDefaultEmulatorHost: () => (/* binding */ getDefaultEmulatorHost),\n/* harmony export */   getDefaultEmulatorHostnameAndPort: () => (/* binding */ getDefaultEmulatorHostnameAndPort),\n/* harmony export */   getDefaults: () => (/* binding */ getDefaults),\n/* harmony export */   getExperimentalSetting: () => (/* binding */ getExperimentalSetting),\n/* harmony export */   getGlobal: () => (/* binding */ getGlobal),\n/* harmony export */   getModularInstance: () => (/* binding */ getModularInstance),\n/* harmony export */   getUA: () => (/* binding */ getUA),\n/* harmony export */   isAdmin: () => (/* binding */ isAdmin),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   isBrowserExtension: () => (/* binding */ isBrowserExtension),\n/* harmony export */   isElectron: () => (/* binding */ isElectron),\n/* harmony export */   isEmpty: () => (/* binding */ isEmpty),\n/* harmony export */   isIE: () => (/* binding */ isIE),\n/* harmony export */   isIndexedDBAvailable: () => (/* binding */ isIndexedDBAvailable),\n/* harmony export */   isMobileCordova: () => (/* binding */ isMobileCordova),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isNodeSdk: () => (/* binding */ isNodeSdk),\n/* harmony export */   isReactNative: () => (/* binding */ isReactNative),\n/* harmony export */   isSafari: () => (/* binding */ isSafari),\n/* harmony export */   isUWP: () => (/* binding */ isUWP),\n/* harmony export */   isValidFormat: () => (/* binding */ isValidFormat),\n/* harmony export */   isValidTimestamp: () => (/* binding */ isValidTimestamp),\n/* harmony export */   issuedAtTime: () => (/* binding */ issuedAtTime),\n/* harmony export */   jsonEval: () => (/* binding */ jsonEval),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   ordinal: () => (/* binding */ ordinal),\n/* harmony export */   promiseWithTimeout: () => (/* binding */ promiseWithTimeout),\n/* harmony export */   querystring: () => (/* binding */ querystring),\n/* harmony export */   querystringDecode: () => (/* binding */ querystringDecode),\n/* harmony export */   safeGet: () => (/* binding */ safeGet),\n/* harmony export */   stringLength: () => (/* binding */ stringLength),\n/* harmony export */   stringToByteArray: () => (/* binding */ stringToByteArray),\n/* harmony export */   stringify: () => (/* binding */ stringify),\n/* harmony export */   uuidv4: () => (/* binding */ uuidv4),\n/* harmony export */   validateArgCount: () => (/* binding */ validateArgCount),\n/* harmony export */   validateCallback: () => (/* binding */ validateCallback),\n/* harmony export */   validateContextObject: () => (/* binding */ validateContextObject),\n/* harmony export */   validateIndexedDBOpenable: () => (/* binding */ validateIndexedDBOpenable),\n/* harmony export */   validateNamespace: () => (/* binding */ validateNamespace)\n/* harmony export */ });\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * @fileoverview Firebase constants.  Some of these (@defines) can be overridden at compile-time.\r\n */ const CONSTANTS = {\n    /**\r\n     * @define {boolean} Whether this is the client Node.js SDK.\r\n     */ NODE_CLIENT: false,\n    /**\r\n     * @define {boolean} Whether this is the Admin Node.js SDK.\r\n     */ NODE_ADMIN: false,\n    /**\r\n     * Firebase SDK Version\r\n     */ SDK_VERSION: \"${JSCORE_VERSION}\"\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Throws an error if the provided assertion is falsy\r\n */ const assert = function(assertion, message) {\n    if (!assertion) {\n        throw assertionError(message);\n    }\n};\n/**\r\n * Returns an Error object suitable for throwing.\r\n */ const assertionError = function(message) {\n    return new Error(\"Firebase Database (\" + CONSTANTS.SDK_VERSION + \") INTERNAL ASSERT FAILED: \" + message);\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const stringToByteArray$1 = function(str) {\n    // TODO(user): Use native implementations if/when available\n    const out = [];\n    let p = 0;\n    for(let i = 0; i < str.length; i++){\n        let c = str.charCodeAt(i);\n        if (c < 128) {\n            out[p++] = c;\n        } else if (c < 2048) {\n            out[p++] = c >> 6 | 192;\n            out[p++] = c & 63 | 128;\n        } else if ((c & 0xfc00) === 0xd800 && i + 1 < str.length && (str.charCodeAt(i + 1) & 0xfc00) === 0xdc00) {\n            // Surrogate Pair\n            c = 0x10000 + ((c & 0x03ff) << 10) + (str.charCodeAt(++i) & 0x03ff);\n            out[p++] = c >> 18 | 240;\n            out[p++] = c >> 12 & 63 | 128;\n            out[p++] = c >> 6 & 63 | 128;\n            out[p++] = c & 63 | 128;\n        } else {\n            out[p++] = c >> 12 | 224;\n            out[p++] = c >> 6 & 63 | 128;\n            out[p++] = c & 63 | 128;\n        }\n    }\n    return out;\n};\n/**\r\n * Turns an array of numbers into the string given by the concatenation of the\r\n * characters to which the numbers correspond.\r\n * @param bytes Array of numbers representing characters.\r\n * @return Stringification of the array.\r\n */ const byteArrayToString = function(bytes) {\n    // TODO(user): Use native implementations if/when available\n    const out = [];\n    let pos = 0, c = 0;\n    while(pos < bytes.length){\n        const c1 = bytes[pos++];\n        if (c1 < 128) {\n            out[c++] = String.fromCharCode(c1);\n        } else if (c1 > 191 && c1 < 224) {\n            const c2 = bytes[pos++];\n            out[c++] = String.fromCharCode((c1 & 31) << 6 | c2 & 63);\n        } else if (c1 > 239 && c1 < 365) {\n            // Surrogate Pair\n            const c2 = bytes[pos++];\n            const c3 = bytes[pos++];\n            const c4 = bytes[pos++];\n            const u = ((c1 & 7) << 18 | (c2 & 63) << 12 | (c3 & 63) << 6 | c4 & 63) - 0x10000;\n            out[c++] = String.fromCharCode(0xd800 + (u >> 10));\n            out[c++] = String.fromCharCode(0xdc00 + (u & 1023));\n        } else {\n            const c2 = bytes[pos++];\n            const c3 = bytes[pos++];\n            out[c++] = String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);\n        }\n    }\n    return out.join(\"\");\n};\n// We define it as an object literal instead of a class because a class compiled down to es5 can't\n// be treeshaked. https://github.com/rollup/rollup/issues/1691\n// Static lookup maps, lazily populated by init_()\nconst base64 = {\n    /**\r\n     * Maps bytes to characters.\r\n     */ byteToCharMap_: null,\n    /**\r\n     * Maps characters to bytes.\r\n     */ charToByteMap_: null,\n    /**\r\n     * Maps bytes to websafe characters.\r\n     * @private\r\n     */ byteToCharMapWebSafe_: null,\n    /**\r\n     * Maps websafe characters to bytes.\r\n     * @private\r\n     */ charToByteMapWebSafe_: null,\n    /**\r\n     * Our default alphabet, shared between\r\n     * ENCODED_VALS and ENCODED_VALS_WEBSAFE\r\n     */ ENCODED_VALS_BASE: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" + \"abcdefghijklmnopqrstuvwxyz\" + \"0123456789\",\n    /**\r\n     * Our default alphabet. Value 64 (=) is special; it means \"nothing.\"\r\n     */ get ENCODED_VALS () {\n        return this.ENCODED_VALS_BASE + \"+/=\";\n    },\n    /**\r\n     * Our websafe alphabet.\r\n     */ get ENCODED_VALS_WEBSAFE () {\n        return this.ENCODED_VALS_BASE + \"-_.\";\n    },\n    /**\r\n     * Whether this browser supports the atob and btoa functions. This extension\r\n     * started at Mozilla but is now implemented by many browsers. We use the\r\n     * ASSUME_* variables to avoid pulling in the full useragent detection library\r\n     * but still allowing the standard per-browser compilations.\r\n     *\r\n     */ HAS_NATIVE_SUPPORT: typeof atob === \"function\",\n    /**\r\n     * Base64-encode an array of bytes.\r\n     *\r\n     * @param input An array of bytes (numbers with\r\n     *     value in [0, 255]) to encode.\r\n     * @param webSafe Boolean indicating we should use the\r\n     *     alternative alphabet.\r\n     * @return The base64 encoded string.\r\n     */ encodeByteArray (input, webSafe) {\n        if (!Array.isArray(input)) {\n            throw Error(\"encodeByteArray takes an array as a parameter\");\n        }\n        this.init_();\n        const byteToCharMap = webSafe ? this.byteToCharMapWebSafe_ : this.byteToCharMap_;\n        const output = [];\n        for(let i = 0; i < input.length; i += 3){\n            const byte1 = input[i];\n            const haveByte2 = i + 1 < input.length;\n            const byte2 = haveByte2 ? input[i + 1] : 0;\n            const haveByte3 = i + 2 < input.length;\n            const byte3 = haveByte3 ? input[i + 2] : 0;\n            const outByte1 = byte1 >> 2;\n            const outByte2 = (byte1 & 0x03) << 4 | byte2 >> 4;\n            let outByte3 = (byte2 & 0x0f) << 2 | byte3 >> 6;\n            let outByte4 = byte3 & 0x3f;\n            if (!haveByte3) {\n                outByte4 = 64;\n                if (!haveByte2) {\n                    outByte3 = 64;\n                }\n            }\n            output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);\n        }\n        return output.join(\"\");\n    },\n    /**\r\n     * Base64-encode a string.\r\n     *\r\n     * @param input A string to encode.\r\n     * @param webSafe If true, we should use the\r\n     *     alternative alphabet.\r\n     * @return The base64 encoded string.\r\n     */ encodeString (input, webSafe) {\n        // Shortcut for Mozilla browsers that implement\n        // a native base64 encoder in the form of \"btoa/atob\"\n        if (this.HAS_NATIVE_SUPPORT && !webSafe) {\n            return btoa(input);\n        }\n        return this.encodeByteArray(stringToByteArray$1(input), webSafe);\n    },\n    /**\r\n     * Base64-decode a string.\r\n     *\r\n     * @param input to decode.\r\n     * @param webSafe True if we should use the\r\n     *     alternative alphabet.\r\n     * @return string representing the decoded value.\r\n     */ decodeString (input, webSafe) {\n        // Shortcut for Mozilla browsers that implement\n        // a native base64 encoder in the form of \"btoa/atob\"\n        if (this.HAS_NATIVE_SUPPORT && !webSafe) {\n            return atob(input);\n        }\n        return byteArrayToString(this.decodeStringToByteArray(input, webSafe));\n    },\n    /**\r\n     * Base64-decode a string.\r\n     *\r\n     * In base-64 decoding, groups of four characters are converted into three\r\n     * bytes.  If the encoder did not apply padding, the input length may not\r\n     * be a multiple of 4.\r\n     *\r\n     * In this case, the last group will have fewer than 4 characters, and\r\n     * padding will be inferred.  If the group has one or two characters, it decodes\r\n     * to one byte.  If the group has three characters, it decodes to two bytes.\r\n     *\r\n     * @param input Input to decode.\r\n     * @param webSafe True if we should use the web-safe alphabet.\r\n     * @return bytes representing the decoded value.\r\n     */ decodeStringToByteArray (input, webSafe) {\n        this.init_();\n        const charToByteMap = webSafe ? this.charToByteMapWebSafe_ : this.charToByteMap_;\n        const output = [];\n        for(let i = 0; i < input.length;){\n            const byte1 = charToByteMap[input.charAt(i++)];\n            const haveByte2 = i < input.length;\n            const byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;\n            ++i;\n            const haveByte3 = i < input.length;\n            const byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;\n            ++i;\n            const haveByte4 = i < input.length;\n            const byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;\n            ++i;\n            if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {\n                throw new DecodeBase64StringError();\n            }\n            const outByte1 = byte1 << 2 | byte2 >> 4;\n            output.push(outByte1);\n            if (byte3 !== 64) {\n                const outByte2 = byte2 << 4 & 0xf0 | byte3 >> 2;\n                output.push(outByte2);\n                if (byte4 !== 64) {\n                    const outByte3 = byte3 << 6 & 0xc0 | byte4;\n                    output.push(outByte3);\n                }\n            }\n        }\n        return output;\n    },\n    /**\r\n     * Lazy static initialization function. Called before\r\n     * accessing any of the static map variables.\r\n     * @private\r\n     */ init_ () {\n        if (!this.byteToCharMap_) {\n            this.byteToCharMap_ = {};\n            this.charToByteMap_ = {};\n            this.byteToCharMapWebSafe_ = {};\n            this.charToByteMapWebSafe_ = {};\n            // We want quick mappings back and forth, so we precompute two maps.\n            for(let i = 0; i < this.ENCODED_VALS.length; i++){\n                this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);\n                this.charToByteMap_[this.byteToCharMap_[i]] = i;\n                this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);\n                this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;\n                // Be forgiving when decoding and correctly decode both encodings.\n                if (i >= this.ENCODED_VALS_BASE.length) {\n                    this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;\n                    this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;\n                }\n            }\n        }\n    }\n};\n/**\r\n * An error encountered while decoding base64 string.\r\n */ class DecodeBase64StringError extends Error {\n    constructor(){\n        super(...arguments);\n        this.name = \"DecodeBase64StringError\";\n    }\n}\n/**\r\n * URL-safe base64 encoding\r\n */ const base64Encode = function(str) {\n    const utf8Bytes = stringToByteArray$1(str);\n    return base64.encodeByteArray(utf8Bytes, true);\n};\n/**\r\n * URL-safe base64 encoding (without \".\" padding in the end).\r\n * e.g. Used in JSON Web Token (JWT) parts.\r\n */ const base64urlEncodeWithoutPadding = function(str) {\n    // Use base64url encoding and remove padding in the end (dot characters).\n    return base64Encode(str).replace(/\\./g, \"\");\n};\n/**\r\n * URL-safe base64 decoding\r\n *\r\n * NOTE: DO NOT use the global atob() function - it does NOT support the\r\n * base64Url variant encoding.\r\n *\r\n * @param str To be decoded\r\n * @return Decoded result, if possible\r\n */ const base64Decode = function(str) {\n    try {\n        return base64.decodeString(str, true);\n    } catch (e) {\n        console.error(\"base64Decode failed: \", e);\n    }\n    return null;\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Do a deep-copy of basic JavaScript Objects or Arrays.\r\n */ function deepCopy(value) {\n    return deepExtend(undefined, value);\n}\n/**\r\n * Copy properties from source to target (recursively allows extension\r\n * of Objects and Arrays).  Scalar values in the target are over-written.\r\n * If target is undefined, an object of the appropriate type will be created\r\n * (and returned).\r\n *\r\n * We recursively copy all child properties of plain Objects in the source- so\r\n * that namespace- like dictionaries are merged.\r\n *\r\n * Note that the target can be a function, in which case the properties in\r\n * the source Object are copied onto it as static properties of the Function.\r\n *\r\n * Note: we don't merge __proto__ to prevent prototype pollution\r\n */ function deepExtend(target, source) {\n    if (!(source instanceof Object)) {\n        return source;\n    }\n    switch(source.constructor){\n        case Date:\n            // Treat Dates like scalars; if the target date object had any child\n            // properties - they will be lost!\n            const dateValue = source;\n            return new Date(dateValue.getTime());\n        case Object:\n            if (target === undefined) {\n                target = {};\n            }\n            break;\n        case Array:\n            // Always copy the array source and overwrite the target.\n            target = [];\n            break;\n        default:\n            // Not a plain Object - treat it as a scalar.\n            return source;\n    }\n    for(const prop in source){\n        // use isValidKey to guard against prototype pollution. See https://snyk.io/vuln/SNYK-JS-LODASH-450202\n        if (!source.hasOwnProperty(prop) || !isValidKey(prop)) {\n            continue;\n        }\n        target[prop] = deepExtend(target[prop], source[prop]);\n    }\n    return target;\n}\nfunction isValidKey(key) {\n    return key !== \"__proto__\";\n}\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Polyfill for `globalThis` object.\r\n * @returns the `globalThis` object for the given environment.\r\n * @public\r\n */ function getGlobal() {\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    if (false) {}\n    if (typeof global !== \"undefined\") {\n        return global;\n    }\n    throw new Error(\"Unable to locate global object.\");\n}\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ const getDefaultsFromGlobal = ()=>getGlobal().__FIREBASE_DEFAULTS__;\n/**\r\n * Attempt to read defaults from a JSON string provided to\r\n * process(.)env(.)__FIREBASE_DEFAULTS__ or a JSON file whose path is in\r\n * process(.)env(.)__FIREBASE_DEFAULTS_PATH__\r\n * The dots are in parens because certain compilers (Vite?) cannot\r\n * handle seeing that variable in comments.\r\n * See https://github.com/firebase/firebase-js-sdk/issues/6838\r\n */ const getDefaultsFromEnvVariable = ()=>{\n    if (typeof process === \"undefined\" || typeof process.env === \"undefined\") {\n        return;\n    }\n    const defaultsJsonString = process.env.__FIREBASE_DEFAULTS__;\n    if (defaultsJsonString) {\n        return JSON.parse(defaultsJsonString);\n    }\n};\nconst getDefaultsFromCookie = ()=>{\n    if (typeof document === \"undefined\") {\n        return;\n    }\n    let match;\n    try {\n        match = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);\n    } catch (e) {\n        // Some environments such as Angular Universal SSR have a\n        // `document` object but error on accessing `document.cookie`.\n        return;\n    }\n    const decoded = match && base64Decode(match[1]);\n    return decoded && JSON.parse(decoded);\n};\n/**\r\n * Get the __FIREBASE_DEFAULTS__ object. It checks in order:\r\n * (1) if such an object exists as a property of `globalThis`\r\n * (2) if such an object was provided on a shell environment variable\r\n * (3) if such an object exists in a cookie\r\n * @public\r\n */ const getDefaults = ()=>{\n    try {\n        return getDefaultsFromGlobal() || getDefaultsFromEnvVariable() || getDefaultsFromCookie();\n    } catch (e) {\n        /**\r\n         * Catch-all for being unable to get __FIREBASE_DEFAULTS__ due\r\n         * to any environment case we have not accounted for. Log to\r\n         * info instead of swallowing so we can find these unknown cases\r\n         * and add paths for them if needed.\r\n         */ console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`);\n        return;\n    }\n};\n/**\r\n * Returns emulator host stored in the __FIREBASE_DEFAULTS__ object\r\n * for the given product.\r\n * @returns a URL host formatted like `127.0.0.1:9999` or `[::1]:4000` if available\r\n * @public\r\n */ const getDefaultEmulatorHost = (productName)=>{\n    var _a, _b;\n    return (_b = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.emulatorHosts) === null || _b === void 0 ? void 0 : _b[productName];\n};\n/**\r\n * Returns emulator hostname and port stored in the __FIREBASE_DEFAULTS__ object\r\n * for the given product.\r\n * @returns a pair of hostname and port like `[\"::1\", 4000]` if available\r\n * @public\r\n */ const getDefaultEmulatorHostnameAndPort = (productName)=>{\n    const host = getDefaultEmulatorHost(productName);\n    if (!host) {\n        return undefined;\n    }\n    const separatorIndex = host.lastIndexOf(\":\"); // Finding the last since IPv6 addr also has colons.\n    if (separatorIndex <= 0 || separatorIndex + 1 === host.length) {\n        throw new Error(`Invalid host ${host} with no separate hostname and port!`);\n    }\n    // eslint-disable-next-line no-restricted-globals\n    const port = parseInt(host.substring(separatorIndex + 1), 10);\n    if (host[0] === \"[\") {\n        // Bracket-quoted `[ipv6addr]:port` => return \"ipv6addr\" (without brackets).\n        return [\n            host.substring(1, separatorIndex - 1),\n            port\n        ];\n    } else {\n        return [\n            host.substring(0, separatorIndex),\n            port\n        ];\n    }\n};\n/**\r\n * Returns Firebase app config stored in the __FIREBASE_DEFAULTS__ object.\r\n * @public\r\n */ const getDefaultAppConfig = ()=>{\n    var _a;\n    return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.config;\n};\n/**\r\n * Returns an experimental setting on the __FIREBASE_DEFAULTS__ object (properties\r\n * prefixed by \"_\")\r\n * @public\r\n */ const getExperimentalSetting = (name)=>{\n    var _a;\n    return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a[`_${name}`];\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ class Deferred {\n    constructor(){\n        this.reject = ()=>{};\n        this.resolve = ()=>{};\n        this.promise = new Promise((resolve, reject)=>{\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n    /**\r\n     * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around\r\n     * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback\r\n     * and returns a node-style callback which will resolve or reject the Deferred's promise.\r\n     */ wrapCallback(callback) {\n        return (error, value)=>{\n            if (error) {\n                this.reject(error);\n            } else {\n                this.resolve(value);\n            }\n            if (typeof callback === \"function\") {\n                // Attaching noop handler just in case developer wasn't expecting\n                // promises\n                this.promise.catch(()=>{});\n                // Some of our callbacks don't expect a value and our own tests\n                // assert that the parameter length is 1\n                if (callback.length === 1) {\n                    callback(error);\n                } else {\n                    callback(error, value);\n                }\n            }\n        };\n    }\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function createMockUserToken(token, projectId) {\n    if (token.uid) {\n        throw new Error('The \"uid\" field is no longer supported by mockUserToken. Please use \"sub\" instead for Firebase Auth User ID.');\n    }\n    // Unsecured JWTs use \"none\" as the algorithm.\n    const header = {\n        alg: \"none\",\n        type: \"JWT\"\n    };\n    const project = projectId || \"demo-project\";\n    const iat = token.iat || 0;\n    const sub = token.sub || token.user_id;\n    if (!sub) {\n        throw new Error(\"mockUserToken must contain 'sub' or 'user_id' field!\");\n    }\n    const payload = Object.assign({\n        // Set all required fields to decent defaults\n        iss: `https://securetoken.google.com/${project}`,\n        aud: project,\n        iat,\n        exp: iat + 3600,\n        auth_time: iat,\n        sub,\n        user_id: sub,\n        firebase: {\n            sign_in_provider: \"custom\",\n            identities: {}\n        }\n    }, token);\n    // Unsecured JWTs use the empty string as a signature.\n    const signature = \"\";\n    return [\n        base64urlEncodeWithoutPadding(JSON.stringify(header)),\n        base64urlEncodeWithoutPadding(JSON.stringify(payload)),\n        signature\n    ].join(\".\");\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Returns navigator.userAgent string or '' if it's not defined.\r\n * @return user agent string\r\n */ function getUA() {\n    if (typeof navigator !== \"undefined\" && typeof navigator[\"userAgent\"] === \"string\") {\n        return navigator[\"userAgent\"];\n    } else {\n        return \"\";\n    }\n}\n/**\r\n * Detect Cordova / PhoneGap / Ionic frameworks on a mobile device.\r\n *\r\n * Deliberately does not rely on checking `file://` URLs (as this fails PhoneGap\r\n * in the Ripple emulator) nor Cordova `onDeviceReady`, which would normally\r\n * wait for a callback.\r\n */ function isMobileCordova() {\n    return  false && 0;\n}\n/**\r\n * Detect Node.js.\r\n *\r\n * @return true if Node.js environment is detected or specified.\r\n */ // Node detection logic from: https://github.com/iliakan/detect-node/\nfunction isNode() {\n    var _a;\n    const forceEnvironment = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.forceEnvironment;\n    if (forceEnvironment === \"node\") {\n        return true;\n    } else if (forceEnvironment === \"browser\") {\n        return false;\n    }\n    try {\n        return Object.prototype.toString.call(global.process) === \"[object process]\";\n    } catch (e) {\n        return false;\n    }\n}\n/**\r\n * Detect Browser Environment\r\n */ function isBrowser() {\n    return typeof self === \"object\" && self.self === self;\n}\nfunction isBrowserExtension() {\n    const runtime = typeof chrome === \"object\" ? chrome.runtime : typeof browser === \"object\" ? browser.runtime : undefined;\n    return typeof runtime === \"object\" && runtime.id !== undefined;\n}\n/**\r\n * Detect React Native.\r\n *\r\n * @return true if ReactNative environment is detected.\r\n */ function isReactNative() {\n    return typeof navigator === \"object\" && navigator[\"product\"] === \"ReactNative\";\n}\n/** Detects Electron apps. */ function isElectron() {\n    return getUA().indexOf(\"Electron/\") >= 0;\n}\n/** Detects Internet Explorer. */ function isIE() {\n    const ua = getUA();\n    return ua.indexOf(\"MSIE \") >= 0 || ua.indexOf(\"Trident/\") >= 0;\n}\n/** Detects Universal Windows Platform apps. */ function isUWP() {\n    return getUA().indexOf(\"MSAppHost/\") >= 0;\n}\n/**\r\n * Detect whether the current SDK build is the Node version.\r\n *\r\n * @return true if it's the Node SDK build.\r\n */ function isNodeSdk() {\n    return CONSTANTS.NODE_CLIENT === true || CONSTANTS.NODE_ADMIN === true;\n}\n/** Returns true if we are running in Safari. */ function isSafari() {\n    return !isNode() && !!navigator.userAgent && navigator.userAgent.includes(\"Safari\") && !navigator.userAgent.includes(\"Chrome\");\n}\n/**\r\n * This method checks if indexedDB is supported by current browser/service worker context\r\n * @return true if indexedDB is supported by current browser/service worker context\r\n */ function isIndexedDBAvailable() {\n    try {\n        return typeof indexedDB === \"object\";\n    } catch (e) {\n        return false;\n    }\n}\n/**\r\n * This method validates browser/sw context for indexedDB by opening a dummy indexedDB database and reject\r\n * if errors occur during the database open operation.\r\n *\r\n * @throws exception if current browser/sw context can't run idb.open (ex: Safari iframe, Firefox\r\n * private browsing)\r\n */ function validateIndexedDBOpenable() {\n    return new Promise((resolve, reject)=>{\n        try {\n            let preExist = true;\n            const DB_CHECK_NAME = \"validate-browser-context-for-indexeddb-analytics-module\";\n            const request = self.indexedDB.open(DB_CHECK_NAME);\n            request.onsuccess = ()=>{\n                request.result.close();\n                // delete database only when it doesn't pre-exist\n                if (!preExist) {\n                    self.indexedDB.deleteDatabase(DB_CHECK_NAME);\n                }\n                resolve(true);\n            };\n            request.onupgradeneeded = ()=>{\n                preExist = false;\n            };\n            request.onerror = ()=>{\n                var _a;\n                reject(((_a = request.error) === null || _a === void 0 ? void 0 : _a.message) || \"\");\n            };\n        } catch (error) {\n            reject(error);\n        }\n    });\n}\n/**\r\n *\r\n * This method checks whether cookie is enabled within current browser\r\n * @return true if cookie is enabled within current browser\r\n */ function areCookiesEnabled() {\n    if (typeof navigator === \"undefined\" || !navigator.cookieEnabled) {\n        return false;\n    }\n    return true;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * @fileoverview Standardized Firebase Error.\r\n *\r\n * Usage:\r\n *\r\n *   // Typescript string literals for type-safe codes\r\n *   type Err =\r\n *     'unknown' |\r\n *     'object-not-found'\r\n *     ;\r\n *\r\n *   // Closure enum for type-safe error codes\r\n *   // at-enum {string}\r\n *   var Err = {\r\n *     UNKNOWN: 'unknown',\r\n *     OBJECT_NOT_FOUND: 'object-not-found',\r\n *   }\r\n *\r\n *   let errors: Map<Err, string> = {\r\n *     'generic-error': \"Unknown error\",\r\n *     'file-not-found': \"Could not find file: {$file}\",\r\n *   };\r\n *\r\n *   // Type-safe function - must pass a valid error code as param.\r\n *   let error = new ErrorFactory<Err>('service', 'Service', errors);\r\n *\r\n *   ...\r\n *   throw error.create(Err.GENERIC);\r\n *   ...\r\n *   throw error.create(Err.FILE_NOT_FOUND, {'file': fileName});\r\n *   ...\r\n *   // Service: Could not file file: foo.txt (service/file-not-found).\r\n *\r\n *   catch (e) {\r\n *     assert(e.message === \"Could not find file: foo.txt.\");\r\n *     if ((e as FirebaseError)?.code === 'service/file-not-found') {\r\n *       console.log(\"Could not read file: \" + e['file']);\r\n *     }\r\n *   }\r\n */ const ERROR_NAME = \"FirebaseError\";\n// Based on code from:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types\nclass FirebaseError extends Error {\n    constructor(/** The error code for this error. */ code, message, /** Custom data for this error. */ customData){\n        super(message);\n        this.code = code;\n        this.customData = customData;\n        /** The custom name for all FirebaseErrors. */ this.name = ERROR_NAME;\n        // Fix For ES5\n        // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        Object.setPrototypeOf(this, FirebaseError.prototype);\n        // Maintains proper stack trace for where our error was thrown.\n        // Only available on V8.\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, ErrorFactory.prototype.create);\n        }\n    }\n}\nclass ErrorFactory {\n    constructor(service, serviceName, errors){\n        this.service = service;\n        this.serviceName = serviceName;\n        this.errors = errors;\n    }\n    create(code, ...data) {\n        const customData = data[0] || {};\n        const fullCode = `${this.service}/${code}`;\n        const template = this.errors[code];\n        const message = template ? replaceTemplate(template, customData) : \"Error\";\n        // Service Name: Error message (service/code).\n        const fullMessage = `${this.serviceName}: ${message} (${fullCode}).`;\n        const error = new FirebaseError(fullCode, fullMessage, customData);\n        return error;\n    }\n}\nfunction replaceTemplate(template, data) {\n    return template.replace(PATTERN, (_, key)=>{\n        const value = data[key];\n        return value != null ? String(value) : `<${key}?>`;\n    });\n}\nconst PATTERN = /\\{\\$([^}]+)}/g;\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Evaluates a JSON string into a javascript object.\r\n *\r\n * @param {string} str A string containing JSON.\r\n * @return {*} The javascript object representing the specified JSON.\r\n */ function jsonEval(str) {\n    return JSON.parse(str);\n}\n/**\r\n * Returns JSON representing a javascript object.\r\n * @param {*} data Javascript object to be stringified.\r\n * @return {string} The JSON contents of the object.\r\n */ function stringify(data) {\n    return JSON.stringify(data);\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Decodes a Firebase auth. token into constituent parts.\r\n *\r\n * Notes:\r\n * - May return with invalid / incomplete claims if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */ const decode = function(token) {\n    let header = {}, claims = {}, data = {}, signature = \"\";\n    try {\n        const parts = token.split(\".\");\n        header = jsonEval(base64Decode(parts[0]) || \"\");\n        claims = jsonEval(base64Decode(parts[1]) || \"\");\n        signature = parts[2];\n        data = claims[\"d\"] || {};\n        delete claims[\"d\"];\n    } catch (e) {}\n    return {\n        header,\n        claims,\n        data,\n        signature\n    };\n};\n/**\r\n * Decodes a Firebase auth. token and checks the validity of its time-based claims. Will return true if the\r\n * token is within the time window authorized by the 'nbf' (not-before) and 'iat' (issued-at) claims.\r\n *\r\n * Notes:\r\n * - May return a false negative if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */ const isValidTimestamp = function(token) {\n    const claims = decode(token).claims;\n    const now = Math.floor(new Date().getTime() / 1000);\n    let validSince = 0, validUntil = 0;\n    if (typeof claims === \"object\") {\n        if (claims.hasOwnProperty(\"nbf\")) {\n            validSince = claims[\"nbf\"];\n        } else if (claims.hasOwnProperty(\"iat\")) {\n            validSince = claims[\"iat\"];\n        }\n        if (claims.hasOwnProperty(\"exp\")) {\n            validUntil = claims[\"exp\"];\n        } else {\n            // token will expire after 24h by default\n            validUntil = validSince + 86400;\n        }\n    }\n    return !!now && !!validSince && !!validUntil && now >= validSince && now <= validUntil;\n};\n/**\r\n * Decodes a Firebase auth. token and returns its issued at time if valid, null otherwise.\r\n *\r\n * Notes:\r\n * - May return null if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */ const issuedAtTime = function(token) {\n    const claims = decode(token).claims;\n    if (typeof claims === \"object\" && claims.hasOwnProperty(\"iat\")) {\n        return claims[\"iat\"];\n    }\n    return null;\n};\n/**\r\n * Decodes a Firebase auth. token and checks the validity of its format. Expects a valid issued-at time.\r\n *\r\n * Notes:\r\n * - May return a false negative if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */ const isValidFormat = function(token) {\n    const decoded = decode(token), claims = decoded.claims;\n    return !!claims && typeof claims === \"object\" && claims.hasOwnProperty(\"iat\");\n};\n/**\r\n * Attempts to peer into an auth token and determine if it's an admin auth token by looking at the claims portion.\r\n *\r\n * Notes:\r\n * - May return a false negative if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */ const isAdmin = function(token) {\n    const claims = decode(token).claims;\n    return typeof claims === \"object\" && claims[\"admin\"] === true;\n};\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function contains(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\nfunction safeGet(obj, key) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        return obj[key];\n    } else {\n        return undefined;\n    }\n}\nfunction isEmpty(obj) {\n    for(const key in obj){\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction map(obj, fn, contextObj) {\n    const res = {};\n    for(const key in obj){\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            res[key] = fn.call(contextObj, obj[key], key, obj);\n        }\n    }\n    return res;\n}\n/**\r\n * Deep equal two objects. Support Arrays and Objects.\r\n */ function deepEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    const aKeys = Object.keys(a);\n    const bKeys = Object.keys(b);\n    for (const k of aKeys){\n        if (!bKeys.includes(k)) {\n            return false;\n        }\n        const aProp = a[k];\n        const bProp = b[k];\n        if (isObject(aProp) && isObject(bProp)) {\n            if (!deepEqual(aProp, bProp)) {\n                return false;\n            }\n        } else if (aProp !== bProp) {\n            return false;\n        }\n    }\n    for (const k of bKeys){\n        if (!aKeys.includes(k)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isObject(thing) {\n    return thing !== null && typeof thing === \"object\";\n}\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Rejects if the given promise doesn't resolve in timeInMS milliseconds.\r\n * @internal\r\n */ function promiseWithTimeout(promise, timeInMS = 2000) {\n    const deferredPromise = new Deferred();\n    setTimeout(()=>deferredPromise.reject(\"timeout!\"), timeInMS);\n    promise.then(deferredPromise.resolve, deferredPromise.reject);\n    return deferredPromise.promise;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Returns a querystring-formatted string (e.g. &arg=val&arg2=val2) from a\r\n * params object (e.g. {arg: 'val', arg2: 'val2'})\r\n * Note: You must prepend it with ? when adding it to a URL.\r\n */ function querystring(querystringParams) {\n    const params = [];\n    for (const [key, value] of Object.entries(querystringParams)){\n        if (Array.isArray(value)) {\n            value.forEach((arrayVal)=>{\n                params.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(arrayVal));\n            });\n        } else {\n            params.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(value));\n        }\n    }\n    return params.length ? \"&\" + params.join(\"&\") : \"\";\n}\n/**\r\n * Decodes a querystring (e.g. ?arg=val&arg2=val2) into a params object\r\n * (e.g. {arg: 'val', arg2: 'val2'})\r\n */ function querystringDecode(querystring) {\n    const obj = {};\n    const tokens = querystring.replace(/^\\?/, \"\").split(\"&\");\n    tokens.forEach((token)=>{\n        if (token) {\n            const [key, value] = token.split(\"=\");\n            obj[decodeURIComponent(key)] = decodeURIComponent(value);\n        }\n    });\n    return obj;\n}\n/**\r\n * Extract the query string part of a URL, including the leading question mark (if present).\r\n */ function extractQuerystring(url) {\n    const queryStart = url.indexOf(\"?\");\n    if (!queryStart) {\n        return \"\";\n    }\n    const fragmentStart = url.indexOf(\"#\", queryStart);\n    return url.substring(queryStart, fragmentStart > 0 ? fragmentStart : undefined);\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * @fileoverview SHA-1 cryptographic hash.\r\n * Variable names follow the notation in FIPS PUB 180-3:\r\n * http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf.\r\n *\r\n * Usage:\r\n *   var sha1 = new sha1();\r\n *   sha1.update(bytes);\r\n *   var hash = sha1.digest();\r\n *\r\n * Performance:\r\n *   Chrome 23:   ~400 Mbit/s\r\n *   Firefox 16:  ~250 Mbit/s\r\n *\r\n */ /**\r\n * SHA-1 cryptographic hash constructor.\r\n *\r\n * The properties declared here are discussed in the above algorithm document.\r\n * @constructor\r\n * @final\r\n * @struct\r\n */ class Sha1 {\n    constructor(){\n        /**\r\n         * Holds the previous values of accumulated variables a-e in the compress_\r\n         * function.\r\n         * @private\r\n         */ this.chain_ = [];\n        /**\r\n         * A buffer holding the partially computed hash result.\r\n         * @private\r\n         */ this.buf_ = [];\n        /**\r\n         * An array of 80 bytes, each a part of the message to be hashed.  Referred to\r\n         * as the message schedule in the docs.\r\n         * @private\r\n         */ this.W_ = [];\n        /**\r\n         * Contains data needed to pad messages less than 64 bytes.\r\n         * @private\r\n         */ this.pad_ = [];\n        /**\r\n         * @private {number}\r\n         */ this.inbuf_ = 0;\n        /**\r\n         * @private {number}\r\n         */ this.total_ = 0;\n        this.blockSize = 512 / 8;\n        this.pad_[0] = 128;\n        for(let i = 1; i < this.blockSize; ++i){\n            this.pad_[i] = 0;\n        }\n        this.reset();\n    }\n    reset() {\n        this.chain_[0] = 0x67452301;\n        this.chain_[1] = 0xefcdab89;\n        this.chain_[2] = 0x98badcfe;\n        this.chain_[3] = 0x10325476;\n        this.chain_[4] = 0xc3d2e1f0;\n        this.inbuf_ = 0;\n        this.total_ = 0;\n    }\n    /**\r\n     * Internal compress helper function.\r\n     * @param buf Block to compress.\r\n     * @param offset Offset of the block in the buffer.\r\n     * @private\r\n     */ compress_(buf, offset) {\n        if (!offset) {\n            offset = 0;\n        }\n        const W = this.W_;\n        // get 16 big endian words\n        if (typeof buf === \"string\") {\n            for(let i = 0; i < 16; i++){\n                // TODO(user): [bug 8140122] Recent versions of Safari for Mac OS and iOS\n                // have a bug that turns the post-increment ++ operator into pre-increment\n                // during JIT compilation.  We have code that depends heavily on SHA-1 for\n                // correctness and which is affected by this bug, so I've removed all uses\n                // of post-increment ++ in which the result value is used.  We can revert\n                // this change once the Safari bug\n                // (https://bugs.webkit.org/show_bug.cgi?id=109036) has been fixed and\n                // most clients have been updated.\n                W[i] = buf.charCodeAt(offset) << 24 | buf.charCodeAt(offset + 1) << 16 | buf.charCodeAt(offset + 2) << 8 | buf.charCodeAt(offset + 3);\n                offset += 4;\n            }\n        } else {\n            for(let i = 0; i < 16; i++){\n                W[i] = buf[offset] << 24 | buf[offset + 1] << 16 | buf[offset + 2] << 8 | buf[offset + 3];\n                offset += 4;\n            }\n        }\n        // expand to 80 words\n        for(let i = 16; i < 80; i++){\n            const t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];\n            W[i] = (t << 1 | t >>> 31) & 0xffffffff;\n        }\n        let a = this.chain_[0];\n        let b = this.chain_[1];\n        let c = this.chain_[2];\n        let d = this.chain_[3];\n        let e = this.chain_[4];\n        let f, k;\n        // TODO(user): Try to unroll this loop to speed up the computation.\n        for(let i = 0; i < 80; i++){\n            if (i < 40) {\n                if (i < 20) {\n                    f = d ^ b & (c ^ d);\n                    k = 0x5a827999;\n                } else {\n                    f = b ^ c ^ d;\n                    k = 0x6ed9eba1;\n                }\n            } else {\n                if (i < 60) {\n                    f = b & c | d & (b | c);\n                    k = 0x8f1bbcdc;\n                } else {\n                    f = b ^ c ^ d;\n                    k = 0xca62c1d6;\n                }\n            }\n            const t = (a << 5 | a >>> 27) + f + e + k + W[i] & 0xffffffff;\n            e = d;\n            d = c;\n            c = (b << 30 | b >>> 2) & 0xffffffff;\n            b = a;\n            a = t;\n        }\n        this.chain_[0] = this.chain_[0] + a & 0xffffffff;\n        this.chain_[1] = this.chain_[1] + b & 0xffffffff;\n        this.chain_[2] = this.chain_[2] + c & 0xffffffff;\n        this.chain_[3] = this.chain_[3] + d & 0xffffffff;\n        this.chain_[4] = this.chain_[4] + e & 0xffffffff;\n    }\n    update(bytes, length) {\n        // TODO(johnlenz): tighten the function signature and remove this check\n        if (bytes == null) {\n            return;\n        }\n        if (length === undefined) {\n            length = bytes.length;\n        }\n        const lengthMinusBlock = length - this.blockSize;\n        let n = 0;\n        // Using local instead of member variables gives ~5% speedup on Firefox 16.\n        const buf = this.buf_;\n        let inbuf = this.inbuf_;\n        // The outer while loop should execute at most twice.\n        while(n < length){\n            // When we have no data in the block to top up, we can directly process the\n            // input buffer (assuming it contains sufficient data). This gives ~25%\n            // speedup on Chrome 23 and ~15% speedup on Firefox 16, but requires that\n            // the data is provided in large chunks (or in multiples of 64 bytes).\n            if (inbuf === 0) {\n                while(n <= lengthMinusBlock){\n                    this.compress_(bytes, n);\n                    n += this.blockSize;\n                }\n            }\n            if (typeof bytes === \"string\") {\n                while(n < length){\n                    buf[inbuf] = bytes.charCodeAt(n);\n                    ++inbuf;\n                    ++n;\n                    if (inbuf === this.blockSize) {\n                        this.compress_(buf);\n                        inbuf = 0;\n                        break;\n                    }\n                }\n            } else {\n                while(n < length){\n                    buf[inbuf] = bytes[n];\n                    ++inbuf;\n                    ++n;\n                    if (inbuf === this.blockSize) {\n                        this.compress_(buf);\n                        inbuf = 0;\n                        break;\n                    }\n                }\n            }\n        }\n        this.inbuf_ = inbuf;\n        this.total_ += length;\n    }\n    /** @override */ digest() {\n        const digest = [];\n        let totalBits = this.total_ * 8;\n        // Add pad 0x80 0x00*.\n        if (this.inbuf_ < 56) {\n            this.update(this.pad_, 56 - this.inbuf_);\n        } else {\n            this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));\n        }\n        // Add # bits.\n        for(let i = this.blockSize - 1; i >= 56; i--){\n            this.buf_[i] = totalBits & 255;\n            totalBits /= 256; // Don't use bit-shifting here!\n        }\n        this.compress_(this.buf_);\n        let n = 0;\n        for(let i = 0; i < 5; i++){\n            for(let j = 24; j >= 0; j -= 8){\n                digest[n] = this.chain_[i] >> j & 255;\n                ++n;\n            }\n        }\n        return digest;\n    }\n}\n/**\r\n * Helper to make a Subscribe function (just like Promise helps make a\r\n * Thenable).\r\n *\r\n * @param executor Function which can make calls to a single Observer\r\n *     as a proxy.\r\n * @param onNoObservers Callback when count of Observers goes to zero.\r\n */ function createSubscribe(executor, onNoObservers) {\n    const proxy = new ObserverProxy(executor, onNoObservers);\n    return proxy.subscribe.bind(proxy);\n}\n/**\r\n * Implement fan-out for any number of Observers attached via a subscribe\r\n * function.\r\n */ class ObserverProxy {\n    /**\r\n     * @param executor Function which can make calls to a single Observer\r\n     *     as a proxy.\r\n     * @param onNoObservers Callback when count of Observers goes to zero.\r\n     */ constructor(executor, onNoObservers){\n        this.observers = [];\n        this.unsubscribes = [];\n        this.observerCount = 0;\n        // Micro-task scheduling by calling task.then().\n        this.task = Promise.resolve();\n        this.finalized = false;\n        this.onNoObservers = onNoObservers;\n        // Call the executor asynchronously so subscribers that are called\n        // synchronously after the creation of the subscribe function\n        // can still receive the very first value generated in the executor.\n        this.task.then(()=>{\n            executor(this);\n        }).catch((e)=>{\n            this.error(e);\n        });\n    }\n    next(value) {\n        this.forEachObserver((observer)=>{\n            observer.next(value);\n        });\n    }\n    error(error) {\n        this.forEachObserver((observer)=>{\n            observer.error(error);\n        });\n        this.close(error);\n    }\n    complete() {\n        this.forEachObserver((observer)=>{\n            observer.complete();\n        });\n        this.close();\n    }\n    /**\r\n     * Subscribe function that can be used to add an Observer to the fan-out list.\r\n     *\r\n     * - We require that no event is sent to a subscriber sychronously to their\r\n     *   call to subscribe().\r\n     */ subscribe(nextOrObserver, error, complete) {\n        let observer;\n        if (nextOrObserver === undefined && error === undefined && complete === undefined) {\n            throw new Error(\"Missing Observer.\");\n        }\n        // Assemble an Observer object when passed as callback functions.\n        if (implementsAnyMethods(nextOrObserver, [\n            \"next\",\n            \"error\",\n            \"complete\"\n        ])) {\n            observer = nextOrObserver;\n        } else {\n            observer = {\n                next: nextOrObserver,\n                error,\n                complete\n            };\n        }\n        if (observer.next === undefined) {\n            observer.next = noop;\n        }\n        if (observer.error === undefined) {\n            observer.error = noop;\n        }\n        if (observer.complete === undefined) {\n            observer.complete = noop;\n        }\n        const unsub = this.unsubscribeOne.bind(this, this.observers.length);\n        // Attempt to subscribe to a terminated Observable - we\n        // just respond to the Observer with the final error or complete\n        // event.\n        if (this.finalized) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this.task.then(()=>{\n                try {\n                    if (this.finalError) {\n                        observer.error(this.finalError);\n                    } else {\n                        observer.complete();\n                    }\n                } catch (e) {\n                // nothing\n                }\n                return;\n            });\n        }\n        this.observers.push(observer);\n        return unsub;\n    }\n    // Unsubscribe is synchronous - we guarantee that no events are sent to\n    // any unsubscribed Observer.\n    unsubscribeOne(i) {\n        if (this.observers === undefined || this.observers[i] === undefined) {\n            return;\n        }\n        delete this.observers[i];\n        this.observerCount -= 1;\n        if (this.observerCount === 0 && this.onNoObservers !== undefined) {\n            this.onNoObservers(this);\n        }\n    }\n    forEachObserver(fn) {\n        if (this.finalized) {\n            // Already closed by previous event....just eat the additional values.\n            return;\n        }\n        // Since sendOne calls asynchronously - there is no chance that\n        // this.observers will become undefined.\n        for(let i = 0; i < this.observers.length; i++){\n            this.sendOne(i, fn);\n        }\n    }\n    // Call the Observer via one of it's callback function. We are careful to\n    // confirm that the observe has not been unsubscribed since this asynchronous\n    // function had been queued.\n    sendOne(i, fn) {\n        // Execute the callback asynchronously\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.task.then(()=>{\n            if (this.observers !== undefined && this.observers[i] !== undefined) {\n                try {\n                    fn(this.observers[i]);\n                } catch (e) {\n                    // Ignore exceptions raised in Observers or missing methods of an\n                    // Observer.\n                    // Log error to console. b/31404806\n                    if (typeof console !== \"undefined\" && console.error) {\n                        console.error(e);\n                    }\n                }\n            }\n        });\n    }\n    close(err) {\n        if (this.finalized) {\n            return;\n        }\n        this.finalized = true;\n        if (err !== undefined) {\n            this.finalError = err;\n        }\n        // Proxy is no longer needed - garbage collect references\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.task.then(()=>{\n            this.observers = undefined;\n            this.onNoObservers = undefined;\n        });\n    }\n}\n/** Turn synchronous function into one called asynchronously. */ // eslint-disable-next-line @typescript-eslint/ban-types\nfunction async(fn, onError) {\n    return (...args)=>{\n        Promise.resolve(true).then(()=>{\n            fn(...args);\n        }).catch((error)=>{\n            if (onError) {\n                onError(error);\n            }\n        });\n    };\n}\n/**\r\n * Return true if the object passed in implements any of the named methods.\r\n */ function implementsAnyMethods(obj, methods) {\n    if (typeof obj !== \"object\" || obj === null) {\n        return false;\n    }\n    for (const method of methods){\n        if (method in obj && typeof obj[method] === \"function\") {\n            return true;\n        }\n    }\n    return false;\n}\nfunction noop() {\n// do nothing\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Check to make sure the appropriate number of arguments are provided for a public function.\r\n * Throws an error if it fails.\r\n *\r\n * @param fnName The function name\r\n * @param minCount The minimum number of arguments to allow for the function call\r\n * @param maxCount The maximum number of argument to allow for the function call\r\n * @param argCount The actual number of arguments provided.\r\n */ const validateArgCount = function(fnName, minCount, maxCount, argCount) {\n    let argError;\n    if (argCount < minCount) {\n        argError = \"at least \" + minCount;\n    } else if (argCount > maxCount) {\n        argError = maxCount === 0 ? \"none\" : \"no more than \" + maxCount;\n    }\n    if (argError) {\n        const error = fnName + \" failed: Was called with \" + argCount + (argCount === 1 ? \" argument.\" : \" arguments.\") + \" Expects \" + argError + \".\";\n        throw new Error(error);\n    }\n};\n/**\r\n * Generates a string to prefix an error message about failed argument validation\r\n *\r\n * @param fnName The function name\r\n * @param argName The name of the argument\r\n * @return The prefix to add to the error thrown for validation.\r\n */ function errorPrefix(fnName, argName) {\n    return `${fnName} failed: ${argName} argument `;\n}\n/**\r\n * @param fnName\r\n * @param argumentNumber\r\n * @param namespace\r\n * @param optional\r\n */ function validateNamespace(fnName, namespace, optional) {\n    if (optional && !namespace) {\n        return;\n    }\n    if (typeof namespace !== \"string\") {\n        //TODO: I should do more validation here. We only allow certain chars in namespaces.\n        throw new Error(errorPrefix(fnName, \"namespace\") + \"must be a valid firebase namespace.\");\n    }\n}\nfunction validateCallback(fnName, argumentName, // eslint-disable-next-line @typescript-eslint/ban-types\ncallback, optional) {\n    if (optional && !callback) {\n        return;\n    }\n    if (typeof callback !== \"function\") {\n        throw new Error(errorPrefix(fnName, argumentName) + \"must be a valid function.\");\n    }\n}\nfunction validateContextObject(fnName, argumentName, context, optional) {\n    if (optional && !context) {\n        return;\n    }\n    if (typeof context !== \"object\" || context === null) {\n        throw new Error(errorPrefix(fnName, argumentName) + \"must be a valid context object.\");\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // Code originally came from goog.crypt.stringToUtf8ByteArray, but for some reason they\n// automatically replaced '\\r\\n' with '\\n', and they didn't handle surrogate pairs,\n// so it's been modified.\n// Note that not all Unicode characters appear as single characters in JavaScript strings.\n// fromCharCode returns the UTF-16 encoding of a character - so some Unicode characters\n// use 2 characters in Javascript.  All 4-byte UTF-8 characters begin with a first\n// character in the range 0xD800 - 0xDBFF (the first character of a so-called surrogate\n// pair).\n// See http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3\n/**\r\n * @param {string} str\r\n * @return {Array}\r\n */ const stringToByteArray = function(str) {\n    const out = [];\n    let p = 0;\n    for(let i = 0; i < str.length; i++){\n        let c = str.charCodeAt(i);\n        // Is this the lead surrogate in a surrogate pair?\n        if (c >= 0xd800 && c <= 0xdbff) {\n            const high = c - 0xd800; // the high 10 bits.\n            i++;\n            assert(i < str.length, \"Surrogate pair missing trail surrogate.\");\n            const low = str.charCodeAt(i) - 0xdc00; // the low 10 bits.\n            c = 0x10000 + (high << 10) + low;\n        }\n        if (c < 128) {\n            out[p++] = c;\n        } else if (c < 2048) {\n            out[p++] = c >> 6 | 192;\n            out[p++] = c & 63 | 128;\n        } else if (c < 65536) {\n            out[p++] = c >> 12 | 224;\n            out[p++] = c >> 6 & 63 | 128;\n            out[p++] = c & 63 | 128;\n        } else {\n            out[p++] = c >> 18 | 240;\n            out[p++] = c >> 12 & 63 | 128;\n            out[p++] = c >> 6 & 63 | 128;\n            out[p++] = c & 63 | 128;\n        }\n    }\n    return out;\n};\n/**\r\n * Calculate length without actually converting; useful for doing cheaper validation.\r\n * @param {string} str\r\n * @return {number}\r\n */ const stringLength = function(str) {\n    let p = 0;\n    for(let i = 0; i < str.length; i++){\n        const c = str.charCodeAt(i);\n        if (c < 128) {\n            p++;\n        } else if (c < 2048) {\n            p += 2;\n        } else if (c >= 0xd800 && c <= 0xdbff) {\n            // Lead surrogate of a surrogate pair.  The pair together will take 4 bytes to represent.\n            p += 4;\n            i++; // skip trail surrogate.\n        } else {\n            p += 3;\n        }\n    }\n    return p;\n};\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Copied from https://stackoverflow.com/a/2117523\r\n * Generates a new uuid.\r\n * @public\r\n */ const uuidv4 = function() {\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c)=>{\n        const r = Math.random() * 16 | 0, v = c === \"x\" ? r : r & 0x3 | 0x8;\n        return v.toString(16);\n    });\n};\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * The amount of milliseconds to exponentially increase.\r\n */ const DEFAULT_INTERVAL_MILLIS = 1000;\n/**\r\n * The factor to backoff by.\r\n * Should be a number greater than 1.\r\n */ const DEFAULT_BACKOFF_FACTOR = 2;\n/**\r\n * The maximum milliseconds to increase to.\r\n *\r\n * <p>Visible for testing\r\n */ const MAX_VALUE_MILLIS = 4 * 60 * 60 * 1000; // Four hours, like iOS and Android.\n/**\r\n * The percentage of backoff time to randomize by.\r\n * See\r\n * http://go/safe-client-behavior#step-1-determine-the-appropriate-retry-interval-to-handle-spike-traffic\r\n * for context.\r\n *\r\n * <p>Visible for testing\r\n */ const RANDOM_FACTOR = 0.5;\n/**\r\n * Based on the backoff method from\r\n * https://github.com/google/closure-library/blob/master/closure/goog/math/exponentialbackoff.js.\r\n * Extracted here so we don't need to pass metadata and a stateful ExponentialBackoff object around.\r\n */ function calculateBackoffMillis(backoffCount, intervalMillis = DEFAULT_INTERVAL_MILLIS, backoffFactor = DEFAULT_BACKOFF_FACTOR) {\n    // Calculates an exponentially increasing value.\n    // Deviation: calculates value from count and a constant interval, so we only need to save value\n    // and count to restore state.\n    const currBaseValue = intervalMillis * Math.pow(backoffFactor, backoffCount);\n    // A random \"fuzz\" to avoid waves of retries.\n    // Deviation: randomFactor is required.\n    const randomWait = Math.round(// A fraction of the backoff value to add/subtract.\n    // Deviation: changes multiplication order to improve readability.\n    RANDOM_FACTOR * currBaseValue * // A random float (rounded to int by Math.round above) in the range [-1, 1]. Determines\n    // if we add or subtract.\n    (Math.random() - 0.5) * 2);\n    // Limits backoff to max to avoid effectively permanent backoff.\n    return Math.min(MAX_VALUE_MILLIS, currBaseValue + randomWait);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ /**\r\n * Provide English ordinal letters after a number\r\n */ function ordinal(i) {\n    if (!Number.isFinite(i)) {\n        return `${i}`;\n    }\n    return i + indicator(i);\n}\nfunction indicator(i) {\n    i = Math.abs(i);\n    const cent = i % 100;\n    if (cent >= 10 && cent <= 20) {\n        return \"th\";\n    }\n    const dec = i % 10;\n    if (dec === 1) {\n        return \"st\";\n    }\n    if (dec === 2) {\n        return \"nd\";\n    }\n    if (dec === 3) {\n        return \"rd\";\n    }\n    return \"th\";\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ function getModularInstance(service) {\n    if (service && service._delegate) {\n        return service._delegate;\n    } else {\n        return service;\n    }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */ // Overriding the constant (we should be the only ones doing this)\nCONSTANTS.NODE_CLIENT = true;\n //# sourceMappingURL=index.node.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9ub2RlLWVzbS9pbmRleC5ub2RlLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRDs7Q0FFQyxHQUNELE1BQU1BLFlBQVk7SUFDZDs7S0FFQyxHQUNEQyxhQUFhO0lBQ2I7O0tBRUMsR0FDREMsWUFBWTtJQUNaOztLQUVDLEdBQ0RDLGFBQWE7QUFDakI7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRDs7Q0FFQyxHQUNELE1BQU1DLFNBQVMsU0FBVUMsU0FBUyxFQUFFQyxPQUFPO0lBQ3ZDLElBQUksQ0FBQ0QsV0FBVztRQUNaLE1BQU1FLGVBQWVEO0lBQ3pCO0FBQ0o7QUFDQTs7Q0FFQyxHQUNELE1BQU1DLGlCQUFpQixTQUFVRCxPQUFPO0lBQ3BDLE9BQU8sSUFBSUUsTUFBTSx3QkFDYlIsVUFBVUcsV0FBVyxHQUNyQiwrQkFDQUc7QUFDUjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNELE1BQU1HLHNCQUFzQixTQUFVQyxHQUFHO0lBQ3JDLDJEQUEyRDtJQUMzRCxNQUFNQyxNQUFNLEVBQUU7SUFDZCxJQUFJQyxJQUFJO0lBQ1IsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILElBQUlJLE1BQU0sRUFBRUQsSUFBSztRQUNqQyxJQUFJRSxJQUFJTCxJQUFJTSxVQUFVLENBQUNIO1FBQ3ZCLElBQUlFLElBQUksS0FBSztZQUNUSixHQUFHLENBQUNDLElBQUksR0FBR0c7UUFDZixPQUNLLElBQUlBLElBQUksTUFBTTtZQUNmSixHQUFHLENBQUNDLElBQUksR0FBRyxLQUFNLElBQUs7WUFDdEJELEdBQUcsQ0FBQ0MsSUFBSSxHQUFHLElBQUssS0FBTTtRQUMxQixPQUNLLElBQUksQ0FBQ0csSUFBSSxNQUFLLE1BQU8sVUFD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QVM7SUFDNUIsT0FDSztRQUNELE9BQU85SjtJQUNYO0FBQ0o7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRCxrRUFBa0U7QUFDbEUxTSxVQUFVQyxXQUFXLEdBQUc7QUFFbzhCLENBQzU5QiwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93b3JsZHdlYi8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9kaXN0L25vZGUtZXNtL2luZGV4Lm5vZGUuZXNtLmpzPzllN2QiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEBmaWxlb3ZlcnZpZXcgRmlyZWJhc2UgY29uc3RhbnRzLiAgU29tZSBvZiB0aGVzZSAoQGRlZmluZXMpIGNhbiBiZSBvdmVycmlkZGVuIGF0IGNvbXBpbGUtdGltZS5cclxuICovXHJcbmNvbnN0IENPTlNUQU5UUyA9IHtcclxuICAgIC8qKlxyXG4gICAgICogQGRlZmluZSB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIGlzIHRoZSBjbGllbnQgTm9kZS5qcyBTREsuXHJcbiAgICAgKi9cclxuICAgIE5PREVfQ0xJRU5UOiBmYWxzZSxcclxuICAgIC8qKlxyXG4gICAgICogQGRlZmluZSB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIGlzIHRoZSBBZG1pbiBOb2RlLmpzIFNESy5cclxuICAgICAqL1xyXG4gICAgTk9ERV9BRE1JTjogZmFsc2UsXHJcbiAgICAvKipcclxuICAgICAqIEZpcmViYXNlIFNESyBWZXJzaW9uXHJcbiAgICAgKi9cclxuICAgIFNES19WRVJTSU9OOiAnJHtKU0NPUkVfVkVSU0lPTn0nXHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHByb3ZpZGVkIGFzc2VydGlvbiBpcyBmYWxzeVxyXG4gKi9cclxuY29uc3QgYXNzZXJ0ID0gZnVuY3Rpb24gKGFzc2VydGlvbiwgbWVzc2FnZSkge1xyXG4gICAgaWYgKCFhc3NlcnRpb24pIHtcclxuICAgICAgICB0aHJvdyBhc3NlcnRpb25FcnJvcihtZXNzYWdlKTtcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIFJldHVybnMgYW4gRXJyb3Igb2JqZWN0IHN1aXRhYmxlIGZvciB0aHJvd2luZy5cclxuICovXHJcbmNvbnN0IGFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgIHJldHVybiBuZXcgRXJyb3IoJ0ZpcmViYXNlIERhdGFiYXNlICgnICtcclxuICAgICAgICBDT05TVEFOVFMuU0RLX1ZFUlNJT04gK1xyXG4gICAgICAgICcpIElOVEVSTkFMIEFTU0VSVCBGQUlMRUQ6ICcgK1xyXG4gICAgICAgIG1lc3NhZ2UpO1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBzdHJpbmdUb0J5dGVBcnJheSQxID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgLy8gVE9ETyh1c2VyKTogVXNlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbnMgaWYvd2hlbiBhdmFpbGFibGVcclxuICAgIGNvbnN0IG91dCA9IFtdO1xyXG4gICAgbGV0IHAgPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGlmIChjIDwgMTI4KSB7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gYztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYyA8IDIwNDgpIHtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyA+PiA2KSB8IDE5MjtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiZcclxuICAgICAgICAgICAgaSArIDEgPCBzdHIubGVuZ3RoICYmXHJcbiAgICAgICAgICAgIChzdHIuY2hhckNvZGVBdChpICsgMSkgJiAweGZjMDApID09PSAweGRjMDApIHtcclxuICAgICAgICAgICAgLy8gU3Vycm9nYXRlIFBhaXJcclxuICAgICAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgJiAweDAzZmYpIDw8IDEwKSArIChzdHIuY2hhckNvZGVBdCgrK2kpICYgMHgwM2ZmKTtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyA+PiAxOCkgfCAyNDA7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKChjID4+IDEyKSAmIDYzKSB8IDEyODtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoKGMgPj4gNikgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDEyKSB8IDIyNDtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoKGMgPj4gNikgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuLyoqXHJcbiAqIFR1cm5zIGFuIGFycmF5IG9mIG51bWJlcnMgaW50byB0aGUgc3RyaW5nIGdpdmVuIGJ5IHRoZSBjb25jYXRlbmF0aW9uIG9mIHRoZVxyXG4gKiBjaGFyYWN0ZXJzIHRvIHdoaWNoIHRoZSBudW1iZXJzIGNvcnJlc3BvbmQuXHJcbiAqIEBwYXJhbSBieXRlcyBBcnJheSBvZiBudW1iZXJzIHJlcHJlc2VudGluZyBjaGFyYWN0ZXJzLlxyXG4gKiBAcmV0dXJuIFN0cmluZ2lmaWNhdGlvbiBvZiB0aGUgYXJyYXkuXHJcbiAqL1xyXG5jb25zdCBieXRlQXJyYXlUb1N0cmluZyA9IGZ1bmN0aW9uIChieXRlcykge1xyXG4gICAgLy8gVE9ETyh1c2VyKTogVXNlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbnMgaWYvd2hlbiBhdmFpbGFibGVcclxuICAgIGNvbnN0IG91dCA9IFtdO1xyXG4gICAgbGV0IHBvcyA9IDAsIGMgPSAwO1xyXG4gICAgd2hpbGUgKHBvcyA8IGJ5dGVzLmxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IGMxID0gYnl0ZXNbcG9zKytdO1xyXG4gICAgICAgIGlmIChjMSA8IDEyOCkge1xyXG4gICAgICAgICAgICBvdXRbYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYzEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjMSA+IDE5MSAmJiBjMSA8IDIyNCkge1xyXG4gICAgICAgICAgICBjb25zdCBjMiA9IGJ5dGVzW3BvcysrXTtcclxuICAgICAgICAgICAgb3V0W2MrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYzEgJiAzMSkgPDwgNikgfCAoYzIgJiA2MykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjMSA+IDIzOSAmJiBjMSA8IDM2NSkge1xyXG4gICAgICAgICAgICAvLyBTdXJyb2dhdGUgUGFpclxyXG4gICAgICAgICAgICBjb25zdCBjMiA9IGJ5dGVzW3BvcysrXTtcclxuICAgICAgICAgICAgY29uc3QgYzMgPSBieXRlc1twb3MrK107XHJcbiAgICAgICAgICAgIGNvbnN0IGM0ID0gYnl0ZXNbcG9zKytdO1xyXG4gICAgICAgICAgICBjb25zdCB1ID0gKCgoYzEgJiA3KSA8PCAxOCkgfCAoKGMyICYgNjMpIDw8IDEyKSB8ICgoYzMgJiA2MykgPDwgNikgfCAoYzQgJiA2MykpIC1cclxuICAgICAgICAgICAgICAgIDB4MTAwMDA7XHJcbiAgICAgICAgICAgIG91dFtjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGQ4MDAgKyAodSA+PiAxMCkpO1xyXG4gICAgICAgICAgICBvdXRbYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkYzAwICsgKHUgJiAxMDIzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBjMiA9IGJ5dGVzW3BvcysrXTtcclxuICAgICAgICAgICAgY29uc3QgYzMgPSBieXRlc1twb3MrK107XHJcbiAgICAgICAgICAgIG91dFtjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMxICYgMTUpIDw8IDEyKSB8ICgoYzIgJiA2MykgPDwgNikgfCAoYzMgJiA2MykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvdXQuam9pbignJyk7XHJcbn07XHJcbi8vIFdlIGRlZmluZSBpdCBhcyBhbiBvYmplY3QgbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY2xhc3MgYmVjYXVzZSBhIGNsYXNzIGNvbXBpbGVkIGRvd24gdG8gZXM1IGNhbid0XHJcbi8vIGJlIHRyZWVzaGFrZWQuIGh0dHBzOi8vZ2l0aHViLmNvbS9yb2xsdXAvcm9sbHVwL2lzc3Vlcy8xNjkxXHJcbi8vIFN0YXRpYyBsb29rdXAgbWFwcywgbGF6aWx5IHBvcHVsYXRlZCBieSBpbml0XygpXHJcbmNvbnN0IGJhc2U2NCA9IHtcclxuICAgIC8qKlxyXG4gICAgICogTWFwcyBieXRlcyB0byBjaGFyYWN0ZXJzLlxyXG4gICAgICovXHJcbiAgICBieXRlVG9DaGFyTWFwXzogbnVsbCxcclxuICAgIC8qKlxyXG4gICAgICogTWFwcyBjaGFyYWN0ZXJzIHRvIGJ5dGVzLlxyXG4gICAgICovXHJcbiAgICBjaGFyVG9CeXRlTWFwXzogbnVsbCxcclxuICAgIC8qKlxyXG4gICAgICogTWFwcyBieXRlcyB0byB3ZWJzYWZlIGNoYXJhY3RlcnMuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBieXRlVG9DaGFyTWFwV2ViU2FmZV86IG51bGwsXHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgd2Vic2FmZSBjaGFyYWN0ZXJzIHRvIGJ5dGVzLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgY2hhclRvQnl0ZU1hcFdlYlNhZmVfOiBudWxsLFxyXG4gICAgLyoqXHJcbiAgICAgKiBPdXIgZGVmYXVsdCBhbHBoYWJldCwgc2hhcmVkIGJldHdlZW5cclxuICAgICAqIEVOQ09ERURfVkFMUyBhbmQgRU5DT0RFRF9WQUxTX1dFQlNBRkVcclxuICAgICAqL1xyXG4gICAgRU5DT0RFRF9WQUxTX0JBU0U6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWicgKyAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonICsgJzAxMjM0NTY3ODknLFxyXG4gICAgLyoqXHJcbiAgICAgKiBPdXIgZGVmYXVsdCBhbHBoYWJldC4gVmFsdWUgNjQgKD0pIGlzIHNwZWNpYWw7IGl0IG1lYW5zIFwibm90aGluZy5cIlxyXG4gICAgICovXHJcbiAgICBnZXQgRU5DT0RFRF9WQUxTKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLkVOQ09ERURfVkFMU19CQVNFICsgJysvPSc7XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBPdXIgd2Vic2FmZSBhbHBoYWJldC5cclxuICAgICAqL1xyXG4gICAgZ2V0IEVOQ09ERURfVkFMU19XRUJTQUZFKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLkVOQ09ERURfVkFMU19CQVNFICsgJy1fLic7XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoaXMgYnJvd3NlciBzdXBwb3J0cyB0aGUgYXRvYiBhbmQgYnRvYSBmdW5jdGlvbnMuIFRoaXMgZXh0ZW5zaW9uXHJcbiAgICAgKiBzdGFydGVkIGF0IE1vemlsbGEgYnV0IGlzIG5vdyBpbXBsZW1lbnRlZCBieSBtYW55IGJyb3dzZXJzLiBXZSB1c2UgdGhlXHJcbiAgICAgKiBBU1NVTUVfKiB2YXJpYWJsZXMgdG8gYXZvaWQgcHVsbGluZyBpbiB0aGUgZnVsbCB1c2VyYWdlbnQgZGV0ZWN0aW9uIGxpYnJhcnlcclxuICAgICAqIGJ1dCBzdGlsbCBhbGxvd2luZyB0aGUgc3RhbmRhcmQgcGVyLWJyb3dzZXIgY29tcGlsYXRpb25zLlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgSEFTX05BVElWRV9TVVBQT1JUOiB0eXBlb2YgYXRvYiA9PT0gJ2Z1bmN0aW9uJyxcclxuICAgIC8qKlxyXG4gICAgICogQmFzZTY0LWVuY29kZSBhbiBhcnJheSBvZiBieXRlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5wdXQgQW4gYXJyYXkgb2YgYnl0ZXMgKG51bWJlcnMgd2l0aFxyXG4gICAgICogICAgIHZhbHVlIGluIFswLCAyNTVdKSB0byBlbmNvZGUuXHJcbiAgICAgKiBAcGFyYW0gd2ViU2FmZSBCb29sZWFuIGluZGljYXRpbmcgd2Ugc2hvdWxkIHVzZSB0aGVcclxuICAgICAqICAgICBhbHRlcm5hdGl2ZSBhbHBoYWJldC5cclxuICAgICAqIEByZXR1cm4gVGhlIGJhc2U2NCBlbmNvZGVkIHN0cmluZy5cclxuICAgICAqL1xyXG4gICAgZW5jb2RlQnl0ZUFycmF5KGlucHV0LCB3ZWJTYWZlKSB7XHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignZW5jb2RlQnl0ZUFycmF5IHRha2VzIGFuIGFycmF5IGFzIGEgcGFyYW1ldGVyJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaW5pdF8oKTtcclxuICAgICAgICBjb25zdCBieXRlVG9DaGFyTWFwID0gd2ViU2FmZVxyXG4gICAgICAgICAgICA/IHRoaXMuYnl0ZVRvQ2hhck1hcFdlYlNhZmVfXHJcbiAgICAgICAgICAgIDogdGhpcy5ieXRlVG9DaGFyTWFwXztcclxuICAgICAgICBjb25zdCBvdXRwdXQgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSArPSAzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUxID0gaW5wdXRbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IGhhdmVCeXRlMiA9IGkgKyAxIDwgaW5wdXQubGVuZ3RoO1xyXG4gICAgICAgICAgICBjb25zdCBieXRlMiA9IGhhdmVCeXRlMiA/IGlucHV0W2kgKyAxXSA6IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhdmVCeXRlMyA9IGkgKyAyIDwgaW5wdXQubGVuZ3RoO1xyXG4gICAgICAgICAgICBjb25zdCBieXRlMyA9IGhhdmVCeXRlMyA/IGlucHV0W2kgKyAyXSA6IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IG91dEJ5dGUxID0gYnl0ZTEgPj4gMjtcclxuICAgICAgICAgICAgY29uc3Qgb3V0Qnl0ZTIgPSAoKGJ5dGUxICYgMHgwMykgPDwgNCkgfCAoYnl0ZTIgPj4gNCk7XHJcbiAgICAgICAgICAgIGxldCBvdXRCeXRlMyA9ICgoYnl0ZTIgJiAweDBmKSA8PCAyKSB8IChieXRlMyA+PiA2KTtcclxuICAgICAgICAgICAgbGV0IG91dEJ5dGU0ID0gYnl0ZTMgJiAweDNmO1xyXG4gICAgICAgICAgICBpZiAoIWhhdmVCeXRlMykge1xyXG4gICAgICAgICAgICAgICAgb3V0Qnl0ZTQgPSA2NDtcclxuICAgICAgICAgICAgICAgIGlmICghaGF2ZUJ5dGUyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0Qnl0ZTMgPSA2NDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvdXRwdXQucHVzaChieXRlVG9DaGFyTWFwW291dEJ5dGUxXSwgYnl0ZVRvQ2hhck1hcFtvdXRCeXRlMl0sIGJ5dGVUb0NoYXJNYXBbb3V0Qnl0ZTNdLCBieXRlVG9DaGFyTWFwW291dEJ5dGU0XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXRwdXQuam9pbignJyk7XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlNjQtZW5jb2RlIGEgc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbnB1dCBBIHN0cmluZyB0byBlbmNvZGUuXHJcbiAgICAgKiBAcGFyYW0gd2ViU2FmZSBJZiB0cnVlLCB3ZSBzaG91bGQgdXNlIHRoZVxyXG4gICAgICogICAgIGFsdGVybmF0aXZlIGFscGhhYmV0LlxyXG4gICAgICogQHJldHVybiBUaGUgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBlbmNvZGVTdHJpbmcoaW5wdXQsIHdlYlNhZmUpIHtcclxuICAgICAgICAvLyBTaG9ydGN1dCBmb3IgTW96aWxsYSBicm93c2VycyB0aGF0IGltcGxlbWVudFxyXG4gICAgICAgIC8vIGEgbmF0aXZlIGJhc2U2NCBlbmNvZGVyIGluIHRoZSBmb3JtIG9mIFwiYnRvYS9hdG9iXCJcclxuICAgICAgICBpZiAodGhpcy5IQVNfTkFUSVZFX1NVUFBPUlQgJiYgIXdlYlNhZmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJ0b2EoaW5wdXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVCeXRlQXJyYXkoc3RyaW5nVG9CeXRlQXJyYXkkMShpbnB1dCksIHdlYlNhZmUpO1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogQmFzZTY0LWRlY29kZSBhIHN0cmluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5wdXQgdG8gZGVjb2RlLlxyXG4gICAgICogQHBhcmFtIHdlYlNhZmUgVHJ1ZSBpZiB3ZSBzaG91bGQgdXNlIHRoZVxyXG4gICAgICogICAgIGFsdGVybmF0aXZlIGFscGhhYmV0LlxyXG4gICAgICogQHJldHVybiBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBkZWNvZGVkIHZhbHVlLlxyXG4gICAgICovXHJcbiAgICBkZWNvZGVTdHJpbmcoaW5wdXQsIHdlYlNhZmUpIHtcclxuICAgICAgICAvLyBTaG9ydGN1dCBmb3IgTW96aWxsYSBicm93c2VycyB0aGF0IGltcGxlbWVudFxyXG4gICAgICAgIC8vIGEgbmF0aXZlIGJhc2U2NCBlbmNvZGVyIGluIHRoZSBmb3JtIG9mIFwiYnRvYS9hdG9iXCJcclxuICAgICAgICBpZiAodGhpcy5IQVNfTkFUSVZFX1NVUFBPUlQgJiYgIXdlYlNhZmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGF0b2IoaW5wdXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYnl0ZUFycmF5VG9TdHJpbmcodGhpcy5kZWNvZGVTdHJpbmdUb0J5dGVBcnJheShpbnB1dCwgd2ViU2FmZSkpO1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogQmFzZTY0LWRlY29kZSBhIHN0cmluZy5cclxuICAgICAqXHJcbiAgICAgKiBJbiBiYXNlLTY0IGRlY29kaW5nLCBncm91cHMgb2YgZm91ciBjaGFyYWN0ZXJzIGFyZSBjb252ZXJ0ZWQgaW50byB0aHJlZVxyXG4gICAgICogYnl0ZXMuICBJZiB0aGUgZW5jb2RlciBkaWQgbm90IGFwcGx5IHBhZGRpbmcsIHRoZSBpbnB1dCBsZW5ndGggbWF5IG5vdFxyXG4gICAgICogYmUgYSBtdWx0aXBsZSBvZiA0LlxyXG4gICAgICpcclxuICAgICAqIEluIHRoaXMgY2FzZSwgdGhlIGxhc3QgZ3JvdXAgd2lsbCBoYXZlIGZld2VyIHRoYW4gNCBjaGFyYWN0ZXJzLCBhbmRcclxuICAgICAqIHBhZGRpbmcgd2lsbCBiZSBpbmZlcnJlZC4gIElmIHRoZSBncm91cCBoYXMgb25lIG9yIHR3byBjaGFyYWN0ZXJzLCBpdCBkZWNvZGVzXHJcbiAgICAgKiB0byBvbmUgYnl0ZS4gIElmIHRoZSBncm91cCBoYXMgdGhyZWUgY2hhcmFjdGVycywgaXQgZGVjb2RlcyB0byB0d28gYnl0ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlucHV0IElucHV0IHRvIGRlY29kZS5cclxuICAgICAqIEBwYXJhbSB3ZWJTYWZlIFRydWUgaWYgd2Ugc2hvdWxkIHVzZSB0aGUgd2ViLXNhZmUgYWxwaGFiZXQuXHJcbiAgICAgKiBAcmV0dXJuIGJ5dGVzIHJlcHJlc2VudGluZyB0aGUgZGVjb2RlZCB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgZGVjb2RlU3RyaW5nVG9CeXRlQXJyYXkoaW5wdXQsIHdlYlNhZmUpIHtcclxuICAgICAgICB0aGlzLmluaXRfKCk7XHJcbiAgICAgICAgY29uc3QgY2hhclRvQnl0ZU1hcCA9IHdlYlNhZmVcclxuICAgICAgICAgICAgPyB0aGlzLmNoYXJUb0J5dGVNYXBXZWJTYWZlX1xyXG4gICAgICAgICAgICA6IHRoaXMuY2hhclRvQnl0ZU1hcF87XHJcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUxID0gY2hhclRvQnl0ZU1hcFtpbnB1dC5jaGFyQXQoaSsrKV07XHJcbiAgICAgICAgICAgIGNvbnN0IGhhdmVCeXRlMiA9IGkgPCBpbnB1dC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUyID0gaGF2ZUJ5dGUyID8gY2hhclRvQnl0ZU1hcFtpbnB1dC5jaGFyQXQoaSldIDogMDtcclxuICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICBjb25zdCBoYXZlQnl0ZTMgPSBpIDwgaW5wdXQubGVuZ3RoO1xyXG4gICAgICAgICAgICBjb25zdCBieXRlMyA9IGhhdmVCeXRlMyA/IGNoYXJUb0J5dGVNYXBbaW5wdXQuY2hhckF0KGkpXSA6IDY0O1xyXG4gICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhdmVCeXRlNCA9IGkgPCBpbnB1dC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGU0ID0gaGF2ZUJ5dGU0ID8gY2hhclRvQnl0ZU1hcFtpbnB1dC5jaGFyQXQoaSldIDogNjQ7XHJcbiAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgaWYgKGJ5dGUxID09IG51bGwgfHwgYnl0ZTIgPT0gbnVsbCB8fCBieXRlMyA9PSBudWxsIHx8IGJ5dGU0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBEZWNvZGVCYXNlNjRTdHJpbmdFcnJvcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG91dEJ5dGUxID0gKGJ5dGUxIDw8IDIpIHwgKGJ5dGUyID4+IDQpO1xyXG4gICAgICAgICAgICBvdXRwdXQucHVzaChvdXRCeXRlMSk7XHJcbiAgICAgICAgICAgIGlmIChieXRlMyAhPT0gNjQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG91dEJ5dGUyID0gKChieXRlMiA8PCA0KSAmIDB4ZjApIHwgKGJ5dGUzID4+IDIpO1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gob3V0Qnl0ZTIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJ5dGU0ICE9PSA2NCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dEJ5dGUzID0gKChieXRlMyA8PCA2KSAmIDB4YzApIHwgYnl0ZTQ7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gob3V0Qnl0ZTMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBMYXp5IHN0YXRpYyBpbml0aWFsaXphdGlvbiBmdW5jdGlvbi4gQ2FsbGVkIGJlZm9yZVxyXG4gICAgICogYWNjZXNzaW5nIGFueSBvZiB0aGUgc3RhdGljIG1hcCB2YXJpYWJsZXMuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBpbml0XygpIHtcclxuICAgICAgICBpZiAoIXRoaXMuYnl0ZVRvQ2hhck1hcF8pIHtcclxuICAgICAgICAgICAgdGhpcy5ieXRlVG9DaGFyTWFwXyA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBfID0ge307XHJcbiAgICAgICAgICAgIHRoaXMuYnl0ZVRvQ2hhck1hcFdlYlNhZmVfID0ge307XHJcbiAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcFdlYlNhZmVfID0ge307XHJcbiAgICAgICAgICAgIC8vIFdlIHdhbnQgcXVpY2sgbWFwcGluZ3MgYmFjayBhbmQgZm9ydGgsIHNvIHdlIHByZWNvbXB1dGUgdHdvIG1hcHMuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5FTkNPREVEX1ZBTFMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnl0ZVRvQ2hhck1hcF9baV0gPSB0aGlzLkVOQ09ERURfVkFMUy5jaGFyQXQoaSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBfW3RoaXMuYnl0ZVRvQ2hhck1hcF9baV1dID0gaTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnl0ZVRvQ2hhck1hcFdlYlNhZmVfW2ldID0gdGhpcy5FTkNPREVEX1ZBTFNfV0VCU0FGRS5jaGFyQXQoaSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBXZWJTYWZlX1t0aGlzLmJ5dGVUb0NoYXJNYXBXZWJTYWZlX1tpXV0gPSBpO1xyXG4gICAgICAgICAgICAgICAgLy8gQmUgZm9yZ2l2aW5nIHdoZW4gZGVjb2RpbmcgYW5kIGNvcnJlY3RseSBkZWNvZGUgYm90aCBlbmNvZGluZ3MuXHJcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSB0aGlzLkVOQ09ERURfVkFMU19CQVNFLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcF9bdGhpcy5FTkNPREVEX1ZBTFNfV0VCU0FGRS5jaGFyQXQoaSldID0gaTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBXZWJTYWZlX1t0aGlzLkVOQ09ERURfVkFMUy5jaGFyQXQoaSldID0gaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIEFuIGVycm9yIGVuY291bnRlcmVkIHdoaWxlIGRlY29kaW5nIGJhc2U2NCBzdHJpbmcuXHJcbiAqL1xyXG5jbGFzcyBEZWNvZGVCYXNlNjRTdHJpbmdFcnJvciBleHRlbmRzIEVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJ0RlY29kZUJhc2U2NFN0cmluZ0Vycm9yJztcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVVJMLXNhZmUgYmFzZTY0IGVuY29kaW5nXHJcbiAqL1xyXG5jb25zdCBiYXNlNjRFbmNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICBjb25zdCB1dGY4Qnl0ZXMgPSBzdHJpbmdUb0J5dGVBcnJheSQxKHN0cik7XHJcbiAgICByZXR1cm4gYmFzZTY0LmVuY29kZUJ5dGVBcnJheSh1dGY4Qnl0ZXMsIHRydWUpO1xyXG59O1xyXG4vKipcclxuICogVVJMLXNhZmUgYmFzZTY0IGVuY29kaW5nICh3aXRob3V0IFwiLlwiIHBhZGRpbmcgaW4gdGhlIGVuZCkuXHJcbiAqIGUuZy4gVXNlZCBpbiBKU09OIFdlYiBUb2tlbiAoSldUKSBwYXJ0cy5cclxuICovXHJcbmNvbnN0IGJhc2U2NHVybEVuY29kZVdpdGhvdXRQYWRkaW5nID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgLy8gVXNlIGJhc2U2NHVybCBlbmNvZGluZyBhbmQgcmVtb3ZlIHBhZGRpbmcgaW4gdGhlIGVuZCAoZG90IGNoYXJhY3RlcnMpLlxyXG4gICAgcmV0dXJuIGJhc2U2NEVuY29kZShzdHIpLnJlcGxhY2UoL1xcLi9nLCAnJyk7XHJcbn07XHJcbi8qKlxyXG4gKiBVUkwtc2FmZSBiYXNlNjQgZGVjb2RpbmdcclxuICpcclxuICogTk9URTogRE8gTk9UIHVzZSB0aGUgZ2xvYmFsIGF0b2IoKSBmdW5jdGlvbiAtIGl0IGRvZXMgTk9UIHN1cHBvcnQgdGhlXHJcbiAqIGJhc2U2NFVybCB2YXJpYW50IGVuY29kaW5nLlxyXG4gKlxyXG4gKiBAcGFyYW0gc3RyIFRvIGJlIGRlY29kZWRcclxuICogQHJldHVybiBEZWNvZGVkIHJlc3VsdCwgaWYgcG9zc2libGVcclxuICovXHJcbmNvbnN0IGJhc2U2NERlY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIGJhc2U2NC5kZWNvZGVTdHJpbmcoc3RyLCB0cnVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignYmFzZTY0RGVjb2RlIGZhaWxlZDogJywgZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIERvIGEgZGVlcC1jb3B5IG9mIGJhc2ljIEphdmFTY3JpcHQgT2JqZWN0cyBvciBBcnJheXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWVwQ29weSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGRlZXBFeHRlbmQodW5kZWZpbmVkLCB2YWx1ZSk7XHJcbn1cclxuLyoqXHJcbiAqIENvcHkgcHJvcGVydGllcyBmcm9tIHNvdXJjZSB0byB0YXJnZXQgKHJlY3Vyc2l2ZWx5IGFsbG93cyBleHRlbnNpb25cclxuICogb2YgT2JqZWN0cyBhbmQgQXJyYXlzKS4gIFNjYWxhciB2YWx1ZXMgaW4gdGhlIHRhcmdldCBhcmUgb3Zlci13cml0dGVuLlxyXG4gKiBJZiB0YXJnZXQgaXMgdW5kZWZpbmVkLCBhbiBvYmplY3Qgb2YgdGhlIGFwcHJvcHJpYXRlIHR5cGUgd2lsbCBiZSBjcmVhdGVkXHJcbiAqIChhbmQgcmV0dXJuZWQpLlxyXG4gKlxyXG4gKiBXZSByZWN1cnNpdmVseSBjb3B5IGFsbCBjaGlsZCBwcm9wZXJ0aWVzIG9mIHBsYWluIE9iamVjdHMgaW4gdGhlIHNvdXJjZS0gc29cclxuICogdGhhdCBuYW1lc3BhY2UtIGxpa2UgZGljdGlvbmFyaWVzIGFyZSBtZXJnZWQuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCB0aGUgdGFyZ2V0IGNhbiBiZSBhIGZ1bmN0aW9uLCBpbiB3aGljaCBjYXNlIHRoZSBwcm9wZXJ0aWVzIGluXHJcbiAqIHRoZSBzb3VyY2UgT2JqZWN0IGFyZSBjb3BpZWQgb250byBpdCBhcyBzdGF0aWMgcHJvcGVydGllcyBvZiB0aGUgRnVuY3Rpb24uXHJcbiAqXHJcbiAqIE5vdGU6IHdlIGRvbid0IG1lcmdlIF9fcHJvdG9fXyB0byBwcmV2ZW50IHByb3RvdHlwZSBwb2xsdXRpb25cclxuICovXHJcbmZ1bmN0aW9uIGRlZXBFeHRlbmQodGFyZ2V0LCBzb3VyY2UpIHtcclxuICAgIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIE9iamVjdCkpIHtcclxuICAgICAgICByZXR1cm4gc291cmNlO1xyXG4gICAgfVxyXG4gICAgc3dpdGNoIChzb3VyY2UuY29uc3RydWN0b3IpIHtcclxuICAgICAgICBjYXNlIERhdGU6XHJcbiAgICAgICAgICAgIC8vIFRyZWF0IERhdGVzIGxpa2Ugc2NhbGFyczsgaWYgdGhlIHRhcmdldCBkYXRlIG9iamVjdCBoYWQgYW55IGNoaWxkXHJcbiAgICAgICAgICAgIC8vIHByb3BlcnRpZXMgLSB0aGV5IHdpbGwgYmUgbG9zdCFcclxuICAgICAgICAgICAgY29uc3QgZGF0ZVZhbHVlID0gc291cmNlO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoZGF0ZVZhbHVlLmdldFRpbWUoKSk7XHJcbiAgICAgICAgY2FzZSBPYmplY3Q6XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0ge307XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBBcnJheTpcclxuICAgICAgICAgICAgLy8gQWx3YXlzIGNvcHkgdGhlIGFycmF5IHNvdXJjZSBhbmQgb3ZlcndyaXRlIHRoZSB0YXJnZXQuXHJcbiAgICAgICAgICAgIHRhcmdldCA9IFtdO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAvLyBOb3QgYSBwbGFpbiBPYmplY3QgLSB0cmVhdCBpdCBhcyBhIHNjYWxhci5cclxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3QgcHJvcCBpbiBzb3VyY2UpIHtcclxuICAgICAgICAvLyB1c2UgaXNWYWxpZEtleSB0byBndWFyZCBhZ2FpbnN0IHByb3RvdHlwZSBwb2xsdXRpb24uIFNlZSBodHRwczovL3NueWsuaW8vdnVsbi9TTllLLUpTLUxPREFTSC00NTAyMDJcclxuICAgICAgICBpZiAoIXNvdXJjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSB8fCAhaXNWYWxpZEtleShwcm9wKSkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gZGVlcEV4dGVuZCh0YXJnZXRbcHJvcF0sIHNvdXJjZVtwcm9wXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59XHJcbmZ1bmN0aW9uIGlzVmFsaWRLZXkoa2V5KSB7XHJcbiAgICByZXR1cm4ga2V5ICE9PSAnX19wcm90b19fJztcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUG9seWZpbGwgZm9yIGBnbG9iYWxUaGlzYCBvYmplY3QuXHJcbiAqIEByZXR1cm5zIHRoZSBgZ2xvYmFsVGhpc2Agb2JqZWN0IGZvciB0aGUgZ2l2ZW4gZW52aXJvbm1lbnQuXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGdldEdsb2JhbCgpIHtcclxuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm4gc2VsZjtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiB3aW5kb3c7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm4gZ2xvYmFsO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gbG9jYXRlIGdsb2JhbCBvYmplY3QuJyk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgZ2V0RGVmYXVsdHNGcm9tR2xvYmFsID0gKCkgPT4gZ2V0R2xvYmFsKCkuX19GSVJFQkFTRV9ERUZBVUxUU19fO1xyXG4vKipcclxuICogQXR0ZW1wdCB0byByZWFkIGRlZmF1bHRzIGZyb20gYSBKU09OIHN0cmluZyBwcm92aWRlZCB0b1xyXG4gKiBwcm9jZXNzKC4pZW52KC4pX19GSVJFQkFTRV9ERUZBVUxUU19fIG9yIGEgSlNPTiBmaWxlIHdob3NlIHBhdGggaXMgaW5cclxuICogcHJvY2VzcyguKWVudiguKV9fRklSRUJBU0VfREVGQVVMVFNfUEFUSF9fXHJcbiAqIFRoZSBkb3RzIGFyZSBpbiBwYXJlbnMgYmVjYXVzZSBjZXJ0YWluIGNvbXBpbGVycyAoVml0ZT8pIGNhbm5vdFxyXG4gKiBoYW5kbGUgc2VlaW5nIHRoYXQgdmFyaWFibGUgaW4gY29tbWVudHMuXHJcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmlyZWJhc2UvZmlyZWJhc2UtanMtc2RrL2lzc3Vlcy82ODM4XHJcbiAqL1xyXG5jb25zdCBnZXREZWZhdWx0c0Zyb21FbnZWYXJpYWJsZSA9ICgpID0+IHtcclxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHByb2Nlc3MuZW52ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IGRlZmF1bHRzSnNvblN0cmluZyA9IHByb2Nlc3MuZW52Ll9fRklSRUJBU0VfREVGQVVMVFNfXztcclxuICAgIGlmIChkZWZhdWx0c0pzb25TdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkZWZhdWx0c0pzb25TdHJpbmcpO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBnZXREZWZhdWx0c0Zyb21Db29raWUgPSAoKSA9PiB7XHJcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGxldCBtYXRjaDtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgbWF0Y2ggPSBkb2N1bWVudC5jb29raWUubWF0Y2goL19fRklSRUJBU0VfREVGQVVMVFNfXz0oW147XSspLyk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIC8vIFNvbWUgZW52aXJvbm1lbnRzIHN1Y2ggYXMgQW5ndWxhciBVbml2ZXJzYWwgU1NSIGhhdmUgYVxyXG4gICAgICAgIC8vIGBkb2N1bWVudGAgb2JqZWN0IGJ1dCBlcnJvciBvbiBhY2Nlc3NpbmcgYGRvY3VtZW50LmNvb2tpZWAuXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGVjb2RlZCA9IG1hdGNoICYmIGJhc2U2NERlY29kZShtYXRjaFsxXSk7XHJcbiAgICByZXR1cm4gZGVjb2RlZCAmJiBKU09OLnBhcnNlKGRlY29kZWQpO1xyXG59O1xyXG4vKipcclxuICogR2V0IHRoZSBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb2JqZWN0LiBJdCBjaGVja3MgaW4gb3JkZXI6XHJcbiAqICgxKSBpZiBzdWNoIGFuIG9iamVjdCBleGlzdHMgYXMgYSBwcm9wZXJ0eSBvZiBgZ2xvYmFsVGhpc2BcclxuICogKDIpIGlmIHN1Y2ggYW4gb2JqZWN0IHdhcyBwcm92aWRlZCBvbiBhIHNoZWxsIGVudmlyb25tZW50IHZhcmlhYmxlXHJcbiAqICgzKSBpZiBzdWNoIGFuIG9iamVjdCBleGlzdHMgaW4gYSBjb29raWVcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY29uc3QgZ2V0RGVmYXVsdHMgPSAoKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiAoZ2V0RGVmYXVsdHNGcm9tR2xvYmFsKCkgfHxcclxuICAgICAgICAgICAgZ2V0RGVmYXVsdHNGcm9tRW52VmFyaWFibGUoKSB8fFxyXG4gICAgICAgICAgICBnZXREZWZhdWx0c0Zyb21Db29raWUoKSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhdGNoLWFsbCBmb3IgYmVpbmcgdW5hYmxlIHRvIGdldCBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gZHVlXHJcbiAgICAgICAgICogdG8gYW55IGVudmlyb25tZW50IGNhc2Ugd2UgaGF2ZSBub3QgYWNjb3VudGVkIGZvci4gTG9nIHRvXHJcbiAgICAgICAgICogaW5mbyBpbnN0ZWFkIG9mIHN3YWxsb3dpbmcgc28gd2UgY2FuIGZpbmQgdGhlc2UgdW5rbm93biBjYXNlc1xyXG4gICAgICAgICAqIGFuZCBhZGQgcGF0aHMgZm9yIHRoZW0gaWYgbmVlZGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhgVW5hYmxlIHRvIGdldCBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gZHVlIHRvOiAke2V9YCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogUmV0dXJucyBlbXVsYXRvciBob3N0IHN0b3JlZCBpbiB0aGUgX19GSVJFQkFTRV9ERUZBVUxUU19fIG9iamVjdFxyXG4gKiBmb3IgdGhlIGdpdmVuIHByb2R1Y3QuXHJcbiAqIEByZXR1cm5zIGEgVVJMIGhvc3QgZm9ybWF0dGVkIGxpa2UgYDEyNy4wLjAuMTo5OTk5YCBvciBgWzo6MV06NDAwMGAgaWYgYXZhaWxhYmxlXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNvbnN0IGdldERlZmF1bHRFbXVsYXRvckhvc3QgPSAocHJvZHVjdE5hbWUpID0+IHsgdmFyIF9hLCBfYjsgcmV0dXJuIChfYiA9IChfYSA9IGdldERlZmF1bHRzKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbXVsYXRvckhvc3RzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbcHJvZHVjdE5hbWVdOyB9O1xyXG4vKipcclxuICogUmV0dXJucyBlbXVsYXRvciBob3N0bmFtZSBhbmQgcG9ydCBzdG9yZWQgaW4gdGhlIF9fRklSRUJBU0VfREVGQVVMVFNfXyBvYmplY3RcclxuICogZm9yIHRoZSBnaXZlbiBwcm9kdWN0LlxyXG4gKiBAcmV0dXJucyBhIHBhaXIgb2YgaG9zdG5hbWUgYW5kIHBvcnQgbGlrZSBgW1wiOjoxXCIsIDQwMDBdYCBpZiBhdmFpbGFibGVcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY29uc3QgZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdG5hbWVBbmRQb3J0ID0gKHByb2R1Y3ROYW1lKSA9PiB7XHJcbiAgICBjb25zdCBob3N0ID0gZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdChwcm9kdWN0TmFtZSk7XHJcbiAgICBpZiAoIWhvc3QpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc2VwYXJhdG9ySW5kZXggPSBob3N0Lmxhc3RJbmRleE9mKCc6Jyk7IC8vIEZpbmRpbmcgdGhlIGxhc3Qgc2luY2UgSVB2NiBhZGRyIGFsc28gaGFzIGNvbG9ucy5cclxuICAgIGlmIChzZXBhcmF0b3JJbmRleCA8PSAwIHx8IHNlcGFyYXRvckluZGV4ICsgMSA9PT0gaG9zdC5sZW5ndGgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaG9zdCAke2hvc3R9IHdpdGggbm8gc2VwYXJhdGUgaG9zdG5hbWUgYW5kIHBvcnQhYCk7XHJcbiAgICB9XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXHJcbiAgICBjb25zdCBwb3J0ID0gcGFyc2VJbnQoaG9zdC5zdWJzdHJpbmcoc2VwYXJhdG9ySW5kZXggKyAxKSwgMTApO1xyXG4gICAgaWYgKGhvc3RbMF0gPT09ICdbJykge1xyXG4gICAgICAgIC8vIEJyYWNrZXQtcXVvdGVkIGBbaXB2NmFkZHJdOnBvcnRgID0+IHJldHVybiBcImlwdjZhZGRyXCIgKHdpdGhvdXQgYnJhY2tldHMpLlxyXG4gICAgICAgIHJldHVybiBbaG9zdC5zdWJzdHJpbmcoMSwgc2VwYXJhdG9ySW5kZXggLSAxKSwgcG9ydF07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gW2hvc3Quc3Vic3RyaW5nKDAsIHNlcGFyYXRvckluZGV4KSwgcG9ydF07XHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBSZXR1cm5zIEZpcmViYXNlIGFwcCBjb25maWcgc3RvcmVkIGluIHRoZSBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb2JqZWN0LlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jb25zdCBnZXREZWZhdWx0QXBwQ29uZmlnID0gKCkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBnZXREZWZhdWx0cygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29uZmlnOyB9O1xyXG4vKipcclxuICogUmV0dXJucyBhbiBleHBlcmltZW50YWwgc2V0dGluZyBvbiB0aGUgX19GSVJFQkFTRV9ERUZBVUxUU19fIG9iamVjdCAocHJvcGVydGllc1xyXG4gKiBwcmVmaXhlZCBieSBcIl9cIilcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY29uc3QgZ2V0RXhwZXJpbWVudGFsU2V0dGluZyA9IChuYW1lKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IGdldERlZmF1bHRzKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtgXyR7bmFtZX1gXTsgfTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgRGVmZXJyZWQge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5yZWplY3QgPSAoKSA9PiB7IH07XHJcbiAgICAgICAgdGhpcy5yZXNvbHZlID0gKCkgPT4geyB9O1xyXG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcclxuICAgICAgICAgICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE91ciBBUEkgaW50ZXJuYWxzIGFyZSBub3QgcHJvbWlzZWlmaWVkIGFuZCBjYW5ub3QgYmVjYXVzZSBvdXIgY2FsbGJhY2sgQVBJcyBoYXZlIHN1YnRsZSBleHBlY3RhdGlvbnMgYXJvdW5kXHJcbiAgICAgKiBpbnZva2luZyBwcm9taXNlcyBpbmxpbmUsIHdoaWNoIFByb21pc2VzIGFyZSBmb3JiaWRkZW4gdG8gZG8uIFRoaXMgbWV0aG9kIGFjY2VwdHMgYW4gb3B0aW9uYWwgbm9kZS1zdHlsZSBjYWxsYmFja1xyXG4gICAgICogYW5kIHJldHVybnMgYSBub2RlLXN0eWxlIGNhbGxiYWNrIHdoaWNoIHdpbGwgcmVzb2x2ZSBvciByZWplY3QgdGhlIERlZmVycmVkJ3MgcHJvbWlzZS5cclxuICAgICAqL1xyXG4gICAgd3JhcENhbGxiYWNrKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIChlcnJvciwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmUodmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIC8vIEF0dGFjaGluZyBub29wIGhhbmRsZXIganVzdCBpbiBjYXNlIGRldmVsb3BlciB3YXNuJ3QgZXhwZWN0aW5nXHJcbiAgICAgICAgICAgICAgICAvLyBwcm9taXNlc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9taXNlLmNhdGNoKCgpID0+IHsgfSk7XHJcbiAgICAgICAgICAgICAgICAvLyBTb21lIG9mIG91ciBjYWxsYmFja3MgZG9uJ3QgZXhwZWN0IGEgdmFsdWUgYW5kIG91ciBvd24gdGVzdHNcclxuICAgICAgICAgICAgICAgIC8vIGFzc2VydCB0aGF0IHRoZSBwYXJhbWV0ZXIgbGVuZ3RoIGlzIDFcclxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjay5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvciwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVNb2NrVXNlclRva2VuKHRva2VuLCBwcm9qZWN0SWQpIHtcclxuICAgIGlmICh0b2tlbi51aWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBcInVpZFwiIGZpZWxkIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgYnkgbW9ja1VzZXJUb2tlbi4gUGxlYXNlIHVzZSBcInN1YlwiIGluc3RlYWQgZm9yIEZpcmViYXNlIEF1dGggVXNlciBJRC4nKTtcclxuICAgIH1cclxuICAgIC8vIFVuc2VjdXJlZCBKV1RzIHVzZSBcIm5vbmVcIiBhcyB0aGUgYWxnb3JpdGhtLlxyXG4gICAgY29uc3QgaGVhZGVyID0ge1xyXG4gICAgICAgIGFsZzogJ25vbmUnLFxyXG4gICAgICAgIHR5cGU6ICdKV1QnXHJcbiAgICB9O1xyXG4gICAgY29uc3QgcHJvamVjdCA9IHByb2plY3RJZCB8fCAnZGVtby1wcm9qZWN0JztcclxuICAgIGNvbnN0IGlhdCA9IHRva2VuLmlhdCB8fCAwO1xyXG4gICAgY29uc3Qgc3ViID0gdG9rZW4uc3ViIHx8IHRva2VuLnVzZXJfaWQ7XHJcbiAgICBpZiAoIXN1Yikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1vY2tVc2VyVG9rZW4gbXVzdCBjb250YWluICdzdWInIG9yICd1c2VyX2lkJyBmaWVsZCFcIik7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwYXlsb2FkID0gT2JqZWN0LmFzc2lnbih7IFxyXG4gICAgICAgIC8vIFNldCBhbGwgcmVxdWlyZWQgZmllbGRzIHRvIGRlY2VudCBkZWZhdWx0c1xyXG4gICAgICAgIGlzczogYGh0dHBzOi8vc2VjdXJldG9rZW4uZ29vZ2xlLmNvbS8ke3Byb2plY3R9YCwgYXVkOiBwcm9qZWN0LCBpYXQsIGV4cDogaWF0ICsgMzYwMCwgYXV0aF90aW1lOiBpYXQsIHN1YiwgdXNlcl9pZDogc3ViLCBmaXJlYmFzZToge1xyXG4gICAgICAgICAgICBzaWduX2luX3Byb3ZpZGVyOiAnY3VzdG9tJyxcclxuICAgICAgICAgICAgaWRlbnRpdGllczoge31cclxuICAgICAgICB9IH0sIHRva2VuKTtcclxuICAgIC8vIFVuc2VjdXJlZCBKV1RzIHVzZSB0aGUgZW1wdHkgc3RyaW5nIGFzIGEgc2lnbmF0dXJlLlxyXG4gICAgY29uc3Qgc2lnbmF0dXJlID0gJyc7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIGJhc2U2NHVybEVuY29kZVdpdGhvdXRQYWRkaW5nKEpTT04uc3RyaW5naWZ5KGhlYWRlcikpLFxyXG4gICAgICAgIGJhc2U2NHVybEVuY29kZVdpdGhvdXRQYWRkaW5nKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKSxcclxuICAgICAgICBzaWduYXR1cmVcclxuICAgIF0uam9pbignLicpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBSZXR1cm5zIG5hdmlnYXRvci51c2VyQWdlbnQgc3RyaW5nIG9yICcnIGlmIGl0J3Mgbm90IGRlZmluZWQuXHJcbiAqIEByZXR1cm4gdXNlciBhZ2VudCBzdHJpbmdcclxuICovXHJcbmZ1bmN0aW9uIGdldFVBKCkge1xyXG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgdHlwZW9mIG5hdmlnYXRvclsndXNlckFnZW50J10gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvclsndXNlckFnZW50J107XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIERldGVjdCBDb3Jkb3ZhIC8gUGhvbmVHYXAgLyBJb25pYyBmcmFtZXdvcmtzIG9uIGEgbW9iaWxlIGRldmljZS5cclxuICpcclxuICogRGVsaWJlcmF0ZWx5IGRvZXMgbm90IHJlbHkgb24gY2hlY2tpbmcgYGZpbGU6Ly9gIFVSTHMgKGFzIHRoaXMgZmFpbHMgUGhvbmVHYXBcclxuICogaW4gdGhlIFJpcHBsZSBlbXVsYXRvcikgbm9yIENvcmRvdmEgYG9uRGV2aWNlUmVhZHlgLCB3aGljaCB3b3VsZCBub3JtYWxseVxyXG4gKiB3YWl0IGZvciBhIGNhbGxiYWNrLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNNb2JpbGVDb3Jkb3ZhKCkge1xyXG4gICAgcmV0dXJuICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgIC8vIEB0cy1pZ25vcmUgU2V0dGluZyB1cCBhbiBicm9hZGx5IGFwcGxpY2FibGUgaW5kZXggc2lnbmF0dXJlIGZvciBXaW5kb3dcclxuICAgICAgICAvLyBqdXN0IHRvIGRlYWwgd2l0aCB0aGlzIGNhc2Ugd291bGQgcHJvYmFibHkgYmUgYSBiYWQgaWRlYS5cclxuICAgICAgICAhISh3aW5kb3dbJ2NvcmRvdmEnXSB8fCB3aW5kb3dbJ3Bob25lZ2FwJ10gfHwgd2luZG93WydQaG9uZUdhcCddKSAmJlxyXG4gICAgICAgIC9pb3N8aXBob25lfGlwb2R8aXBhZHxhbmRyb2lkfGJsYWNrYmVycnl8aWVtb2JpbGUvaS50ZXN0KGdldFVBKCkpKTtcclxufVxyXG4vKipcclxuICogRGV0ZWN0IE5vZGUuanMuXHJcbiAqXHJcbiAqIEByZXR1cm4gdHJ1ZSBpZiBOb2RlLmpzIGVudmlyb25tZW50IGlzIGRldGVjdGVkIG9yIHNwZWNpZmllZC5cclxuICovXHJcbi8vIE5vZGUgZGV0ZWN0aW9uIGxvZ2ljIGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9pbGlha2FuL2RldGVjdC1ub2RlL1xyXG5mdW5jdGlvbiBpc05vZGUoKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBjb25zdCBmb3JjZUVudmlyb25tZW50ID0gKF9hID0gZ2V0RGVmYXVsdHMoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvcmNlRW52aXJvbm1lbnQ7XHJcbiAgICBpZiAoZm9yY2VFbnZpcm9ubWVudCA9PT0gJ25vZGUnKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChmb3JjZUVudmlyb25tZW50ID09PSAnYnJvd3NlcicpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBEZXRlY3QgQnJvd3NlciBFbnZpcm9ubWVudFxyXG4gKi9cclxuZnVuY3Rpb24gaXNCcm93c2VyKCkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBzZWxmID09PSAnb2JqZWN0JyAmJiBzZWxmLnNlbGYgPT09IHNlbGY7XHJcbn1cclxuZnVuY3Rpb24gaXNCcm93c2VyRXh0ZW5zaW9uKCkge1xyXG4gICAgY29uc3QgcnVudGltZSA9IHR5cGVvZiBjaHJvbWUgPT09ICdvYmplY3QnXHJcbiAgICAgICAgPyBjaHJvbWUucnVudGltZVxyXG4gICAgICAgIDogdHlwZW9mIGJyb3dzZXIgPT09ICdvYmplY3QnXHJcbiAgICAgICAgICAgID8gYnJvd3Nlci5ydW50aW1lXHJcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xyXG4gICAgcmV0dXJuIHR5cGVvZiBydW50aW1lID09PSAnb2JqZWN0JyAmJiBydW50aW1lLmlkICE9PSB1bmRlZmluZWQ7XHJcbn1cclxuLyoqXHJcbiAqIERldGVjdCBSZWFjdCBOYXRpdmUuXHJcbiAqXHJcbiAqIEByZXR1cm4gdHJ1ZSBpZiBSZWFjdE5hdGl2ZSBlbnZpcm9ubWVudCBpcyBkZXRlY3RlZC5cclxuICovXHJcbmZ1bmN0aW9uIGlzUmVhY3ROYXRpdmUoKSB7XHJcbiAgICByZXR1cm4gKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICdvYmplY3QnICYmIG5hdmlnYXRvclsncHJvZHVjdCddID09PSAnUmVhY3ROYXRpdmUnKTtcclxufVxyXG4vKiogRGV0ZWN0cyBFbGVjdHJvbiBhcHBzLiAqL1xyXG5mdW5jdGlvbiBpc0VsZWN0cm9uKCkge1xyXG4gICAgcmV0dXJuIGdldFVBKCkuaW5kZXhPZignRWxlY3Ryb24vJykgPj0gMDtcclxufVxyXG4vKiogRGV0ZWN0cyBJbnRlcm5ldCBFeHBsb3Jlci4gKi9cclxuZnVuY3Rpb24gaXNJRSgpIHtcclxuICAgIGNvbnN0IHVhID0gZ2V0VUEoKTtcclxuICAgIHJldHVybiB1YS5pbmRleE9mKCdNU0lFICcpID49IDAgfHwgdWEuaW5kZXhPZignVHJpZGVudC8nKSA+PSAwO1xyXG59XHJcbi8qKiBEZXRlY3RzIFVuaXZlcnNhbCBXaW5kb3dzIFBsYXRmb3JtIGFwcHMuICovXHJcbmZ1bmN0aW9uIGlzVVdQKCkge1xyXG4gICAgcmV0dXJuIGdldFVBKCkuaW5kZXhPZignTVNBcHBIb3N0LycpID49IDA7XHJcbn1cclxuLyoqXHJcbiAqIERldGVjdCB3aGV0aGVyIHRoZSBjdXJyZW50IFNESyBidWlsZCBpcyB0aGUgTm9kZSB2ZXJzaW9uLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHRydWUgaWYgaXQncyB0aGUgTm9kZSBTREsgYnVpbGQuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc05vZGVTZGsoKSB7XHJcbiAgICByZXR1cm4gQ09OU1RBTlRTLk5PREVfQ0xJRU5UID09PSB0cnVlIHx8IENPTlNUQU5UUy5OT0RFX0FETUlOID09PSB0cnVlO1xyXG59XHJcbi8qKiBSZXR1cm5zIHRydWUgaWYgd2UgYXJlIHJ1bm5pbmcgaW4gU2FmYXJpLiAqL1xyXG5mdW5jdGlvbiBpc1NhZmFyaSgpIHtcclxuICAgIHJldHVybiAoIWlzTm9kZSgpICYmXHJcbiAgICAgICAgISFuYXZpZ2F0b3IudXNlckFnZW50ICYmXHJcbiAgICAgICAgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcygnU2FmYXJpJykgJiZcclxuICAgICAgICAhbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcygnQ2hyb21lJykpO1xyXG59XHJcbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCBjaGVja3MgaWYgaW5kZXhlZERCIGlzIHN1cHBvcnRlZCBieSBjdXJyZW50IGJyb3dzZXIvc2VydmljZSB3b3JrZXIgY29udGV4dFxyXG4gKiBAcmV0dXJuIHRydWUgaWYgaW5kZXhlZERCIGlzIHN1cHBvcnRlZCBieSBjdXJyZW50IGJyb3dzZXIvc2VydmljZSB3b3JrZXIgY29udGV4dFxyXG4gKi9cclxuZnVuY3Rpb24gaXNJbmRleGVkREJBdmFpbGFibGUoKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgaW5kZXhlZERCID09PSAnb2JqZWN0JztcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCB2YWxpZGF0ZXMgYnJvd3Nlci9zdyBjb250ZXh0IGZvciBpbmRleGVkREIgYnkgb3BlbmluZyBhIGR1bW15IGluZGV4ZWREQiBkYXRhYmFzZSBhbmQgcmVqZWN0XHJcbiAqIGlmIGVycm9ycyBvY2N1ciBkdXJpbmcgdGhlIGRhdGFiYXNlIG9wZW4gb3BlcmF0aW9uLlxyXG4gKlxyXG4gKiBAdGhyb3dzIGV4Y2VwdGlvbiBpZiBjdXJyZW50IGJyb3dzZXIvc3cgY29udGV4dCBjYW4ndCBydW4gaWRiLm9wZW4gKGV4OiBTYWZhcmkgaWZyYW1lLCBGaXJlZm94XHJcbiAqIHByaXZhdGUgYnJvd3NpbmcpXHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZUluZGV4ZWREQk9wZW5hYmxlKCkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBsZXQgcHJlRXhpc3QgPSB0cnVlO1xyXG4gICAgICAgICAgICBjb25zdCBEQl9DSEVDS19OQU1FID0gJ3ZhbGlkYXRlLWJyb3dzZXItY29udGV4dC1mb3ItaW5kZXhlZGRiLWFuYWx5dGljcy1tb2R1bGUnO1xyXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gc2VsZi5pbmRleGVkREIub3BlbihEQl9DSEVDS19OQU1FKTtcclxuICAgICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnJlc3VsdC5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgLy8gZGVsZXRlIGRhdGFiYXNlIG9ubHkgd2hlbiBpdCBkb2Vzbid0IHByZS1leGlzdFxyXG4gICAgICAgICAgICAgICAgaWYgKCFwcmVFeGlzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW5kZXhlZERCLmRlbGV0ZURhdGFiYXNlKERCX0NIRUNLX05BTUUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBwcmVFeGlzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoKChfYSA9IHJlcXVlc3QuZXJyb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZXNzYWdlKSB8fCAnJyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKlxyXG4gKiBUaGlzIG1ldGhvZCBjaGVja3Mgd2hldGhlciBjb29raWUgaXMgZW5hYmxlZCB3aXRoaW4gY3VycmVudCBicm93c2VyXHJcbiAqIEByZXR1cm4gdHJ1ZSBpZiBjb29raWUgaXMgZW5hYmxlZCB3aXRoaW4gY3VycmVudCBicm93c2VyXHJcbiAqL1xyXG5mdW5jdGlvbiBhcmVDb29raWVzRW5hYmxlZCgpIHtcclxuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyB8fCAhbmF2aWdhdG9yLmNvb2tpZUVuYWJsZWQpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQGZpbGVvdmVydmlldyBTdGFuZGFyZGl6ZWQgRmlyZWJhc2UgRXJyb3IuXHJcbiAqXHJcbiAqIFVzYWdlOlxyXG4gKlxyXG4gKiAgIC8vIFR5cGVzY3JpcHQgc3RyaW5nIGxpdGVyYWxzIGZvciB0eXBlLXNhZmUgY29kZXNcclxuICogICB0eXBlIEVyciA9XHJcbiAqICAgICAndW5rbm93bicgfFxyXG4gKiAgICAgJ29iamVjdC1ub3QtZm91bmQnXHJcbiAqICAgICA7XHJcbiAqXHJcbiAqICAgLy8gQ2xvc3VyZSBlbnVtIGZvciB0eXBlLXNhZmUgZXJyb3IgY29kZXNcclxuICogICAvLyBhdC1lbnVtIHtzdHJpbmd9XHJcbiAqICAgdmFyIEVyciA9IHtcclxuICogICAgIFVOS05PV046ICd1bmtub3duJyxcclxuICogICAgIE9CSkVDVF9OT1RfRk9VTkQ6ICdvYmplY3Qtbm90LWZvdW5kJyxcclxuICogICB9XHJcbiAqXHJcbiAqICAgbGV0IGVycm9yczogTWFwPEVyciwgc3RyaW5nPiA9IHtcclxuICogICAgICdnZW5lcmljLWVycm9yJzogXCJVbmtub3duIGVycm9yXCIsXHJcbiAqICAgICAnZmlsZS1ub3QtZm91bmQnOiBcIkNvdWxkIG5vdCBmaW5kIGZpbGU6IHskZmlsZX1cIixcclxuICogICB9O1xyXG4gKlxyXG4gKiAgIC8vIFR5cGUtc2FmZSBmdW5jdGlvbiAtIG11c3QgcGFzcyBhIHZhbGlkIGVycm9yIGNvZGUgYXMgcGFyYW0uXHJcbiAqICAgbGV0IGVycm9yID0gbmV3IEVycm9yRmFjdG9yeTxFcnI+KCdzZXJ2aWNlJywgJ1NlcnZpY2UnLCBlcnJvcnMpO1xyXG4gKlxyXG4gKiAgIC4uLlxyXG4gKiAgIHRocm93IGVycm9yLmNyZWF0ZShFcnIuR0VORVJJQyk7XHJcbiAqICAgLi4uXHJcbiAqICAgdGhyb3cgZXJyb3IuY3JlYXRlKEVyci5GSUxFX05PVF9GT1VORCwgeydmaWxlJzogZmlsZU5hbWV9KTtcclxuICogICAuLi5cclxuICogICAvLyBTZXJ2aWNlOiBDb3VsZCBub3QgZmlsZSBmaWxlOiBmb28udHh0IChzZXJ2aWNlL2ZpbGUtbm90LWZvdW5kKS5cclxuICpcclxuICogICBjYXRjaCAoZSkge1xyXG4gKiAgICAgYXNzZXJ0KGUubWVzc2FnZSA9PT0gXCJDb3VsZCBub3QgZmluZCBmaWxlOiBmb28udHh0LlwiKTtcclxuICogICAgIGlmICgoZSBhcyBGaXJlYmFzZUVycm9yKT8uY29kZSA9PT0gJ3NlcnZpY2UvZmlsZS1ub3QtZm91bmQnKSB7XHJcbiAqICAgICAgIGNvbnNvbGUubG9nKFwiQ291bGQgbm90IHJlYWQgZmlsZTogXCIgKyBlWydmaWxlJ10pO1xyXG4gKiAgICAgfVxyXG4gKiAgIH1cclxuICovXHJcbmNvbnN0IEVSUk9SX05BTUUgPSAnRmlyZWJhc2VFcnJvcic7XHJcbi8vIEJhc2VkIG9uIGNvZGUgZnJvbTpcclxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3IjQ3VzdG9tX0Vycm9yX1R5cGVzXHJcbmNsYXNzIEZpcmViYXNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKiBUaGUgZXJyb3IgY29kZSBmb3IgdGhpcyBlcnJvci4gKi9cclxuICAgIGNvZGUsIG1lc3NhZ2UsIFxyXG4gICAgLyoqIEN1c3RvbSBkYXRhIGZvciB0aGlzIGVycm9yLiAqL1xyXG4gICAgY3VzdG9tRGF0YSkge1xyXG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xyXG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XHJcbiAgICAgICAgdGhpcy5jdXN0b21EYXRhID0gY3VzdG9tRGF0YTtcclxuICAgICAgICAvKiogVGhlIGN1c3RvbSBuYW1lIGZvciBhbGwgRmlyZWJhc2VFcnJvcnMuICovXHJcbiAgICAgICAgdGhpcy5uYW1lID0gRVJST1JfTkFNRTtcclxuICAgICAgICAvLyBGaXggRm9yIEVTNVxyXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC13aWtpL2Jsb2IvbWFzdGVyL0JyZWFraW5nLUNoYW5nZXMubWQjZXh0ZW5kaW5nLWJ1aWx0LWlucy1saWtlLWVycm9yLWFycmF5LWFuZC1tYXAtbWF5LW5vLWxvbmdlci13b3JrXHJcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIEZpcmViYXNlRXJyb3IucHJvdG90eXBlKTtcclxuICAgICAgICAvLyBNYWludGFpbnMgcHJvcGVyIHN0YWNrIHRyYWNlIGZvciB3aGVyZSBvdXIgZXJyb3Igd2FzIHRocm93bi5cclxuICAgICAgICAvLyBPbmx5IGF2YWlsYWJsZSBvbiBWOC5cclxuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcclxuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgRXJyb3JGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jbGFzcyBFcnJvckZhY3Rvcnkge1xyXG4gICAgY29uc3RydWN0b3Ioc2VydmljZSwgc2VydmljZU5hbWUsIGVycm9ycykge1xyXG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XHJcbiAgICAgICAgdGhpcy5zZXJ2aWNlTmFtZSA9IHNlcnZpY2VOYW1lO1xyXG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlKGNvZGUsIC4uLmRhdGEpIHtcclxuICAgICAgICBjb25zdCBjdXN0b21EYXRhID0gZGF0YVswXSB8fCB7fTtcclxuICAgICAgICBjb25zdCBmdWxsQ29kZSA9IGAke3RoaXMuc2VydmljZX0vJHtjb2RlfWA7XHJcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSB0aGlzLmVycm9yc1tjb2RlXTtcclxuICAgICAgICBjb25zdCBtZXNzYWdlID0gdGVtcGxhdGUgPyByZXBsYWNlVGVtcGxhdGUodGVtcGxhdGUsIGN1c3RvbURhdGEpIDogJ0Vycm9yJztcclxuICAgICAgICAvLyBTZXJ2aWNlIE5hbWU6IEVycm9yIG1lc3NhZ2UgKHNlcnZpY2UvY29kZSkuXHJcbiAgICAgICAgY29uc3QgZnVsbE1lc3NhZ2UgPSBgJHt0aGlzLnNlcnZpY2VOYW1lfTogJHttZXNzYWdlfSAoJHtmdWxsQ29kZX0pLmA7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRmlyZWJhc2VFcnJvcihmdWxsQ29kZSwgZnVsbE1lc3NhZ2UsIGN1c3RvbURhdGEpO1xyXG4gICAgICAgIHJldHVybiBlcnJvcjtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByZXBsYWNlVGVtcGxhdGUodGVtcGxhdGUsIGRhdGEpIHtcclxuICAgIHJldHVybiB0ZW1wbGF0ZS5yZXBsYWNlKFBBVFRFUk4sIChfLCBrZXkpID0+IHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IGRhdGFba2V5XTtcclxuICAgICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCA/IFN0cmluZyh2YWx1ZSkgOiBgPCR7a2V5fT8+YDtcclxuICAgIH0pO1xyXG59XHJcbmNvbnN0IFBBVFRFUk4gPSAvXFx7XFwkKFtefV0rKX0vZztcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEV2YWx1YXRlcyBhIEpTT04gc3RyaW5nIGludG8gYSBqYXZhc2NyaXB0IG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBBIHN0cmluZyBjb250YWluaW5nIEpTT04uXHJcbiAqIEByZXR1cm4geyp9IFRoZSBqYXZhc2NyaXB0IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNwZWNpZmllZCBKU09OLlxyXG4gKi9cclxuZnVuY3Rpb24ganNvbkV2YWwoc3RyKSB7XHJcbiAgICByZXR1cm4gSlNPTi5wYXJzZShzdHIpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIEpTT04gcmVwcmVzZW50aW5nIGEgamF2YXNjcmlwdCBvYmplY3QuXHJcbiAqIEBwYXJhbSB7Kn0gZGF0YSBKYXZhc2NyaXB0IG9iamVjdCB0byBiZSBzdHJpbmdpZmllZC5cclxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgSlNPTiBjb250ZW50cyBvZiB0aGUgb2JqZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gc3RyaW5naWZ5KGRhdGEpIHtcclxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRGVjb2RlcyBhIEZpcmViYXNlIGF1dGguIHRva2VuIGludG8gY29uc3RpdHVlbnQgcGFydHMuXHJcbiAqXHJcbiAqIE5vdGVzOlxyXG4gKiAtIE1heSByZXR1cm4gd2l0aCBpbnZhbGlkIC8gaW5jb21wbGV0ZSBjbGFpbXMgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXHJcbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXHJcbiAqL1xyXG5jb25zdCBkZWNvZGUgPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuICAgIGxldCBoZWFkZXIgPSB7fSwgY2xhaW1zID0ge30sIGRhdGEgPSB7fSwgc2lnbmF0dXJlID0gJyc7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHBhcnRzID0gdG9rZW4uc3BsaXQoJy4nKTtcclxuICAgICAgICBoZWFkZXIgPSBqc29uRXZhbChiYXNlNjREZWNvZGUocGFydHNbMF0pIHx8ICcnKTtcclxuICAgICAgICBjbGFpbXMgPSBqc29uRXZhbChiYXNlNjREZWNvZGUocGFydHNbMV0pIHx8ICcnKTtcclxuICAgICAgICBzaWduYXR1cmUgPSBwYXJ0c1syXTtcclxuICAgICAgICBkYXRhID0gY2xhaW1zWydkJ10gfHwge307XHJcbiAgICAgICAgZGVsZXRlIGNsYWltc1snZCddO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHsgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBoZWFkZXIsXHJcbiAgICAgICAgY2xhaW1zLFxyXG4gICAgICAgIGRhdGEsXHJcbiAgICAgICAgc2lnbmF0dXJlXHJcbiAgICB9O1xyXG59O1xyXG4vKipcclxuICogRGVjb2RlcyBhIEZpcmViYXNlIGF1dGguIHRva2VuIGFuZCBjaGVja3MgdGhlIHZhbGlkaXR5IG9mIGl0cyB0aW1lLWJhc2VkIGNsYWltcy4gV2lsbCByZXR1cm4gdHJ1ZSBpZiB0aGVcclxuICogdG9rZW4gaXMgd2l0aGluIHRoZSB0aW1lIHdpbmRvdyBhdXRob3JpemVkIGJ5IHRoZSAnbmJmJyAobm90LWJlZm9yZSkgYW5kICdpYXQnIChpc3N1ZWQtYXQpIGNsYWltcy5cclxuICpcclxuICogTm90ZXM6XHJcbiAqIC0gTWF5IHJldHVybiBhIGZhbHNlIG5lZ2F0aXZlIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxyXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxyXG4gKi9cclxuY29uc3QgaXNWYWxpZFRpbWVzdGFtcCA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgY29uc3QgY2xhaW1zID0gZGVjb2RlKHRva2VuKS5jbGFpbXM7XHJcbiAgICBjb25zdCBub3cgPSBNYXRoLmZsb29yKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCk7XHJcbiAgICBsZXQgdmFsaWRTaW5jZSA9IDAsIHZhbGlkVW50aWwgPSAwO1xyXG4gICAgaWYgKHR5cGVvZiBjbGFpbXMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgaWYgKGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnbmJmJykpIHtcclxuICAgICAgICAgICAgdmFsaWRTaW5jZSA9IGNsYWltc1snbmJmJ107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnaWF0JykpIHtcclxuICAgICAgICAgICAgdmFsaWRTaW5jZSA9IGNsYWltc1snaWF0J107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjbGFpbXMuaGFzT3duUHJvcGVydHkoJ2V4cCcpKSB7XHJcbiAgICAgICAgICAgIHZhbGlkVW50aWwgPSBjbGFpbXNbJ2V4cCddO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdG9rZW4gd2lsbCBleHBpcmUgYWZ0ZXIgMjRoIGJ5IGRlZmF1bHRcclxuICAgICAgICAgICAgdmFsaWRVbnRpbCA9IHZhbGlkU2luY2UgKyA4NjQwMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKCEhbm93ICYmXHJcbiAgICAgICAgISF2YWxpZFNpbmNlICYmXHJcbiAgICAgICAgISF2YWxpZFVudGlsICYmXHJcbiAgICAgICAgbm93ID49IHZhbGlkU2luY2UgJiZcclxuICAgICAgICBub3cgPD0gdmFsaWRVbnRpbCk7XHJcbn07XHJcbi8qKlxyXG4gKiBEZWNvZGVzIGEgRmlyZWJhc2UgYXV0aC4gdG9rZW4gYW5kIHJldHVybnMgaXRzIGlzc3VlZCBhdCB0aW1lIGlmIHZhbGlkLCBudWxsIG90aGVyd2lzZS5cclxuICpcclxuICogTm90ZXM6XHJcbiAqIC0gTWF5IHJldHVybiBudWxsIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxyXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxyXG4gKi9cclxuY29uc3QgaXNzdWVkQXRUaW1lID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcbiAgICBjb25zdCBjbGFpbXMgPSBkZWNvZGUodG9rZW4pLmNsYWltcztcclxuICAgIGlmICh0eXBlb2YgY2xhaW1zID09PSAnb2JqZWN0JyAmJiBjbGFpbXMuaGFzT3duUHJvcGVydHkoJ2lhdCcpKSB7XHJcbiAgICAgICAgcmV0dXJuIGNsYWltc1snaWF0J107XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufTtcclxuLyoqXHJcbiAqIERlY29kZXMgYSBGaXJlYmFzZSBhdXRoLiB0b2tlbiBhbmQgY2hlY2tzIHRoZSB2YWxpZGl0eSBvZiBpdHMgZm9ybWF0LiBFeHBlY3RzIGEgdmFsaWQgaXNzdWVkLWF0IHRpbWUuXHJcbiAqXHJcbiAqIE5vdGVzOlxyXG4gKiAtIE1heSByZXR1cm4gYSBmYWxzZSBuZWdhdGl2ZSBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cclxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cclxuICovXHJcbmNvbnN0IGlzVmFsaWRGb3JtYXQgPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGUodG9rZW4pLCBjbGFpbXMgPSBkZWNvZGVkLmNsYWltcztcclxuICAgIHJldHVybiAhIWNsYWltcyAmJiB0eXBlb2YgY2xhaW1zID09PSAnb2JqZWN0JyAmJiBjbGFpbXMuaGFzT3duUHJvcGVydHkoJ2lhdCcpO1xyXG59O1xyXG4vKipcclxuICogQXR0ZW1wdHMgdG8gcGVlciBpbnRvIGFuIGF1dGggdG9rZW4gYW5kIGRldGVybWluZSBpZiBpdCdzIGFuIGFkbWluIGF1dGggdG9rZW4gYnkgbG9va2luZyBhdCB0aGUgY2xhaW1zIHBvcnRpb24uXHJcbiAqXHJcbiAqIE5vdGVzOlxyXG4gKiAtIE1heSByZXR1cm4gYSBmYWxzZSBuZWdhdGl2ZSBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cclxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cclxuICovXHJcbmNvbnN0IGlzQWRtaW4gPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuICAgIGNvbnN0IGNsYWltcyA9IGRlY29kZSh0b2tlbikuY2xhaW1zO1xyXG4gICAgcmV0dXJuIHR5cGVvZiBjbGFpbXMgPT09ICdvYmplY3QnICYmIGNsYWltc1snYWRtaW4nXSA9PT0gdHJ1ZTtcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gY29udGFpbnMob2JqLCBrZXkpIHtcclxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xyXG59XHJcbmZ1bmN0aW9uIHNhZmVHZXQob2JqLCBrZXkpIHtcclxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XHJcbiAgICAgICAgcmV0dXJuIG9ialtrZXldO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc0VtcHR5KG9iaikge1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIG1hcChvYmosIGZuLCBjb250ZXh0T2JqKSB7XHJcbiAgICBjb25zdCByZXMgPSB7fTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xyXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHJlc1trZXldID0gZm4uY2FsbChjb250ZXh0T2JqLCBvYmpba2V5XSwga2V5LCBvYmopO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuLyoqXHJcbiAqIERlZXAgZXF1YWwgdHdvIG9iamVjdHMuIFN1cHBvcnQgQXJyYXlzIGFuZCBPYmplY3RzLlxyXG4gKi9cclxuZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcclxuICAgIGlmIChhID09PSBiKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhS2V5cyA9IE9iamVjdC5rZXlzKGEpO1xyXG4gICAgY29uc3QgYktleXMgPSBPYmplY3Qua2V5cyhiKTtcclxuICAgIGZvciAoY29uc3QgayBvZiBhS2V5cykge1xyXG4gICAgICAgIGlmICghYktleXMuaW5jbHVkZXMoaykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhUHJvcCA9IGFba107XHJcbiAgICAgICAgY29uc3QgYlByb3AgPSBiW2tdO1xyXG4gICAgICAgIGlmIChpc09iamVjdChhUHJvcCkgJiYgaXNPYmplY3QoYlByb3ApKSB7XHJcbiAgICAgICAgICAgIGlmICghZGVlcEVxdWFsKGFQcm9wLCBiUHJvcCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhUHJvcCAhPT0gYlByb3ApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvciAoY29uc3QgayBvZiBiS2V5cykge1xyXG4gICAgICAgIGlmICghYUtleXMuaW5jbHVkZXMoaykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGlzT2JqZWN0KHRoaW5nKSB7XHJcbiAgICByZXR1cm4gdGhpbmcgIT09IG51bGwgJiYgdHlwZW9mIHRoaW5nID09PSAnb2JqZWN0JztcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUmVqZWN0cyBpZiB0aGUgZ2l2ZW4gcHJvbWlzZSBkb2Vzbid0IHJlc29sdmUgaW4gdGltZUluTVMgbWlsbGlzZWNvbmRzLlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIHByb21pc2VXaXRoVGltZW91dChwcm9taXNlLCB0aW1lSW5NUyA9IDIwMDApIHtcclxuICAgIGNvbnN0IGRlZmVycmVkUHJvbWlzZSA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgc2V0VGltZW91dCgoKSA9PiBkZWZlcnJlZFByb21pc2UucmVqZWN0KCd0aW1lb3V0IScpLCB0aW1lSW5NUyk7XHJcbiAgICBwcm9taXNlLnRoZW4oZGVmZXJyZWRQcm9taXNlLnJlc29sdmUsIGRlZmVycmVkUHJvbWlzZS5yZWplY3QpO1xyXG4gICAgcmV0dXJuIGRlZmVycmVkUHJvbWlzZS5wcm9taXNlO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgcXVlcnlzdHJpbmctZm9ybWF0dGVkIHN0cmluZyAoZS5nLiAmYXJnPXZhbCZhcmcyPXZhbDIpIGZyb20gYVxyXG4gKiBwYXJhbXMgb2JqZWN0IChlLmcuIHthcmc6ICd2YWwnLCBhcmcyOiAndmFsMid9KVxyXG4gKiBOb3RlOiBZb3UgbXVzdCBwcmVwZW5kIGl0IHdpdGggPyB3aGVuIGFkZGluZyBpdCB0byBhIFVSTC5cclxuICovXHJcbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5nKHF1ZXJ5c3RyaW5nUGFyYW1zKSB7XHJcbiAgICBjb25zdCBwYXJhbXMgPSBbXTtcclxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHF1ZXJ5c3RyaW5nUGFyYW1zKSkge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKGFycmF5VmFsID0+IHtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGFycmF5VmFsKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcGFyYW1zLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGFyYW1zLmxlbmd0aCA/ICcmJyArIHBhcmFtcy5qb2luKCcmJykgOiAnJztcclxufVxyXG4vKipcclxuICogRGVjb2RlcyBhIHF1ZXJ5c3RyaW5nIChlLmcuID9hcmc9dmFsJmFyZzI9dmFsMikgaW50byBhIHBhcmFtcyBvYmplY3RcclxuICogKGUuZy4ge2FyZzogJ3ZhbCcsIGFyZzI6ICd2YWwyJ30pXHJcbiAqL1xyXG5mdW5jdGlvbiBxdWVyeXN0cmluZ0RlY29kZShxdWVyeXN0cmluZykge1xyXG4gICAgY29uc3Qgb2JqID0ge307XHJcbiAgICBjb25zdCB0b2tlbnMgPSBxdWVyeXN0cmluZy5yZXBsYWNlKC9eXFw/LywgJycpLnNwbGl0KCcmJyk7XHJcbiAgICB0b2tlbnMuZm9yRWFjaCh0b2tlbiA9PiB7XHJcbiAgICAgICAgaWYgKHRva2VuKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IHRva2VuLnNwbGl0KCc9Jyk7XHJcbiAgICAgICAgICAgIG9ialtkZWNvZGVVUklDb21wb25lbnQoa2V5KV0gPSBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG9iajtcclxufVxyXG4vKipcclxuICogRXh0cmFjdCB0aGUgcXVlcnkgc3RyaW5nIHBhcnQgb2YgYSBVUkwsIGluY2x1ZGluZyB0aGUgbGVhZGluZyBxdWVzdGlvbiBtYXJrIChpZiBwcmVzZW50KS5cclxuICovXHJcbmZ1bmN0aW9uIGV4dHJhY3RRdWVyeXN0cmluZyh1cmwpIHtcclxuICAgIGNvbnN0IHF1ZXJ5U3RhcnQgPSB1cmwuaW5kZXhPZignPycpO1xyXG4gICAgaWYgKCFxdWVyeVN0YXJ0KSB7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZnJhZ21lbnRTdGFydCA9IHVybC5pbmRleE9mKCcjJywgcXVlcnlTdGFydCk7XHJcbiAgICByZXR1cm4gdXJsLnN1YnN0cmluZyhxdWVyeVN0YXJ0LCBmcmFnbWVudFN0YXJ0ID4gMCA/IGZyYWdtZW50U3RhcnQgOiB1bmRlZmluZWQpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IFNIQS0xIGNyeXB0b2dyYXBoaWMgaGFzaC5cclxuICogVmFyaWFibGUgbmFtZXMgZm9sbG93IHRoZSBub3RhdGlvbiBpbiBGSVBTIFBVQiAxODAtMzpcclxuICogaHR0cDovL2NzcmMubmlzdC5nb3YvcHVibGljYXRpb25zL2ZpcHMvZmlwczE4MC0zL2ZpcHMxODAtM19maW5hbC5wZGYuXHJcbiAqXHJcbiAqIFVzYWdlOlxyXG4gKiAgIHZhciBzaGExID0gbmV3IHNoYTEoKTtcclxuICogICBzaGExLnVwZGF0ZShieXRlcyk7XHJcbiAqICAgdmFyIGhhc2ggPSBzaGExLmRpZ2VzdCgpO1xyXG4gKlxyXG4gKiBQZXJmb3JtYW5jZTpcclxuICogICBDaHJvbWUgMjM6ICAgfjQwMCBNYml0L3NcclxuICogICBGaXJlZm94IDE2OiAgfjI1MCBNYml0L3NcclxuICpcclxuICovXHJcbi8qKlxyXG4gKiBTSEEtMSBjcnlwdG9ncmFwaGljIGhhc2ggY29uc3RydWN0b3IuXHJcbiAqXHJcbiAqIFRoZSBwcm9wZXJ0aWVzIGRlY2xhcmVkIGhlcmUgYXJlIGRpc2N1c3NlZCBpbiB0aGUgYWJvdmUgYWxnb3JpdGhtIGRvY3VtZW50LlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGZpbmFsXHJcbiAqIEBzdHJ1Y3RcclxuICovXHJcbmNsYXNzIFNoYTEge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSG9sZHMgdGhlIHByZXZpb3VzIHZhbHVlcyBvZiBhY2N1bXVsYXRlZCB2YXJpYWJsZXMgYS1lIGluIHRoZSBjb21wcmVzc19cclxuICAgICAgICAgKiBmdW5jdGlvbi5cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2hhaW5fID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBidWZmZXIgaG9sZGluZyB0aGUgcGFydGlhbGx5IGNvbXB1dGVkIGhhc2ggcmVzdWx0LlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5idWZfID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW4gYXJyYXkgb2YgODAgYnl0ZXMsIGVhY2ggYSBwYXJ0IG9mIHRoZSBtZXNzYWdlIHRvIGJlIGhhc2hlZC4gIFJlZmVycmVkIHRvXHJcbiAgICAgICAgICogYXMgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgaW4gdGhlIGRvY3MuXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLldfID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udGFpbnMgZGF0YSBuZWVkZWQgdG8gcGFkIG1lc3NhZ2VzIGxlc3MgdGhhbiA2NCBieXRlcy5cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucGFkXyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pbmJ1Zl8gPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50b3RhbF8gPSAwO1xyXG4gICAgICAgIHRoaXMuYmxvY2tTaXplID0gNTEyIC8gODtcclxuICAgICAgICB0aGlzLnBhZF9bMF0gPSAxMjg7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLmJsb2NrU2l6ZTsgKytpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFkX1tpXSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgIH1cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuY2hhaW5fWzBdID0gMHg2NzQ1MjMwMTtcclxuICAgICAgICB0aGlzLmNoYWluX1sxXSA9IDB4ZWZjZGFiODk7XHJcbiAgICAgICAgdGhpcy5jaGFpbl9bMl0gPSAweDk4YmFkY2ZlO1xyXG4gICAgICAgIHRoaXMuY2hhaW5fWzNdID0gMHgxMDMyNTQ3NjtcclxuICAgICAgICB0aGlzLmNoYWluX1s0XSA9IDB4YzNkMmUxZjA7XHJcbiAgICAgICAgdGhpcy5pbmJ1Zl8gPSAwO1xyXG4gICAgICAgIHRoaXMudG90YWxfID0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJuYWwgY29tcHJlc3MgaGVscGVyIGZ1bmN0aW9uLlxyXG4gICAgICogQHBhcmFtIGJ1ZiBCbG9jayB0byBjb21wcmVzcy5cclxuICAgICAqIEBwYXJhbSBvZmZzZXQgT2Zmc2V0IG9mIHRoZSBibG9jayBpbiB0aGUgYnVmZmVyLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgY29tcHJlc3NfKGJ1Ziwgb2Zmc2V0KSB7XHJcbiAgICAgICAgaWYgKCFvZmZzZXQpIHtcclxuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgVyA9IHRoaXMuV187XHJcbiAgICAgICAgLy8gZ2V0IDE2IGJpZyBlbmRpYW4gd29yZHNcclxuICAgICAgICBpZiAodHlwZW9mIGJ1ZiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPKHVzZXIpOiBbYnVnIDgxNDAxMjJdIFJlY2VudCB2ZXJzaW9ucyBvZiBTYWZhcmkgZm9yIE1hYyBPUyBhbmQgaU9TXHJcbiAgICAgICAgICAgICAgICAvLyBoYXZlIGEgYnVnIHRoYXQgdHVybnMgdGhlIHBvc3QtaW5jcmVtZW50ICsrIG9wZXJhdG9yIGludG8gcHJlLWluY3JlbWVudFxyXG4gICAgICAgICAgICAgICAgLy8gZHVyaW5nIEpJVCBjb21waWxhdGlvbi4gIFdlIGhhdmUgY29kZSB0aGF0IGRlcGVuZHMgaGVhdmlseSBvbiBTSEEtMSBmb3JcclxuICAgICAgICAgICAgICAgIC8vIGNvcnJlY3RuZXNzIGFuZCB3aGljaCBpcyBhZmZlY3RlZCBieSB0aGlzIGJ1Zywgc28gSSd2ZSByZW1vdmVkIGFsbCB1c2VzXHJcbiAgICAgICAgICAgICAgICAvLyBvZiBwb3N0LWluY3JlbWVudCArKyBpbiB3aGljaCB0aGUgcmVzdWx0IHZhbHVlIGlzIHVzZWQuICBXZSBjYW4gcmV2ZXJ0XHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNoYW5nZSBvbmNlIHRoZSBTYWZhcmkgYnVnXHJcbiAgICAgICAgICAgICAgICAvLyAoaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEwOTAzNikgaGFzIGJlZW4gZml4ZWQgYW5kXHJcbiAgICAgICAgICAgICAgICAvLyBtb3N0IGNsaWVudHMgaGF2ZSBiZWVuIHVwZGF0ZWQuXHJcbiAgICAgICAgICAgICAgICBXW2ldID1cclxuICAgICAgICAgICAgICAgICAgICAoYnVmLmNoYXJDb2RlQXQob2Zmc2V0KSA8PCAyNCkgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVmLmNoYXJDb2RlQXQob2Zmc2V0ICsgMSkgPDwgMTYpIHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGJ1Zi5jaGFyQ29kZUF0KG9mZnNldCArIDIpIDw8IDgpIHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmLmNoYXJDb2RlQXQob2Zmc2V0ICsgMyk7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBXW2ldID1cclxuICAgICAgICAgICAgICAgICAgICAoYnVmW29mZnNldF0gPDwgMjQpIHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGJ1ZltvZmZzZXQgKyAxXSA8PCAxNikgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVmW29mZnNldCArIDJdIDw8IDgpIHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmW29mZnNldCArIDNdO1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZXhwYW5kIHRvIDgwIHdvcmRzXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgODA7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCB0ID0gV1tpIC0gM10gXiBXW2kgLSA4XSBeIFdbaSAtIDE0XSBeIFdbaSAtIDE2XTtcclxuICAgICAgICAgICAgV1tpXSA9ICgodCA8PCAxKSB8ICh0ID4+PiAzMSkpICYgMHhmZmZmZmZmZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGEgPSB0aGlzLmNoYWluX1swXTtcclxuICAgICAgICBsZXQgYiA9IHRoaXMuY2hhaW5fWzFdO1xyXG4gICAgICAgIGxldCBjID0gdGhpcy5jaGFpbl9bMl07XHJcbiAgICAgICAgbGV0IGQgPSB0aGlzLmNoYWluX1szXTtcclxuICAgICAgICBsZXQgZSA9IHRoaXMuY2hhaW5fWzRdO1xyXG4gICAgICAgIGxldCBmLCBrO1xyXG4gICAgICAgIC8vIFRPRE8odXNlcik6IFRyeSB0byB1bnJvbGwgdGhpcyBsb29wIHRvIHNwZWVkIHVwIHRoZSBjb21wdXRhdGlvbi5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDgwOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGkgPCA0MCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPCAyMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGYgPSBkIF4gKGIgJiAoYyBeIGQpKTtcclxuICAgICAgICAgICAgICAgICAgICBrID0gMHg1YTgyNzk5OTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGYgPSBiIF4gYyBeIGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgayA9IDB4NmVkOWViYTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA8IDYwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZiA9IChiICYgYykgfCAoZCAmIChiIHwgYykpO1xyXG4gICAgICAgICAgICAgICAgICAgIGsgPSAweDhmMWJiY2RjO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZiA9IGIgXiBjIF4gZDtcclxuICAgICAgICAgICAgICAgICAgICBrID0gMHhjYTYyYzFkNjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB0ID0gKCgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZiArIGUgKyBrICsgV1tpXSkgJiAweGZmZmZmZmZmO1xyXG4gICAgICAgICAgICBlID0gZDtcclxuICAgICAgICAgICAgZCA9IGM7XHJcbiAgICAgICAgICAgIGMgPSAoKGIgPDwgMzApIHwgKGIgPj4+IDIpKSAmIDB4ZmZmZmZmZmY7XHJcbiAgICAgICAgICAgIGIgPSBhO1xyXG4gICAgICAgICAgICBhID0gdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jaGFpbl9bMF0gPSAodGhpcy5jaGFpbl9bMF0gKyBhKSAmIDB4ZmZmZmZmZmY7XHJcbiAgICAgICAgdGhpcy5jaGFpbl9bMV0gPSAodGhpcy5jaGFpbl9bMV0gKyBiKSAmIDB4ZmZmZmZmZmY7XHJcbiAgICAgICAgdGhpcy5jaGFpbl9bMl0gPSAodGhpcy5jaGFpbl9bMl0gKyBjKSAmIDB4ZmZmZmZmZmY7XHJcbiAgICAgICAgdGhpcy5jaGFpbl9bM10gPSAodGhpcy5jaGFpbl9bM10gKyBkKSAmIDB4ZmZmZmZmZmY7XHJcbiAgICAgICAgdGhpcy5jaGFpbl9bNF0gPSAodGhpcy5jaGFpbl9bNF0gKyBlKSAmIDB4ZmZmZmZmZmY7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoYnl0ZXMsIGxlbmd0aCkge1xyXG4gICAgICAgIC8vIFRPRE8oam9obmxlbnopOiB0aWdodGVuIHRoZSBmdW5jdGlvbiBzaWduYXR1cmUgYW5kIHJlbW92ZSB0aGlzIGNoZWNrXHJcbiAgICAgICAgaWYgKGJ5dGVzID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBsZW5ndGhNaW51c0Jsb2NrID0gbGVuZ3RoIC0gdGhpcy5ibG9ja1NpemU7XHJcbiAgICAgICAgbGV0IG4gPSAwO1xyXG4gICAgICAgIC8vIFVzaW5nIGxvY2FsIGluc3RlYWQgb2YgbWVtYmVyIHZhcmlhYmxlcyBnaXZlcyB+NSUgc3BlZWR1cCBvbiBGaXJlZm94IDE2LlxyXG4gICAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMuYnVmXztcclxuICAgICAgICBsZXQgaW5idWYgPSB0aGlzLmluYnVmXztcclxuICAgICAgICAvLyBUaGUgb3V0ZXIgd2hpbGUgbG9vcCBzaG91bGQgZXhlY3V0ZSBhdCBtb3N0IHR3aWNlLlxyXG4gICAgICAgIHdoaWxlIChuIDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgaGF2ZSBubyBkYXRhIGluIHRoZSBibG9jayB0byB0b3AgdXAsIHdlIGNhbiBkaXJlY3RseSBwcm9jZXNzIHRoZVxyXG4gICAgICAgICAgICAvLyBpbnB1dCBidWZmZXIgKGFzc3VtaW5nIGl0IGNvbnRhaW5zIHN1ZmZpY2llbnQgZGF0YSkuIFRoaXMgZ2l2ZXMgfjI1JVxyXG4gICAgICAgICAgICAvLyBzcGVlZHVwIG9uIENocm9tZSAyMyBhbmQgfjE1JSBzcGVlZHVwIG9uIEZpcmVmb3ggMTYsIGJ1dCByZXF1aXJlcyB0aGF0XHJcbiAgICAgICAgICAgIC8vIHRoZSBkYXRhIGlzIHByb3ZpZGVkIGluIGxhcmdlIGNodW5rcyAob3IgaW4gbXVsdGlwbGVzIG9mIDY0IGJ5dGVzKS5cclxuICAgICAgICAgICAgaWYgKGluYnVmID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAobiA8PSBsZW5ndGhNaW51c0Jsb2NrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wcmVzc18oYnl0ZXMsIG4pO1xyXG4gICAgICAgICAgICAgICAgICAgIG4gKz0gdGhpcy5ibG9ja1NpemU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChuIDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmW2luYnVmXSA9IGJ5dGVzLmNoYXJDb2RlQXQobik7XHJcbiAgICAgICAgICAgICAgICAgICAgKytpbmJ1ZjtcclxuICAgICAgICAgICAgICAgICAgICArK247XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluYnVmID09PSB0aGlzLmJsb2NrU2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXByZXNzXyhidWYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmJ1ZiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEp1bXAgdG8gdGhlIG91dGVyIGxvb3Agc28gd2UgdXNlIHRoZSBmdWxsLWJsb2NrIG9wdGltaXphdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKG4gPCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBidWZbaW5idWZdID0gYnl0ZXNbbl07XHJcbiAgICAgICAgICAgICAgICAgICAgKytpbmJ1ZjtcclxuICAgICAgICAgICAgICAgICAgICArK247XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluYnVmID09PSB0aGlzLmJsb2NrU2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXByZXNzXyhidWYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmJ1ZiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEp1bXAgdG8gdGhlIG91dGVyIGxvb3Agc28gd2UgdXNlIHRoZSBmdWxsLWJsb2NrIG9wdGltaXphdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaW5idWZfID0gaW5idWY7XHJcbiAgICAgICAgdGhpcy50b3RhbF8gKz0gbGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgLyoqIEBvdmVycmlkZSAqL1xyXG4gICAgZGlnZXN0KCkge1xyXG4gICAgICAgIGNvbnN0IGRpZ2VzdCA9IFtdO1xyXG4gICAgICAgIGxldCB0b3RhbEJpdHMgPSB0aGlzLnRvdGFsXyAqIDg7XHJcbiAgICAgICAgLy8gQWRkIHBhZCAweDgwIDB4MDAqLlxyXG4gICAgICAgIGlmICh0aGlzLmluYnVmXyA8IDU2KSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHRoaXMucGFkXywgNTYgLSB0aGlzLmluYnVmXyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh0aGlzLnBhZF8sIHRoaXMuYmxvY2tTaXplIC0gKHRoaXMuaW5idWZfIC0gNTYpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQWRkICMgYml0cy5cclxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5ibG9ja1NpemUgLSAxOyBpID49IDU2OyBpLS0pIHtcclxuICAgICAgICAgICAgdGhpcy5idWZfW2ldID0gdG90YWxCaXRzICYgMjU1O1xyXG4gICAgICAgICAgICB0b3RhbEJpdHMgLz0gMjU2OyAvLyBEb24ndCB1c2UgYml0LXNoaWZ0aW5nIGhlcmUhXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29tcHJlc3NfKHRoaXMuYnVmXyk7XHJcbiAgICAgICAgbGV0IG4gPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAyNDsgaiA+PSAwOyBqIC09IDgpIHtcclxuICAgICAgICAgICAgICAgIGRpZ2VzdFtuXSA9ICh0aGlzLmNoYWluX1tpXSA+PiBqKSAmIDI1NTtcclxuICAgICAgICAgICAgICAgICsrbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGlnZXN0O1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBIZWxwZXIgdG8gbWFrZSBhIFN1YnNjcmliZSBmdW5jdGlvbiAoanVzdCBsaWtlIFByb21pc2UgaGVscHMgbWFrZSBhXHJcbiAqIFRoZW5hYmxlKS5cclxuICpcclxuICogQHBhcmFtIGV4ZWN1dG9yIEZ1bmN0aW9uIHdoaWNoIGNhbiBtYWtlIGNhbGxzIHRvIGEgc2luZ2xlIE9ic2VydmVyXHJcbiAqICAgICBhcyBhIHByb3h5LlxyXG4gKiBAcGFyYW0gb25Ob09ic2VydmVycyBDYWxsYmFjayB3aGVuIGNvdW50IG9mIE9ic2VydmVycyBnb2VzIHRvIHplcm8uXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVTdWJzY3JpYmUoZXhlY3V0b3IsIG9uTm9PYnNlcnZlcnMpIHtcclxuICAgIGNvbnN0IHByb3h5ID0gbmV3IE9ic2VydmVyUHJveHkoZXhlY3V0b3IsIG9uTm9PYnNlcnZlcnMpO1xyXG4gICAgcmV0dXJuIHByb3h5LnN1YnNjcmliZS5iaW5kKHByb3h5KTtcclxufVxyXG4vKipcclxuICogSW1wbGVtZW50IGZhbi1vdXQgZm9yIGFueSBudW1iZXIgb2YgT2JzZXJ2ZXJzIGF0dGFjaGVkIHZpYSBhIHN1YnNjcmliZVxyXG4gKiBmdW5jdGlvbi5cclxuICovXHJcbmNsYXNzIE9ic2VydmVyUHJveHkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gZXhlY3V0b3IgRnVuY3Rpb24gd2hpY2ggY2FuIG1ha2UgY2FsbHMgdG8gYSBzaW5nbGUgT2JzZXJ2ZXJcclxuICAgICAqICAgICBhcyBhIHByb3h5LlxyXG4gICAgICogQHBhcmFtIG9uTm9PYnNlcnZlcnMgQ2FsbGJhY2sgd2hlbiBjb3VudCBvZiBPYnNlcnZlcnMgZ29lcyB0byB6ZXJvLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihleGVjdXRvciwgb25Ob09ic2VydmVycykge1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gW107XHJcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZXMgPSBbXTtcclxuICAgICAgICB0aGlzLm9ic2VydmVyQ291bnQgPSAwO1xyXG4gICAgICAgIC8vIE1pY3JvLXRhc2sgc2NoZWR1bGluZyBieSBjYWxsaW5nIHRhc2sudGhlbigpLlxyXG4gICAgICAgIHRoaXMudGFzayA9IFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIHRoaXMuZmluYWxpemVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5vbk5vT2JzZXJ2ZXJzID0gb25Ob09ic2VydmVycztcclxuICAgICAgICAvLyBDYWxsIHRoZSBleGVjdXRvciBhc3luY2hyb25vdXNseSBzbyBzdWJzY3JpYmVycyB0aGF0IGFyZSBjYWxsZWRcclxuICAgICAgICAvLyBzeW5jaHJvbm91c2x5IGFmdGVyIHRoZSBjcmVhdGlvbiBvZiB0aGUgc3Vic2NyaWJlIGZ1bmN0aW9uXHJcbiAgICAgICAgLy8gY2FuIHN0aWxsIHJlY2VpdmUgdGhlIHZlcnkgZmlyc3QgdmFsdWUgZ2VuZXJhdGVkIGluIHRoZSBleGVjdXRvci5cclxuICAgICAgICB0aGlzLnRhc2tcclxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICBleGVjdXRvcih0aGlzKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAuY2F0Y2goZSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBuZXh0KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5mb3JFYWNoT2JzZXJ2ZXIoKG9ic2VydmVyKSA9PiB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQodmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZXJyb3IoZXJyb3IpIHtcclxuICAgICAgICB0aGlzLmZvckVhY2hPYnNlcnZlcigob2JzZXJ2ZXIpID0+IHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXJyb3IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuY2xvc2UoZXJyb3IpO1xyXG4gICAgfVxyXG4gICAgY29tcGxldGUoKSB7XHJcbiAgICAgICAgdGhpcy5mb3JFYWNoT2JzZXJ2ZXIoKG9ic2VydmVyKSA9PiB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJzY3JpYmUgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBhZGQgYW4gT2JzZXJ2ZXIgdG8gdGhlIGZhbi1vdXQgbGlzdC5cclxuICAgICAqXHJcbiAgICAgKiAtIFdlIHJlcXVpcmUgdGhhdCBubyBldmVudCBpcyBzZW50IHRvIGEgc3Vic2NyaWJlciBzeWNocm9ub3VzbHkgdG8gdGhlaXJcclxuICAgICAqICAgY2FsbCB0byBzdWJzY3JpYmUoKS5cclxuICAgICAqL1xyXG4gICAgc3Vic2NyaWJlKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpIHtcclxuICAgICAgICBsZXQgb2JzZXJ2ZXI7XHJcbiAgICAgICAgaWYgKG5leHRPck9ic2VydmVyID09PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgZXJyb3IgPT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgICAgICBjb21wbGV0ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBPYnNlcnZlci4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQXNzZW1ibGUgYW4gT2JzZXJ2ZXIgb2JqZWN0IHdoZW4gcGFzc2VkIGFzIGNhbGxiYWNrIGZ1bmN0aW9ucy5cclxuICAgICAgICBpZiAoaW1wbGVtZW50c0FueU1ldGhvZHMobmV4dE9yT2JzZXJ2ZXIsIFtcclxuICAgICAgICAgICAgJ25leHQnLFxyXG4gICAgICAgICAgICAnZXJyb3InLFxyXG4gICAgICAgICAgICAnY29tcGxldGUnXHJcbiAgICAgICAgXSkpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIgPSBuZXh0T3JPYnNlcnZlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyID0ge1xyXG4gICAgICAgICAgICAgICAgbmV4dDogbmV4dE9yT2JzZXJ2ZXIsXHJcbiAgICAgICAgICAgICAgICBlcnJvcixcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvYnNlcnZlci5uZXh0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCA9IG5vb3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvYnNlcnZlci5lcnJvciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yID0gbm9vcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9ic2VydmVyLmNvbXBsZXRlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUgPSBub29wO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB1bnN1YiA9IHRoaXMudW5zdWJzY3JpYmVPbmUuYmluZCh0aGlzLCB0aGlzLm9ic2VydmVycy5sZW5ndGgpO1xyXG4gICAgICAgIC8vIEF0dGVtcHQgdG8gc3Vic2NyaWJlIHRvIGEgdGVybWluYXRlZCBPYnNlcnZhYmxlIC0gd2VcclxuICAgICAgICAvLyBqdXN0IHJlc3BvbmQgdG8gdGhlIE9ic2VydmVyIHdpdGggdGhlIGZpbmFsIGVycm9yIG9yIGNvbXBsZXRlXHJcbiAgICAgICAgLy8gZXZlbnQuXHJcbiAgICAgICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcclxuICAgICAgICAgICAgdGhpcy50YXNrLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5maW5hbEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKHRoaXMuZmluYWxFcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90aGluZ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XHJcbiAgICAgICAgcmV0dXJuIHVuc3ViO1xyXG4gICAgfVxyXG4gICAgLy8gVW5zdWJzY3JpYmUgaXMgc3luY2hyb25vdXMgLSB3ZSBndWFyYW50ZWUgdGhhdCBubyBldmVudHMgYXJlIHNlbnQgdG9cclxuICAgIC8vIGFueSB1bnN1YnNjcmliZWQgT2JzZXJ2ZXIuXHJcbiAgICB1bnN1YnNjcmliZU9uZShpKSB7XHJcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXJzID09PSB1bmRlZmluZWQgfHwgdGhpcy5vYnNlcnZlcnNbaV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlbGV0ZSB0aGlzLm9ic2VydmVyc1tpXTtcclxuICAgICAgICB0aGlzLm9ic2VydmVyQ291bnQgLT0gMTtcclxuICAgICAgICBpZiAodGhpcy5vYnNlcnZlckNvdW50ID09PSAwICYmIHRoaXMub25Ob09ic2VydmVycyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25Ob09ic2VydmVycyh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3JFYWNoT2JzZXJ2ZXIoZm4pIHtcclxuICAgICAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcclxuICAgICAgICAgICAgLy8gQWxyZWFkeSBjbG9zZWQgYnkgcHJldmlvdXMgZXZlbnQuLi4uanVzdCBlYXQgdGhlIGFkZGl0aW9uYWwgdmFsdWVzLlxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFNpbmNlIHNlbmRPbmUgY2FsbHMgYXN5bmNocm9ub3VzbHkgLSB0aGVyZSBpcyBubyBjaGFuY2UgdGhhdFxyXG4gICAgICAgIC8vIHRoaXMub2JzZXJ2ZXJzIHdpbGwgYmVjb21lIHVuZGVmaW5lZC5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMub2JzZXJ2ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZE9uZShpLCBmbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gQ2FsbCB0aGUgT2JzZXJ2ZXIgdmlhIG9uZSBvZiBpdCdzIGNhbGxiYWNrIGZ1bmN0aW9uLiBXZSBhcmUgY2FyZWZ1bCB0b1xyXG4gICAgLy8gY29uZmlybSB0aGF0IHRoZSBvYnNlcnZlIGhhcyBub3QgYmVlbiB1bnN1YnNjcmliZWQgc2luY2UgdGhpcyBhc3luY2hyb25vdXNcclxuICAgIC8vIGZ1bmN0aW9uIGhhZCBiZWVuIHF1ZXVlZC5cclxuICAgIHNlbmRPbmUoaSwgZm4pIHtcclxuICAgICAgICAvLyBFeGVjdXRlIHRoZSBjYWxsYmFjayBhc3luY2hyb25vdXNseVxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcclxuICAgICAgICB0aGlzLnRhc2sudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9ic2VydmVycyAhPT0gdW5kZWZpbmVkICYmIHRoaXMub2JzZXJ2ZXJzW2ldICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm4odGhpcy5vYnNlcnZlcnNbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZXhjZXB0aW9ucyByYWlzZWQgaW4gT2JzZXJ2ZXJzIG9yIG1pc3NpbmcgbWV0aG9kcyBvZiBhblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ic2VydmVyLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIExvZyBlcnJvciB0byBjb25zb2xlLiBiLzMxNDA0ODA2XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlLmVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjbG9zZShlcnIpIHtcclxuICAgICAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmZpbmFsaXplZCA9IHRydWU7XHJcbiAgICAgICAgaWYgKGVyciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmluYWxFcnJvciA9IGVycjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUHJveHkgaXMgbm8gbG9uZ2VyIG5lZWRlZCAtIGdhcmJhZ2UgY29sbGVjdCByZWZlcmVuY2VzXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xyXG4gICAgICAgIHRoaXMudGFzay50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHRoaXMub25Ob09ic2VydmVycyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4vKiogVHVybiBzeW5jaHJvbm91cyBmdW5jdGlvbiBpbnRvIG9uZSBjYWxsZWQgYXN5bmNocm9ub3VzbHkuICovXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXHJcbmZ1bmN0aW9uIGFzeW5jKGZuLCBvbkVycm9yKSB7XHJcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcclxuICAgICAgICBQcm9taXNlLnJlc29sdmUodHJ1ZSlcclxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICBmbiguLi5hcmdzKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChvbkVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBvbkVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIG9iamVjdCBwYXNzZWQgaW4gaW1wbGVtZW50cyBhbnkgb2YgdGhlIG5hbWVkIG1ldGhvZHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBpbXBsZW1lbnRzQW55TWV0aG9kcyhvYmosIG1ldGhvZHMpIHtcclxuICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBtZXRob2RzKSB7XHJcbiAgICAgICAgaWYgKG1ldGhvZCBpbiBvYmogJiYgdHlwZW9mIG9ialttZXRob2RdID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBub29wKCkge1xyXG4gICAgLy8gZG8gbm90aGluZ1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBDaGVjayB0byBtYWtlIHN1cmUgdGhlIGFwcHJvcHJpYXRlIG51bWJlciBvZiBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIGZvciBhIHB1YmxpYyBmdW5jdGlvbi5cclxuICogVGhyb3dzIGFuIGVycm9yIGlmIGl0IGZhaWxzLlxyXG4gKlxyXG4gKiBAcGFyYW0gZm5OYW1lIFRoZSBmdW5jdGlvbiBuYW1lXHJcbiAqIEBwYXJhbSBtaW5Db3VudCBUaGUgbWluaW11bSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGFsbG93IGZvciB0aGUgZnVuY3Rpb24gY2FsbFxyXG4gKiBAcGFyYW0gbWF4Q291bnQgVGhlIG1heGltdW0gbnVtYmVyIG9mIGFyZ3VtZW50IHRvIGFsbG93IGZvciB0aGUgZnVuY3Rpb24gY2FsbFxyXG4gKiBAcGFyYW0gYXJnQ291bnQgVGhlIGFjdHVhbCBudW1iZXIgb2YgYXJndW1lbnRzIHByb3ZpZGVkLlxyXG4gKi9cclxuY29uc3QgdmFsaWRhdGVBcmdDb3VudCA9IGZ1bmN0aW9uIChmbk5hbWUsIG1pbkNvdW50LCBtYXhDb3VudCwgYXJnQ291bnQpIHtcclxuICAgIGxldCBhcmdFcnJvcjtcclxuICAgIGlmIChhcmdDb3VudCA8IG1pbkNvdW50KSB7XHJcbiAgICAgICAgYXJnRXJyb3IgPSAnYXQgbGVhc3QgJyArIG1pbkNvdW50O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYXJnQ291bnQgPiBtYXhDb3VudCkge1xyXG4gICAgICAgIGFyZ0Vycm9yID0gbWF4Q291bnQgPT09IDAgPyAnbm9uZScgOiAnbm8gbW9yZSB0aGFuICcgKyBtYXhDb3VudDtcclxuICAgIH1cclxuICAgIGlmIChhcmdFcnJvcikge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gZm5OYW1lICtcclxuICAgICAgICAgICAgJyBmYWlsZWQ6IFdhcyBjYWxsZWQgd2l0aCAnICtcclxuICAgICAgICAgICAgYXJnQ291bnQgK1xyXG4gICAgICAgICAgICAoYXJnQ291bnQgPT09IDEgPyAnIGFyZ3VtZW50LicgOiAnIGFyZ3VtZW50cy4nKSArXHJcbiAgICAgICAgICAgICcgRXhwZWN0cyAnICtcclxuICAgICAgICAgICAgYXJnRXJyb3IgK1xyXG4gICAgICAgICAgICAnLic7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIHN0cmluZyB0byBwcmVmaXggYW4gZXJyb3IgbWVzc2FnZSBhYm91dCBmYWlsZWQgYXJndW1lbnQgdmFsaWRhdGlvblxyXG4gKlxyXG4gKiBAcGFyYW0gZm5OYW1lIFRoZSBmdW5jdGlvbiBuYW1lXHJcbiAqIEBwYXJhbSBhcmdOYW1lIFRoZSBuYW1lIG9mIHRoZSBhcmd1bWVudFxyXG4gKiBAcmV0dXJuIFRoZSBwcmVmaXggdG8gYWRkIHRvIHRoZSBlcnJvciB0aHJvd24gZm9yIHZhbGlkYXRpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBlcnJvclByZWZpeChmbk5hbWUsIGFyZ05hbWUpIHtcclxuICAgIHJldHVybiBgJHtmbk5hbWV9IGZhaWxlZDogJHthcmdOYW1lfSBhcmd1bWVudCBgO1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gZm5OYW1lXHJcbiAqIEBwYXJhbSBhcmd1bWVudE51bWJlclxyXG4gKiBAcGFyYW0gbmFtZXNwYWNlXHJcbiAqIEBwYXJhbSBvcHRpb25hbFxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVOYW1lc3BhY2UoZm5OYW1lLCBuYW1lc3BhY2UsIG9wdGlvbmFsKSB7XHJcbiAgICBpZiAob3B0aW9uYWwgJiYgIW5hbWVzcGFjZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIC8vVE9ETzogSSBzaG91bGQgZG8gbW9yZSB2YWxpZGF0aW9uIGhlcmUuIFdlIG9ubHkgYWxsb3cgY2VydGFpbiBjaGFycyBpbiBuYW1lc3BhY2VzLlxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeChmbk5hbWUsICduYW1lc3BhY2UnKSArICdtdXN0IGJlIGEgdmFsaWQgZmlyZWJhc2UgbmFtZXNwYWNlLicpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlQ2FsbGJhY2soZm5OYW1lLCBhcmd1bWVudE5hbWUsIFxyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xyXG5jYWxsYmFjaywgb3B0aW9uYWwpIHtcclxuICAgIGlmIChvcHRpb25hbCAmJiAhY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4KGZuTmFtZSwgYXJndW1lbnROYW1lKSArICdtdXN0IGJlIGEgdmFsaWQgZnVuY3Rpb24uJyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGVDb250ZXh0T2JqZWN0KGZuTmFtZSwgYXJndW1lbnROYW1lLCBjb250ZXh0LCBvcHRpb25hbCkge1xyXG4gICAgaWYgKG9wdGlvbmFsICYmICFjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBjb250ZXh0ICE9PSAnb2JqZWN0JyB8fCBjb250ZXh0ID09PSBudWxsKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4KGZuTmFtZSwgYXJndW1lbnROYW1lKSArICdtdXN0IGJlIGEgdmFsaWQgY29udGV4dCBvYmplY3QuJyk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLy8gQ29kZSBvcmlnaW5hbGx5IGNhbWUgZnJvbSBnb29nLmNyeXB0LnN0cmluZ1RvVXRmOEJ5dGVBcnJheSwgYnV0IGZvciBzb21lIHJlYXNvbiB0aGV5XHJcbi8vIGF1dG9tYXRpY2FsbHkgcmVwbGFjZWQgJ1xcclxcbicgd2l0aCAnXFxuJywgYW5kIHRoZXkgZGlkbid0IGhhbmRsZSBzdXJyb2dhdGUgcGFpcnMsXHJcbi8vIHNvIGl0J3MgYmVlbiBtb2RpZmllZC5cclxuLy8gTm90ZSB0aGF0IG5vdCBhbGwgVW5pY29kZSBjaGFyYWN0ZXJzIGFwcGVhciBhcyBzaW5nbGUgY2hhcmFjdGVycyBpbiBKYXZhU2NyaXB0IHN0cmluZ3MuXHJcbi8vIGZyb21DaGFyQ29kZSByZXR1cm5zIHRoZSBVVEYtMTYgZW5jb2Rpbmcgb2YgYSBjaGFyYWN0ZXIgLSBzbyBzb21lIFVuaWNvZGUgY2hhcmFjdGVyc1xyXG4vLyB1c2UgMiBjaGFyYWN0ZXJzIGluIEphdmFzY3JpcHQuICBBbGwgNC1ieXRlIFVURi04IGNoYXJhY3RlcnMgYmVnaW4gd2l0aCBhIGZpcnN0XHJcbi8vIGNoYXJhY3RlciBpbiB0aGUgcmFuZ2UgMHhEODAwIC0gMHhEQkZGICh0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgc28tY2FsbGVkIHN1cnJvZ2F0ZVxyXG4vLyBwYWlyKS5cclxuLy8gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi81LjEvI3NlYy0xNS4xLjNcclxuLyoqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqL1xyXG5jb25zdCBzdHJpbmdUb0J5dGVBcnJheSA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgIGNvbnN0IG91dCA9IFtdO1xyXG4gICAgbGV0IHAgPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIC8vIElzIHRoaXMgdGhlIGxlYWQgc3Vycm9nYXRlIGluIGEgc3Vycm9nYXRlIHBhaXI/XHJcbiAgICAgICAgaWYgKGMgPj0gMHhkODAwICYmIGMgPD0gMHhkYmZmKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhpZ2ggPSBjIC0gMHhkODAwOyAvLyB0aGUgaGlnaCAxMCBiaXRzLlxyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIGFzc2VydChpIDwgc3RyLmxlbmd0aCwgJ1N1cnJvZ2F0ZSBwYWlyIG1pc3NpbmcgdHJhaWwgc3Vycm9nYXRlLicpO1xyXG4gICAgICAgICAgICBjb25zdCBsb3cgPSBzdHIuY2hhckNvZGVBdChpKSAtIDB4ZGMwMDsgLy8gdGhlIGxvdyAxMCBiaXRzLlxyXG4gICAgICAgICAgICBjID0gMHgxMDAwMCArIChoaWdoIDw8IDEwKSArIGxvdztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGMgPCAxMjgpIHtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSBjO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjIDwgMjA0OCkge1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDYpIHwgMTkyO1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjIDwgNjU1MzYpIHtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyA+PiAxMikgfCAyMjQ7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKChjID4+IDYpICYgNjMpIHwgMTI4O1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyA+PiAxOCkgfCAyNDA7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKChjID4+IDEyKSAmIDYzKSB8IDEyODtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoKGMgPj4gNikgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuLyoqXHJcbiAqIENhbGN1bGF0ZSBsZW5ndGggd2l0aG91dCBhY3R1YWxseSBjb252ZXJ0aW5nOyB1c2VmdWwgZm9yIGRvaW5nIGNoZWFwZXIgdmFsaWRhdGlvbi5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAqL1xyXG5jb25zdCBzdHJpbmdMZW5ndGggPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICBsZXQgcCA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGMgPSBzdHIuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBpZiAoYyA8IDEyOCkge1xyXG4gICAgICAgICAgICBwKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGMgPCAyMDQ4KSB7XHJcbiAgICAgICAgICAgIHAgKz0gMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYyA+PSAweGQ4MDAgJiYgYyA8PSAweGRiZmYpIHtcclxuICAgICAgICAgICAgLy8gTGVhZCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpci4gIFRoZSBwYWlyIHRvZ2V0aGVyIHdpbGwgdGFrZSA0IGJ5dGVzIHRvIHJlcHJlc2VudC5cclxuICAgICAgICAgICAgcCArPSA0O1xyXG4gICAgICAgICAgICBpKys7IC8vIHNraXAgdHJhaWwgc3Vycm9nYXRlLlxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcCArPSAzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwO1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQ29waWVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIxMTc1MjNcclxuICogR2VuZXJhdGVzIGEgbmV3IHV1aWQuXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNvbnN0IHV1aWR2NCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGMgPT4ge1xyXG4gICAgICAgIGNvbnN0IHIgPSAoTWF0aC5yYW5kb20oKSAqIDE2KSB8IDAsIHYgPSBjID09PSAneCcgPyByIDogKHIgJiAweDMpIHwgMHg4O1xyXG4gICAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcclxuICAgIH0pO1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhlIGFtb3VudCBvZiBtaWxsaXNlY29uZHMgdG8gZXhwb25lbnRpYWxseSBpbmNyZWFzZS5cclxuICovXHJcbmNvbnN0IERFRkFVTFRfSU5URVJWQUxfTUlMTElTID0gMTAwMDtcclxuLyoqXHJcbiAqIFRoZSBmYWN0b3IgdG8gYmFja29mZiBieS5cclxuICogU2hvdWxkIGJlIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiAxLlxyXG4gKi9cclxuY29uc3QgREVGQVVMVF9CQUNLT0ZGX0ZBQ1RPUiA9IDI7XHJcbi8qKlxyXG4gKiBUaGUgbWF4aW11bSBtaWxsaXNlY29uZHMgdG8gaW5jcmVhc2UgdG8uXHJcbiAqXHJcbiAqIDxwPlZpc2libGUgZm9yIHRlc3RpbmdcclxuICovXHJcbmNvbnN0IE1BWF9WQUxVRV9NSUxMSVMgPSA0ICogNjAgKiA2MCAqIDEwMDA7IC8vIEZvdXIgaG91cnMsIGxpa2UgaU9TIGFuZCBBbmRyb2lkLlxyXG4vKipcclxuICogVGhlIHBlcmNlbnRhZ2Ugb2YgYmFja29mZiB0aW1lIHRvIHJhbmRvbWl6ZSBieS5cclxuICogU2VlXHJcbiAqIGh0dHA6Ly9nby9zYWZlLWNsaWVudC1iZWhhdmlvciNzdGVwLTEtZGV0ZXJtaW5lLXRoZS1hcHByb3ByaWF0ZS1yZXRyeS1pbnRlcnZhbC10by1oYW5kbGUtc3Bpa2UtdHJhZmZpY1xyXG4gKiBmb3IgY29udGV4dC5cclxuICpcclxuICogPHA+VmlzaWJsZSBmb3IgdGVzdGluZ1xyXG4gKi9cclxuY29uc3QgUkFORE9NX0ZBQ1RPUiA9IDAuNTtcclxuLyoqXHJcbiAqIEJhc2VkIG9uIHRoZSBiYWNrb2ZmIG1ldGhvZCBmcm9tXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvY2xvc3VyZS1saWJyYXJ5L2Jsb2IvbWFzdGVyL2Nsb3N1cmUvZ29vZy9tYXRoL2V4cG9uZW50aWFsYmFja29mZi5qcy5cclxuICogRXh0cmFjdGVkIGhlcmUgc28gd2UgZG9uJ3QgbmVlZCB0byBwYXNzIG1ldGFkYXRhIGFuZCBhIHN0YXRlZnVsIEV4cG9uZW50aWFsQmFja29mZiBvYmplY3QgYXJvdW5kLlxyXG4gKi9cclxuZnVuY3Rpb24gY2FsY3VsYXRlQmFja29mZk1pbGxpcyhiYWNrb2ZmQ291bnQsIGludGVydmFsTWlsbGlzID0gREVGQVVMVF9JTlRFUlZBTF9NSUxMSVMsIGJhY2tvZmZGYWN0b3IgPSBERUZBVUxUX0JBQ0tPRkZfRkFDVE9SKSB7XHJcbiAgICAvLyBDYWxjdWxhdGVzIGFuIGV4cG9uZW50aWFsbHkgaW5jcmVhc2luZyB2YWx1ZS5cclxuICAgIC8vIERldmlhdGlvbjogY2FsY3VsYXRlcyB2YWx1ZSBmcm9tIGNvdW50IGFuZCBhIGNvbnN0YW50IGludGVydmFsLCBzbyB3ZSBvbmx5IG5lZWQgdG8gc2F2ZSB2YWx1ZVxyXG4gICAgLy8gYW5kIGNvdW50IHRvIHJlc3RvcmUgc3RhdGUuXHJcbiAgICBjb25zdCBjdXJyQmFzZVZhbHVlID0gaW50ZXJ2YWxNaWxsaXMgKiBNYXRoLnBvdyhiYWNrb2ZmRmFjdG9yLCBiYWNrb2ZmQ291bnQpO1xyXG4gICAgLy8gQSByYW5kb20gXCJmdXp6XCIgdG8gYXZvaWQgd2F2ZXMgb2YgcmV0cmllcy5cclxuICAgIC8vIERldmlhdGlvbjogcmFuZG9tRmFjdG9yIGlzIHJlcXVpcmVkLlxyXG4gICAgY29uc3QgcmFuZG9tV2FpdCA9IE1hdGgucm91bmQoXHJcbiAgICAvLyBBIGZyYWN0aW9uIG9mIHRoZSBiYWNrb2ZmIHZhbHVlIHRvIGFkZC9zdWJ0cmFjdC5cclxuICAgIC8vIERldmlhdGlvbjogY2hhbmdlcyBtdWx0aXBsaWNhdGlvbiBvcmRlciB0byBpbXByb3ZlIHJlYWRhYmlsaXR5LlxyXG4gICAgUkFORE9NX0ZBQ1RPUiAqXHJcbiAgICAgICAgY3VyckJhc2VWYWx1ZSAqXHJcbiAgICAgICAgLy8gQSByYW5kb20gZmxvYXQgKHJvdW5kZWQgdG8gaW50IGJ5IE1hdGgucm91bmQgYWJvdmUpIGluIHRoZSByYW5nZSBbLTEsIDFdLiBEZXRlcm1pbmVzXHJcbiAgICAgICAgLy8gaWYgd2UgYWRkIG9yIHN1YnRyYWN0LlxyXG4gICAgICAgIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqXHJcbiAgICAgICAgMik7XHJcbiAgICAvLyBMaW1pdHMgYmFja29mZiB0byBtYXggdG8gYXZvaWQgZWZmZWN0aXZlbHkgcGVybWFuZW50IGJhY2tvZmYuXHJcbiAgICByZXR1cm4gTWF0aC5taW4oTUFYX1ZBTFVFX01JTExJUywgY3VyckJhc2VWYWx1ZSArIHJhbmRvbVdhaXQpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBQcm92aWRlIEVuZ2xpc2ggb3JkaW5hbCBsZXR0ZXJzIGFmdGVyIGEgbnVtYmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBvcmRpbmFsKGkpIHtcclxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGkpKSB7XHJcbiAgICAgICAgcmV0dXJuIGAke2l9YDtcclxuICAgIH1cclxuICAgIHJldHVybiBpICsgaW5kaWNhdG9yKGkpO1xyXG59XHJcbmZ1bmN0aW9uIGluZGljYXRvcihpKSB7XHJcbiAgICBpID0gTWF0aC5hYnMoaSk7XHJcbiAgICBjb25zdCBjZW50ID0gaSAlIDEwMDtcclxuICAgIGlmIChjZW50ID49IDEwICYmIGNlbnQgPD0gMjApIHtcclxuICAgICAgICByZXR1cm4gJ3RoJztcclxuICAgIH1cclxuICAgIGNvbnN0IGRlYyA9IGkgJSAxMDtcclxuICAgIGlmIChkZWMgPT09IDEpIHtcclxuICAgICAgICByZXR1cm4gJ3N0JztcclxuICAgIH1cclxuICAgIGlmIChkZWMgPT09IDIpIHtcclxuICAgICAgICByZXR1cm4gJ25kJztcclxuICAgIH1cclxuICAgIGlmIChkZWMgPT09IDMpIHtcclxuICAgICAgICByZXR1cm4gJ3JkJztcclxuICAgIH1cclxuICAgIHJldHVybiAndGgnO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIGdldE1vZHVsYXJJbnN0YW5jZShzZXJ2aWNlKSB7XHJcbiAgICBpZiAoc2VydmljZSAmJiBzZXJ2aWNlLl9kZWxlZ2F0ZSkge1xyXG4gICAgICAgIHJldHVybiBzZXJ2aWNlLl9kZWxlZ2F0ZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBzZXJ2aWNlO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8vIE92ZXJyaWRpbmcgdGhlIGNvbnN0YW50ICh3ZSBzaG91bGQgYmUgdGhlIG9ubHkgb25lcyBkb2luZyB0aGlzKVxyXG5DT05TVEFOVFMuTk9ERV9DTElFTlQgPSB0cnVlO1xuXG5leHBvcnQgeyBDT05TVEFOVFMsIERlY29kZUJhc2U2NFN0cmluZ0Vycm9yLCBEZWZlcnJlZCwgRXJyb3JGYWN0b3J5LCBGaXJlYmFzZUVycm9yLCBNQVhfVkFMVUVfTUlMTElTLCBSQU5ET01fRkFDVE9SLCBTaGExLCBhcmVDb29raWVzRW5hYmxlZCwgYXNzZXJ0LCBhc3NlcnRpb25FcnJvciwgYXN5bmMsIGJhc2U2NCwgYmFzZTY0RGVjb2RlLCBiYXNlNjRFbmNvZGUsIGJhc2U2NHVybEVuY29kZVdpdGhvdXRQYWRkaW5nLCBjYWxjdWxhdGVCYWNrb2ZmTWlsbGlzLCBjb250YWlucywgY3JlYXRlTW9ja1VzZXJUb2tlbiwgY3JlYXRlU3Vic2NyaWJlLCBkZWNvZGUsIGRlZXBDb3B5LCBkZWVwRXF1YWwsIGRlZXBFeHRlbmQsIGVycm9yUHJlZml4LCBleHRyYWN0UXVlcnlzdHJpbmcsIGdldERlZmF1bHRBcHBDb25maWcsIGdldERlZmF1bHRFbXVsYXRvckhvc3QsIGdldERlZmF1bHRFbXVsYXRvckhvc3RuYW1lQW5kUG9ydCwgZ2V0RGVmYXVsdHMsIGdldEV4cGVyaW1lbnRhbFNldHRpbmcsIGdldEdsb2JhbCwgZ2V0TW9kdWxhckluc3RhbmNlLCBnZXRVQSwgaXNBZG1pbiwgaXNCcm93c2VyLCBpc0Jyb3dzZXJFeHRlbnNpb24sIGlzRWxlY3Ryb24sIGlzRW1wdHksIGlzSUUsIGlzSW5kZXhlZERCQXZhaWxhYmxlLCBpc01vYmlsZUNvcmRvdmEsIGlzTm9kZSwgaXNOb2RlU2RrLCBpc1JlYWN0TmF0aXZlLCBpc1NhZmFyaSwgaXNVV1AsIGlzVmFsaWRGb3JtYXQsIGlzVmFsaWRUaW1lc3RhbXAsIGlzc3VlZEF0VGltZSwganNvbkV2YWwsIG1hcCwgb3JkaW5hbCwgcHJvbWlzZVdpdGhUaW1lb3V0LCBxdWVyeXN0cmluZywgcXVlcnlzdHJpbmdEZWNvZGUsIHNhZmVHZXQsIHN0cmluZ0xlbmd0aCwgc3RyaW5nVG9CeXRlQXJyYXksIHN0cmluZ2lmeSwgdXVpZHY0LCB2YWxpZGF0ZUFyZ0NvdW50LCB2YWxpZGF0ZUNhbGxiYWNrLCB2YWxpZGF0ZUNvbnRleHRPYmplY3QsIHZhbGlkYXRlSW5kZXhlZERCT3BlbmFibGUsIHZhbGlkYXRlTmFtZXNwYWNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5ub2RlLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJDT05TVEFOVFMiLCJOT0RFX0NMSUVOVCIsIk5PREVfQURNSU4iLCJTREtfVkVSU0lPTiIsImFzc2VydCIsImFzc2VydGlvbiIsIm1lc3NhZ2UiLCJhc3NlcnRpb25FcnJvciIsIkVycm9yIiwic3RyaW5nVG9CeXRlQXJyYXkkMSIsInN0ciIsIm91dCIsInAiLCJpIiwibGVuZ3RoIiwiYyIsImNoYXJDb2RlQXQiLCJieXRlQXJyYXlUb1N0cmluZyIsImJ5dGVzIiwicG9zIiwiYzEiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJjMiIsImMzIiwiYzQiLCJ1Iiwiam9pbiIsImJhc2U2NCIsImJ5dGVUb0NoYXJNYXBfIiwiY2hhclRvQnl0ZU1hcF8iLCJieXRlVG9DaGFyTWFwV2ViU2FmZV8iLCJjaGFyVG9CeXRlTWFwV2ViU2FmZV8iLCJFTkNPREVEX1ZBTFNfQkFTRSIsIkVOQ09ERURfVkFMUyIsIkVOQ09ERURfVkFMU19XRUJTQUZFIiwiSEFTX05BVElWRV9TVVBQT1JUIiwiYXRvYiIsImVuY29kZUJ5dGVBcnJheSIsImlucHV0Iiwid2ViU2FmZSIsIkFycmF5IiwiaXNBcnJheSIsImluaXRfIiwiYnl0ZVRvQ2hhck1hcCIsIm91dHB1dCIsImJ5dGUxIiwiaGF2ZUJ5dGUyIiwiYnl0ZTIiLCJoYXZlQnl0ZTMiLCJieXRlMyIsIm91dEJ5dGUxIiwib3V0Qnl0ZTIiLCJvdXRCeXRlMyIsIm91dEJ5dGU0IiwicHVzaCIsImVuY29kZVN0cmluZyIsImJ0b2EiLCJkZWNvZGVTdHJpbmciLCJkZWNvZGVTdHJpbmdUb0J5dGVBcnJheSIsImNoYXJUb0J5dGVNYXAiLCJjaGFyQXQiLCJoYXZlQnl0ZTQiLCJieXRlNCIsIkRlY29kZUJhc2U2NFN0cmluZ0Vycm9yIiwiY29uc3RydWN0b3IiLCJhcmd1bWVudHMiLCJuYW1lIiwiYmFzZTY0RW5jb2RlIiwidXRmOEJ5dGVzIiwiYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmciLCJyZXBsYWNlIiwiYmFzZTY0RGVjb2RlIiwiZSIsImNvbnNvbGUiLCJlcnJvciIsImRlZXBDb3B5IiwidmFsdWUiLCJkZWVwRXh0ZW5kIiwidW5kZWZpbmVkIiwidGFyZ2V0Iiwic291cmNlIiwiT2JqZWN0IiwiRGF0ZSIsImRhdGVWYWx1ZSIsImdldFRpbWUiLCJwcm9wIiwiaGFzT3duUHJvcGVydHkiLCJpc1ZhbGlkS2V5Iiwia2V5IiwiZ2V0R2xvYmFsIiwic2VsZiIsIndpbmRvdyIsImdsb2JhbCIsImdldERlZmF1bHRzRnJvbUdsb2JhbCIsIl9fRklSRUJBU0VfREVGQVVMVFNfXyIsImdldERlZmF1bHRzRnJvbUVudlZhcmlhYmxlIiwicHJvY2VzcyIsImVudiIsImRlZmF1bHRzSnNvblN0cmluZyIsIkpTT04iLCJwYXJzZSIsImdldERlZmF1bHRzRnJvbUNvb2tpZSIsImRvY3VtZW50IiwibWF0Y2giLCJjb29raWUiLCJkZWNvZGVkIiwiZ2V0RGVmYXVsdHMiLCJpbmZvIiwiZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdCIsInByb2R1Y3ROYW1lIiwiX2EiLCJfYiIsImVtdWxhdG9ySG9zdHMiLCJnZXREZWZhdWx0RW11bGF0b3JIb3N0bmFtZUFuZFBvcnQiLCJob3N0Iiwic2VwYXJhdG9ySW5kZXgiLCJsYXN0SW5kZXhPZiIsInBvcnQiLCJwYXJzZUludCIsInN1YnN0cmluZyIsImdldERlZmF1bHRBcHBDb25maWciLCJjb25maWciLCJnZXRFeHBlcmltZW50YWxTZXR0aW5nIiwiRGVmZXJyZWQiLCJyZWplY3QiLCJyZXNvbHZlIiwicHJvbWlzZSIsIlByb21pc2UiLCJ3cmFwQ2FsbGJhY2siLCJjYWxsYmFjayIsImNhdGNoIiwiY3JlYXRlTW9ja1VzZXJUb2tlbiIsInRva2VuIiwicHJvamVjdElkIiwidWlkIiwiaGVhZGVyIiwiYWxnIiwidHlwZSIsInByb2plY3QiLCJpYXQiLCJzdWIiLCJ1c2VyX2lkIiwicGF5bG9hZCIsImFzc2lnbiIsImlzcyIsImF1ZCIsImV4cCIsImF1dGhfdGltZSIsImZpcmViYXNlIiwic2lnbl9pbl9wcm92aWRlciIsImlkZW50aXRpZXMiLCJzaWduYXR1cmUiLCJzdHJpbmdpZnkiLCJnZXRVQSIsIm5hdmlnYXRvciIsImlzTW9iaWxlQ29yZG92YSIsInRlc3QiLCJpc05vZGUiLCJmb3JjZUVudmlyb25tZW50IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwiaXNCcm93c2VyIiwiaXNCcm93c2VyRXh0ZW5zaW9uIiwicnVudGltZSIsImNocm9tZSIsImJyb3dzZXIiLCJpZCIsImlzUmVhY3ROYXRpdmUiLCJpc0VsZWN0cm9uIiwiaW5kZXhPZiIsImlzSUUiLCJ1YSIsImlzVVdQIiwiaXNOb2RlU2RrIiwiaXNTYWZhcmkiLCJ1c2VyQWdlbnQiLCJpbmNsdWRlcyIsImlzSW5kZXhlZERCQXZhaWxhYmxlIiwiaW5kZXhlZERCIiwidmFsaWRhdGVJbmRleGVkREJPcGVuYWJsZSIsInByZUV4aXN0IiwiREJfQ0hFQ0tfTkFNRSIsInJlcXVlc3QiLCJvcGVuIiwib25zdWNjZXNzIiwicmVzdWx0IiwiY2xvc2UiLCJkZWxldGVEYXRhYmFzZSIsIm9udXBncmFkZW5lZWRlZCIsIm9uZXJyb3IiLCJhcmVDb29raWVzRW5hYmxlZCIsImNvb2tpZUVuYWJsZWQiLCJFUlJPUl9OQU1FIiwiRmlyZWJhc2VFcnJvciIsImNvZGUiLCJjdXN0b21EYXRhIiwic2V0UHJvdG90eXBlT2YiLCJjYXB0dXJlU3RhY2tUcmFjZSIsIkVycm9yRmFjdG9yeSIsImNyZWF0ZSIsInNlcnZpY2UiLCJzZXJ2aWNlTmFtZSIsImVycm9ycyIsImRhdGEiLCJmdWxsQ29kZSIsInRlbXBsYXRlIiwicmVwbGFjZVRlbXBsYXRlIiwiZnVsbE1lc3NhZ2UiLCJQQVRURVJOIiwiXyIsImpzb25FdmFsIiwiZGVjb2RlIiwiY2xhaW1zIiwicGFydHMiLCJzcGxpdCIsImlzVmFsaWRUaW1lc3RhbXAiLCJub3ciLCJNYXRoIiwiZmxvb3IiLCJ2YWxpZFNpbmNlIiwidmFsaWRVbnRpbCIsImlzc3VlZEF0VGltZSIsImlzVmFsaWRGb3JtYXQiLCJpc0FkbWluIiwiY29udGFpbnMiLCJvYmoiLCJzYWZlR2V0IiwiaXNFbXB0eSIsIm1hcCIsImZuIiwiY29udGV4dE9iaiIsInJlcyIsImRlZXBFcXVhbCIsImEiLCJiIiwiYUtleXMiLCJrZXlzIiwiYktleXMiLCJrIiwiYVByb3AiLCJiUHJvcCIsImlzT2JqZWN0IiwidGhpbmciLCJwcm9taXNlV2l0aFRpbWVvdXQiLCJ0aW1lSW5NUyIsImRlZmVycmVkUHJvbWlzZSIsInNldFRpbWVvdXQiLCJ0aGVuIiwicXVlcnlzdHJpbmciLCJxdWVyeXN0cmluZ1BhcmFtcyIsInBhcmFtcyIsImVudHJpZXMiLCJmb3JFYWNoIiwiYXJyYXlWYWwiLCJlbmNvZGVVUklDb21wb25lbnQiLCJxdWVyeXN0cmluZ0RlY29kZSIsInRva2VucyIsImRlY29kZVVSSUNvbXBvbmVudCIsImV4dHJhY3RRdWVyeXN0cmluZyIsInVybCIsInF1ZXJ5U3RhcnQiLCJmcmFnbWVudFN0YXJ0IiwiU2hhMSIsImNoYWluXyIsImJ1Zl8iLCJXXyIsInBhZF8iLCJpbmJ1Zl8iLCJ0b3RhbF8iLCJibG9ja1NpemUiLCJyZXNldCIsImNvbXByZXNzXyIsImJ1ZiIsIm9mZnNldCIsIlciLCJ0IiwiZCIsImYiLCJ1cGRhdGUiLCJsZW5ndGhNaW51c0Jsb2NrIiwibiIsImluYnVmIiwiZGlnZXN0IiwidG90YWxCaXRzIiwiaiIsImNyZWF0ZVN1YnNjcmliZSIsImV4ZWN1dG9yIiwib25Ob09ic2VydmVycyIsInByb3h5IiwiT2JzZXJ2ZXJQcm94eSIsInN1YnNjcmliZSIsImJpbmQiLCJvYnNlcnZlcnMiLCJ1bnN1YnNjcmliZXMiLCJvYnNlcnZlckNvdW50IiwidGFzayIsImZpbmFsaXplZCIsIm5leHQiLCJmb3JFYWNoT2JzZXJ2ZXIiLCJvYnNlcnZlciIsImNvbXBsZXRlIiwibmV4dE9yT2JzZXJ2ZXIiLCJpbXBsZW1lbnRzQW55TWV0aG9kcyIsIm5vb3AiLCJ1bnN1YiIsInVuc3Vic2NyaWJlT25lIiwiZmluYWxFcnJvciIsInNlbmRPbmUiLCJlcnIiLCJhc3luYyIsIm9uRXJyb3IiLCJhcmdzIiwibWV0aG9kcyIsIm1ldGhvZCIsInZhbGlkYXRlQXJnQ291bnQiLCJmbk5hbWUiLCJtaW5Db3VudCIsIm1heENvdW50IiwiYXJnQ291bnQiLCJhcmdFcnJvciIsImVycm9yUHJlZml4IiwiYXJnTmFtZSIsInZhbGlkYXRlTmFtZXNwYWNlIiwibmFtZXNwYWNlIiwib3B0aW9uYWwiLCJ2YWxpZGF0ZUNhbGxiYWNrIiwiYXJndW1lbnROYW1lIiwidmFsaWRhdGVDb250ZXh0T2JqZWN0IiwiY29udGV4dCIsInN0cmluZ1RvQnl0ZUFycmF5IiwiaGlnaCIsImxvdyIsInN0cmluZ0xlbmd0aCIsInV1aWR2NCIsInIiLCJyYW5kb20iLCJ2IiwiREVGQVVMVF9JTlRFUlZBTF9NSUxMSVMiLCJERUZBVUxUX0JBQ0tPRkZfRkFDVE9SIiwiTUFYX1ZBTFVFX01JTExJUyIsIlJBTkRPTV9GQUNUT1IiLCJjYWxjdWxhdGVCYWNrb2ZmTWlsbGlzIiwiYmFja29mZkNvdW50IiwiaW50ZXJ2YWxNaWxsaXMiLCJiYWNrb2ZmRmFjdG9yIiwiY3VyckJhc2VWYWx1ZSIsInBvdyIsInJhbmRvbVdhaXQiLCJyb3VuZCIsIm1pbiIsIm9yZGluYWwiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImluZGljYXRvciIsImFicyIsImNlbnQiLCJkZWMiLCJnZXRNb2R1bGFySW5zdGFuY2UiLCJfZGVsZWdhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\n");

/***/ })

};
;